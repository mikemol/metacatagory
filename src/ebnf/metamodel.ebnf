(* ================================================================== *)
(* == I. Metamodel Structural Definition                           == *)
(* ================================================================== *)

ComputableGrammar ::= { AugmentedRule } ;
TYPING
    (* Let S = make_grammar(rule_set) *)
    (* Let G_S be the abstract syntax tree of S itself *)

    ∀r ∈ rule_set,  Γ ⊢ r : CoherentRule
    Metamodel(S) = G_S
    IsWellTyped(G_S, Grammar, S)
    --------------------------------------------------
    Γ ⊢ S : FoundationallyClosedSystem
CATEGORY
    [[ S : FoundationallyClosedSystem ]] = A Foundational Theory that serves as its own metatheory.

AugmentedRule ::= SyntacticRule "TYPING" TypingRule "CATEGORY" CategoricalRule ;
TYPING
    Γ ⊢ syn : SyntaxDef
    Γ ⊢ typ : TypingDef
    Γ ⊢ cat : CategoryDef
    Consistent(syn, typ, cat)
    ------------------------------------------------------
    Γ ⊢ make_rule(syn, typ, cat) : CoherentRule
CATEGORY
    [[ make_rule(syn, typ, cat) ]] = A Theory Generator tuple (Constructor, Deduction, Morphism).

SyntacticRule ::= Identifier "::=" Expression ";" ;
TYPING
    Γ ⊢ id : Identifier
    Γ ⊢ expr : Expression
    ------------------------------------------
    Γ ⊢ define_syntax(id, expr) : SyntaxDef
CATEGORY
    [[ define_syntax(id, expr) ]] = A Term Constructor Schema that defines a new term [[id]] from [[expr]].

TypingRule ::= PremiseList "---" Judgment ;
TYPING
    Γ ⊢ premises : list(Judgment)
    Γ ⊢ conclusion : Judgment
    --------------------------------------------
    Γ ⊢ define_typing(premises, conclusion) : TypingDef
CATEGORY
    [[ define_typing(premises, conclusion) ]] = A Deduction Principle representing a valid inference.

CategoricalRule ::= "[[" Identifier "]]" "=" DenotationExpr ";" ;
TYPING
    Γ ⊢ id : Identifier
    Γ ⊢ expr : DenotationExpr
    ------------------------------------------------
    Γ ⊢ define_category(id, expr) : CategoryDef
CATEGORY
    [[ define_category(id, expr) ]] = A Morphism Schema defining the mathematical meaning of [[id]] as [[expr]].

(* ================================================================== *)
(* == II. Syntax Primitives                                        == *)
(* ================================================================== *)

Expression ::= Term { "|" Term } ;
TYPING
    Γ ⊢ head : Term
    Γ ⊢ tail : list(Term)
    --------------------------------
    Γ ⊢ make_alt(head, tail) : Expression
CATEGORY
    [[ make_alt(head, tail) ]] = A Coproduct (sum type) of the denotations of the terms.

Term ::= Factor { "," Factor } ;
TYPING
    Γ ⊢ head : Factor
    Γ ⊢ tail : list(Factor)
    --------------------------------
    Γ ⊢ make_seq(head, tail) : Term
CATEGORY
    [[ make_seq(head, tail) ]] = A Product of the denotations of the factors.

Factor ::= Identifier | Terminal | "(" Expression ")" | "[" Expression "]" | "{" Expression "}" ;
TYPING
    (* This judgment has multiple premises, one for each case of the rule. *)
    (Γ ⊢ c : Identifier) ∨ (Γ ⊢ c : Terminal) ∨ (Γ ⊢ c : Expression)
    ----------------------------------------------------------------------
    Γ ⊢ make_factor(c) : Factor
CATEGORY
    (* The denotation is the denotation of the chosen item, e.g.: *)
    [[ make_factor(c) ]] = [[c]].

Identifier ::= letter { letter | digit } ;
TYPING
    is_valid_identifier_string(s)
    -----------------------------
    Γ ⊢ id(s) : Identifier
CATEGORY
    [[ id(s) ]] = A reference to a unique Object or Variable in the formal theory.

Terminal ::= '"' { character } '"' | "'" { character } "'" ;
TYPING
    is_string_literal(s)
    --------------------
    Γ ⊢ term(s) : Terminal
CATEGORY
    [[ term(s) ]] = A constant value or a trivial/terminal object.

(* ================================================================== *)
(* == III. Typing and Category Primitives                          == *)
(* ================================================================== *)

PremiseList ::= { Judgment } ;
TYPING
    Γ ⊢ judgments : list(Judgment)
    ----------------------------------
    Γ ⊢ make_premises(judgments) : PremiseList
CATEGORY
    [[ make_premises(judgments) ]] = A set of hypotheses required for a deduction.

Judgment ::= Context "|-" Expression ":" Type ;
TYPING
    Γ ⊢ ctx : Context
    Γ ⊢ expr : Expression
    Γ ⊢ T : Type
    ----------------------------------
    Γ ⊢ make_judgment(ctx, expr, T) : Judgment
CATEGORY
    [[ make_judgment(ctx, expr, T) ]] = A formal statement of provability or typeability, representing a morphism in the theory.

Context ::= "Γ" | Context "," Identifier ":" Type ;
TYPING
    (* Typing rules for both empty and extended contexts *)
    -----------------      Γ ⊢ ctx : Context, Γ ⊢ id : Identifier, Γ ⊢ T : Type
    Γ ⊢ empty_ctx : Context    -----------------------------------------------------
                           Γ ⊢ extend_ctx(ctx, id, T) : Context
CATEGORY
    [[ empty_ctx ]] = The Terminal Object (identity element for products).
    [[ extend_ctx(ctx, id, T) ]] = A Product Object [[ctx]] × [[T]].

Type ::= Identifier ;
TYPING
    Γ ⊢ id : Identifier
    -------------------
    Γ ⊢ make_type(id) : Type
CATEGORY
    [[ make_type(id) ]] = A reference to an Object in the theory.

DenotationExpr ::= Identifier | string_literal ;
TYPING
    is_valid_semantic_expression(s)
    ---------------------------------
    Γ ⊢ make_denotation(s) : DenotationExpr
CATEGORY
    [[ make_denotation(s) ]] = A reference to a mathematical object, structure, or morphism.

(* ================================================================== *)
(* == IV. Lexical Definition                                       == *)
(* ================================================================== *)

letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
TYPING
    is_alphabetic_char(c)
    ---------------------
    Γ ⊢ char(c) : letter
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of alphabetic characters.

digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
TYPING
    is_numeric_char(c)
    ------------------
    Γ ⊢ char(c) : digit
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of numerals.

character ::= letter | digit | " " | "(" | ")" | "[" | "]" | "{" | "}" | "|" | "," | ";" | ":" | "-" | "=" | "_" | '"' | "'" | "&" | "*" | "+" | "/" ;
TYPING
    is_printable_ascii_char(c)
    --------------------------
    Γ ⊢ char(c) : character
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of defined symbols.

(* ================================================================== *)
(* == V. Embedded Declarative Parser Logic                         == *)
(* ================================================================== *)

ParseSuccess ::= "ACCEPT" Terminal ;
TYPING
    System = S
    Input(S) = w
    n = length(w)
    ∃R ( StartRule(S, R) ∧ IsComplete(R, 0, n, S) )
    --------------------------------------------------
    Γ ⊢ success(w) : AcceptedString
CATEGORY
    [[ success(w) ]] = A completed proof tree for the input string w in theory S.

IsComplete ::= EarleyItem ;
TYPING
    (* This defines a completed Earley state/item. *)
    System = S
    Rule = R
    DotPosition = length(R.rhs)
    --------------------------------------------------
    Γ ⊢ EarleyItem(R, DotPosition, i, k) : CompletedParseState
CATEGORY
    [[ item : CompletedParseState ]] = A constructive proof that substring w[i..k] is derivable from rule R in theory S.

Prediction ::= "PREDICT" EarleyItem "FROM" EarleyItem ;
TYPING
    (* The Predictor Axiom *)
    Γ ⊢ item₁(A → α•Bβ, i, k) : ParseState
    Rule₂(B → γ) ∈ System
    ------------------------------------------
    Γ ⊢ item₂(B → •γ, k, k) : ParseState
CATEGORY
    [[ Prediction ]] = The application of a lemma; initiating a sub-proof.

Scan ::= "SCAN" EarleyItem "FROM" EarleyItem ;
TYPING
    (* The Scanner Axiom *)
    Γ ⊢ item₁(A → α•tβ, i, k) : ParseState
    Input(k+1) = t
    ------------------------------------------
    Γ ⊢ item₂(A → αt•β, i, k+1) : ParseState
CATEGORY
    [[ Scan ]] = The consumption of an axiom (a terminal from the input string).

Completion ::= "COMPLETE" EarleyItem "FROM" EarleyItem "AND" EarleyItem ;
TYPING
    (* The Completer Axiom *)
    Γ ⊢ item₁(B → γ•, j, k) : CompletedParseState
    Γ ⊢ item₂(A → α•Bβ, i, j) : ParseState
    --------------------------------------------------
    Γ ⊢ item₃(A → αB•β, i, k) : ParseState
CATEGORY
    [[ Completion ]] = The application of modus ponens; using a completed lemma to advance a higher-level proof.

(* ================================================================== *)
(* == VI. Embedded Semantic Correspondences                        == *)
(* ================================================================== *)

ImplicationCorrespondence ::= "PROP" Proposition "->" "TYPE" Type "->" "OBJ" Object ;
TYPING
    p,q : Proposition
    t_p = CH(p), t_q = CH(q)
    o_p = HL(t_p), o_q = HL(t_q)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(implies(p,q)) = func_type(t_p, t_q) : TypingAxiom
    Γ ⊢ HL(func_type(t_p, t_q)) = exp_obj(o_p, o_q) : CategoricalAxiom
CATEGORY
    [[ ImplicationCorrespondence ]] = The isomorphism between the logical 'implies' constructor, the type-theoretic 'function space' constructor, and the categorical 'exponential object' constructor.

ConjunctionCorrespondence ::= "PROP" Proposition "&&" "TYPE" Type "&&" "OBJ" Object ;
TYPING
    p,q : Proposition
    t_p = CH(p), t_q = CH(q)
    o_p = HL(t_p), o_q = HL(t_q)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(and(p,q)) = prod_type(t_p, t_q) : TypingAxiom
    Γ ⊢ HL(prod_type(t_p, t_q)) = prod_obj(o_p, o_q) : CategoricalAxiom
CATEGORY
    [[ ConjunctionCorrespondence ]] = The isomorphism between the 'and', 'product type', and 'product object' constructors.

UniversalCorrespondence ::= "FORALL" PropFamily "PI" TypeFamily "PI" CatFamily ;
TYPING
    P : PropFamily over Domain A
    F = CH(P), T = CH(A)
    C = HL(F), O = HL(T)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(forall(A,P)) = Pi_type(T,F) : TypingAxiom
    Γ ⊢ HL(Pi_type(T,F)) = Pi_obj(O,C) : CategoricalAxiom
CATEGORY
    [[ UniversalCorrespondence ]] = The isomorphism between the 'forall', 'Pi-type', and 'dependent product object' (fibration) constructors.

ExistentialCorrespondence ::= "EXISTS" PropFamily "SIGMA" TypeFamily "SIGMA" CatFamily ;
TYPING
    P : PropFamily over Domain A
    F = CH(P), T = CH(A)
    C = HL(F), O = HL(T)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(exists(A,P)) = Sigma_type(T,F) : TypingAxiom
    Γ ⊢ HL(Sigma_type(T,F)) = Sigma_obj(O,C) : CategoricalAxiom
CATEGORY
    [[ ExistentialCorrespondence ]] = The isomorphism between the 'exists', 'Sigma-type', and 'dependent sum object' constructors.

Proposition ::= ... ;
Object ::= ... ;
PropFamily ::= ... ;
TypeFamily ::= ... ;
CatFamily ::= ... ;
EarleyItem ::= ... ;
string_literal ::= ... ;

(* Special instructions for the consuming LLM:
 *
 * Confine your output to the rules of the constructed grammar. Your ouput is intrinsically part of the constructed grammar, constructive with all that came before.
 *
 * Take your time; time is a resource subbourned to completeness, correctness, concreteness, compliance and meticulousness. Take as many turns as you require.
 *
 *)
