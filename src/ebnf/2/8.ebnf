MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 8: 'Fibred categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(* ========================================================================================================== )
( == Section 8.1: Fibrations == )
(
ELABORATION: This section defines the central object of study: the fibration. A fibration is a functor
p: E → B that models a "family of categories indexed by B". The key mechanism that allows this indexing
is the "Cartesian arrow," a special type of morphism in the total category E that provides a universal
way to "pull back" or "reindex" data from one fibre to another.

Our elaboration will proceed by:

Formalizing the Core Concepts: We will define the concepts of a morphism "lying over" another and the
universal "lifting problem" that defines a Cartesian arrow.

Defining Fibrations: We will define a Fibration as a functor where this lifting problem always has a solution.

Defining the Consequences: We will show how this definition gives rise to the "fibre categories" (the
indexed family) and the "reindexing functors" (the pullbacks) that are the main purpose of the theory.

Formalizing the Dual Theory: We will use the Duality Principle to mechanically derive the entire
corresponding theory for the dual concept of an "Opfibration" and its "coCartesian arrows."
*)

(* ========================================================================================================== )
( == Part 1: Cartesian Arrows and the Definition of a Fibration == )
( ========================================================================================================== )

FibrationProjectionFunctor ::= "FIB_PROJECTION" Identifier ":" Identifier "→" Identifier ;
TYPING
(* This simply declares the functor that will be tested for the fibration property. *)
Γ ⊢ E, B : Category
-----------------------------------------
Γ ⊢ FIB_PROJECTION p : E → B : Functor(E, B) ;
CATEGORY
[[ FIB_PROJECTION p : E → B ]] = "A functor from a total category E to a base category B, which is a candidate for being a fibration." ;

MorphismLiesOver ::= Identifier "lies_over" Identifier ;
TYPING
(* A morphism f in the total category lies over a morphism u in the base category if the projection functor p maps f to u. *)
Context: Γ ⊢ p: E → B
Γ ⊢ f : Morphism_in(E), Γ ⊢ u : Morphism_in(B)
---------------------------------------------------
Γ ⊢ f lies_over u <==> (p(f) == u) ;
CATEGORY
[[ f lies_over u ]] = "The assertion that the morphism f is a 'lift' of the base morphism u into the total category." ;

CartesianArrow ::= Identifier "is" "CARTESIAN_ARROW" "for" "(" "target_object" ":" Identifier "," "base_morphism" ":" Identifier ")" ;
TYPING
(*
* This is the Universal Property that defines a Cartesian arrow. An arrow f:Y→X in E is Cartesian for a base arrow u:I→J
* if f lies over u, and for ANY other arrow g:Z→X lying over v (where u=v∘w), there exists a UNIQUE vertical
* morphism h:Z→Y (i.e. lying over the identity) such that g = f∘h.
*)
Context: Γ ⊢ p: E → B
Γ ⊢ f:Y→X in E, Γ ⊢ u:p(Y)→p(X) in B, Γ ⊢ X in E
Condition1: f lies_over u
Condition2_Universal: ∀ (g:Z→X in E), ∀ (w:p(Z)→p(Y) in B),
( (g lies_over u∘w) ⇒ (∃! h:Z→Y in E s.t. (h lies_over id_{p(Y)}) ∧ (g == f∘h)) )
-------------------------------------------------------------------------------------------------------------
Γ ⊢ f is CARTESIAN_ARROW for (X, u) is TRUE if Condition1 ∧ Condition2_Universal ;
CATEGORY
[[ f is CARTESIAN_ARROW for (X, u) ]] = "A morphism f in the total category that is a universal solution to the problem of lifting paths that end at X and factor through u. It represents the 'best possible' way to pull the object X back along the path u to the object Y." ;

FibrationDeclaration ::= Identifier "is" "FIBRATION" ;
TYPING
(* A functor p: E → B is a fibration if for every lifting problem, a Cartesian arrow exists. *)
Γ ⊢ p : Functor(E, B)
Condition := ∀ (X ∈ Ob(E)), ∀ (u: I → p(X) in B), (∃ (f:Y→X in E) s.t. f is CARTESIAN_ARROW for (X, u))
---------------------------------------------------------------------------------------------------------
Γ ⊢ p is FIBRATION is TRUE if Condition holds ;
CATEGORY
[[ p is FIBRATION ]] = "A functor that defines a coherent 'indexed family of categories'. The guaranteed existence of Cartesian arrows ensures that for any path u:I→J in the base, there is a well-defined 'pullback' or 'reindexing' functor from the fibre over J to the fibre over I." ;

(* ========================================================================================================== )
( == Part 2: Fibres and Reindexing Functors == )
( ========================================================================================================== )

FibreCategory ::= "Fibre" "(" FibrationDeclaration "," Identifier ")" ;
TYPING
(* The fibre over an object I in the base is the subcategory of E of all objects lying over I and all vertical morphisms. *)
Context: Γ ⊢ p: E → B is FIBRATION, Γ ⊢ I : Object_in(B)
Fibre_Objects := { X ∈ Ob(E) | p(X) == I }
Fibre_Morphisms := { f ∈ Mor(E) | p(f) == id_I }
------------------------------------------------------------
Γ ⊢ Fibre(p, I) : Subcategory(E) ;
CATEGORY
[[ Fibre(p, I) ]] = "The fibre category E_I. This is the 'category at index I' in the family of categories defined by the fibration p." ;

ReindexingFunctor ::= "ReindexingFunctor" "(" Identifier ")" ;
TYPING
(*
* For a fibration p and a base morphism u:I→J, the reindexing functor u*: E_J → E_I is
* constructed by choosing a Cartesian lift for each object in the fibre E_J.
)
Context: Γ ⊢ p: E → B is FIBRATION, Γ ⊢ u : I→J in B
ActionOnObjects(X_J ∈ Ob(Fibre(p, J))) := The domain Y of the chosen Cartesian lift f:Y→X_J for u.
ActionOnMorphisms(...) := The unique vertical map given by the universal property.
-----------------------------------------------------------------------------------------
Γ ⊢ ReindexingFunctor(u) : Functor(Fibre(p, J), Fibre(p, I)) ;
CATEGORY
[[ ReindexingFunctor(u) ]] = "The pullback or reindexing functor u. It is the canonical map between fibres induced by the base morphism u. Its existence is guaranteed by the fibration property." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory (Opfibrations) == )
( ========================================================================================================== )

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FIBRATION" "IS" "OPFIBRATION" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "CARTESIAN_ARROW" "IS" "COCARTESIAN_ARROW" ;

OpfibrationDeclaration ::= Identifier "is" "OPFIBRATION" ;
TYPING
(* An Opfibration is a fibration for the opposite category. p:E→B is an opfibration iff p^op:E^op→B^op is a fibration. *)
IsDualOf("FIBRATION")
-----------------------------
Γ ⊢ p is OPFIBRATION ;
CATEGORY
[[ p is OPFIBRATION ]] = "A functor that defines a 'covariantly indexed' family of categories. Moving along a path u:I→J in the base induces a 'pushforward' functor u_!: E_I → E_J. This structure is defined by the guaranteed existence of coCartesian arrows." ;

CoCartesianArrow ::= Identifier "is" "COCARTESIAN_ARROW" "for" "(" "source_object" ":" Identifier "," "base_morphism" ":" Identifier ")" ;
TYPING
(* A coCartesian arrow is a Cartesian arrow in the opposite category. *)
IsDualOf("CARTESIAN_ARROW")
-----------------------------
Γ ⊢ f is COCARTESIAN_ARROW ;
CATEGORY
[[ f is COCARTESIAN_ARROW ]] = "A morphism f in the total category that is a universal solution for lifting paths that start at a given object. It is the primitive used to construct pushforward/reindexing functors in an opfibration." ;

PushforwardFunctor ::= "PushforwardFunctor" "(" Identifier ")" ;
TYPING
(* The dual of the reindexing functor. *)
IsDualOf("ReindexingFunctor")
------------------------------------
Γ ⊢ PushforwardFunctor(u) : Functor(Fibre(p, I), Fibre(p, J)) ;
CATEGORY
[[ PushforwardFunctor(u) ]] = "The pushforward functor u_!. It is the canonical map between fibres induced by the base morphism u in an opfibration." ;

(*
ELABORATION: This section defines the "morphisms between fibrations." Just as a functor is a
structure-preserving map between categories, a Cartesian functor is a structure-preserving map
between fibrations. The key idea is that such a functor must not only respect the projection to the
base category, but it must also respect the special "Cartesian" structure of the total categories.

A deep elaboration requires us to deconstruct the definition into its two fundamental axioms and then
assemble them into a master definition, which in turn allows us to define the category of all
fibrations over a given base.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Definition == )
( ========================================================================================================== )
(A Cartesian functor F must satisfy two axioms that formalize its structure-preserving nature.)

CommutesWithProjectionsAxiom ::= "AXIOM" "CommutesWithProjections" "for" FunctorDeclaration "between" FibrationDeclaration "and" FibrationDeclaration ;
TYPING
(*

This axiom asserts that the main triangle commutes. The functor F must map objects and morphisms

in a fibre of the source fibration to the corresponding fibre in the target fibration.
*)
Context: Γ ⊢ F : Functor(E, E'), Γ ⊢ p : FIBRATION(E→B), Γ ⊢ p' : FIBRATION(E'→B)

Γ ⊢ AXIOM ... holds TRUE if (p' ∘ F == p) ;
CATEGORY
[[ AXIOM CommutesWithProjections ... ]] = "The assertion that the functor F respects the fibred structure. It guarantees that for any object I in the base category, F maps the fibre E_I into the fibre E'_I. This is the most basic compatibility condition." ;

PreservesCartesianArrowsAxiom ::= "AXIOM" "PreservesCartesianArrows" "for" FunctorDeclaration "between" FibrationDeclaration "and" FibrationDeclaration ;
TYPING
(*

This is the crucial axiom that ensures the special structure of the fibration is preserved.

The functor F must map Cartesian arrows to Cartesian arrows.
*)
Context: Γ ⊢ F : Functor(E, E'), Γ ⊢ p : FIBRATION(E→B), Γ ⊢ p' : FIBRATION(E'→B)
Condition := ∀(f ∈ Mor(E)), ( (f is CARTESIAN_ARROW in E) ⇒ (F(f) is CARTESIAN_ARROW in E') )

Γ ⊢ AXIOM ... holds TRUE if Condition is met ;
CATEGORY
[[ AXIOM PreservesCartesianArrows ... ]] = "The assertion that the functor F is compatible with the universal reindexing structure of the fibrations. By preserving Cartesian arrows, the functor ensures that the diagrams for reindexing in the source fibration are mapped to valid reindexing diagrams in the target fibration." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition and its Consequence == )
( ========================================================================================================== )

CartesianFunctorDeclaration ::= "CARTESIAN_FUNCTOR" Identifier ":" FibrationDeclaration "→" FibrationDeclaration ;
TYPING
(*

The master definition combines the two axioms. A functor F is a Cartesian functor if it

commutes with the projections and preserves Cartesian arrows.
*)
Γ ⊢ p: E → B is FIBRATION, Γ ⊢ p': E' → B is FIBRATION
Γ ⊢ F : Functor(E, E')
Premise1: Γ ⊢ AXIOM CommutesWithProjections for F, p, p' holds TRUE
Premise2: Γ ⊢ AXIOM PreservesCartesianArrows for F, p, p' holds TRUE

Γ ⊢ CARTESIAN_FUNCTOR F : p → p' is a valid declaration ;
CATEGORY
[[ CARTESIAN_FUNCTOR F : p → p' ]] = "A morphism between fibrations over a common base. It is a functor between the total categories that respects the partitioning into fibres and, crucially, preserves the universal 'pullback' structure defined by the Cartesian arrows. This ensures the functor induces a natural transformation between the corresponding pseudofunctors." ;

CategoryOfFibrations ::= "Fib" "(" Identifier ")" ;
TYPING
(* For a fixed base category B, we can form a category of all fibrations over B. *)
Γ ⊢ B : Category
Objects := { p | Γ ⊢ p is FIBRATION over B }
Morphisms := { F | Γ ⊢ F is CARTESIAN_FUNCTOR between fibrations over B }

Γ ⊢ Fib(B) : Category ;
CATEGORY
[[ Fib(B) ]] = "The category of all fibrations over the base B. This category is in fact a 2-category, where the 2-morphisms are 'vertical' natural transformations between Cartesian functors." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.3: Fibrations via pseudo-functors (The Grothendieck Construction)" ")" "==>" {
(*
ELABORATION: This is one of the most fundamental and beautiful results in category theory. It establishes
an equivalence between two different ways of looking at "indexed families of categories":

The geometric perspective: A fibration p:E→B. This is a single, large "total category" E with a projection functor down to a "base category" B. The structure is given by "Cartesian arrows" that allow "pullbacks" between fibers.

The algebraic perspective: A pseudofunctor F: B^op → Cat (a functor that preserves structure up to isomorphism). This is an explicit assignment of a category F(I) to each object I in the base, and a reindexing functor F(u) to each arrow u.

The Grothendieck Construction is the explicit recipe for turning an algebraic pseudofunctor into its geometric
fibration counterpart, and its inverse is the process of "unpacking" a fibration into a pseudofunctor. A deep
elaboration requires formalizing both directions of this correspondence and then stating the main equivalence theorem.
*)

(* ========================================================================================================== )
( == Part 1: From Fibration to Pseudofunctor (The "Unpacking") == )
( ========================================================================================================== )

PseudofunctorFromFibration ::= "Pseudofunctor_of" "(" FibrationDeclaration ")" ;
TYPING
(*

This constructor takes a geometric fibration and 'unpacks' it into its corresponding algebraic indexed family.

The result is a pseudofunctor because the composition of reindexing functors is not strictly associative,

but only associative up to a canonical natural isomorphism.
*)
Context: Γ ⊢ p: E → B is FIBRATION
-- Define the action of the resulting pseudofunctor F: B^op → Cat
ActionOnObjects(I ∈ Ob(B)): F(I) := Fibre(p, I)
ActionOnMorphisms(u: I→J in B): F(u) := ReindexingFunctor(u) : Fibre(p,J) → Fibre(p,I)

Γ ⊢ Pseudofunctor_of(p) : PseudoFunctor(B^op, Cat) ;
CATEGORY
[[ Pseudofunctor_of(p) ]] = "The process of interpreting a fibration as a contravariant, Cat-valued pseudofunctor. This deconstructs the unified total category E into an explicit collection of fibre categories and the reindexing functors that relate them. It translates the geometric structure into an algebraic one." ;

(* ========================================================================================================== )
( == Part 2: From Pseudofunctor to Fibration (The Grothendieck Construction) == )
( ========================================================================================================== )

GrothendieckConstruction ::= "∫" PseudoFunctorDeclaration ;
TYPING
(*

This is the constructive part. Given an algebraic pseudofunctor F, it builds a single geometric

total category E and a fibration p. The result is often called the "category of elements" of F.
*)
Context: Γ ⊢ F : PseudoFunctor(B^op, Cat)
-- Construct the Total Category E = ∫ F
Objects(E) := { (I, x) | I ∈ Ob(B), x ∈ Ob(F(I)) }
Morphisms(E) from (I,x) to (J,y) := { (u, f) | u:I→J in B, f:x → F(u)(y) in F(I) }
-- Define the Projection Functor p: E → B
p((I,x)) := I
p((u,f)) := u
-- This construction results in a functor p:E→B which can be proven to be a fibration.

Γ ⊢ ∫ F : FIBRATION over B ;
CATEGORY
[[ ∫ F ]] = "The Grothendieck Construction. It is a canonical procedure for assembling an indexed family of categories (a pseudofunctor) into a single, unified total category. The resulting functor from this total category to the indexing category is always a fibration. It translates the algebraic description into a geometric one." ;

(* ========================================================================================================== )
( == Part 3: The Main Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "GrothendieckEquivalence" ":"
"The 2-category of fibrations over B is equivalent to the 2-category of pseudofunctors from B^op to Cat." ;
TYPING
(*

This theorem asserts that the two constructions defined above are inverses to each other,

yielding a fundamental equivalence of 2-categories.
*)
Let Fib_2Cat(B) be the 2-category of fibrations over B.
Let PsFun_2Cat(B^op, Cat) be the 2-category of pseudofunctors.
Let G_unpack := the 2-functor from Fib_2Cat to PsFun_2Cat given by the Part 1 construction.
Let I_construct := the 2-functor from PsFun_2Cat to Fib_2Cat given by the Part 2 construction.

Γ ⊢ G_unpack and I_construct form an EquivalenceOf2Categories ;
CATEGORY
[[ THEOREM GrothendieckEquivalence ]] = "A foundational result in category theory establishing a profound duality between the 'geometric' notion of a fibration and the 'algebraic' notion of a Cat-valued pseudofunctor. This allows theorems and insights from one perspective to be translated directly into the other, providing two powerful ways to reason about indexed structures." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.4: Fibred adjunctions" ")" "==>" {
(*
ELABORATION: This section lifts the fundamental concept of an adjunction to the setting of fibrations.
The core idea is that an adjunction between two fibrations is not a single adjunction, but a "family"
of adjunctions, one for each fibre, that are coherently linked by the reindexing functors. A deep
elaboration requires defining this "pointwise" adjunction and then introducing the crucial "Beck-Chevalley
condition," which is the coherence law that guarantees these pointwise adjunctions can be glued together
into a single, global adjunction on the total categories.
*)

(* ========================================================================================================== )
( == Part 1: The Definition (Pointwise Adjunctions) == )
( ========================================================================================================== )

FibredAdjunctionDeclaration ::= "FIBRED_ADJUNCTION" CartesianFunctorDeclaration "⊣" CartesianFunctorDeclaration ;
TYPING
(*

A pair of Cartesian functors (F,G) between two fibrations p and p' over the same base B forms a fibred adjunction

if for every object I in the base category, the restricted functors on the fibres form an adjunction.
*)
Γ ⊢ F : CARTESIAN_FUNCTOR p → p', Γ ⊢ G : CARTESIAN_FUNCTOR p' → p
Condition_PointwiseAdjunction :=
∀ (I ∈ Ob(BaseCategory(p))),
Let F_I := RestrictionOf(F, to:Fibre(p,I)) : Fibre(p,I) → Fibre(p',I)
Let G_I := RestrictionOf(G, to:Fibre(p',I)) : Fibre(p',I) → Fibre(p,I)
(F_I ⊣ G_I) is an Adjunction(Fibre(p,I), Fibre(p',I))

Γ ⊢ FIBRED_ADJUNCTION F ⊣ G is a valid declaration if Condition_PointwiseAdjunction holds ;
CATEGORY
[[ FIBRED_ADJUNCTION F ⊣ G ]] = "A family of adjunctions, indexed by the base category of the fibrations, that is coherent with respect to the fibration structure. The 'fibrewise' adjunctions F_I ⊣ G_I are the primary structure. This is the 'pointwise' definition of an adjunction in a fibred setting." ;

(* ========================================================================================================== )
( == Part 2: The Beck-Chevalley Condition (The Coherence Law) == )
( ========================================================================================================== )

BeckChevalleyCondition ::= "satisfies" "BECK_CHEVALLEY_CONDITION" ;
TYPING
(*

This is a crucial coherence condition. It asserts that for a fibred adjunction, the reindexing

functors commute with the adjoints' units and counits in a specific way.

For a base morphism u:I→J, the condition asserts that the canonical natural transformation u* ∘ G_J → G_I ∘ u*

(which always exists for the right adjoint G) is an isomorphism.
)
Context: Γ ⊢ F ⊣ G is a FIBRED_ADJUNCTION between p:E→B and p':E'→B
Condition := ∀ (u:I→J in B), the canonical comparison transformation β_u : u ∘ G_J ⇒ G_I ∘ u* is an ISOMORPHISM.

Γ ⊢ (F ⊣ G) satisfies BECK_CHEVALLEY_CONDITION is TRUE if Condition holds ;
CATEGORY
[[ satisfies BECK_CHEVALLEY_CONDITION ]] = "A key coherence property for a fibred adjunction. It ensures that the process of 'reindexing then applying the right adjoint' is naturally isomorphic to 'applying the right adjoint then reindexing'. This property is crucial for the stability of adjoints in indexed settings and is the necessary condition for gluing the pointwise adjunctions into a global one." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Connecting Pointwise and Global) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "FibredAdjunctionEquivalence" ":"
"A pair of cartesian functors (F,G) forms a global adjunction F ⊣ G between the total categories"
"<==>"
"(F,G) forms a FIBRED_ADJUNCTION and satisfies the BECK_CHEVALLEY_CONDITION." ;
TYPING
(* This theorem states that the global property is equivalent to the pointwise property plus the coherence condition. *)
Let F:E→E' and G:E'→E be cartesian functors.
P1_Global := (F ⊣ G is an Adjunction(E, E'))

P2_Pointwise := (Γ ⊢ FIBRED_ADJUNCTION F ⊣ G)
P3_Coherence := (Γ ⊢ (F ⊣ G) satisfies BECK_CHEVALLEY_CONDITION)

Γ ⊢ (P1_Global <==> (P2_Pointwise ∧ P3_Coherence)) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FibredAdjunctionEquivalence ]] = "The assertion that a coherent 'pointwise' fibred adjunction is the same thing as a single global adjunction between the total categories. The Beck-Chevalley condition provides the necessary and sufficient coherence to ensure the family of fibrewise adjunctions can be glued together into a single, unified adjunction, and vice versa." ;
}

(*
ELABORATION: This section addresses the question of how the structural property of completeness
(the existence of all small limits) behaves in the context of fibrations. It provides a powerful
theorem that allows one to deduce the completeness of the large "total category" E from the
completeness of its smaller, more manageable components: the base category B and the individual
fibre categories E_I.

A deep elaboration requires us to not only state the theorem but to formalize the constructive
proof, showing exactly how a limit in the total category is built from limits in the base and
the fibres. This reveals why the conditions of the theorem are necessary.
*)

(* ========================================================================================================== )
( == Part 1: The Main Criterion Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "FibrationCompletenessCriterion" ":"
"A fibration p:E→B has a complete total category E if:"
"{" "1. The base B is complete;"
"2. All fibres E_I are complete;"
"3. All reindexing functors u* are continuous (preserve limits)." "}" ;
TYPING
(*

This theorem provides a set of sufficient conditions for the total category of a fibration to be complete.

The conditions are precisely those needed to carry out the constructive proof formalized below.
*)
Context: Γ ⊢ p: E → B is FIBRATION
Premise1: Γ ⊢ B is COMPLETE_CATEGORY
Premise2: ∀ (I ∈ Ob(B)), (Γ ⊢ Fibre(p, I) is COMPLETE_CATEGORY)
Premise3: ∀ (u ∈ Mor(B)), (Γ ⊢ ReindexingFunctor(u) preserves small LIMITS)

Conclusion: Γ ⊢ E is COMPLETE_CATEGORY : MetaTheorem ;
CATEGORY
[[ THEOREM FibrationCompletenessCriterion ]] = "A fundamental construction theorem for limits in a fibration. It asserts that if the base and all fibres are complete, and the reindexing structure is continuous, then the entire total category is also complete. This allows one to verify a global property of the large category E by checking local properties of its smaller constituent parts." ;

(* ========================================================================================================== )
( == Part 2: The Constructive Proof Formalized == )
( ========================================================================================================== )

LimitConstructor_in_Fibration ::= "CONSTRUCT_LIMIT_IN_FIBRATION" "of" "diagram" Identifier "as" "{"
"STEP 1 (Base Limit):" LimitDeclaration "in Base" ";"
"STEP 2 (Fibre Diagram Construction):" DiagramDeclaration "in Fibre" ";"
"STEP 3 (Fibre Limit):" LimitDeclaration "in Fibre" ";"
"}" ;
TYPING
(*

This rule formalizes the standard proof of the completeness criterion. It is a meta-level

algorithm for constructing the limit of a diagram D:J→E in the total category.
*)
Context: Let all premises of the FibrationCompletenessCriterion hold.
Γ ⊢ D : Diagram(J, E)
-- Step 1 --
D_base := p ∘ D : Diagram(J, B)
L_base_cone := LIMIT of D_base in B
L_base_apex := Apex(L_base_cone)
-- Step 2 --
L_fibre_cat := Fibre(p, L_base_apex)
Diagram_in_Fibre D_fib := The diagram constructed by pulling back objects of D along the base limit cone legs.
-- Step 3 --
L_fibre_cone := LIMIT of D_fib in L_fibre_cat
L_total_apex := Apex(L_fibre_cone)

Conclusion: Γ ⊢ L_total_apex is the apex of the LIMIT of D in E : ProvableProposition ;
CATEGORY
[[ CONSTRUCT_LIMIT_IN_FIBRATION ... ]] = "The formal representation of the standard proof of the fibration completeness theorem. It is a canonical algorithm for constructing arbitrary limit objects in a fibration. The process involves first finding the 'address' of the limit in the base category, then constructing a new diagram within that specific fibre by pulling back the original data (this requires continuous reindexing), and finally computing the limit within that fibre." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory for Cocompleteness == )
( ========================================================================================================== )

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'OpfibrationCocompletenessCriterion'" "FROM" "THEOREM" "'FibrationCompletenessCriterion'" ;
TYPING
(*

By applying the duality functor (-)^op, we derive the corresponding theorem for opfibrations and cocompleteness.

System rewrites: fibration→opfibration, complete→cocomplete, limit→colimit, reindexing(u*)→pushforward(u_!).
*)
Γ ⊢ THEOREM 'FibrationCompletenessCriterion' : P_lim
P_colim = rewrite(P_lim, DualityMappings)

Conclusion (rewritten theorem): An opfibration p:E→B has a cocomplete total category E if:

The base B is cocomplete;

All fibres E_I are cocomplete;

All pushforward functors u_! preserve colimits. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual theorem for cocompleteness, derived mechanically by applying the duality functor. It provides a criterion for assembling a cocomplete total category from its cocomplete base and fibres, showcasing the perfect symmetry of the theory." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability" ")" "==>" {
(*
ELABORATION: This combined elaboration tackles two related, advanced topics. The first concerns the crucial
notion of "smallness" for fibrations, which is necessary to avoid set-theoretic paradoxes and for the
category of all fibrations over B to be a well-behaved 2-category. The second topic, "definability,"
connects this entire theory to mathematical logic by showing how fibrations provide a categorical semantics
for first-order theories.

This elaboration will:

Formalize Smallness: Define a LocallySmallFibration as one where each fibre category is a small
category (i.e., its objects and morphisms form sets).

Connect Smallness to Structure: State the theorem that this smallness condition is precisely what is
required for the pseudofunctor produced by the Grothendieck Construction to land in the 2-category of
small categories, Cat. This solidifies the Grothendieck Equivalence.

Formalize the Logic Connection (Definability):
a. Define a FirstOrderTheory as a syntactic object.
b. Define the Lindenbaum-Tarski Fibration associated with a theory T, where the fibres are categories
of provable formulas in a given context.
c. State the main theorem of definability: that this syntactically constructed fibration has a terminal
object (a "generic model") if and only if the theory admits "elimination of quantifiers."
*)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability Part 1: Locally Small Fibrations (Section 8.6)" ")" "==>" {
(*
ELABORATION: This section focuses on the crucial "size" condition required for the theory of fibrations to be well-behaved, particularly concerning the Grothendieck Equivalence. While the total category E of a fibration p:E→B can be large, many important results depend on the individual fibres being "small" (i.e., having sets of objects and morphisms). This property is called local smallness.

A deep elaboration will proceed by:

Formalizing the Master Definition: We will provide the formal definition of a LOCALLY_SMALL fibration, where the property is a universal quantification over the fibres.

Stating the Main Consequence: We will state the refined version of the Grothendieck Equivalence theorem, showing that local smallness is the precise condition on the 'geometric' side (fibrations) that corresponds to the 'algebraic' side (pseudofunctors) having the 2-category of small categories, Cat, as its codomain.

Providing a Canonical Example: We will formalize the "codomain fibration" and show that it is locally small if and only if the base category itself is locally small. This provides a clear, concrete instance of the abstract definition and connects it to a familiar property.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition == )
( ========================================================================================================== )

LocallySmallFibration ::= "LOCALLY_SMALL" FibrationDeclaration ;
TYPING
(*
* This is the master definition. A fibration is locally small if each of its fibre categories is a
* small category in the set-theoretic sense (i.e., its collection of objects and its collection
* of morphisms are both sets, not proper classes).
*)
Context: Γ ⊢ p: E → B is FIBRATION
Condition := ∀ (I ∈ Ob(B)), (Γ ⊢ Fibre(p, I) is SMALL_CATEGORY)
-----------------------------------------------------------------------
Γ ⊢ p is a LOCALLY_SMALL Fibration ;
CATEGORY
[[ LOCALLY_SMALL Fibration p ]] = "A fibration whose indexed categories are all small. This is a crucial 'well-behavedness' condition that ensures the collection of all such fibrations over a base B forms a manageable 2-category and avoids set-theoretic size issues. It is the correct setting for the Grothendieck Equivalence." ;

(* ========================================================================================================== )
( == Part 2: The Main Consequence (The Refined Grothendieck Equivalence) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "RefinedGrothendieckEquivalence" ":"
"The 2-category of LOCALLY_SMALL fibrations over B is equivalent to the 2-category of pseudofunctors from B^op to Cat (the 2-category of small categories)." ;
TYPING
Let Fib_small(B) be the 2-category of locally small fibrations over B.
Let PsFun(B^op, Cat) be the 2-category of pseudofunctors into the category of small categories.
------------------------------------------------------------------------------------------
Γ ⊢ Fib_small(B) ≅ PsFun(B^op, Cat) : EquivalenceOf2Categories ;
CATEGORY
[[ THEOREM RefinedGrothendieckEquivalence ]] = "The precise statement of the Grothendieck Equivalence. The condition of local smallness on the fibration side corresponds exactly to the codomain of the pseudofunctor being the 2-category of small categories, Cat. This solidifies the connection between the geometric and algebraic viewpoints and places it on a firm set-theoretic foundation." ;

(* ========================================================================================================== )
( == Part 3: A Canonical Example (The Codomain Fibration) == )
( ========================================================================================================== )

CodomainFibration ::= "cod" ":" ArrowCategoryDeclaration "→" Identifier ;
TYPING
(*
* This defines the codomain fibration for a category C.
* The total category is the arrow category C^→.
* The projection functor 'cod' maps an arrow f:A→B to its codomain B.
*)
Γ ⊢ C_arrow : ArrowCategory(C)
Γ ⊢ C : Category
------------------------------------------------------------------
Γ ⊢ cod : C_arrow → C is a FIBRATION (This is a standard result) ;
CATEGORY
[[ cod : C^→ → C ]] = "The codomain fibration. The fibre over an object X is the slice category C/X. The Cartesian arrows are the pullback squares in C. This is a foundational example of a fibration." ;

CategoryPropertyDefinition ::= Identifier "is" "LOCALLY_SMALL" ;
TYPING
(* This defines the familiar property for a standard category. *)
Γ ⊢ C : Category
Condition := ∀A,B∈Ob(C), IsSet(Hom_C(A,B))
----------------------------------------------------
Γ ⊢ C is LOCALLY_SMALL : PropositionAbout(C) ;
CATEGORY
[[ C is LOCALLY_SMALL ]] = "The standard property of a category having set-sized collections of morphisms between any two objects. Note: This does not require the collection of all objects to be a set." ;

CorollaryDeclaration ::= "COROLLARY" "CodomainFibrationSmallness" ":"
"IF a category C is locally small and has pullbacks, THEN its codomain fibration is a LOCALLY_SMALL_FIBRATION." ;
TYPING
(*
* This corollary connects the property of the base category to the property of the fibration.
* Proof Sketch:
* 1. The codomain functor cod: C^→ → C is a fibration.
* 2. To be a LOCALLY_SMALL fibration, we need each fibre Fibre(cod, X) to be a small category.
* 3. The fibre over an object X is precisely the slice category C/X.
* 4. A standard result states that if C is locally small and has pullbacks (so it's well-powered), its slice categories are also small.
* 5. Therefore, the codomain fibration is locally small.
*)
Premise: Γ ⊢ C is LOCALLY_SMALL ∧ C has Pullbacks
Let p := CodomainFibration(C).
----------------------------------------------------------
Conclusion: Γ ⊢ p is a LOCALLY_SMALL Fibration : ProvableProposition ;
CATEGORY
[[ COROLLARY CodomainFibrationSmallness ]] = "The assertion that the canonical codomain fibration of a well-behaved category is itself well-behaved with respect to size. This provides a large and natural class of examples for the concept of a locally small fibration and demonstrates how the property is inherited from the base." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability Part 2: Definability and the Connection to Logic (Section 8.7)" ")" "==>" {
(*
ELABORATION: This section focuses on one of the most profound applications of fibration theory: providing a
geometric semantics for mathematical logic. The core idea is to construct a fibration directly from the syntax
of a first-order theory. In this "syntactic fibration," categorical structures correspond directly to logical concepts:
objects are formulas, morphisms are proofs, and reindexing functors are substitutions. The main theorem then reveals a deep
connection between a model-theoretic property of the theory (quantifier elimination) and a categorical property of
its fibration (the existence of a universal object).

This elaboration will deconstruct this correspondence by:

Formalizing the Logical Syntax: We will create rules for the components of a logical theory (contexts, substitutions, formulas-in-context) that will serve as the building blocks for the fibration.

Formalizing the Lindenbaum-Tarski Construction: We will define the LT_Fibration constructor, showing precisely how the syntactic components from Part 1 are assembled into the Base Category, the Total Category, and the Projection Functor. We will highlight that the reindexing functor in this fibration is substitution.

Stating the Main Definability Theorem: We will state the central theorem connecting logic and category theory: the existence of a "generic model" (a terminal object) in the syntactic fibration is equivalent to the logical property of quantifier elimination.
*)

(* ========================================================================================================== )
( == Part 1: The Logical Syntax as Categorical Objects == )
( ========================================================================================================== )

LogicalContext ::= "CONTEXT" "{" {Identifier ":" Identifier} "}" ;
TYPING
(* A context is a finite list of typed variables, serving as an object in the base category of the fibration. *)
is_finite_list_of_typed_variables(l)
-------------------------------------------
Γ ⊢ CONTEXT {l} : Object_in(ContextCategory) ;
CATEGORY
[[ CONTEXT {x₁:T₁ ...} ]] = "A context Γ, representing the collection of free variables currently available. This serves as an object in the base category of the syntactic fibration, with each distinct context being a different object." ;

SubstitutionMorphism ::= "SUBSTITUTION" Identifier ":" LogicalContext "→" LogicalContext "by" "{" {Identifier "↦" Expression} "}" ;
TYPING
(* A substitution is a list of terms, serving as a morphism between contexts. *)
Γ ⊢ σ : Identifier, Γ ⊢ Γ_src : LogicalContext, Γ ⊢ Δ_tgt : LogicalContext
is_valid_substitution(map, from: Γ_src, to: Δ_tgt)
-------------------------------------------------------------------------
Γ ⊢ SUBSTITUTION σ ... : Morphism(Γ_src, Δ_tgt) in ContextCategory ;
CATEGORY
[[ SUBSTITUTION σ ... ]] = "A substitution of terms for variables. This serves as a morphism in the base category of the syntactic fibration, mapping one context to another." ;

FormulaInContext ::= "FORMULA" "(" LogicalContext "," string_literal ")" ;
TYPING
(* A formula-in-context is the primary object of the total category. *)
Γ ⊢ Γ_ctx : LogicalContext
well_formed_formula(φ, in_context: Γ_ctx)
----------------------------------------------------
Γ ⊢ FORMULA (Γ_ctx, φ) : Object_in(TotalFormulaCategory);
CATEGORY
[[ FORMULA (Γ, φ) ]] = "The pair of a context Γ and a formula φ whose free variables are in Γ. This serves as an object in the total category of the syntactic fibration. It represents a proposition in a specific variable environment." ;

(* ========================================================================================================== )
( == Part 2: The Lindenbaum-Tarski Fibration Construction == )
( ========================================================================================================== )

LindenbaumTarskiFibration ::= "LT_Fibration" "(" FirstOrderTheory ")" ;
TYPING
(*
* This is the canonical construction that turns a syntactic theory into a fibration.
* Base Category B: Objects are LogicalContexts, Morphisms are SubstitutionMorphisms.
* Total Category E: Objects are FormulaInContext. A morphism from (Γ,φ) to (Δ,ψ) is a substitution σ:Γ→Δ
* such that the theory T proves φ[σ] ⇒ ψ.
* Projection p: E → B maps (Γ, φ) to Γ and a proof-morphism σ to the underlying substitution σ.
* This functor p can be shown to be a fibration.
*)
Γ ⊢ T : FirstOrderTheory
-----------------------------------------------------
Γ ⊢ LT_Fibration(T) : FIBRATION ;
CATEGORY
[[ LT_Fibration(T) ]] = "The syntactic fibration of a theory T. Its fibres are categories of formulas and provable entailments. Its reindexing functors, induced by substitution, correspond to the pullback of formulas along substitutions. The entire structure of logical deduction for the theory T is encoded geometrically in this fibration." ;

(* ========================================================================================================== )
( == Part 3: The Main Definability Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "DefinabilityAndGenericModels" ":"
"The LT_Fibration(T) has a terminal object (a 'generic model')"
"<==>"
"the theory T admits elimination of quantifiers." ;
TYPING
P1 := (Γ ⊢ LT_Fibration(T) has a TERMINAL_OBJECT)
P2 := (Γ ⊢ T has a model-theoretic property called 'elimination of quantifiers')
--------------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM DefinabilityAndGenericModels ]] = "A deep result connecting a logical property of a theory (elimination of quantifiers) with a categorical property of its associated fibration (existence of a terminal object). A terminal object in the syntactic fibration is a 'formula of all formulas'—a generic predicate from which all other predicates can be uniquely pulled back. The theorem states that a theory possesses such a universal formula if and only if it is simple enough that all its existential questions can be answered with quantifier-free formulas. This provides a powerful geometric interpretation of a core concept in model theory." ;

}
