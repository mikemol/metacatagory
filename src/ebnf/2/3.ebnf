MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 3: 'Algebraic theories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.1: The calculus of relations" ")" "==>" {
(*
ELABORATION: This section formalizes the concept of a "relation" in a regular category. A relation
is no longer a subset of a Cartesian product, but a subobject of a categorical product. The "calculus"
refers to the operations for composing and manipulating these relations. A deep elaboration requires
us to define a relation constructively, then define its composition in terms of the fundamental
categorical operations of pullbacks and images, and finally to show that these operations give rise
to a new categorical structure.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition of a Relation == )
( ========================================================================================================== *)

RelationDeclaration ::= Identifier "is_a" "RELATION" "from" Identifier "to" Identifier ;
TYPING
(*

A relation R from A to B is formally defined as a subobject of their product, A × B.

This requires the ambient category C to have finite products, a property guaranteed by

the assumption that C is a regular category.
*)
Context: C is a REGULAR_CATEGORY
Γ ⊢ A, B : Object_in(C)

Γ ⊢ R is_a RELATION from A to B <==> (Γ ⊢ R : SubobjectOf(A × B)) ;
CATEGORY
[[ R is_a RELATION from A to B ]] = "A categorical relation. It is a subobject of the product A×B, which generalizes the set-theoretic notion of a subset of a Cartesian product. The subobject represents the 'graph' of the relation." ;

(* ========================================================================================================== )
( == Part 2: The Core "Calculus" Operation: Composition == )
( ========================================================================================================== *)

RelationComposition ::= RelationDeclaration "∘" RelationDeclaration ;
TYPING
(*

The composition of a relation S:A⇸B with a relation R:B⇸C is defined by a pullback-then-image construction.

This construction is the categorical analogue of the set-theoretic definition:

R∘S = { (a,c) | ∃b s.t. (a,b)∈S and (b,c)∈R }

The pullback finds all such triples (a,b,c) and the image projects out the (a,c) pairs.

This requires the ambient category to be regular, which guarantees it has both pullbacks and images.
*)
Context: C is a REGULAR_CATEGORY
Γ ⊢ S : RELATION from A to B (represented by mono m_S: S_obj → A×B)
Γ ⊢ R : RELATION from B to C (represented by mono m_R: R_obj → B×C)
-- Step 1: Find the common 'b' values via pullback.
p_B_S := proj_B ∘ m_S : S_obj → B
p_B_R := proj_B ∘ m_R : R_obj → B
P_obj := PullbackObject(p_B_S, p_B_R)
-- Step 2: Project the results into A×C.
map_to_A := proj_A ∘ m_S ∘ proj_S(P_obj) : P_obj → A
map_to_C := proj_C ∘ m_R ∘ proj_R(P_obj) : P_obj → C
composite_map := <map_to_A, map_to_C> : P_obj → A×C
-- Step 3: The composition is the image of this map.

Γ ⊢ R ∘ S : RELATION from A to C (defined as Image(composite_map)) ;
CATEGORY
[[ R ∘ S ]] = "The composition of relations, generalizing relational composition in set theory. It is constructed by finding all 'chains' of length two (the pullback step) and then taking the subobject of the endpoints (the image step). This is the fundamental operation in the category of relations, Rel(C)." ;

(* ========================================================================================================== )
( == Part 3: Other Calculus Operations == )
( ========================================================================================================== *)

OppositeRelation ::= RelationDeclaration "^op" ;
TYPING
(* The opposite of a relation R:A⇸B is a relation R^op:B⇸A, found by swapping the components. *)
Γ ⊢ R : SubobjectOf(A × B)
Let τ : A × B → B × A be the canonical swap isomorphism.
Let m_R : R_obj → A × B be the representative mono for R.

Γ ⊢ R^op : SubobjectOf(B × A) (defined as Image(τ ∘ m_R)) ;
CATEGORY
[[ R^op ]] = "The opposite or converse of a relation, analogous to the transpose of a matrix." ;

IdentityRelation ::= "Id_Rel" "(" Identifier ")" ;
TYPING
(* The identity relation on A is the subobject corresponding to the diagonal map Δ: A → A×A. *)
Γ ⊢ A : Object_in(REGULAR_CATEGORY C)
Let Δ : A → A × A be the diagonal monomorphism.

Γ ⊢ Id_Rel(A) : RELATION from A to A (represented by Δ) ;
CATEGORY
[[ Id_Rel(A) ]] = "The identity relation on A, representing the relation 'is equal to'. It is the graph of the identity function, and it serves as the identity morphism for relation composition." ;

(* ========================================================================================================== )
( == Part 4: The Category of Relations == )
( ========================================================================================================== )

CategoryOfRelations ::= "Rel" "(" Identifier ")" ;
TYPING
(* These operations form a new category, Rel(C). *)
Γ ⊢ C : REGULAR_CATEGORY
Premise_Objects: Objects(Rel(C)) := Objects(C)
Premise_Morphisms: Morphisms_{Rel(C)}(A, B) := { R | Γ ⊢ R is_a RELATION from A to B }
Premise_Composition: Composition in Rel(C) := RelationComposition
Premise_Identities: IdentityMorphism for A in Rel(C) := Id_Rel(A)

Γ ⊢ Rel(C) : Category ;
CATEGORY
[[ Rel(C) ]] = "The category of relations on C. This construction takes a regular category C and produces a new category where the morphisms are relations. This new category has additional structure, such as being a 2-category with inclusions of relations as 2-cells." ;

}

(* ========================================================================================================== )
( == Section 3.2-3.4: Categorical Approach to Universal Algebra (Lawvere Theories) == )
(
ELABORATION: These sections represent a profound conceptual shift, moving universal algebra from a set-theoretic
foundation (sets with operations and equations) to a purely categorical one. The key idea, developed by
William Lawvere, is that an entire algebraic theory (like the theory of groups) can be encoded as a special
kind of category, and a specific algebra (like a particular group) is simply a structure-preserving
functor from that theory-category into Set.

A deep elaboration requires us to formalize this entire pipeline: from the definition of the abstract
"theory-category," to the definition of a "model" as a functor, to the construction of the familiar
"category of models."

Our formalization will proceed by:

Formalizing the Theory: We will define LawvereTheory as a category with finite products whose
objects are abstract "arities" (powers of a single base object). The morphisms of this category are the
"abstract operations" of the theory.

Formalizing the Model: We will define a ModelOfTheory as a product-preserving functor from the theory
category to Set. This functor is the semantic interpretation of the theory: it assigns a concrete carrier
set to the base object and concrete functions to the abstract operations. The functoriality itself ensures
that the theory's axioms (encoded as commutative diagrams) hold true for the model.

Formalizing the Category of Models: We will show how to construct Mod(T, Set), the familiar
category of all algebras for a theory T (e.g., Grp or Mon), where the objects are the model-functors
and the morphisms are natural transformations between them.

Illustrating with an Example: We will instantiate this entire framework with the concrete theory of
Monoids, showing how its operations (multiplication, unit) and axioms (associativity, unitality) are
perfectly captured by the morphisms and commutative diagrams of its Lawvere theory.
*)

(* ========================================================================================================== )
( == Part 1: The Theory-Category (The Syntax) == )
( ========================================================================================================== *)

LawvereTheoryDeclaration ::= "LAWVERE_THEORY" Identifier "with_base_object" Identifier ";" ;
TYPING
(*

The formal definition of a Lawvere Theory. It is a category T with two key properties:

It has all finite products.

Every object in it is isomorphic to a finite product of a single base object, T_obj.

The objects T_obj^n (for n=0,1,2,...) represent the abstract "arities" of the theory's operations.
*)
Γ ⊢ T : Category
Premise1: Γ ⊢ T has FINITE_PRODUCTS
Premise2: ∃ (T_obj ∈ Ob(T)) s.t. (∀X∈Ob(T), ∃n∈ℕ s.t. X ≅ Product(T_obj, n))

Γ ⊢ LAWVERE_THEORY T with_base_object T_obj : AlgebraicTheory ;
CATEGORY
[[ LAWVERE_THEORY T ... ]] = "A syntactic category whose structure embodies an algebraic theory. The objects T_obj^n are the 'types' of arity n, and the morphisms f: T_obj^n → T_obj^m represent the abstract operations of the theory. Composition in the category corresponds to substitution of operations." ;

OperationInTheory ::= "OPERATION" Identifier ":" Identifier "^" integer_literal "→" Identifier "^" integer_literal ";" ;
TYPING
(* An operation is simply a morphism in the Lawvere theory. *)
Context: T is a LAWVERE_THEORY with base object T_obj
Γ ⊢ n, m : integer_literal

Γ ⊢ OPERATION name : T_obj^n → T_obj^m : Morphism(Product(T_obj, n), Product(T_obj, m)) in T ;
CATEGORY
[[ OPERATION name : T_obj^n → T_obj^m ]] = "An m-tuple of n-ary operations defined syntactically as a morphism in the theory category. For example, a binary operation like group multiplication is a morphism T_obj² → T_obj¹." ;

AxiomInTheory ::= "AXIOM" string_literal ":" "Diagram" "(" {Morphism} ")" "COMMUTES" ";" ;
TYPING
(* An axiom is an assertion that two morphisms in the theory are equal, i.e., a diagram commutes. *)
Context: T is a LAWVERE_THEORY
Γ ⊢ f, g : Morphism(A, B) in T

Γ ⊢ AXIOM ... : (f == g) in T ;
CATEGORY
[[ AXIOM ... ]] = "An equational law of the algebraic theory, encoded as a commutative diagram. For example, the associativity of multiplication is encoded by the commuting of the diagram corresponding to the equation μ(μ(x,y),z) = μ(x,μ(y,z))." ;

(* ========================================================================================================== )
( == Part 2: The Model-Functor and Category of Models (The Semantics) == )
( ========================================================================================================== *)

ModelOfTheory ::= "MODEL" Identifier "of" LawvereTheoryDeclaration "in" CategoryDeclaration ";" ;
TYPING
(* A model is a product-preserving functor from the theory-category to a target category (usually Set). *)
Γ ⊢ T : LAWVERE_THEORY, Γ ⊢ C : Category with FINITE_PRODUCTS
Γ ⊢ M : Functor(T, C)
Premise_PreservesProducts: ∀X,Y∈Ob(T), M(Product(X,Y)) ≅ Product(M(X), M(Y))

Γ ⊢ MODEL M of T in C : T_Algebra ;
CATEGORY
[[ MODEL M of T in C ]] = "An algebra, or semantic interpretation of the theory T. The functor M assigns a concrete object in C (the 'carrier') to the base object T_obj and interprets the abstract operation-morphisms of T as concrete morphisms in C. The functoriality guarantees that all the theory's axioms are satisfied by these concrete operations." ;

CategoryOfModels ::= "Mod" "(" LawvereTheoryDeclaration "," CategoryDeclaration ")" ;
TYPING
(* The category of T-Models in C has the models as objects and natural transformations as morphisms. *)
Γ ⊢ T : LAWVERE_THEORY, Γ ⊢ C : Category
Objects := { M | Γ ⊢ M : MODEL of T in C }
Morphisms := { α : M₁ ⇒ M₂ | Γ ⊢ α : NaturalTransformation }

Γ ⊢ Mod(T, C) : Category ;
CATEGORY
[[ Mod(T, C) ]] = "The category of all T-algebras in C. For instance, if T is the theory of Monoids and C is Set, then Mod(T, Set) is precisely the category Mon. This construction provides the bridge from the abstract syntax of a theory to the concrete category of its models." ;

(* ========================================================================================================== )
( == Concrete Example: The Lawvere Theory of Monoids == )
( ========================================================================================================== *)

LAWVERE_THEORY "T_Mon" "with_base_object" "X" {
"Operations" : {
OPERATION "μ" : X^2 → X^1 ; (* The binary multiplication )
OPERATION "η" : X^0 → X^1 ; ( The nullary unit element )
},
"Axioms" : {
AXIOM "Associativity" : "Diagram involving μ(μ(x,y),z) and μ(x,μ(y,z))" COMMUTES ;
AXIOM "Left Unitality" : "Diagram involving μ(η, x)" COMMUTES ;
AXIOM "Right Unitality" : "Diagram involving μ(x, η)" COMMUTES ;
}
};
TYPING
( This declares the theory of monoids. A model M: T_Mon -> Set will be a product-preserving functor. *)
M(X) := S (a carrier set)
M(X²) ≅ M(X) × M(X) = S × S
M(X⁰) ≅ M(X)⁰ = {∗} (a singleton set, the terminal object in Set)
M(μ) : M(X²) → M(X¹) becomes a concrete function f_μ : S×S → S.
M(η) : M(X⁰) → M(X¹) becomes a concrete function f_η : {∗} → S, which is equivalent to picking an element e ∈ S.
-- The functoriality M(diag commutes) => M(diag) commutes means:
-- The abstract associativity diagram becomes the concrete law: f_μ(f_μ(a,b),c) = f_μ(a,f_μ(b,c)).
-- The abstract unitality diagrams become the concrete laws: f_μ(a,e) = a and f_μ(e,a) = a.
-- Therefore, the data (S, f_μ, e) is precisely a monoid.

Γ ⊢ "Any MODEL of T_Mon in Set is a Monoid." : ProvableProposition ;
CATEGORY
[[ MODEL of T_Mon in Set ]] = "A concrete monoid. The Lawvere theory framework demonstrates that the entire structure of a monoid—its carrier set, its binary operation, its unit element, and its axioms—is perfectly captured by a single product-preserving functor." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.5-3.7: Properties of Algebraic Categories" ")" "==>" {
(*
ELABORATION: This elaboration deconstructs the bundled summary of properties for algebraic categories, formalizing each major result from Sections 3.5, 3.6, and 3.7 as a distinct, detailed theorem. This approach clarifies the specific structural guarantees that come from a category being "algebraic" (i.e., a category of models for a Lawvere theory).
*)

(* ========================================================================================================== )
( == Section 3.5: Limits and Colimits in Algebraic Categories == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "AlgebraicCategoriesAreCompleteAndCocomplete" ":"
"Every ALGEBRAIC_CATEGORY is both complete and cocomplete." ;
TYPING
(*
* This theorem is a consequence of the fact that limits and colimits in a category of models Mod(T, Set)
* can be constructed "pointwise" in the base category, Set. Since Set itself is complete and
* cocomplete, Mod(T, Set) inherits these properties.
*)
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> ((Γ ⊢ C is COMPLETE) ∧ (Γ ⊢ C is COCOMPLETE))
----------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM AlgebraicCategoriesAreCompleteAndCocomplete ]] = "A fundamental structural property. It asserts that the category of models inherits the excellent completeness properties of its base category (usually Set). Limits in an algebraic category are computed by taking the limit of the underlying sets and endowing it with the algebraic structure in a canonical way. A similar, though more complex, construction holds for colimits." ;

(* ========================================================================================================== )
( == Section 3.6: The Exactness Properties of Algebraic Categories == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "AlgebraicCategoriesAreRegular" ":"
"Every ALGEBRAIC_CATEGORY is a REGULAR_CATEGORY." ;
TYPING
(*
* This property is also inherited from the base category Set, which is the archetypal regular category.
* The necessary structures—finite limits, stable (RegularEpi, Mono) factorizations—are created
* "pointwise" in Set and lift to the category of models.
*)
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> (Γ ⊢ C is REGULAR_CATEGORY)
----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM AlgebraicCategoriesAreRegular ]] = "An assertion of the well-behaved exactness properties of algebraic categories. This guarantees that they have a robust theory of images (factorizations) and effective equivalence relations, making them suitable for a wide range of algebraic constructions even in a non-additive setting." ;

(* ========================================================================================================== )
( == Section 3.9 (Context for 3.7): Free Objects == )
( ========================================================================================================== )

ForgetfulFunctor_Algebraic ::= "U" ":" Identifier "→" "Set" ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ U : C → Set : ForgetfulFunctor ;
CATEGORY
[[ U : C → Set ]] = "The forgetful functor that maps an algebra to its underlying set of elements, forgetting the operations and axioms." ;

FreeFunctor_Algebraic ::= "F" ":" "Set" "→" Identifier ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ F : Set → C : Functor ;
CATEGORY
[[ F : Set → C ]] = "The free functor, which constructs the 'freest' possible algebra on a given set of generators. This involves building a term algebra and quotienting by the theory's equational laws." ;

TheoremDeclaration ::= "THEOREM" "ExistenceOfFreeFunctorAdjunction" ":"
"For every ALGEBRAIC_CATEGORY C, the forgetful functor U:C→Set has a left adjoint F, the Free Functor." ;
TYPING
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> (∃ F s.t. FunctionalAdjunction(F, U_{C}))
---------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ExistenceOfFreeFunctorAdjunction ]] = "The assertion of the free-forgetful adjunction (F ⊣ U), a hallmark of algebraic categories. The existence of the free functor guarantees that for any set of generators, there is a universal algebra satisfying the theory's laws, from which all other homomorphisms are uniquely determined. This is the categorical foundation of 'free objects' in algebra." ;

(* ========================================================================================================== )
( == Section 3.7: The Algebraic Lattices of Subobjects == )
( ========================================================================================================== )

LatticeElementProperty ::= Identifier "is" "COMPACT_IN" Identifier ;
TYPING
(* An element c in a complete lattice L is compact if its relationship to any join can be witnessed by a finite sub-join. *)
Γ ⊢ L : CompleteLattice
Γ ⊢ c : ElementOf(L)
Condition := ∀S ⊆ L, (c ≤ Join(S)) ==> (∃ S_fin ⊆ S, (|S_fin| is finite) ∧ (c ≤ Join(S_fin)) )
-----------------------------------------------------------------------------------------------
Γ ⊢ c is COMPACT_IN L is TRUE if Condition holds ;
CATEGORY
[[ c is COMPACT_IN L ]] = "A lattice-theoretic notion of finiteness. A compact element cannot be 'reached' by an infinite process without also being reached by a finite part of that process." ;

LatticePropertyDeclaration ::= Identifier "is" "ALGEBRAIC_LATTICE" ;
TYPING
(* A complete lattice is algebraic if every element is the join of the compact elements below it. *)
Γ ⊢ L : CompleteLattice
Condition := ∀x ∈ L, (x == Join({c ∈ L | c is COMPACT_IN L ∧ c ≤ x}))
----------------------------------------------------------------------
Γ ⊢ L is ALGEBRAIC_LATTICE is TRUE if Condition holds ;
CATEGORY
[[ L is ALGEBRAIC_LATTICE ]] = "A type of complete lattice that is richly supplied with compact elements. These lattices are characteristic of algebraic structures." ;

TheoremDeclaration ::= "THEOREM" "SubobjectLatticesInAlgebraicCategoriesAreAlgebraic" ":"
"In any ALGEBRAIC_CATEGORY C, for any object X, the subobject lattice Sub(X) is an ALGEBRAIC_LATTICE." ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
--------------------------------------------------------------------
∀X ∈ Ob(C), (Γ ⊢ Sub(X) is ALGEBRAIC_LATTICE) : MetaTheorem ;
CATEGORY
[[ THEOREM SubobjectLatticesInAlgebraicCategoriesAreAlgebraic ]] = "A deep structural result connecting the algebraic nature of the category to the lattice-theoretic nature of its subobjects. In this context, the compact elements of the subobject lattice Sub(X) correspond precisely to the finitely generated sub-algebras of X. The theorem states that any sub-algebra is the directed union of its finitely generated sub-algebras." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.8, 3.10: Algebraic Functors and Characterization" ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.8: Algebraic Functors" ")" "==>" {
(*

ELABORATION: This section defines the "correct" notion of a structure-preserving map between two
algebraic categories. The central idea is that an algebraic category (like Grp or Ring) is a category
of "sets with extra structure." A functor between such categories should not be arbitrary; it must
respect this underlying "set-based" foundation.

The way to formalize this respect is to require the functor to commute with the process of "forgetting"
the algebraic structure. For any algebraic category C, there is a forgetful functor U_C: C → Set that
maps an algebra to its underlying set. An algebraic functor F: C → D must behave such that if you
take an algebra in C, apply F to get an algebra in D, and then forget D's structure to get a set, the result
should be the same (up to natural isomorphism) as just forgetting C's structure in the first place.

Our elaboration will formalize this principle through three main steps:

The Components: We will clearly define the players: the Algebraic Categories and their canonical Forgetful Functors.

The Master Definition: We will define an Algebraic Functor by the property that it commutes with these forgetful functors up to a natural isomorphism.

The Origin Theorem: We will state the crucial theorem that explains where algebraic functors come from: they are precisely the functors induced by morphisms between the underlying Lawvere theories. This connects the semantic notion of an algebraic functor to the syntactic notion of a map between theories.
*)

(* ========================================================================================================== )
( == Part 1: The Components (The Stage and the Players) == )
( ========================================================================================================== *)

AlgebraicCategoryDeclaration ::= Identifier "is" "ALGEBRAIC_CATEGORY" ;
TYPING
(* A category C is algebraic if it is equivalent to the category of models of some Lawvere theory in Set. *)
∃ (T : LAWVERE_THEORY) s.t. (Γ ⊢ C ≅ Mod(T, Set))
---------------------------------------------------
Γ ⊢ C is ALGEBRAIC_CATEGORY ;
CATEGORY
[[ C is ALGEBRAIC_CATEGORY ]] = "A category that is the semantic realization of some finite-product theory. These categories, like Grp, Mon, and Ring, share a rich common structure." ;

ForgetfulFunctor_Algebraic ::= "U_" Identifier ;
TYPING
(* This constructor defines the forgetful functor U_C: C -> Set for an algebraic category C. *)
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ U_C : Functor(C, Set) ;
CATEGORY
[[ U_C ]] = "The canonical forgetful functor that maps an algebra in C to its underlying set of elements, forgetting the operations and axioms." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition (Commutation with Forgetting) == )
( ========================================================================================================== *)

AlgebraicFunctorDeclaration ::= Identifier "is" "ALGEBRAIC_FUNCTOR" ;
TYPING
(*
* The formal definition of an algebraic functor F: C -> D. It must commute with the respective
* forgetful functors up to a natural isomorphism. This ensures it maps underlying sets to
* underlying sets in a coherent way.
*)
Γ ⊢ F : Functor(C, D)
Γ ⊢ C, D : ALGEBRAIC_CATEGORY
Let U_C := ForgetfulFunctor_Algebraic of C
Let U_D := ForgetfulFunctor_Algebraic of D
Condition: ∃ (α : NaturalIsomorphism s.t. α : U_D ∘ F ⇒ U_C)
----------------------------------------------------------------
Γ ⊢ F is ALGEBRAIC_FUNCTOR is TRUE if Condition holds ;
CATEGORY
[[ F is ALGEBRAIC_FUNCTOR ]] = "A structure-preserving map between algebraic categories. The requirement that it commutes with the forgetful functors is the key coherence condition. It means that the process of 'applying F then forgetting' is naturally the same as just 'forgetting'. The functor F must act on the algebraic structure in a way that is compatible with how it acts on the underlying sets." ;

(* ========================================================================================================== )
( == Part 3: The Origin Theorem (The Source of Algebraic Functors) == )
( ========================================================================================================== *)

LawvereTheoryMorphism ::= "THEORY_MORPHISM" Identifier ":" LawvereTheoryDeclaration "→" LawvereTheoryDeclaration ;
TYPING
(* A morphism between two Lawvere theories is a functor that preserves the finite product structure. *)
Γ ⊢ T1, T2 : LAWVERE_THEORY
-------------------------------------------------------------------------------------
Γ ⊢ THEORY_MORPHISM φ : T1 → T2 : Functor(T1, T2) which preserves FINITE_PRODUCTS ;
CATEGORY
[[ THEORY_MORPHISM φ : T1 → T2 ]] = "A structure-preserving map between the syntactic theories themselves. It translates the operations and axioms of theory T1 into the language of theory T2." ;

InducedFunctorOnModels ::= "Mod" "(" LawvereTheoryMorphism ")" ;
TYPING
(* A theory morphism φ: T1 → T2 induces a functor in the opposite direction on the categories of models. *)
Γ ⊢ φ : THEORY_MORPHISM(T1 → T2)
ActionOnObjects: (A T2-Model M:T2→Set) ↦ (the T1-Model M∘φ : T1→Set)
--------------------------------------------------------------------------
Γ ⊢ Mod(φ) : Functor(Mod(T2, Set), Mod(T1, Set)) ;
CATEGORY
[[ Mod(φ) ]] = "The functor between model categories induced by a theory morphism φ. It acts via pre-composition, taking a model of T2 and restricting it along φ to produce a model of T1. For example, a theory morphism from the theory of rings to the theory of monoids induces the forgetful functor from Ring to Mon." ;

TheoremDeclaration ::= "THEOREM" "CharacterizationOfAlgebraicFunctors" ":"
"A functor F: C → D is ALGEBRAIC"
"<==>"
"F is naturally isomorphic to Mod(φ) for some THEORY_MORPHISM φ." ;
TYPING
(* This provides a complete characterization. *)
P1 := (Γ ⊢ F is ALGEBRAIC_FUNCTOR)
P2 := ∃(φ : THEORY_MORPHISM(T_D → T_C)) s.t. (Γ ⊢ F ≅ Mod(φ))
----------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CharacterizationOfAlgebraicFunctors ]] = "A fundamental theorem revealing the origin of algebraic functors. It asserts that every semantic map between algebraic categories arises from a corresponding syntactic map between their underlying Lawvere theories. This establishes a deep duality between the syntactic world of theories and the semantic world of their models." ;
}

(*
ELABORATION: This section presents the Beck Characterization Theorem, a deep and powerful result that provides an "internal"
way to recognize an algebraic category. Instead of needing to find an external Lawvere theory T
and prove an equivalence C ≅ Mod(T, Set), this theorem gives a checklist of properties internal
to C that are necessary and sufficient.

A deep elaboration requires us to formally deconstruct this checklist into its constituent parts,
showing how each condition contributes to the overall "algebraic" nature of the category.

Our formalization will proceed by:

Formalizing the Key Object (The Generator): We will define the special properties the
generator G must have. It must be a "regular projective" object, a specific kind of "freeness"
suited to the regular category context.

Formalizing the Construction Principle: We will formalize the idea that every object in the
category must be "built from" the generator. This is captured by the property that every
object is a regular quotient of a coproduct of copies of the generator.

Assembling the Master Theorem: We will combine these properties into the full statement of
Beck's Characterization Theorem, showing that a category satisfying these internal structural
axioms is guaranteed to be equivalent to a category of models for some Lawvere theory.
*)

(* ========================================================================================================== )
( == Part 1: The Properties of the Generator == )
( ========================================================================================================== )

ObjectPropertyAssertion ::= Identifier "is" "REGULAR_PROJECTIVE" ;
TYPING
(*

An object P is regular projective if it has the lifting property specifically with respect

to the class of regular epimorphisms. This is a weaker condition than full projectivity but

is the precise notion of 'freeness' relevant for regular and algebraic categories.
*)
Γ ⊢ P : Object
Condition := ∀(e:A→B is REGULAR_EPIMORPHISM), the map (f↦e∘f) : Hom(P,A)→Hom(P,B) is a surjection.

Γ ⊢ P is REGULAR_PROJECTIVE is TRUE if Condition holds ;
CATEGORY
[[ P is REGULAR_PROJECTIVE ]] = "The property of an object having sufficient 'freeness' to lift through any regular quotient map. In an algebraic category, the free algebra on one generator is the canonical example of a regular projective generator." ;

(* ========================================================================================================== )
( == Part 2: The Construction Principle from the Generator == )
( ========================================================================================================== )

CoproductOfGenerator ::= "Coproduct_over" "(" Identifier ")" "of" Identifier ;
TYPING
(* This constructor defines the coproduct of a generator G over an index set I. *)
Γ ⊢ G : Object_in(Category C), Γ ⊢ C has Coproducts
Γ ⊢ I : Set

Γ ⊢ Coproduct_over(I) of G : Object_in(C) ;
CATEGORY
[[ Coproduct_over(I) of G ]] = "The coproduct of I copies of the generator G, written ∐_I G. In an algebraic category, this object plays the role of the 'free object on I generators'." ;

CategoryProperty_IsRegularlyCoveredByGenerator ::= Identifier "is" "REGULARLY_COVERED_BY" Identifier ;
TYPING
(*

This is a global property of the category. It asserts that every object X can be

constructed from the generator G by first taking a large enough coproduct of G and then

forming a regular quotient of it.
*)
Context: Γ ⊢ C : Category, Γ ⊢ G : Object_in(C)
Condition := ∀ X ∈ Ob(C), ∃ (I:Set) s.t. ( ∃ (e: Coproduct_over(I) of G → X s.t. e is REGULAR_EPIMORPHISM) )

Γ ⊢ C is REGULARLY_COVERED_BY G is TRUE if Condition holds ;
CATEGORY
[[ C is REGULARLY_COVERED_BY G ]] = "The assertion that the generator G is sufficient to construct every other object in the category using only the canonical 'algebraic' constructions of coproducts (for gathering generators) and regular epimorphisms (for imposing relations)." ;

(* ========================================================================================================== )
( == Part 3: The Master Characterization Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "BeckCharacterizationOfAlgebraicCategories" ":"
"A category C is ALGEBRAIC_CATEGORY if and only if:"
"{" "1. C is COCOMPLETE;"
"2. C has a REGULAR_PROJECTIVE generator G;"
"3. C is REGULARLY_COVERED_BY G."
"}" ;
TYPING
(* This is the formal typing for the master characterization theorem. *)
P1 := (Γ ⊢ C is ALGEBRAIC_CATEGORY)

P2_Cocomplete := (Γ ⊢ C is COCOMPLETE)
P2_Generator := (∃ G ∈ Ob(C) s.t. (Γ ⊢ G is GENERATOR) ∧ (Γ ⊢ G is REGULAR_PROJECTIVE))
P2_Covering := (Γ ⊢ C is REGULARLY_COVERED_BY G)
P2 := (P2_Cocomplete ∧ P2_Generator ∧ P2_Covering)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM BeckCharacterizationOfAlgebraicCategories ]] = "A deep theorem providing a complete internal characterization of algebraic categories. It asserts that the 'external' property of being equivalent to a category of models for a Lawvere theory is precisely the same as a set of 'internal' structural properties: having all colimits, possessing a sufficiently 'free' generator, and being built entirely from that generator via coproducts and quotients. This allows one to identify a category as algebraic from the inside out, without needing to first construct its theory." ;

(*
ELABORATION: This section elaborates on the advanced topics that conclude the study of algebraic
theories. A deep elaboration requires deconstructing each concept—commutativity, tensor product, and
Morita equivalence—into its formal definition and its primary consequence or characterization, showing
how these concepts build a meta-theory about the relationships between algebraic theories themselves.
*)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.11: Commutative Theories" ")" "==>" {
(*
ELABORATION: This section defines a special, powerful property of an algebraic theory. A theory is "commutative"
not merely if a single binary operation is commutative, but in a much deeper sense: every operation must be
a homomorphism for every other operation. This syntactic property within the Lawvere theory has a profound
semantic consequence: it endows the category of models with a symmetric monoidal structure (a tensor product).

A deep elaboration requires us to:

Formalize the Commutativity Axiom: We will define the "interchange law" between two
abstract operations as a commutative diagram in the Lawvere theory. This is the heart of the definition.

Define a Commutative Theory: We will define a COMMUTATIVE LawvereTheoryDeclaration as a theory where this
interchange law holds for every pair of its operations.

State the Main Consequence: We will formalize the main theorem, which asserts that the category
of models for a commutative theory is always a symmetric monoidal category.

Provide Canonical Examples: We will contrast the theory of R-modules (which is commutative) with the
theory of Groups (which is not, unless the groups are abelian), showing how the interchange law
manifests as the familiar distributivity law in the case of modules, and how its failure explains
the lack of a canonical tensor product for general groups.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Commutativity Axiom (The Interchange Law) == )
( ========================================================================================================== *)

CommutativityAxiom ::= "AXIOM" "Interchange" "for" "(" OperationDeclaration "," OperationDeclaration ")" "COMMUTES" ;
TYPING
(*

This axiom formalizes the idea that an n-ary operation f and an m-ary operation g commute.

This is expressed by an "interchange square". Imagine an n×m matrix of variables. Applying g to

each row and then f to the results must be the same as applying f to each column and then g to the results.

This is encoded as a commutative diagram in the Lawvere theory T with base object X.
)
Context: T is a LAWVERE_THEORY with base object X
Γ ⊢ f : Morphism(X^n, X), Γ ⊢ g : Morphism(X^m, X) in T
-- Build the diagram paths
Path1 := f ∘ (g × ... × g) : X^(nm) → X (* Apply g to n rows, then f to the result )
Path2 := g ∘ (f × ... × f) : X^(nm) → X (* Apply f to m columns, then g to the result *)

Γ ⊢ AXIOM Interchange for (f,g) COMMUTES <==> (Path1 == Path2) in T ;
CATEGORY
[[ AXIOM Interchange for (f,g) COMMUTES ]] = "The assertion of the interchange law for operations f and g. It is the syntactic condition within the Lawvere theory that guarantees the operations can be applied in any order without changing the overall result. When f is addition and g is multiplication, this is the distributivity law." ;

(* ========================================================================================================== )
( == Part 2: The Definition of a Commutative Theory == )
( ========================================================================================================== *)

CommutativeLawvereTheory ::= "COMMUTATIVE" LawvereTheoryDeclaration ;
TYPING
(* A Lawvere theory is commutative if the interchange law holds for every pair of its operations. *)
Γ ⊢ T : LAWVERE_THEORY
Condition := ∀ (op1, op2 ∈ Operations(T)), (Γ ⊢ AXIOM Interchange for (op1,op2) COMMUTES)

Γ ⊢ T is COMMUTATIVE ;
CATEGORY
[[ COMMUTATIVE LAWVERE_THEORY T ]] = "An algebraic theory in which all operations are mutually homomorphic. This compatibility is a very strong condition with powerful consequences for the category of models." ;

(* ========================================================================================================== )
( == Part 3: The Main Semantic Consequence == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CommutativeTheoriesYieldMonoidalCategories" ":"
"IF T is a COMMUTATIVE Lawvere Theory, THEN the category Mod(T,Set) is a symmetric monoidal category." ;
TYPING
(*

The tensor product of two models, M₁ and M₂, is constructed on the tensor product of their underlying sets.

The commutative (interchange) axiom is precisely what is needed to define the action of any operation

on the tensor product set S₁⊗S₂ in a canonical, coherent way.
*)
Γ ⊢ T is COMMUTATIVE

Γ ⊢ Mod(T, Set) is SYMMETRIC_MONOIDAL_CATEGORY : ProvableProposition ;
CATEGORY
[[ THEOREM CommutativeTheoriesYieldMonoidalCategories ]] = "A deep result connecting the syntactic property of commutativity in a theory to the semantic property of having a tensor product structure on its category of models. For example, because the theory of abelian groups is commutative, the category Ab has a tensor product (⊗_ℤ). The non-commutativity of the theory of general groups is why Grp does not have such a canonical tensor product." ;

(* ========================================================================================================== )
( == Part 4: The Canonical Examples == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "TheoryOfRModulesIsCommutative" "of" CommutativeLawvereTheory ;
TYPING
(*

The theory of R-modules has addition (+ : 2→1) and scalar multiplication for each r∈R (s_r : 1→1).

We must check the interchange law for all pairs.

(+, +): This holds because addition is commutative and associative in an R-module.

(s_r, s_q): This holds because s_r(s_q(x)) = (rq)x = (qr)x = s_q(s_r(x)) (if R is commutative).

(+, s_r): The interchange diagram for these two operations is precisely the distributivity law:

s_r(x + y) = s_r(x) + s_r(y).

Since all pairs commute, the theory is commutative.
*)
Let T_RMod be the Lawvere Theory for R-modules.

Γ ⊢ T_RMod is COMMUTATIVE : ProvableProposition ;
CATEGORY
[[ INSTANCE TheoryOfRModulesIsCommutative ... ]] = "A key example of a commutative theory. The familiar axiom of distributivity for modules is a specific instance of the general interchange law. Because the theory is commutative, the category R-Mod has a tensor product (⊗_R), as predicted by the main theorem." ;

TheoremInstantiation ::= "INSTANCE" "TheoryOfGroupsIsNotCommutative" ;
TYPING
(*

The theory of groups has one binary operation, multiplication (μ : 2→1), and a nullary unit.

For the theory to be commutative, μ must commute with itself.

The interchange law for (μ, μ) is the statement: μ(μ(a,b), μ(c,d)) = μ(μ(a,c), μ(b,d)).

This is known as the Eckmann-Hilton argument. In a group, this identity holds if and only if

the group is abelian. Therefore, the Lawvere theory for general, non-abelian groups is not commutative.
*)
Let T_Grp be the Lawvere Theory for Groups.

Γ ⊢ (T_Grp is COMMUTATIVE <==> Models are Abelian) : ProvableEquivalence ;
CATEGORY
[[ INSTANCE TheoryOfGroupsIsNotCommutative ... ]] = "A key counterexample. The self-interchange law for group multiplication only holds if the group is abelian. This demonstrates that the property of being a commutative theory is a very strong condition, corresponding to abelian-like structures. The failure of this syntactic condition in the theory is the ultimate reason for the failure of the category Grp to have a canonical tensor product." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.12: Tensor product of theories" ")" "==>" {
(*
ELABORATION: This section provides a powerful categorical tool for combining two distinct algebraic theories
into a single, richer theory. The key idea is to construct a new theory, the "Tensor Product" T₁⊗T₂,
whose models are precisely those objects that possess both a T₁-structure and a T₂-structure, with the
added crucial condition that these two structures are "compatible." This compatibility is formalized as the
requirement that every operation from the first theory must be a homomorphism for every operation from
the second theory.

A deep elaboration requires that we first formalize this semantic target—the "bialgebra"—and then show how
the syntactic construction of the tensor product of theories is precisely the object that generates it.
*)

(* ========================================================================================================== )
( == Part 1: The Semantic Target - The Bialgebra == )
( ========================================================================================================== )
(Before defining the theory T₁⊗T₂, we must define what we want its models to be.)

BialgebraDeclaration ::= Identifier "is" "T1_T2_Bialgebra" ;
TYPING
(*

A (T₁,T₂)-bialgebra is a set S that is equipped with both a T₁-algebra structure and a T₂-algebra

structure, such that the operations are compatible.
*)
Context: Γ ⊢ T1, T2 : LAWVERE_THEORY
Γ ⊢ S : Set
Premise1: S has a T1-algebra structure (functor M₁: T₁→Set with carrier S).
Premise2: S has a T2-algebra structure (functor M₂: T₂→Set with carrier S).
Premise3: (Compatibility) Every operation from T₁ commutes with every operation from T₂.

Γ ⊢ S is T1_T2_Bialgebra : ProvableProposition ;
CATEGORY
[[ S is T1_T2_Bialgebra ]] = "An algebra with two compatible structures. The compatibility condition is the interchange law between operations from the different theories. For example, a Ring is a (Theory_Monoids, Theory_AbelianGroups)-Bialgebra, where the compatibility is the distributivity of multiplication over addition." ;

CategoryOfBialgebras ::= "Bialg" "(" LawvereTheoryDeclaration "," LawvereTheoryDeclaration ")" ;
TYPING
(* The category of (T₁,T₂)-bialgebras in Set. *)
Objects := { S | Γ ⊢ S is T1_T2_Bialgebra }
Morphisms := { f:S₁→S₂ | f is a homomorphism for both the T₁ and T₂ structures }

Γ ⊢ Bialg(T1, T2) : Category ;
CATEGORY
[[ Bialg(T1, T2) ]] = "The category of all (T₁,T₂)-bialgebras. This is our semantic target category." ;

(* ========================================================================================================== )
( == Part 2: The Syntactic Construction - The Tensor Product Theory == )
( ========================================================================================================== )
(This is the syntactic object whose models will be the bialgebras defined above.)

TensorProductOfTheories ::= LawvereTheoryDeclaration "⊗" LawvereTheoryDeclaration ;
TYPING
(*

The tensor product of two Lawvere theories is a new Lawvere theory. It is the coproduct

in the category of Lawvere theories.

Its operations are the union of the operations of T₁ and T₂, and its axioms include all axioms

from T₁ and T₂, plus all interchange law axioms between pairs of operations from T₁ and T₂.
*)
Γ ⊢ T1, T2 : LAWVERE_THEORY
T_tensor := a new LAWVERE_THEORY where:
Operations(T_tensor) := Operations(T1) ∪ Operations(T2)
Axioms(T_tensor) := Axioms(T1) ∪ Axioms(T2) ∪ { InterchangeAxiom(f,g) | f∈Ops(T1), g∈Ops(T2) }

Γ ⊢ T1 ⊗ T2 : LAWVERE_THEORY (defined by this construction) ;
CATEGORY
[[ T1 ⊗ T2 ]] = "The Lawvere theory whose operations are the disjoint union of the operations of T1 and T2, and whose axioms are the combined axioms of both theories plus new axioms enforcing that every operation from T1 commutes with every operation from T2. It is the syntactic embodiment of compatible, combined structures." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Connecting Syntax and Semantics) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "TensorProductModelsAreBialgebras" ":"
"The category of models of a tensor product of theories is equivalent to the category of bialgebras." ;
TYPING
(* This theorem is the universal property of the tensor product of theories. *)
Γ ⊢ T1, T2 : LAWVERE_THEORY
P1_SemanticCategory := Bialg(T1, T2)
P2_ModelCategory := Mod(T1 ⊗ T2, Set)

Γ ⊢ P1_SemanticCategory ≅ P2_ModelCategory : EquivalenceOfCategories ;
CATEGORY
[[ THEOREM TensorProductModelsAreBialgebras ]] = "The fundamental theorem of the tensor product of theories. It asserts that our syntactic construction (T₁⊗T₂) is the correct one, as its semantic models (Mod(T₁⊗T₂, Set)) are precisely the category of objects that have both a T₁-structure and a T₂-structure in a compatible way (Bialg(T₁, T₂))." ;

(* ========================================================================================================== )
( == Concrete Example: The Theory of Rings == )
( ========================================================================================================== )

TheoremInstantiation ::= "INSTANCE" "TheoryOfRingsAsTensorProduct" "of" TensorProductOfTheories ;
TYPING
(*

We instantiate the theory with the canonical example: Rings.

A ring has a monoid structure (for multiplication) and an abelian group structure (for addition).

The compatibility condition is that multiplication distributes over addition.

This is exactly the interchange law communion between the monoid operation and the group operations.
*)
T_Mon := LAWVERE_THEORY for Monoids
T_Ab := LAWVERE_THEORY for Abelian Groups

Γ ⊢ TheoryOfRings ≅ (T_Mon ⊗ T_Ab) : IsomorphismOfTheories ;
-- Consequence via the main theorem:
Γ ⊢ Mod(TheoryOfRings, Set) ≅ Bialg(T_Mon, T_Ab)
Γ ⊢ Category("Ring") ≅ Bialg(T_Mon, T_Ab) ;
CATEGORY
[[ INSTANCE TheoryOfRingsAsTensorProduct ]] = "A concrete realization of the tensor product of theories. It asserts that the syntactic theory of rings is the tensor product of the theory of monoids and the theory of abelian groups. The distributivity law is not an ad-hoc axiom, but is the necessary interchange axiom that arises from the tensor product construction. Consequently, the category of Rings is precisely the category of (Monoid, Abelian Group)-bialgebras." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.13: Morita Equivalence" ")" "==>" {
(*
ELABORATION: This section, "A glance at Morita theory," introduces one of the most profound equivalence
relations in algebra. The central idea is that two different algebraic theories (and thus two different
rings, in the classic example) can be syntactically distinct yet semantically identical, meaning their
categories of models are equivalent. This is a much weaker notion than isomorphism of theories.

A deep elaboration requires us to not just state this definition, but to deconstruct the canonical
example—the equivalence of a ring R with its matrix ring Mₙ(R)—to show how this equivalence is
achieved. This requires formalizing the "bridge" object, the Progenerator, that facilitates the
equivalence.

Our elaboration will proceed by:

Formalizing the Master Definition: We will define MoritaEquivalence as an equivalence between
two Lawvere theories whose categories of models are equivalent.

Formalizing the Bridge (The Progenerator): We will define the concept of a Progenerator
Module, the special type of module that is used to construct the equivalence between two
Morita-equivalent rings.

Formalizing the Equivalence Functors: We will define the Tensor and Hom functors that are
constructed from the progenerator and which witness the categorical equivalence.

Stating the Main Theorem: We will formalize the classic Morita Theorem for rings, showing
that two rings are Morita equivalent if and only if such a progenerator exists, and we will
instantiate this with the canonical example of R and Mₙ(R).
*)

(* ========================================================================================================== )
( == Part 1: The Master Definition (Semantic Equivalence of Theories) == )
( ========================================================================================================== *)

MoritaEquivalence ::= LawvereTheoryDeclaration "is" "MORITA_EQUIVALENT_TO" LawvereTheoryDeclaration ;
TYPING
(*

The definition of Morita equivalence is purely semantic: two theories are Morita equivalent

if they generate equivalent categories of models. This is the ultimate test of theories

having the same "expressive power."
*)
Γ ⊢ T1, T2 : LAWVERE_THEORY

(Γ ⊢ T1 is MORITA_EQUIVALENT_TO T2) <==> (Γ ⊢ Mod(T1,Set) ≅ Mod(T2,Set)) ;
CATEGORY
[[ T1 is MORITA_EQUIVALENT_TO T2 ]] = "An equivalence relation on theories. It asserts that while the syntactic presentations T₁ and T₂ may be different, the semantic universes they describe (their categories of models) are structurally identical. It separates the 'syntactic flavor' of a theory from its 'semantic substance'." ;

(* ========================================================================================================== )
( == Part 2: The Canonical Example - The Tools for Ring Equivalence == )
( ========================================================================================================== )
(To show two rings R and S are Morita equivalent, we need to find a special module that acts as a bridge.)

ProgeneratorModule ::= Identifier "is" "PROGENERATOR_MODULE" "over" Identifier ;
TYPING
(*

A progenerator is a module P that is a finitely generated, projective generator for the category.

These are the "nicest" possible modules and are the key to building Morita equivalences.
*)
Context: R is a Ring, C = R-Mod
Γ ⊢ P : Object_in(C)
Premise1: Γ ⊢ P is FINITELY_GENERATED
Premise2: Γ ⊢ P is PROJECTIVE
Premise3: Γ ⊢ P is a GENERATOR for C

Γ ⊢ P is PROGENERATOR_MODULE over R ;
CATEGORY
[[ P is PROGENERATOR_MODULE over R ]] = "A module P that is the perfect 'building block' for the category R-Mod. Its properties ensure that it can be used to reconstruct the entire category and relate it to other categories of modules. The canonical example is the free module Rⁿ." ;

MoritaEquivalenceFunctor_Tensor ::= "- ⊗_" Identifier Identifier ;
MoritaEquivalenceFunctor_Hom ::= "Hom_" Identifier "(" Identifier ", -)" ;
TYPING
(*

Given two rings R and S, and a (S,R)-bimodule P, these constructors define the

functors that will witness the Morita equivalence.
*)
Context: R, S are Rings, P is an (S,R)-Bimodule
Functor1 := (- ⊗_R P) : R-Mod → S-Mod
Functor2 := (Hom_S(P, -)) : S-Mod → R-Mod

Γ ⊢ Functor1 : Functor, Γ ⊢ Functor2 : Functor ;
CATEGORY
[[ - ⊗_R P ]] = "The functor that provides one half of a Morita equivalence. It takes an R-module and transforms it into an S-module." ;
[[ Hom_S(P, -) ]] = "The functor that provides the other half of the equivalence, going in the reverse direction." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem for Rings == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "MoritaTheoremForRings" ":"
"Two rings R and S are Morita equivalent IFF there exists a Progenerator P in R-Mod"
"such that S is isomorphic to the endomorphism ring of P." ;
TYPING
(* This is the central theorem of Morita theory. *)
Γ ⊢ R, S : Ring
P1 := (TheoryOfModulesFor(R) is MORITA_EQUIVALENT_TO TheoryOfModulesFor(S))
P2 := (∃ P ∈ Ob(R-Mod) s.t. (P is PROGENERATOR_MODULE ∧ S ≅ End_{R-Mod}(P)))

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM MoritaTheoremForRings ]] = "The fundamental theorem of Morita Theory. It asserts that the abstract categorical notion of model equivalence is precisely equivalent to a concrete algebraic condition: the existence of a progenerator bimodule that connects the two rings. This provides a powerful, constructive tool for proving Morita equivalence." ;

(* ========================================================================================================== )
( == Part 4: Instantiating the Canonical Example == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "MoritaEquivalenceOfMatrixRings" "of" "MoritaTheoremForRings" ;
TYPING
(*

We apply the theorem to show that R is Morita equivalent to the matrix ring Mₙ(R).

We need to find a progenerator P in R-Mod such that Mₙ(R) is its endomorphism ring.

The object P = Rⁿ (the free module of rank n) is the perfect candidate.
*)
Let R_ring := a chosen Ring
Let S_ring := MatrixRing(n, R_ring)
-- Check premises of P2 from the theorem
Premise_Module: Let P := R_ring^n. P is an object in R-Mod.
Premise_Progenerator: Γ ⊢ P is PROGENERATOR_MODULE over R_ring. (This is a standard result for free modules).
Premise_EndoRing: End_{R-Mod}(P) = End_{R-Mod}(Rⁿ) ≅ Mₙ(R) = S_ring. (This is also a standard result).
-- Conclude P1 from the theorem
Conclusion: (TheoryOfModulesFor(R_ring) is MORITA_EQUIVALENT_TO TheoryOfModulesFor(S_ring))

Γ ⊢ INSTANCE ... : ProvableProposition ;
CATEGORY
[[ INSTANCE MoritaEquivalenceOfMatrixRings ... ]] = "The canonical example of Morita equivalence. It demonstrates that although the rings R and Mₙ(R) are very different (e.g., one can be commutative while the other is not), their module categories are equivalent. This means they share all 'module-theoretic' properties, such as being abelian, having enough injectives, etc. The equivalence is witnessed by the free module Rⁿ acting as the progenerator." ;
}
