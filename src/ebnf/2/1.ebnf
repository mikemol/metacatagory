MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'Abelian categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(*

ELABORATION: To provide a deep elaboration on Section 1.1, we must deconstruct the concepts of
"zero object," "kernel," and "cokernel" into their most fundamental definitions and properties,
formalizing them within our grammar.

Zero Object: We will formalize a zero object not just as a property, but by its core
universal property: the existence of a unique "zero morphism" between any two objects that
factors through it.

Kernel as Equalizer: We will define the kernel of a morphism f not as a primitive, but
constructively. The kernel ker(f) will be formally defined as the equalizer of f and
the corresponding zero morphism. This makes the universal property of the kernel a direct
consequence of the universal property of a limit.

Cokernel as Dual: We will use the Duality Principle, a core feature of our constructed grammar,
to define the cokernel. By declaring the duality mapping KERNEL <-> COKERNEL, we will derive
the entire theory of cokernels (their definition as a coequalizer, their universal property)
mechanically from the theory of kernels, showcasing the power and symmetry of the categorical approach.

This approach reveals that these concepts are not arbitrary but are specific instances of the more
general theory of limits and colimits in a category with a specified point (the zero object).
*)

(* ========================================================================================================== )
( == Part 1: Zero Objects and the Induced Zero Morphisms == )
( ========================================================================================================== *)

CategoryProperty_HasZeroObject ::= Identifier "has_a" "ZERO_OBJECT" ;
TYPING
(* This property asserts the existence of an object that is both initial and terminal. *)
Γ ⊢ C : Category
∃ (Z ∈ Ob(C)) s.t. ( (Γ ⊢ Z is INITIAL_OBJECT) ∧ (Γ ⊢ Z is TERMINAL_OBJECT) )
-------------------------------------------------------------------------------
Γ ⊢ C has_a ZERO_OBJECT : PropositionAbout(C) ;
CATEGORY
[[ C has_a ZERO_OBJECT ]] = "The assertion that the category C is 'pointed', containing a unique (up to isomorphism) object that serves as both the universal source and universal sink for morphisms." ;

ZeroMorphismConstructor ::= "zero_mor" "(" "from" ":" Identifier "," "to" ":" Identifier ")" ;
TYPING
(*
* This defines the unique zero morphism 0_{A,B}: A -> B.
* Its existence is guaranteed by the presence of a zero object Z.
* It is constructed as the unique composition through Z.
)
Context: Γ ⊢ C has_a ZERO_OBJECT (Let Z be the zero object)
Γ ⊢ A, B : Object_in(C)
u_AZ := unique_to_terminal_from(A) ( The unique map A -> Z, since Z is terminal )
u_ZB := unique_from_initial_to(B) ( The unique map Z -> B, since Z is initial *)
---------------------------------------------------------------------------------
Γ ⊢ zero_mor(from:A, to:B) : Morphism(A, B) (defined as u_ZB ∘ u_AZ) ;
CATEGORY
[[ zero_mor(from:A, to:B) ]] = "The unique morphism between A and B that factors through the zero object. In an additive category, this morphism will act as the additive identity in the hom-set Hom(A,B)." ;

(* ========================================================================================================== )
( == Part 2: The Kernel as a Limit Construction (an Equalizer) == )
( ========================================================================================================== *)

KernelAsEqualizerAxiom ::= "DEFINE" "ker" "(" Identifier "f" ")" "as" "Equalizer" "(" "f" "," ZeroMorphismConstructor ")" ;
TYPING
(*
* This is the formal, constructive definition of a kernel. The kernel of a morphism f
* is not a new primitive; it IS the equalizer of f and the zero morphism.
*)
Context: Γ ⊢ C has_a ZERO_OBJECT
Γ ⊢ f : A -> B
z_AB := zero_mor(from:A, to:B)
----------------------------------------------------------------
(Γ ⊢ ker(f) : SubobjectOf(A)) <==> (Γ ⊢ Equalizer(f, z_AB) : SubobjectOf(A)) ;
CATEGORY
[[ DEFINE ker(f) as Equalizer(...) ]] = "The assertion of definitional equivalence between the kernel of f and a specific limit construction. This definition endows the kernel with a universal property 'for free': for any map g:X→A such that f∘g=0, there exists a unique mediating morphism u:X→ker(f) such that k∘u=g, where k is the kernel monomorphism. This is precisely the universal property of the equalizer." ;

KernelProperty ::= "is_kernel_of" "(" Identifier ")" ;
TYPING
(* This predicate checks if a given monomorphism m is THE kernel of f. *)
Γ ⊢ m : K -> A, Γ ⊢ f : A -> B
----------------------------------------------------------
Γ ⊢ m is_kernel_of(f) is TRUE if (m ≅ ker(f)) ;
CATEGORY
[[ m is_kernel_of(f) ]] = "The assertion that the subobject represented by the monomorphism m is isomorphic (in the slice category C/A) to the kernel of f." ;

(* ========================================================================================================== )
( == Part 3: The Cokernel as a Colimit Construction (via Duality) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "KERNEL" "IS" "COKERNEL" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "Equalizer" "IS" "Coequalizer" ;

CokernelAsCoequalizerAxiom ::= "INFER_DUAL_AXIOM" "'CokernelAsCoequalizer'" "FROM" "AXIOM" "'KernelAsEqualizerAxiom'" ;
TYPING
(*
* This rule shows the Duality Principle in action. We do not define the cokernel from scratch.
* We apply the duality operator (-)^op to the KernelAsEqualizerAxiom.
* The system uses the DualityMapping dictionary to perform rewrites:
* 1. ker(f) -> coker(f)
* 2. Equalizer -> Coequalizer
* 3. SubobjectOf(A) -> QuotientObjectOf(B)
* The result is the correct, dual definition for the cokernel.
*)
Γ ⊢ AXIOM 'KernelAsEqualizerAxiom' : P_kernel
P_cokernel = rewrite(P_kernel, DualityMappings)
---------------------------------------------------------
Conclusion: (Γ ⊢ coker(f)) <==> (Γ ⊢ Coequalizer(f, zero_mor(from:A, to:B))) ;
CATEGORY
[[ INFER_DUAL_AXIOM ... ]] = "A constructive proof of the definition of the cokernel, derived mechanically by applying the duality functor to the definition of the kernel. It asserts that the cokernel of f is definitionally equivalent to the coequalizer of f and the zero morphism, endowing it with the corresponding universal property of a colimit." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.2: Additive categories and biproducts" ")" "==>" {
(*

ELABORATION: This section builds upon the concept of a pointed category (one with a zero object)
to define a much richer structure. An additive category is a category where the collection of
morphisms between any two objects is not just a set, but an abelian group, and composition
behaves like a bilinear map. This leads to the remarkable consequence that finite products and
finite coproducts coincide, giving rise to the "biproduct."

To elaborate, we will:

Formalize Enrichment: First, we formalize the abstract idea of a category being
"enriched" over another, which is the core concept needed to say "hom-sets are abelian groups."

Define Additive Category: We will then use this to build the formal definition of an
Additive Category as one that has a zero object, has all binary biproducts, and is enriched
over the category of Abelian Groups (Ab).

Define the Biproduct: We will formally define the biproduct object A⊕B and state its
definitive property: it is simultaneously a product and a coproduct.

State the Equivalence Theorem: We will assert the theorem that a category with all finite
products and coproducts is additive if and only if the canonical map from the coproduct to the
product is an isomorphism, providing a structural check for additivity.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing Enrichment over Abelian Groups == )
( ========================================================================================================== *)

Category_is_Enriched_over ::= Identifier "is" "ENRICHED_OVER" Identifier ;
TYPING
(*
* This defines the general property of enrichment. A category C is enriched over a monoidal category M
* if its hom-collections are objects in M, and composition is a morphism in M.
* For additive categories, the enriching category M is Ab, the category of abelian groups
* with the tensor product as the monoidal operation.
*)
Γ ⊢ C : Category, Γ ⊢ M : MonoidalCategory
∀A,B ∈ Ob(C), Hom_C(A,B) ∈ Ob(M)
∀A,B,C ∈ Ob(C), Composition : Hom_C(B,C) ⊗ Hom_C(A,B) → Hom_C(A,C) is a morphism in M.
--------------------------------------------------------------------------------------------------
Γ ⊢ C is ENRICHED_OVER M : PropositionAbout(C) ;
CATEGORY
[[ C is ENRICHED_OVER M ]] = "The property that the internal structure of the hom-sets of C mirrors the structure of the category M. The fact that composition is a morphism Hom(B,C) ⊗ Hom(A,B) → Hom(A,C) is the precise categorical statement of bilinearity." ;

(* ========================================================================================================== )
( == Part 2: The Biproduct and the Definition of an Additive Category == )
( ========================================================================================================== *)

BiproductObject ::= Identifier "⊕" Identifier ;
TYPING
(*
* The biproduct A⊕B is an object that is, simultaneously and compatibly, the product
* and coproduct of A and B. Its existence is the defining feature of additivity.
*)
Context: C is an Preadditive_Category (enriched over Ab, has zero object)
Γ ⊢ A, B : Object_in(C)
-------------------------------------------------
Γ ⊢ (A ⊕ B) is PRODUCT of (A,B)
Γ ⊢ (A ⊕ B) is COPRODUCT of (A,B) ;
CATEGORY
[[ A ⊕ B ]] = "The biproduct of A and B. It is an object equipped with projection maps (pA, pB) and injection maps (iA, iB) satisfying the product and coproduct universal properties, along with the coherence conditions pA∘iA=id, pB∘iB=id, pA∘iB=0, pB∘iA=0, and iA∘pA + iB∘pB = id." ;

AdditiveCategoryDeclaration ::= "ADDITIVE_CATEGORY" Identifier ;
TYPING
(* The master definition of an additive category, combining the prerequisites. *)
Γ ⊢ C : Category
Premise1: C has a ZERO_OBJECT
Premise2: C has a biproduct A⊕B for every pair of objects A, B.
Premise3: C is ENRICHED_OVER Ab
-----------------------------------------------------------------
Γ ⊢ C is ADDITIVE_CATEGORY ;
CATEGORY
[[ C is ADDITIVE_CATEGORY ]] = "A category equipped with a zero object and a compatible abelian group structure on its hom-sets, which manifests in the existence of biproducts. This is the foundational setting for homological algebra." ;

(* ========================================================================================================== )
( == Part 3: The Structural Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdditivityEquivalence" ":"
"A category with finite products and coproducts is ADDITIVE IFF"
"the canonical morphism from Coproduct(A,B) to Product(A,B) is an ISOMORPHISM." ;
TYPING
(*
* In any category with products and coproducts, there is a canonical map from the coproduct to the product.
* The category is additive if and only if this map is always an isomorphism. This provides a purely
* structural way to check for additivity without direct reference to the Ab-enrichment.
*)
Context: Γ ⊢ C has finite products and coproducts
Let P = Product(A,B) with projections pA, pB.
Let C = Coproduct(A,B) with injections iA, iB.
CanonicalMap := < <id_A, 0>, <0, id_B> > : C → P
-----------------------------------------------------------------------------
(Γ ⊢ C is ADDITIVE_CATEGORY) <==> (∀A,B, Γ ⊢ CanonicalMap is ISOMORPHISM) ;
CATEGORY
[[ THEOREM AdditivityEquivalence ]] = "A fundamental theorem providing a structural criterion for additivity. It asserts that the abstract algebraic property of being enriched over Abelian Groups is equivalent to the concrete property that the natural comparison map from the coproduct to the product is always an isomorphism. This is why in additive categories, products and coproducts coincide as the biproduct." ;

}

(* ========================================================================================================== )
( == Section 1.3: Additive functors == )
( ========================================================================================================== )
(
ELABORATION: This section defines "additive functors," which are the structure-preserving maps
between additive categories. The key idea is that these functors must respect the abelian group
structure on the hom-sets. A deep elaboration requires not just stating this, but showing its powerful
equivalence to a more structural, diagrammatic property.

To elaborate, we will:

Formalize the Primary Definition: Define an additive functor as one whose action on hom-sets
is a homomorphism of abelian groups. This is the fundamental algebraic definition.

State the Equivalence Theorem: Assert the crucial theorem that a functor between additive categories
is additive if and only if it preserves finite biproducts. This bridges the algebraic definition with
a concrete, structural-diagrammatic test.

Provide a Canonical Example: Instantiate these definitions by proving that the Hom-functor
Hom(A, -) is itself a canonical example of an additive functor, demonstrating how the Ab-enrichment
(distributivity of composition) ensures this property.

Formalize the Duality: Assert that the concept of an additive functor is self-dual, which
implies that the contravariant Hom-functor Hom(-, A) is also additive, completing the picture.
*)

(* ========================================================================================================== )
( == Part 1: The Primary Definition (Respect for Enrichment) == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "ADDITIVE" ;
TYPING
(*
* This is the fundamental definition. A functor F: C -> D between additive categories
* is additive if for every pair of objects A,B in C, the induced map on hom-sets
* is a homomorphism of abelian groups.
*)
Γ ⊢ F : Functor(C, D)
Γ ⊢ C, D : ADDITIVE_CATEGORY
Condition := ∀A,B∈Ob(C), the map F_{A,B}: Hom_C(A,B) → Hom_D(F(A),F(B)) is_a GroupHomomorphism(Ab)
----------------------------------------------------------------------------------------------------------
Γ ⊢ F is ADDITIVE is TRUE if Condition holds ;
CATEGORY
[[ F is ADDITIVE ]] = "A functor that preserves the Ab-enriched structure of its domain. This means it respects the addition of morphisms, mapping F(f+g) to F(f)+F(g), and maps the zero morphism to the zero morphism. This is the correct notion of a 'linear' functor between additive categories." ;

(* ========================================================================================================== )
( == Part 2: The Key Equivalence Theorem (Structural Test) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdditiveFunctorBiproductEquivalence" ":"
"A functor F between additive categories is ADDITIVE"
"<==>"
"F preserves finite biproducts." ;
TYPING
(*
* This theorem provides a powerful, often easier-to-check, structural condition
* that is equivalent to the algebraic definition above.
)
Context: Γ ⊢ F : Functor(C, D) between ADDITIVE_CATEGORY C, D
P1 := (Γ ⊢ F is ADDITIVE) ( The group homomorphism definition *)
P2 := (∀ A,B ∈ Ob(C), the canonical map F(A⊕B) → F(A)⊕F(B) is an ISOMORPHISM)
-----------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdditiveFunctorBiproductEquivalence ]] = "A fundamental result connecting the algebraic property of additivity (respecting hom-set structure) with the diagrammatic property of preserving biproducts. This allows one to prove a functor is additive by showing it preserves the product/coproduct structure, which is often more direct." ;

(* ========================================================================================================== )
( == Part 3: The Canonical Example (The Hom-Functor) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "HomFunctorIsAdditive" ":"
"FOR_ALL object A in an AdditiveCategory C, the functor Hom_C(A, -) is ADDITIVE." ;
TYPING
(*
* We prove this using the primary definition. We must show that the map induced by
* Hom(A,-) on the hom-set Hom_C(X,Y) is a group homomorphism.
* Let g1, g2 ∈ Hom_C(X,Y). Hom(A,-) maps (g1+g2) to the map [ (h:A→X) ↦ (g1+g2)∘h ].
* It maps g1 and g2 to [h ↦ g1∘h] and [h ↦ g2∘h] respectively.
* The Ab-enrichment of C guarantees composition is bilinear, so (g1+g2)∘h = (g1∘h) + (g2∘h).
* Therefore, Hom(A,-) preserves addition and is an additive functor.
*)
Context: Γ ⊢ C : ADDITIVE_CATEGORY, Γ ⊢ A : Object_in(C)
Let F := Hom_C(A, -) : C → Ab
F_map_on_Hom(g1+g2) == (F_map_on_Hom(g1) + F_map_on_Hom(g2)) because composition distributes.
--------------------------------------------------------------------------
Γ ⊢ Functor F is ADDITIVE : ProvableProposition ;
CATEGORY
[[ THEOREM HomFunctorIsAdditive ]] = "The assertion that the covariant representable functor is always additive. This is a direct consequence of the bilinear nature of composition in an Ab-enriched category and establishes the Hom functor as a primary and foundational example of an additive functor." ;

(* ========================================================================================================== )
( == Part 4: Duality == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "ADDITIVE" "IS" "ADDITIVE" ;
TYPING
---
----------------------------------------------------
(Γ ⊢ F is ADDITIVE)^op <==> (Γ ⊢ F^op is ADDITIVE) ;
CATEGORY
[[ DUALITY_MAPPING FOR ADDITIVE IS ADDITIVE ]] = "The assertion that the concept of an additive functor is self-dual. The opposite of an additive category is additive, and a functor respects the structure if and only if its opposite does. A direct corollary is that the contravariant Hom-functor, Hom(-, A), is also an additive functor." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.4: Abelian categories" ")" "==>" {
(*

ELABORATION: Section 1.4 introduces the definition of an abelian category, the foundational setting
for homological algebra. Simply stating the definition is insufficient; a deep elaboration requires
deconstructing it to reveal why each condition is necessary and what powerful consequences follow.

Our elaboration will proceed in four stages:

Formalize the Building Blocks (Normality): We will first formalize the key concepts of "normal"
monomorphisms and epimorphisms. A monomorphism is normal if it is "well-behaved" enough to be a kernel,
and dually for epimorphisms. We will define this precisely as a morphism being the kernel of its cokernel.

Construct the Master Definition: Using these building blocks, we will assemble the complete, formal
definition of an AbelianCategoryDeclaration, showing it as an additive category where these normality
conditions hold universally.

Reveal the Core Consequence (The Isomorphism Theorem): We will formalize the most important
structural consequence of the definition: that in an abelian category, the "coimage" of a morphism is
canonically isomorphic to its "image." This is what makes diagram chasing work and is often used as
an alternative definition. We will define the coimage and image constructively as coker(ker(f)) and
ker(coker(f)) respectively.

State the Canonical Examples: We will anchor the abstract definition by declaring that the category of
Abelian Groups (Ab) and the category of R-Modules (R-Mod) are the quintessential examples that
satisfy all the required axioms.

This approach shows that the definition of an abelian category is not an arbitrary list of axioms, but a
carefully chosen set of conditions designed to produce a category with the powerful structural properties
of Ab.
*)

(* ========================================================================================================== )
( == Part 1: Formalizing Normality == )
( ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "is" "NORMAL_MONOMORPHISM" ;
TYPING
(*
* A monomorphism m is normal if it arises as the kernel of some morphism.
* The canonical choice for that morphism is its own cokernel.
*)
Γ ⊢ m : K -> A, Γ ⊢ m is MONOMORPHISM
----------------------------------------------------------
Γ ⊢ m is NORMAL_MONOMORPHISM is TRUE if (m ≅ ker(coker(m))) ;
CATEGORY
[[ m is NORMAL_MONOMORPHISM ]] = "The property of a monomorphism being the kernel of its cokernel. This is a well-behavedness condition ensuring that the subobject represented by m is the solution to a universal problem defined by its corresponding quotient object." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "NORMAL_MONOMORPHISM" "IS" "NORMAL_EPIMORPHISM" ;

MorphismPropertyAssertion ::= Identifier "is" "NORMAL_EPIMORPHISM" ;
TYPING
(* Derived via duality. An epimorphism e is normal if it is the cokernel of its own kernel. *)
IsDualOf("NORMAL_MONOMORPHISM")
EquivalentTyping: Γ ⊢ e : A -> Q, Γ ⊢ e is EPIMORPHISM, (e ≅ coker(ker(e)))
-------------------------------------------------------------------------
Γ ⊢ e is NORMAL_EPIMORPHISM ;
CATEGORY
[[ e is NORMAL_EPIMORPHISM ]] = "The dual property. An epimorphism is normal if it arises as the cokernel of its kernel. This ensures the quotient object it represents is canonically related to the subobject it annihilates." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of an Abelian Category == )
( ========================================================================================================== *)

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" Identifier ;
TYPING
(* The master definition, composed of four precise conditions. *)
Γ ⊢ C : Category
Premise1: Γ ⊢ C is ADDITIVE_CATEGORY
Premise2: C has all KERNELS and COKERNELS
Premise3: ∀(m ∈ Mor(C)), ( (m is MONOMORPHISM) ⇒ (m is NORMAL_MONOMORPHISM) )
Premise4: ∀(e ∈ Mor(C)), ( (e is EPIMORPHISM) ⇒ (e is NORMAL_EPIMORPHISM) )
-------------------------------------------------------------------------
Γ ⊢ C is ABELIAN_CATEGORY ;
CATEGORY
[[ C is ABELIAN_CATEGORY ]] = "A category possessing the rich structure of the category of Abelian Groups. It is additive, has all kernels and cokernels, and crucially, every subobject is the kernel of some map and every quotient object is the cokernel of some map. This is the ideal environment for homological algebra." ;

(* ========================================================================================================== )
( == Part 3: The Core Consequence - The First Isomorphism Theorem == )
( ========================================================================================================== *)

CoimageOfMorphism ::= "Coim" "(" Identifier ")" ;
TYPING
(* In this context, the coimage of f is defined as the cokernel of its kernel. *)
Γ ⊢ f : A -> B
--------------------------------------------
Γ ⊢ Coim(f) : QuotientObjectOf(A) (defined as coker(ker(f))) ;
CATEGORY
[[ Coim(f) ]] = "The coimage of f. This is a quotient of the domain A, representing the domain modulo the kernel. In Set, this is isomorphic to the image." ;

ImageOfMorphism ::= "Im" "(" Identifier ")" ;
TYPING
(* Dually, the image of f is defined as the kernel of its cokernel. *)
Γ ⊢ f : A -> B
----------------------------------------
Γ ⊢ Im(f) : SubobjectOf(B) (defined as ker(coker(f))) ;
CATEGORY
[[ Im(f) ]] = "The image of f. This is a subobject of the codomain B. In an abelian category, this more abstract definition coincides with the intuitive notion of the image." ;

TheoremDeclaration ::= "THEOREM" "FirstIsomorphismTheoremForCategories" ":"
"A category C is ABELIAN if and only if C is Additive, has Kernels and Cokernels, and"
"the canonical morphism Coim(f) → Im(f) is an ISOMORPHISM for all f." ;
TYPING
(* This provides the most powerful and often-used characterization of an abelian category. *)
P1 := (Γ ⊢ C is ABELIAN_CATEGORY)
Let f_bar be the canonical morphism Coim(f) → Im(f).
P2 := ( Γ ⊢ C is ADDITIVE ∧ C has Kernels/Cokernels ∧ (∀f, f_bar is ISOMORPHISM) )
---------------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FirstIsomorphismTheoremForCategories ]] = "The categorical analogue of the first isomorphism theorem for groups (A/ker(f) ≅ Im(f)). It states that the conditions of normality for monos and epis are precisely equivalent to the condition that the coimage and image of every morphism are canonically isomorphic. This property is the key to all diagram-chasing proofs." ;

(* ========================================================================================================== )
( == Part 4: The Canonical Examples == )
( ========================================================================================================== *)

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" "Ab" ;
TYPING
-- Verify all premises for the category of Abelian Groups --
Premise1: IsAdditive(Ab) is TRUE.
Premise2: Ab has all kernels and cokernels.
Premise3: All monos in Ab are normal.
Premise4: All epis in Ab are normal.
-----------------------------------------------
Γ ⊢ "Ab" is ABELIAN_CATEGORY : ProvableProposition ;
CATEGORY
[[ ABELIAN_CATEGORY Ab ]] = "The category of abelian groups. It is the archetypal abelian category from which the abstract definition is derived." ;

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" "R-Mod" ;
TYPING
-- Verify all premises for the category of left R-modules --
Context: R is a Ring
(All premises can be verified to be TRUE)
--------------------------------------------------
Γ ⊢ "R-Mod" is ABELIAN_CATEGORY : ProvableProposition ;
CATEGORY
[[ ABELIAN_CATEGORY R-Mod ]] = "The category of left modules over a ring R. This, along with Ab, is the primary working example of an abelian category in algebra and homological algebra." ;
}

(* ========================================================================================================== )
( == Section 1.5, 1.6: Exactness and Additivity Properties of Abelian Categories == )
( ========================================================================================================== )
(

ELABORATION: These sections reveal the deep interplay between the algebraic structure (additivity)

and the limit-based structure (exactness) of an abelian category. The key insight is that the

Ab-enrichment forces the diagrammatic structures to be exceptionally well-behaved.

To elaborate, we will:

I. Deconstruct the "Image Factorization":

Formalize the canonical f_bar morphism that connects the "quotient" part of a morphism

Generated code
(its Coimage) to the "subobject" part (its Image).


State the central theorem of exactness: that in an abelian category, this f_bar is always an

Generated code
isomorphism (Coimage ≅ Image). This is the First Isomorphism Theorem for categories.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

II. Deconstruct the "Biproduct":

Formalize the canonical comparison map that exists in any pointed category from the

Generated code
coproduct (A ∐ B) to the product (A × B).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

State the central theorem of additivity: that a category's hom-sets form abelian groups

Generated code
(i.e., it is additive) if and only if this canonical comparison map is always an isomorphism.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

This approach demonstrates that the abstract axioms of an abelian category have concrete, powerful

structural consequences: images and coimages are the same, and products and coproducts are the same.
*)

(* ========================================================================================================== )
( == Part I: The Exactness Property (Coimage ≅ Image) == )
( ========================================================================================================== *)

Coim_f_Constructor ::= "Coim" "(" Identifier ")" ;
Im_f_Constructor ::= "Im" "(" Identifier ")" ;
TYPING
(* Formal definitions of Coimage and Image used in this context. *)
Γ ⊢ f : A -> B in Category with Kernels/Cokernels
-----------------------------------------------------------------------------------------------------
(Γ ⊢ Coim(f) : QuotientObjectOf(A)) <==> (Γ ⊢ coker(ker(f)) : QuotientObjectOf(A))
(Γ ⊢ Im(f) : SubobjectOf(B)) <==> (Γ ⊢ ker(coker(f)) : SubobjectOf(B)) ;
CATEGORY
[[ Coim(f) ]] = "The coimage of f, defined universally as the cokernel of its kernel. It represents the domain A modulo the part that f annihilates." ;
[[ Im(f) ]] = "The image of f, defined universally as the kernel of its cokernel. It represents the part of the codomain B that is 'reachable' by f." ;

CanonicalMorphism_f_bar ::= "f_bar" "(" Identifier ")" ;
TYPING
(*
* This constructor defines the canonical map f_bar from the Coimage to the Image.
* The morphism f: A -> B can be factored through both its coimage and its image.
* The universal properties of these objects guarantee a unique mediating morphism between them.
*)
Γ ⊢ f : A -> B in ABELIAN_CATEGORY C
e := projection_to Coim(f)
m := inclusion_from Im(f)
∃! g s.t. f = g ∘ e
∃! h s.t. g = m ∘ h
-------------------------------------------------------------------------
Γ ⊢ f_bar(f) : Morphism(Coim(f), Im(f)) (defined as the unique map h) ;
CATEGORY
[[ f_bar(f) ]] = "The unique canonical morphism from the coimage of f to the image of f, which exists due to the universal properties of kernels and cokernels. The exactness of the category is captured by the properties of this specific morphism." ;

TheoremDeclaration ::= "THEOREM" "FirstIsomorphismForAbelianCategories" ":"
"IN " "ABELIAN_CATEGORY" "C" "," "FOR_ALL morphism f," "f_bar(f)" "is an ISOMORPHISM." ;
TYPING
(*
* This is the central theorem of exactness. The property of all monomorphisms and epimorphisms
* being 'normal' is precisely equivalent to this Coim-Im isomorphism holding for all f.
*)
Γ ⊢ C is ABELIAN_CATEGORY
------------------------------------------------------------
∀(f ∈ Mor(C)), (Γ ⊢ f_bar(f) is ISOMORPHISM) : MetaTheorem ;
CATEGORY
[[ THEOREM FirstIsomorphismForAbelianCategories ]] = "The fundamental theorem of exactness in abelian categories, and the categorical analogue of the First Isomorphism Theorem (G/ker(φ) ≅ Im(φ)). It asserts that the object constructed as a quotient of the domain (the Coimage) is always canonically isomorphic to the object constructed as a subobject of the codomain (the Image). This powerful property is what enables all diagram-chasing arguments." ;

(* ========================================================================================================== )
( == Part II: The Additivity Property (Coproduct ≅ Product) == )
( ========================================================================================================== *)

CanonicalMap_CoproductToProduct ::= "canonical_map" "(" Identifier "→" Identifier ")" ;
TYPING
(*
* In any category with a zero object, finite products, and finite coproducts, there exists
* a canonical map from the coproduct C = A ∐ B to the product P = A × B.
* This map is built from the universal property of the coproduct, using maps into P.
*)
Context: C is a pointed category with finite products and coproducts.
P_obj := Product(A,B)
C_obj := Coproduct(A,B)
map1 := <id_A, 0_{A,B}> : A -> P_obj
map2 := <0_{B,A}, id_B> : B -> P_obj
-------------------------------------------------------------------------
Γ ⊢ canonical_map(C_obj → P_obj) : Morphism(C_obj, P_obj) (defined as <map1, map2>) ;
CATEGORY
[[ canonical_map(A∐B → A×B) ]] = "The canonical comparison morphism that exists in any pointed category between the coproduct and the product. The properties of this map determine the additive nature of the category." ;

TheoremDeclaration ::= "THEOREM" "AdditivityViaBiproductCoincidence" ":"
"A category with finite products/coproducts and a zero object is ADDITIVE_CATEGORY"
"<==>"
"the canonical_map(Coproduct → Product) is an ISOMORPHISM for all objects." ;
TYPING
(*
* This theorem provides a purely structural criterion for additivity. It states that the
* algebraic property (Ab-enrichment) is equivalent to the diagrammatic property
* that the product and coproduct are not just related, but are naturally isomorphic.
*)
Context: C is a pointed category with finite products and coproducts.
P1 := (Γ ⊢ C is ADDITIVE_CATEGORY)
P2 := (∀A,B ∈ Ob(C), Γ ⊢ canonical_map(A∐B → A×B) is ISOMORPHISM)
--------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdditivityViaBiproductCoincidence ]] = "A key structural result asserting that the requirements for an additive category (zero object, Ab-enrichment) are precisely the conditions needed to make finite products and finite coproducts coincide. When they do, the resulting object is called the biproduct (A ⊕ B), and this coincidence is the defining structural feature of additivity." ;

(* ========================================================================================================== )
( == Section 1.7: Union of subobjects == )
( ========================================================================================================== )
(

ELABORATION: This section describes the behavior of subobjects in an abelian category. The key

insight is that the collection of subobjects of any given object forms a special kind of lattice.

A deep elaboration requires not just defining the union/join operation, but formalizing its

construction, contrasting it with the dual construction for intersection/meet, and stating the

powerful structural property (modularity) that this lattice is guaranteed to have in the abelian setting.

To this end, we will:

I. Deconstruct the Join/Union: We will formalize the construction of the union (join) of a

family of subobjects. This is a two-step process: (1) form the coproduct of the subobject

domains, and (2) take the image of the induced universal map into the ambient object.

II. Formalize the Dual Meet/Intersection: For completeness, we will formalize the dual

construction for the intersection (meet) of subobjects, which is given by their pullback.

III. Formalize the Lattice Property (Modularity): We will define a "modular lattice," the specific

algebraic structure that the subobject lattice possesses.

IV. State the Main Theorem: We will assert the central theorem of this section: that in any

abelian category, the lattice of subobjects of any object is always a modular lattice.
*)

(* ========================================================================================================== )
( == Part I & II: The Lattice Operations (Join/Union and Meet/Intersection) == )
( ========================================================================================================== *)

UnionOfSubobjects ::= "Join" "(" "{" {SubobjectOf} "}" ")" ;
TYPING
(*
* This rule formalizes the construction of the least upper bound (join or "union") of a
* family of subobjects {s_i} of an object X. Each s_i is represented by a mono m_i: A_i -> X.
* The construction relies on the abelian category having coproducts and images.
*)
Context: C is an ABELIAN_CATEGORY
Subobjects_Set = { s_i | s_i has representative m_i: A_i -> X }
1. Form the coproduct of the domains: CP_obj := Coproduct({ A_i })
2. Form the universal map from the coproduct: u := UniversalCoproductMorphism( from:CP_obj, to:X, via:{m_i} )
3. The union is the image of this map.
------------------------------------------------------------------------------------------------------------
Γ ⊢ Join(Subobjects_Set) : SubobjectOf(X) (defined as Image(u)) ;
CATEGORY
[[ Join({s_i}) ]] = "The supremum of the family of subobjects {s_i} in the subobject lattice Sub(X). It is constructively defined as the image of the universal map from the coproduct of the subobjects' domains. This represents the smallest subobject of X containing all the s_i." ;

IntersectionOfSubobjects ::= "Meet" "(" "{" {SubobjectOf} "}" ")" ;
TYPING
(*
* This rule formalizes the dual construction for the greatest lower bound (meet or "intersection").
* The intersection of a family of subobjects {s_i} is their limit, which is their wide pullback.
*)
Context: C is an ABELIAN_CATEGORY (which has all finite limits, including pullbacks)
Subobjects_Set = { s_i | s_i has representative m_i: A_i -> X }
1. Form the diagram of all m_i mapping to X.
2. The intersection is the limit of this diagram.
-------------------------------------------------------------------------------------------
Γ ⊢ Meet(Subobjects_Set) : SubobjectOf(X) (defined as Pullback({m_i})) ;
CATEGORY
[[ Meet({s_i}) ]] = "The infimum of the family of subobjects {s_i} in the subobject lattice Sub(X). It is constructively defined as the (wide) pullback of the representative monomorphisms. This represents the largest subobject of X contained within all of the s_i." ;

(* ========================================================================================================== )
( == Part III: The Property of the Resulting Lattice (Modularity) == )
( ========================================================================================================== *)

LatticePropertyDefinition ::= Identifier "is" "MODULAR_LATTICE" ;
TYPING
(* A lattice is modular if it satisfies the modular law (a weaker form of distributivity). *)
Γ ⊢ L : Lattice
ModularLaw := ∀x,a,b∈L, ( (x ≤ b) ⇒ (Join(x, Meet(a, b)) == Meet(Join(x, a), b)) )
--------------------------------------------------------------------------------
Γ ⊢ L is MODULAR_LATTICE is TRUE if ModularLaw holds ;
CATEGORY
[[ L is MODULAR_LATTICE ]] = "A key property of lattices that arise in algebraic contexts. A modular lattice is one where the Jordan-Hölder theorem holds. This property is stronger than a general lattice but weaker than a distributive lattice." ;

(* ========================================================================================================== )
( == Part IV: The Main Theorem Connecting the Concepts == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "SubobjectLatticeInAbelianIsModular" ":"
"IN any" "ABELIAN_CATEGORY" "C" "," "FOR_ALL object X of C,"
"the subobject lattice Sub(X) is a MODULAR_LATTICE." ;
TYPING
(*
* This is a fundamental result about the structure of abelian categories. The rich interplay
* of kernels, cokernels, products, and coproducts forces the subobject lattices to be
* exceptionally well-behaved.
*)
Γ ⊢ C is ABELIAN_CATEGORY
-----------------------------------------------------------------
∀X∈Ob(C), Γ ⊢ Sub(X) is MODULAR_LATTICE : ProvableProposition ;
CATEGORY
[[ THEOREM SubobjectLatticeInAbelianIsModular ]] = "An important structural theorem asserting that the exactness properties of an abelian category are reflected in the algebraic properties of its subobject lattices. This result is crucial for many proofs in homological algebra and module theory, as it guarantees that subobjects interact in a predictable and regular way." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.8: Exact sequences" ")" "==>" {
(*

ELABORATION: This section introduces the concept of an "exact sequence," which is arguably the
most important tool in homological algebra. It defines a very specific relationship between kernels and
images that captures the notion of "homological triviality" at a certain point. A deep elaboration
requires not just stating the definition, but deconstructing its meaning and consequences, especially
the powerful "Splitting Lemma."

Our elaboration will proceed by:

Formalizing the Local Condition: We will define the atomic property of a sequence being "exact at"
a single object. This is the core Image ≅ Kernel condition.

Defining the Short Exact Sequence (SES): We will build upon the local condition to define the
Short Exact Sequence, the most important type of exact sequence, and show how its definition
implies that the first map is a monomorphism and the last map is an epimorphism.

Formalizing the Splitting Lemma: We will deconstruct the famous Splitting Lemma by
formalizing its three equivalent conditions: the existence of a retraction, the existence of a
section, and the central object being a biproduct. This reveals the deep connection between
the sequence structure and the additive structure of the category.

Defining the General Case: Finally, we will define a "long exact sequence" as a sequence that
satisfies the local exactness condition at every intermediate object.
*)

(* ========================================================================================================== )
( == Part 1: The Local Condition (Exactness at an Object) == )
( ========================================================================================================== *)

ExactSequenceAt ::= Identifier "is" "EXACT_AT" Identifier ;
TYPING
(*
* This defines the core property. A sequence of morphisms A --f--> B --g--> C
* is exact at the object B if the image of the incoming morphism f is precisely
* the kernel of the outgoing morphism g.
*)
Context: A --f--> B --g--> C is a sequence in an ABELIAN_CATEGORY.
----------------------------------------------------------
Γ ⊢ Sequence is EXACT_AT B <==> (Image(f) ≅ Kernel(g)) ;
CATEGORY
[[ Sequence is EXACT_AT B ]] = "A statement of local homological triviality. It asserts that everything arriving at B from A via f is precisely what gets annihilated by the subsequent map g. There are no 'gaps' or 'excess' at B." ;

(* ========================================================================================================== )
( == Part 2: The Short Exact Sequence (SES) == )
(* ========================================================================================================== *)

ShortExactSequence ::= "0 →" Identifier "→" Identifier "→" Identifier "→ 0" " is SES" ;
TYPING
(*
* A short exact sequence is a sequence of this form that is exact at A, B, and C.
* These conditions imply f is a monomorphism and g is an epimorphism.
*)
Context: 0 → A --f--> B --g--> C → 0
Premise1: Sequence is EXACT_AT A ( Im(0→A)≅Ker(f) ⇒ 0≅Ker(f) ⇒ f is mono )
Premise2: Sequence is EXACT_AT B ( Im(f)≅Ker(g), the main condition )
Premise3: Sequence is EXACT_AT C ( Im(g)≅Ker(C→0) ⇒ Im(g)≅C ⇒ g is epi )
-------------------------------------------------------------------------
Γ ⊢ "0 → A → B → C → 0" is SES : ProvableProposition ;
CATEGORY
[[ 0 → A → B → C → 0 is SES ]] = "A short exact sequence. This is a fundamental building block in homological algebra, representing that the object B is an 'extension' of A by C (i.e. A is a subobject of B, and C is the corresponding quotient B/A)." ;

(* ========================================================================================================== )
( == Part 3: The Splitting Lemma == )
(* ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "has_retraction" | Identifier "has_section" ;
TYPING
CASE "has_retraction":
Γ ⊢ f:A->B is MONOMORPHISM
∃ r:B->A s.t. (r ∘ f == id_A)
CASE "has_section":
Γ ⊢ g:B->C is EPIMORPHISM
∃ s:C->B s.t. (g ∘ s == id_C)
-------------------------------------------
Γ ⊢ ... : PropositionAbout(Morphism) ;
CATEGORY
[[ f has_retraction ]] = "f is a split monomorphism. There is a map that 'undoes' it." ;
[[ g has_section ]] = "g is a split epimorphism. There is a map that provides a right-inverse." ;

TheoremDeclaration ::= "THEOREM" "SplittingLemmaForSES" ":"
"FOR a ShortExactSequence 0→A→B→C→0, the following are equivalent:"
"(" "f has_retraction" ")" "<==>" "(" "g has_section" ")" "<==>" "(" "B ≅ A ⊕ C" ")" ;
TYPING
(*
* This is a cornerstone theorem of homological algebra. It gives checkable criteria
* for when an extension B is 'trivial' -- i.e., just the biproduct of A and C.
*)
Context: seq = "0 → A --f--> B --g--> C → 0" is SES
P1 := (Γ ⊢ f has_retraction)
P2 := (Γ ⊢ g has_section)
P3 := (Γ ⊢ B ≅ (A ⊕ C) such that the isomorphism respects the SES structure)
--------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2 <==> P3) : ProvableEquivalence ;
CATEGORY
[[ THEOREM SplittingLemmaForSES ]] = "The Splitting Lemma. It provides three equivalent conditions for a short exact sequence to 'split'. A split sequence is one where the middle object B is structurally no more complex than the biproduct (direct sum) of the objects at the ends. This theorem connects the existence of specific morphisms (retractions and sections) to the fundamental additive structure of the category." ;

(* ========================================================================================================== )
( == Part 4: The General Case (Long Exact Sequences) == )
(* ========================================================================================================== *)

LongExactSequence ::= "LONG_EXACT_SEQUENCE" "{" Identifier { "→" Identifier } "}" ;
TYPING
(* A long exact sequence is simply a sequence that is exact at every internal position. *)
Let S be the sequence A₁ → A₂ → ... → Aₙ
-------------------------------------------------------------------------
Γ ⊢ LONG_EXACT_SEQUENCE {S} is TRUE if (∀ i ∈ {2..n-1}, S is EXACT_AT Aᵢ) ;
CATEGORY
[[ LONG_EXACT_SEQUENCE {...} ]] = "A sequence of objects and morphisms, often infinite, which is exact at every position. Long exact sequences are the primary tool for relating the homology or cohomology groups of different objects and are central to algebraic topology and homological algebra." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.9, 1.10: Diagram chasing & The Five Lemma" ")" "==>" {
(*

ELABORATION: These sections introduce a powerful proof technique—diagram chasing—and its most
famous consequences, such as the Five Lemma and the Snake Lemma. A deep elaboration must
formalize the proof technique itself and then use it to justify the assertions of the lemmas.

Our elaboration will proceed by:

Formalizing the Technique: We will create a meta-rule, ProofByDiagramChase, that represents
the application of this element-wise reasoning. Its validity will be explicitly predicated on the
Freyd-Mitchell Embedding Theorem, which is the theoretical justification for the technique. This
makes the proof method itself a formal object in our grammar.

Formalizing the Setup: We will define a DiagrammaticAssertion which encapsulates the
data for a diagrammatic lemma: a commutative diagram with specific exactness properties.

Formalizing the Lemmas as Theorems: We will state the Five Lemma, the Snake Lemma, and the
3x3 Lemma as formal TheoremDeclarations. Each theorem will assert that given a specific
DiagrammaticAssertion (the premises), a certain conclusion holds.

Connecting Technique to Theorem: We will assert that the proof of each of these theorems
is a ProofByDiagramChase. This formally links the abstract statement of the lemma to the
concrete (though meta-mathematical) method used to prove it, providing a complete and rigorous
formalization of the section's content.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Proof Technique == )
( ========================================================================================================== *)

ProofByDiagramChase ::= "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;
TYPING
(*
* This defines the proof technique as a valid meta-level inference rule. The rule is only sound
* because the Freyd-Mitchell Embedding Theorem guarantees we can treat the objects and morphisms
* as if they were modules and homomorphisms, where chasing elements makes sense.
*)
Context: Current category C is ABELIAN.
Γ ⊢ FreydMitchellEmbeddingTheorem is valid.
-----------------------------------------------------
Γ ⊢ PROOF by DIAGRAM_CHASE ... : SoundProofTechnique ;
CATEGORY
[[ PROOF by DIAGRAM_CHASE ... ]] = "A meta-mathematical proof object. It represents a a proof that proceeds by treating morphisms in an abstract abelian category as functions between sets/modules and 'chasing' elements through the diagram. Its soundness is guaranteed by the deep Freyd-Mitchell Embedding Theorem." ;

(* ========================================================================================================== )
( == Part 2: Formalizing the Lemmas == )
( ========================================================================================================== *)

DiagrammaticAssertion ::= "DIAGRAMMATIC_ASSERTION" string_literal "{" "Diagram" ":" DiagramDeclaration "," "Premises" ":" {Proposition} "}" ;
TYPING
(* This structure holds the premises for a diagrammatic lemma. *)
Γ ⊢ diag : DiagramDeclaration
∀ p ∈ Premises, Γ ⊢ p : Proposition
---------------------------------------------------------
Γ ⊢ DIAGRAMMATIC_ASSERTION ... : SetOfPremises ;
CATEGORY
[[ DIAGRAMMATIC_ASSERTION ... ]] = "The complete set of premises for a diagrammatic lemma, specifying the shape of the diagram, its commutativity, and the exactness of its sequences." ;

TheoremDeclaration_FromDiagramChase ::= "THEOREM" string_literal ":" "(" DiagrammaticAssertion "⇒" Proposition ")" "proven_by" ProofByDiagramChase ;
TYPING
(* This links a theorem to its proof method. *)
Γ ⊢ premises : SetOfPremises
Γ ⊢ conclusion : Proposition
Γ ⊢ proof_method : SoundProofTechnique
IsSound(premises, conclusion, proof_method)
---------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ... proven_by DIAGRAM_CHASE ]] = "A formal theorem whose provided justification is a diagram chase. This explicitly grounds the theorem's validity in the element-wise reasoning permitted by the ambient abelian category." ;

(* --- Concrete Instance: The Five Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "TheFiveLemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "FiveLemmaSetup" "{"
"Diagram" ":" "The standard 5-column commutative diagram with two rows" ","
"Premises" ":" "{" "Top row is EXACT_SEQUENCE" "," "Bottom row is EXACT_SEQUENCE" ","
"f1 is ISO" "," "f2 is ISO" "," "f4 is ISO" "," "f5 is ISO" "}"
"}"
"⇒"
"f3 is ISOMORPHISM"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

(* --- Concrete Instance: The Snake Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "TheSnakeLemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "SnakeLemmaSetup" "{"
"Diagram" ":" "A 2x3 commutative diagram with vertical maps" ","
"Premises" ":" "{" "Rows are short exact sequences" "}"
"}"
"⇒"
"( ∃ connecting_homomorphism δ:ker(h)→coker(f) s.t. the resulting 6-term sequence is EXACT )"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

(* --- Concrete Instance: The 3x3 Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "The3x3Lemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "3x3LemmaSetup" "{"
"Diagram" ":" "A 3x3 commutative diagram" ","
"Premises" ":" "{" "All columns are SES" "," "Bottom two rows are SES" "}"
"}"
"⇒"
"(Top row is also a SES)"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

}

(* ELABORATION: This section defines "exact functors" in the rich context of abelian categories.
While the general notion of a functor preserving certain limits/colimits has been seen before,
the abelian setting provides a much sharper and more powerful characterization. An exact functor
is the "correct" type of morphism between abelian categories, as it preserves the structure of
short exact sequences, which are the fundamental building blocks of homological algebra.

A deep elaboration will proceed by:

Formalizing Half-Exactness: We will define LEFT_EXACT and RIGHT_EXACT functors in this specific context and state their powerful criterion: a functor is left exact if and only if it preserves kernels, and dually for right exactness and cokernels.

Formalizing Full Exactness: We will define an EXACT functor as one that is both left and right exact, and then state the main theorem: this algebraic condition is precisely equivalent to the preservation of all short exact sequences.

Analyzing the Canonical Example (Hom Functor): We will deeply analyze the exactness properties of the Hom functor. We will prove that the covariant Hom functor is always left exact.

Connecting to Projectives/Injectives: We will close the loop with previous chapters by showing that the condition under which the Hom functor becomes fully exact is precisely the definition of projective (or injective) objects. This reveals that projectivity/injectivity are "exactness conditions" on the Hom functor, a profound insight.
*)

(* ========================================================================================================== )
( == Part 1: Half-Exact Functors and their Criteria == )
( ========================================================================================================== *)
(In an abelian category, the general test for preserving finite limits/colimits simplifies dramatically.)

FunctorProperty ::= Identifier "is" "LEFT_EXACT_in_Abelian" ;
TYPING
(*
* In an additive category, a functor automatically preserves finite products/coproducts (biproducts)
* iff it is additive. As an abelian category has all finite limits constructed from products and kernels,
* the test for left exactness reduces to checking if the functor preserves kernels.
*)
Γ ⊢ F : Functor(C, D), Γ ⊢ C, D : ADDITIVE_CATEGORY
Γ ⊢ C, D : have all Kernels
---------------------------------------------------------------------------------
(Γ ⊢ F is LEFT_EXACT) <==> (Γ ⊢ F preserves KERNELS) ;
CATEGORY
[[ F is LEFT_EXACT_in_Abelian ]] = "A functor that preserves the limit-based part of the homological structure. The equivalence with kernel preservation provides a simple and powerful test for this property. The covariant Hom functor Hom(A,-) is the canonical example." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LEFT_EXACT_in_Abelian" "IS" "RIGHT_EXACT_in_Abelian" ;

FunctorProperty ::= Identifier "is" "RIGHT_EXACT_in_Abelian" ;
TYPING
(* Derived via duality. A functor is right exact iff it preserves cokernels. *)
IsDualOf("LEFT_EXACT_in_Abelian")
----------------------------------------------------------------------------------
(Γ ⊢ F is RIGHT_EXACT) <==> (Γ ⊢ F preserves COKERNELS) ;
CATEGORY
[[ F is RIGHT_EXACT_in_Abelian ]] = "A functor that preserves the colimit-based part of the homological structure. The equivalence with cokernel preservation is the dual test. The tensor product functor A⊗- is the canonical example." ;

(* ========================================================================================================== )
( == Part 2: Full Exactness and Short Exact Sequences == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "EXACT_FUNCTOR_in_Abelian" ;
TYPING
(* An exact functor is one that is both left and right exact. *)
Γ ⊢ F is LEFT_EXACT_in_Abelian
Γ ⊢ F is RIGHT_EXACT_in_Abelian
------------------------------------------
Γ ⊢ F is EXACT_FUNCTOR_in_Abelian ;
CATEGORY
[[ F is EXACT_FUNCTOR_in_Abelian ]] = "A functor that preserves all the fundamental homological structure of its domain. This is the strongest and most desirable property for a functor in homological algebra." ;

TheoremDeclaration ::= "THEOREM" "ExactnessViaShortExactSequences" ":"
"A functor F between Abelian Categories is EXACT"
"<==>"
"F sends Short Exact Sequences to Short Exact Sequences." ;
TYPING
(* This theorem shows that preserving the atomic 'SES' structure is equivalent to preserving all finite limits and colimits. *)
Context: Γ ⊢ F : Functor(C, D) between ABELIAN_CATEGORY C, D
P1 := (Γ ⊢ F is EXACT_FUNCTOR_in_Abelian)
P2 := (∀(s : SES in C), (F(s) is SES in D))
-------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM ExactnessViaShortExactSequences ]] = "A fundamental theorem connecting the algebraic definition of exactness (preserving kernels and cokernels) to the sequence-based definition. It confirms that the short exact sequence is the essential structure that an exact functor must preserve." ;

(* ========================================================================================================== )
( == Part 3 & 4: The Hom Functor, Projectives, and Injectives == )
( ========================================================================================================== *)
(This connects the abstract theory back to core examples and previously defined concepts.)

TheoremDeclaration ::= "THEOREM" "CovariantHomIsLeftExact" ":"
"For any object A in an Abelian Category C, the functor Hom_C(A, -): C → Ab is LEFT_EXACT." ;
TYPING
(*
* Proof sketch: We must show F=Hom(A,-) preserves kernels. Let k:K→B be ker(g:B→C).
* We must show F(k) is ker(F(g)). This means the sequence 0 → Hom(A,K) → Hom(A,B) → Hom(A,C)
* is exact in Ab, which is precisely the definition of the kernel K's universal property.
*)
Context: Γ ⊢ C is ABELIAN_CATEGORY, Γ ⊢ A : Object_in(C)
F := Hom_C(A,-)
-----------------------------------
Γ ⊢ F is LEFT_EXACT : ProvableProposition ;
CATEGORY
[[ THEOREM CovariantHomIsLeftExact ]] = "A cornerstone result of homological algebra. It asserts that the representable functor Hom(A,-) is always left exact. This property stems directly from the universal property of the kernel." ;

TheoremDeclaration ::= "THEOREM" "ExactHomCharacterizesProjectives" ":"
"An object P in an Abelian Category C is PROJECTIVE"
"<==>"
"the functor Hom_C(P, -) is EXACT." ;
TYPING
(*
* A functor is exact if it's left exact AND right exact. We already know Hom(P,-) is left exact.
* So it's exact iff it's right exact, which means it sends epis to epis.
* Hom(P,-) sending an epi e:A→B to an epi means Hom(P,A)→Hom(P,B) is surjective.
* This surjectivity is precisely the 'lifting property' that defines a projective object P.
*)
Context: Γ ⊢ P : Object_in(AbelianCategory C)
P1 := (Γ ⊢ P is PROJECTIVE_OBJECT)
P2 := (Γ ⊢ Hom_C(P,-) is EXACT_FUNCTOR_in_Abelian)
----------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM ExactHomCharacterizesProjectives ]] = "A deep characterization of projective objects. It reveals that projectivity is not an arbitrary lifting property, but is precisely the condition required to make the covariant Hom functor fully exact. A projective object is an object 'from which' the process of representation is homologically perfect." ;

DualTheoremInference ::= "INFER_DUAL_THEORY" "'InjectiveTheoryFromHom'" "FROM" "THEORY" "'ProjectiveTheoryFromHom'" ;
TYPING
(* By applying the duality functor (-)^op to the entire theory block for covariant Hom, we get the dual theory. )
( 1. Covariant Hom(A,-) -> Contravariant Hom(-,A) )
( 2. LEFT_EXACT -> LEFT_EXACT (this is a tricky self-dual concept under f^op, but the property holds) )
( 3. PROJECTIVE -> INJECTIVE )
( 4. EXACT -> EXACT )
( The results are: )
( Thm 1: Contravariant Hom(-,I) is always LEFT_EXACT. )
( Thm 2: An object I is INJECTIVE iff the functor Hom_C(-,I) is EXACT. *)
Γ ⊢ TheoryBlock["ProjectiveTheoryFromHom"] : CoherentTheoryFragment
--------------------------------------------------------------------
Γ ⊢ TheoryBlock["InjectiveTheoryFromHom"] := (TheoryBlock["ProjectiveTheoryFromHom"])^op ;
CATEGORY
[[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the corresponding theory for injective objects. It asserts that the contravariant Hom functor is always left exact, and that injective objects are precisely those objects for which the contravariant Hom functor is fully exact. This reveals injectivity as the condition for a 'perfect receiver' in homological algebra." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.12: Torsion theories" ")" "==>" {
(*

ELABORATION: This section defines a "torsion theory," a powerful concept that generalizes the
decomposition of an abelian group into its torsion subgroup and torsion-free quotient. A torsion theory
provides a canonical way to split any object in an abelian category into a "torsion part" and a
"torsion-free part." A deep elaboration requires deconstructing this concept into its essential
components: the orthogonality of the classes, the universal decomposition, and the resulting closure
and reflectivity properties.

Our elaboration will proceed by:

Formalizing the Core Orthogonality: We will define the fundamental relationship between the torsion class (T) and the torsion-free class (F): the fact that there are no non-trivial morphisms between them.

Formalizing the Universal Decomposition: The purpose of a torsion theory is to guarantee that every object X fits into a canonical short exact sequence 0 → tX → X → fX → 0, where tX is its maximal torsion subobject and fX is its maximal torsion-free quotient. We will formalize this structure.

Constructing the Master Definition: We will combine orthogonality and universal decomposition into the complete, formal definition of a Torsion Theory.

Stating the Characterization Theorem: We will formalize the powerful theorem that characterizes a torsion theory by the closure properties of its constituent classes (e.g., the torsion class is closed under quotients). This provides an alternative, structural way to define and identify torsion theories.

Connecting to Adjunctions: We will reveal the deep connection to the theory of reflective subcategories by stating the theorem that a torsion theory (T,F) implies that T is a coreflective subcategory and F is a reflective subcategory.

*)

(* ========================================================================================================== )
( == Part 1: The Core Orthogonality Condition == )
( ========================================================================================================== *)

OrthogonalObjectClasses ::= Identifier "⊥" Identifier ;
TYPING
(*
* This predicate defines the core relationship between the two classes T and F.
* They are orthogonal if the Hom-set between any object in T and any object in F is the zero object.
*)
Γ ⊢ T, F : ClassOfObjects(C)
Condition := ∀ (A ∈ T), ∀ (B ∈ F), (Hom_C(A, B) ≅ {0})
---------------------------------------------------
Γ ⊢ (T ⊥ F) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ T ⊥ F ]] = "The assertion of Hom-orthogonality. It states that from the perspective of the torsion-free objects, all torsion objects are trivial (isomorphic to the zero object), and dually. This is the fundamental separation property of a torsion theory." ;

(* ========================================================================================================== )
( == Part 2: The Universal Decomposition Sequence == )
( ========================================================================================================== *)

TorsionShortExactSequence ::= "TorsionSES_for" "(" Identifier ")" "decomposes_as" "(" Identifier "," Identifier ")" ;
TYPING
(*
* This rule asserts the existence of the canonical short exact sequence for an object X.
* This SES defines the maximal torsion subobject tX and the maximal torsion-free quotient fX.
*)
Γ ⊢ X : Object_in(AbelianCategory C)
Γ ⊢ T, F : ClassOfObjects(C)
----------------------------------------------------------------------------------------------------------------------
Γ ⊢ TorsionSES_for(X) ... is TRUE if ( ∃ SES "0 → tX → X → fX → 0" s.t. (tX ∈ T) ∧ (fX ∈ F) ) ;
CATEGORY
[[ TorsionSES_for(X) ... ]] = "The canonical short exact sequence associated with object X by the torsion theory. The object tX is the 'torsion radical' of X, and fX is its 'torsion-free part'. The existence and uniqueness (up to isomorphism) of this sequence for every object is the central utility of the theory." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition of a Torsion Theory == )
( ========================================================================================================== *)

TorsionTheoryDeclaration ::= "TORSION_THEORY" "(" "Torsion" ":" Identifier "," "Free" ":" Identifier ")" ;
TYPING
(*
* A pair of classes (T,F) forms a torsion theory if it satisfies both the orthogonality
* and the decomposition conditions.
*)
Γ ⊢ T, F : ClassOfObjects(AbelianCategory C)
Premise1: Γ ⊢ T ⊥ F
Premise2: ∀ X ∈ Ob(C), (Γ ⊢ TorsionSES_for(X) decomposes_as(T,F))
------------------------------------------------------------------
Γ ⊢ TORSION_THEORY (Torsion:T, Free:F) : ValidTorsionTheory ;
CATEGORY
[[ TORSION_THEORY (T, F) ]] = "A canonical decomposition of an abelian category into two orthogonal classes such that every object has a unique resolution into a subobject from one class and a quotient from the other. It is a fundamental organizing principle for abelian categories." ;

(* ========================================================================================================== )
( == Part 4: The Characterization via Closure Properties == )
( ========================================================================================================== *)

ClassClosedUnder ::= Identifier "is_closed_under" ("QUOTIENTS" | "COPRODUCTS" | "SUBOBJECTS" | "PRODUCTS" | "EXTENSIONS") ;
TYPING
(* Defines various closure properties for a class of objects. *)
Γ ⊢ A : ClassOfObjects(AbelianCategory C)
CASE "QUOTIENTS": ∀(a∈A, e:a→x is EPI), x∈A
CASE "COPRODUCTS": ∀({a_i}⊆A), Coproduct({a_i})∈A
CASE "SUBOBJECTS": ∀(a∈A, m:x→a is MONO), x∈A
CASE "PRODUCTS": ∀({a_i}⊆A), Product({a_i})∈A
CASE "EXTENSIONS": ∀(SES 0→A→B→C→0), (A∈A ∧ C∈A) ⇒ B∈A
-----------------------------------------------------
Γ ⊢ A is_closed_under ... : PropositionAbout(A) ;
CATEGORY
[[ A is_closed_under ... ]] = "A statement about the stability of the class A with respect to a standard categorical construction. These properties reveal the structural nature of the class." ;

TheoremDeclaration ::= "THEOREM" "TorsionTheoryClosureCriterion" ":"
"A pair (T,F) is a TORSION_THEORY IFF"
"(" "T is_closed_under QUOTIENTS and COPRODUCTS, and"
"F is_closed_under SUBOBJECTS and PRODUCTS" ")" ;
TYPING
(* This is a standard characterization theorem for torsion theories. *)
P1 := (Γ ⊢ TORSION_THEORY(T, F))
P2 := ( Γ ⊢ T is_closed_under QUOTIENTS ∧ Γ ⊢ T is_closed_under COPRODUCTS ∧
Γ ⊢ F is_closed_under SUBOBJECTS ∧ Γ ⊢ F is_closed_under PRODUCTS )
-------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM TorsionTheoryClosureCriterion ]] = "A key structural theorem that provides an alternative definition for a torsion theory. It asserts that the universal decomposition property is equivalent to a specific set of closure properties for the two classes. This often provides a more direct way to prove that a given pair constitutes a torsion theory." ;

(* ========================================================================================================== )
(* == Part 5: The Connection to Reflective Subcategories == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "TorsionClassesInduceAdjunctions" ":"
"IF (T,F) is a TORSION_THEORY in C, THEN"
"(" "T is a COREFLECTIVE subcategory of C, and"
" F is a REFLECTIVE subcategory of C." ")" ;
TYPING
(*
* This theorem reveals the deep connection between torsion theories and adjunctions.
* The decomposition provides the universal arrows for the reflections.
*)
Context: (T,F) is a TORSION_THEORY in C.
For object X, the SES is 0 → tX → X → fX → 0.
Conclusion1: F is REFLECTIVE_IN C.
Reflector Functor L(X) := fX.
Reflection Arrow η_X := the map X → fX.
Conclusion2: T is COREFLECTIVE_IN C.
Coreflector Functor R(X) := tX.
Coreflection Arrow ε_X := the map tX → X.
-----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM TorsionClassesInduceAdjunctions ]] = "A fundamental result that recasts the concept of a torsion theory in the language of adjunctions. It asserts that the torsion-free class F is a reflective subcategory, where the reflector functor L sends an object X to its maximal torsion-free quotient fX. Dually, the torsion class T is a coreflective subcategory, where the coreflector functor R sends X to its maximal torsion subobject tX. This provides a powerful, modern perspective on the structure of torsion theories." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.13: Finitizations of abelian categories" ")" "==>" {
(*

ELABORATION: This section provides a formal way to talk about the "finite" part of a large
abelian category. The key insight is that "finiteness" is not about the number of objects, but about
how objects are constructed. An object is "finitely presented" if it can be described by a finite
number of generators and a finite number of relations. The main result is that the collection of all
such objects forms a self-contained, well-behaved subcategory which is itself abelian.

A deep elaboration requires deconstructing this concept step-by-step:

Finitely Generated: We first formalize the weaker notion of a "finitely generated" object,
which is an object that can be constructed as a quotient of a finite "building block".

Finitely Presented: We then build upon this to define a "finitely presented" object, which
is finitely generated, and where the "relations" needed to construct it are also finitely generated.

The Finitization Construction: We formalize the construction of the "finitization" of a
category C as the full subcategory C_fp consisting of all finitely presented objects.

The Main Theorem: We state the crucial theorem: this subcategory C_fp is itself an abelian
category. This ensures that the 'finite part' of an abelian category is a well-behaved world
where homological algebra can be done.

This approach reveals that the finitization is a canonical way to extract the core algebraic essence
of a larger abelian category.
*)

(* ========================================================================================================== )
( == Part 1: The Building Block - Finitely Generated Objects == )
( ========================================================================================================== *)

Biproduct_Power ::= Identifier "^" integer_literal ;
TYPING
(* This syntactic rule defines the n-th biproduct power of an object G. *)
Γ ⊢ G : Object_in(ADDITIVE_CATEGORY C)
Γ ⊢ n : integer_literal, n ≥ 0
-----------------------------------------------------------------
Γ ⊢ G^n : Object_in(C) (defined as G ⊕ G ⊕ ... ⊕ G, n times) ;
CATEGORY
[[ G^n ]] = "The n-fold biproduct of the object G. In R-Mod, if G is the ring R, this is the free module Rⁿ." ;

ObjectPropertyAssertion ::= Identifier "is" "FINITELY_GENERATED" "by" Identifier ;
TYPING
(*
* An object X is finitely generated by G if it is a quotient of some finite power of G.
* The object G is typically a generator for the category.
)
Γ ⊢ X : Object_in(ADDITIVE_CATEGORY C)
Γ ⊢ G : Object_in(C) ( G is usually a generator object *)
Condition := ∃ (n ∈ ℕ) s.t. ( ∃ (e : G^n → X is EPIMORPHISM) )
------------------------------------------------------------------------------------
Γ ⊢ X is FINITELY_GENERATED by G is TRUE if Condition holds ;
CATEGORY
[[ X is FINITELY_GENERATED by G ]] = "The property that the object X can be completely described by a finite amount of information from the generator G. It is 'spanned' by a finite number of elements of G." ;

(* ========================================================================================================== )
( == Part 2: The Core Concept - Finitely Presented Objects == )
( ========================================================================================================== *)

ObjectPropertyAssertion ::= Identifier "is" "FINITELY_PRESENTED" ;
TYPING
(*
* This is the core definition. An object X is finitely presented if it fits into a specific
* kind of exact sequence, called a "finite presentation".
* This sequence shows that X is finitely generated (by P₀) and that the kernel of that
* generation (the "relations") is also finitely generated (by P₁).
*)
Γ ⊢ X : Object_in(ADDITIVE_CATEGORY C)
Let G be a generator for C.
Condition := ∃ (P₁, P₀ are FINITELY_GENERATED by G) s.t.
( ∃ EXACT_SEQUENCE "P₁ → P₀ → X → 0" )
------------------------------------------------------------------------------------
Γ ⊢ X is FINITELY_PRESENTED is TRUE if Condition holds ;
CATEGORY
[[ X is FINITELY_PRESENTED ]] = "The property of an object being determined by both a finite number of generators and a finite number of relations. This is a crucial finiteness condition in algebra, ensuring the object is 'algebraically small' and computable." ;

(* ========================================================================================================== )
( == Part 3: The Main Construction - The Finitization Subcategory == )
( ========================================================================================================== *)

FinitizationSubcategoryCtor ::= "FinitizationOf" "(" Identifier ")" ;
TYPING
(*
* This constructor takes an abelian category C and builds its "finitization", C_fp.
* C_fp is the full subcategory whose objects are precisely the finitely presented objects of C.
*)
Γ ⊢ C : ABELIAN_CATEGORY
FP_Objects := { X ∈ Ob(C) | Γ ⊢ X is FINITELY_PRESENTED }
----------------------------------------------------------------------------------
Γ ⊢ FinitizationOf(C) : FullSubcategory(C) on objects FP_Objects ;
CATEGORY
[[ FinitizationOf(C) ]] = "The finitization of C, denoted C_fp. This subcategory isolates the 'algebraically finite' core of the larger category C. For example, the finitization of R-Mod is the category of finitely presented R-modules." ;

(* ========================================================================================================== )
( == Part 4: The Main Theorem - The Finitization is Abelian == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "FinitizationIsAbelian" ":"
"IF" Identifier "C" "is an ABELIAN_CATEGORY with a generator,"
"THEN" "FinitizationOf(C)" "is an ABELIAN_CATEGORY." ;
TYPING
(*
* This is a deep and powerful theorem. Proving that C_fp is an abelian category requires
* showing that it is closed under all the necessary constructions (biproducts, kernels, cokernels).
* The most difficult part is proving that the kernel of a morphism between two finitely presented
* objects is itself finitely presented.
*)
Premise: Γ ⊢ C is ABELIAN_CATEGORY (with suitable properties like a generator)
--------------------------------------------------------------------------
Conclusion: Γ ⊢ FinitizationOf(C) is ABELIAN_CATEGORY : MetaTheorem ;
CATEGORY
[[ THEOREM FinitizationIsAbelian ]] = "A key closure property in the theory of abelian categories. It guarantees that the collection of finitely presented objects is not just a grab-bag, but a self-contained, well-behaved algebraic universe in which all the powerful tools of homological algebra (like exact sequences and diagram chasing) can be applied. It ensures that finite constructions remain finite." ;

}

(*
ELABORATION: Section 1.14 presents the Freyd-Mitchell Embedding Theorem, one of the most profound
and consequential results in the theory of abelian categories. It is not a theorem within
a category, but a statement about all small abelian categories. Its importance lies in the fact
that it justifies a powerful and intuitive proof technique—diagram chasing—which would otherwise
be informal and potentially invalid.

A deep elaboration requires us to not only state the theorem but to formalize its role as a
justification for this proof method. We will therefore:

Formalize the Theorem: We will state the Freyd-Mitchell Embedding Theorem as a formal
meta-theorem within our grammar, precisely specifying its premises (a small abelian category)
and its conclusion (the existence of a full, faithful, and exact embedding into a category of modules).

Formalize the Consequence: We will then introduce a formal "Justification Axiom." This axiom
will be a meta-level implication, stating that IF the Freyd-Mitchell Embedding Theorem is true,
THEN the technique of diagram chasing is a valid and sound method of proof.

Formalize the Technique: Finally, we will re-state the ProofByDiagramChase construct,
explicitly showing that its own validity is contingent on the Justification Axiom.

This approach transforms the theorem from a mere statement of fact into the foundational pillar that
supports the entire edifice of element-based reasoning in abstract homological algebra.
*)

(* ========================================================================================================== )
( == Part 1: The Freyd-Mitchell Embedding Theorem (The Statement) == )
(* ========================================================================================================== *)

FreydMitchellEmbeddingTheorem ::= "THEOREM" "FreydMitchellEmbedding" ":"
"FOR_ALL small abelian category A,"
"∃ Ring R and ∃ Functor F: A → R-Mod s.t."
"F is FULLY_FAITHFUL and EXACT." ;
TYPING
(*
* This is a meta-theorem about the structure of all small abelian categories.
* It is asserted as a foundational axiom of our meta-theory.
*)
Premise: Γ ⊢ A : ABELIAN_CATEGORY, Γ ⊢ A is SMALL
-----------------------------------------------------------------------------------------
Conclusion: ∃ (R:Ring, F:Functor(A,Category(R-Mod))) s.t. (F is FULLY_FAITHFUL ∧ F is EXACT_FUNCTOR) ;
CATEGORY
[[ THEOREM FreydMitchellEmbedding ]] = "A foundational meta-theorem asserting the existence of a concrete representation for any abstract small abelian category. It guarantees that the objects and morphisms of A, no matter how abstractly defined, behave precisely as if they were modules and module homomorphisms. This is the bridge between the abstract and concrete worlds of homological algebra." ;

(* ========================================================================================================== )
( == Part 2: The Justification Axiom (The Consequence) == )
(* ========================================================================================================== *)

DiagramChasingJustificationAxiom ::= "JUSTIFICATION_AXIOM" ":" FreydMitchellEmbeddingTheorem "==>" "DiagramChasing_is_SOUND_TECHNIQUE" ;
TYPING
(*
* This is a meta-level inference rule. It states that the truth of the embedding theorem
* directly implies the soundness of diagram chasing as a proof method.
*)
Γ ⊢ FreydMitchellEmbeddingTheorem is TRUE
-------------------------------------------------
Γ ⊢ DiagramChasing_is_SOUND_TECHNIQUE : Proposition ;
CATEGORY
[[ JUSTIFICATION_AXIOM ... ]] = "A meta-inference rule that connects the existence theorem to a specific proof methodology. It formalizes the logical step: 'Because any small abelian category behaves like a category of modules, we are justified in reasoning about its morphisms as if they were functions and its objects as if they had elements.'" ;

(* ========================================================================================================== )
( == Part 3: The Proof Technique Itself (The Application) == )
(* ========================================================================================================== *)

ProofByDiagramChase ::= "PROOF" "by" "DIAGRAM_CHASE" ;
TYPING
(*
* This rule represents the application of the proof technique. Its own validity as a step in
* a larger proof rests on the justification axiom.
)
Premise1: The proposition P to be proven is a statement about a diagram in an ABELIAN_CATEGORY.
Premise2: Γ ⊢ DiagramChasing_is_SOUND_TECHNIQUE ( From the Justification Axiom )
Premise3: An element-wise proof of P exists. ( An oracle check that the chase is correct *)
-------------------------------------------------------------------------------------------------
Γ ⊢ (PROOF by DIAGRAM_CHASE proves P) : ValidProofStep ;
CATEGORY
[[ PROOF by DIAGRAM_CHASE ]] = "The application of the justified proof technique. It represents the act of transporting the diagrammatic problem into a concrete category of modules (via the guaranteed embedding F), performing an element-wise proof there, and then reflecting the conclusion back into the abstract category. The properties of the embedding (full, faithful, exact) guarantee this reflection is valid." ;


