MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'Locales', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(* ========================================================================================================== )
( == Section 1.1: The intuitionistic propositional calculus == )
( ========================================================================================================== )
(*
ELABORATION: This section formalizes the syntax and deduction rules of intuitionistic logic. This logic
is the internal logic of Heyting algebras and toposes, and its syntax serves as the raw material for
the Lindenbaum-Tarski algebra construction in the next section. We will formalize the propositions
and the deduction rules as categorical constructs, anticipating the Curry-Howard-Lambek correspondence.
*)

(* --- The Syntax of Propositions --- *)

IntuitionisticProposition ::= Terminal("⊤") | Terminal("⊥") | Identifier | "(" IntuitionisticProposition "∧" IntuitionisticProposition ")" | "(" IntuitionisticProposition "∨" IntuitionisticProposition ")" | "(" IntuitionisticProposition "→" IntuitionisticProposition ")" ;
TYPING
(* Propositions are the objects of our logical category. *)
Γ ⊢ p : IntuitionisticProposition
-----------------------------------
Γ ⊢ p : Object_in(Cat_of_Proofs) ;
CATEGORY
[[ p : IntuitionisticProposition ]] = "A proposition, viewed as an object in the category of proofs (a Cartesian Closed Category). A proof of the proposition will be a morphism into this object." ;

(* --- The Form of Judgments and Proofs --- *)

DeductionSequent ::= "{" {IntuitionisticProposition} "}" "⊢" IntuitionisticProposition ;
TYPING
(* A sequent Γ ⊢ p asserts the existence of a proof. This corresponds to the existence of a morphism. )
Context_Γ := {p_i} ( The set of assumptions *)
Conclusion_p := p
---------------------------------------------------------------------------------------------------
Γ ⊢ ({p_i} ⊢ p) <==> (∃ proof_morphism : Product({[[p_i]]}) → [[p]] in Cat_of_Proofs) ;
CATEGORY
[[ {p_i} ⊢ p ]] = "An assertion of provability. Categorically, it is the statement that the hom-set Hom( [[Γ]], [[p]] ) is inhabited, where [[Γ]] is the product of the objects corresponding to the propositions in Γ." ;

(* --- The Inference Rules as Formal Constructions --- *)

AssumptionRule ::= "ASSUME" "(" IntuitionisticProposition ")" "from" DeductionSequent ;
TYPING
(* The axiom rule of natural deduction: an assumption is a proof. *)
Γ ⊢ {p_i} ⊢ ...
p_k ∈ {p_i}
-------------------
Γ ⊢ {p_i} ⊢ p_k ;
CATEGORY
[[ ASSUME(p_k) from ... ]] = "The projection morphism proj_k from the product object [[Γ]] = Π[[p_i]] to its k-th component, [[p_k]]. This is the fundamental proof object corresponding to using an assumption." ;

ConjunctionIntroductionRule ::= "AND_INTRO" "(" DeductionSequent "," DeductionSequent ")" ;
TYPING
(* To prove a conjunction, you must prove both conjuncts. *)
Γ ⊢ p , Γ ⊢ q
-----------------
Γ ⊢ (p ∧ q) ;
CATEGORY
[[ AND_INTRO(proof_p, proof_q) ]] = "The universal morphism <proof_p, proof_q> into the product object [[p]] × [[q]], guaranteed to exist by the universal property of the product." ;

ConjunctionEliminationRule ::= "AND_ELIM_" ("LEFT"|"RIGHT") "(" DeductionSequent ")" ;
TYPING
(* If you have a proof of a conjunction, you have a proof of each part. *)
Γ ⊢ (p ∧ q) Γ ⊢ (p ∧ q)
------------- -------------
Γ ⊢ p Γ ⊢ q ;
CATEGORY
[[ AND_ELIM_LEFT(proof_pandq) ]] = "The composition of the proof morphism proof_pandq with the first projection, proj₁ ∘ proof_pandq. This extracts the proof of the left conjunct from the proof of the product." ;

ImplicationIntroductionRule ::= "IMPLIES_INTRO" "(" DeductionSequent ")" ;
TYPING
(* To prove an implication, assume the antecedent and derive the consequent. *)
Γ, {p} ⊢ q
---------------
Γ ⊢ (p → q) ;
CATEGORY
[[ IMPLIES_INTRO(proof_of_q_from_p) ]] = "The currying of the proof morphism proof_of_q_from_p : [[Γ]]×[[p]] → [[q]] to a new morphism curry(proof) : [[Γ]] → [[q]]^[[p]]. This is the universal property of the exponential object." ;

ImplicationEliminationRule ::= "MODUS_PONENS" "(" DeductionSequent "," DeductionSequent ")" ;
TYPING
(* If you have a proof of an implication and its antecedent, you have a proof of its consequent. *)
Γ ⊢ p , Γ ⊢ (p → q)
---------------------
Γ ⊢ q ;
CATEGORY
[[ MODUS_PONENS(proof_p, proof_p_implies_q) ]] = "The composition eval ∘ <proof_p_implies_q, proof_p>, where <...> is the universal map into the product [[q]]^[[p]] × [[p]] and eval is the evaluation morphism eval: [[q]]^[[p]] × [[p]] → [[q]]." ;

TruthIntroductionRule ::= "TRUTH_INTRO" ;
TYPING
(* Truth is always provable, from any context. *)
---
Γ ⊢ ⊤ ;
CATEGORY
[[ TRUTH_INTRO ]] = "The unique morphism ! from the object [[Γ]] to the terminal object, [[⊤]]." ;

FalsityEliminationRule ::= "EX_FALSO_QUODLIBET" "(" DeductionSequent "," IntuitionisticProposition ")" ;
TYPING
(* From a proof of falsity, any proposition can be derived. *)
Γ ⊢ ⊥
-----------
Γ ⊢ p ;
CATEGORY
[[ EX_FALSO_QUODLIBET(proof_of_false, target_p) ]] = "The composition ! ∘ proof_of_false, where proof_of_false is a morphism [[Γ]] → [[⊥]] and ! is the unique morphism from the initial object [[⊥]] to the target object [[p]]." ;
}

(* ========================================================================================================== )
( == Section 1.2: Heyting algebras == )
( ========================================================================================================== )
(*
ELABORATION: This section introduces the algebraic semantics for intuitionistic logic: the Heyting algebra.
This structure is central to the entire chapter, as a "frame" (the basis for locales) is a special kind of
complete Heyting algebra. A deep elaboration requires us to formalize not just the definition, but the
key insight behind it: the implication operator → is defined by an adjunction with the meet operator ∧.
This reveals the fundamentally categorical nature of intuitionistic logic.

Our formalization will proceed by:

Deconstructing the Definition: We will define a HeytingAlgebraDeclaration by explicitly
requiring an underlying bounded lattice and then adding the new implication operator.

Formalizing the
Adjunction Axiom: The core of the TYPING rule will be to formalize the universal property that
defines implication: (c ∧ a ≤ b) ⇔ (c ≤ (a → b)). This is the adjunction (- ∧ a) ⊣ (a → -).

Defining the Homomorphisms: We will define the structure-preserving maps between Heyting
algebras, showing that they must preserve not just the lattice structure but also this new
implication structure.

Stating the Fundamental Connection to Logic: We will formalize the Lindenbaum-Tarski theorem as a
key TheoremDeclaration, asserting that the algebra of provable statements in intuitionistic logic
forms the archetypal Heyting algebra. This bridges the syntax of the previous section with the
algebraic semantics of this one.
*)

(* ========================================================================================================== )
( == Part 1: The Definition and its Core Adjunction == )
( ========================================================================================================== )

HeytingAlgebraDeclaration ::= "HEYTING_ALGEBRA" Identifier "is" "{" "UnderlyingLattice" ":" BoundedLatticeDeclaration "," "Implication" ":" OperationDeclaration "}" ;
TYPING
(*
* The typing rule verifies that the given data forms a Heyting algebra.
* It checks that we have a bounded lattice, and a binary operation →.
* The crucial condition is the Adjointness Axiom, which uniquely defines the → operator
* in relation to the meet ∧ and the ordering ≤.
*)
Γ ⊢ L : BoundedLattice
Γ ⊢ (→) : Morphism(Product(Carrier(L),Carrier(L)), Carrier(L))
Axiom_Adjointness: ∀ a,b,c ∈ Carrier(L), ( (c ∧ a ≤ b) <==> (c ≤ (a → b)) )
--------------------------------------------------------------------------------
Γ ⊢ HEYTING_ALGEBRA H ... : HeytingAlgebra_Type ;
CATEGORY
[[ HEYTING_ALGEBRA H ]] = "A bounded lattice that serves as a sound and complete model for intuitionistic propositional logic. The implication operation (Heyting implication) is precisely the right adjoint to the meet operation, viewed as a functor on the poset category. This adjunction is expressed as (- ∧ a) ⊣ (a → -)." ;

(* ========================================================================================================== )
( == Part 2: The Structure-Preserving Maps == )
( ========================================================================================================== )

HeytingAlgebraHomomorphism ::= "HEYTING_HOMOMORPHISM" Identifier ":" HeytingAlgebraDeclaration "→" HeytingAlgebraDeclaration ;
TYPING
(* A Heyting homomorphism must preserve all the structure: the lattice operations and the implication. *)
Γ ⊢ f : Morphism(HA₁, HA₂)
f is a BoundedLatticeHomomorphism
f preserves HeytingImplication: ∀a,b ∈ HA₁, f(a → b) == f(a) → f(b)
----------------------------------------------------------------------
Γ ⊢ f is a HEYTING_HOMOMORPHISM ;
CATEGORY
[[ f : HEYTING_HOMOMORPHISM ]] = "A structure-preserving map between Heyting algebras. It is a morphism in the category Heyt." ;

(* ========================================================================================================== )
( == Part 3: The Bridge from Logic to Algebra == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "LindenbaumTarskiForIPC" ":" "The set of intuitionistic propositions, under the relation of provable equivalence, forms the initial HEYTING_ALGEBRA." ;
TYPING
(*
* This is a meta-theorem. It asserts that the syntactic constructions of Section 1.1
* provide the canonical model for the algebraic structures of Section 1.2.
* The proof involves showing that the set of equivalence classes of propositions, with the
* ordering p≤q iff p⊢q, and the operations defined by the logical connectives,
* satisfy all the axioms of a Heyting algebra.
*)
Let IPC_Prop be the set of IntuitionisticPropositions.
Let ~ be the equivalence relation p~q iff (p⊢q and q⊢p).
Let LT_Algebra = IPC_Prop / ~.
------------------------------------------------------------------------------
Γ ⊢ LT_Algebra is a HEYTING_ALGEBRA : ProvableProposition ;
CATEGORY
[[ THEOREM "LindenbaumTarskiForIPC" ]] = "The assertion that the syntactic category of intuitionistic proofs, when quotiented by provable equivalence, yields a canonical semantic model in the category of Heyting algebras. This is the fundamental bridge from the syntax of intuitionistic logic to its algebraic semantics, and it establishes that the Heyting algebra is the 'correct' algebraic model for this logic." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.3: Locales" ")" "==>" {
(*
ELABORATION: The original definition of a locale was compact: "a locale is the dual of a frame."
This is the central insight, but a deep elaboration requires formalizing the machinery of this duality.
The key is to understand that while the objects (locales) are abstract, the morphisms between
them are concrete, and it is in the definition of these morphisms that the crucial arrow-reversal
occurs.

This elaboration will therefore:

Formalize the two categories, Frm (of frames) and Loc (of locales), as distinct entities.

Explicitly define a LocaleMorphism by showing it is concretely represented by a FrameHomomorphism
traveling in the opposite direction.

State the foundational duality as a formal theorem, asserting that the category Loc is, by
construction, precisely the opposite category of Frm.
*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Two Interacting Categories == )
( ========================================================================================================== )

CategoryOfFrames ::= "Frm" ;
TYPING
(* This rule declares the category of Frames. *)
Objects(Frm) := { F | Γ ⊢ F : FRAME }
Morphisms(Frm) := { g | Γ ⊢ g : FRAME_HOMOMORPHISM }
-------------------------------------------------------
Γ ⊢ Frm : Category ;
CATEGORY
[[ Frm ]] = "The category whose objects are frames (complete Heyting algebras) and whose morphisms are frame homomorphisms (preserving finite meets and arbitrary joins). This is the 'algebraic' side of the duality." ;

CategoryOfLocales ::= "Loc" ;
TYPING
(* This rule declares the category of Locales. Its full definition is given by the duality theorem below. *)
Objects(Loc) := { L | Γ ⊢ L : LOCALE }
Morphisms(Loc) := { f | Γ ⊢ f : LOCALE_MORPHISM }
------------------------------------------------------
Γ ⊢ Loc : Category ;
CATEGORY
[[ Loc ]] = "The category of locales, or 'pointless spaces'. This is the 'spatial' or 'geometric' side of the duality, constructed to have better categorical properties (e.g., being cocomplete) than the category of topological spaces." ;

(* ========================================================================================================== )
( == Part 2: The Core of the Duality - The Locale Morphism == )
( ========================================================================================================== )

LocaleMorphismDeclaration ::= "LOCALE_MORPHISM" Identifier ":" LocaleDeclaration "→" LocaleDeclaration ;
TYPING
(*
* This is the heart of the elaboration. It defines what a morphism between locales IS.
* A locale morphism f: L₁ → L₂ is defined to be, and is represented by, a frame
* homomorphism g: Frame(L₂) → Frame(L₁) that goes in the REVERSE direction.
*)
Γ ⊢ f : Identifier
Γ ⊢ L₁ : LOCALE, Γ ⊢ L₂ : LOCALE
Let F₁ = Frame(L₁), F₂ = Frame(L₂).
-------------------------------------------------------------------------------------------------------------
(Γ ⊢ LOCALE_MORPHISM f : L₁ → L₂) <==> (∃ g:FRAME_HOMOMORPHISM s.t. g: F₂ → F₁) ;
CATEGORY
[[ LOCALE_MORPHISM f : L₁ → L₂ ]] = "A morphism between locales. It is representationally a frame homomorphism between their corresponding frames, but going in the opposite direction. This reversal of arrows is the essence of the Frm-Loc duality. If a continuous map of spaces h: X₁ → X₂ induces a frame homomorphism h⁻¹: Ω(X₂) → Ω(X₁) on the open sets, then the corresponding locale morphism goes f: Ω(X₁) → Ω(X₂), preserving the original direction of the map." ;

(* ========================================================================================================== )
( == Part 3: The Foundational Duality Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "LocaleFrameDuality" ":" "The category Loc is the opposite of the category Frm." ;
TYPING
(*
* This theorem formalizes the definition of the category of locales. It is not something to be proven
* from other axioms, but is the foundational constructive definition of Loc.
*)
Let Frm be the category of frames and frame homomorphisms.
Let Loc be the category of locales and locale morphisms.
-----------------------------------------------------------------
Γ ⊢ Loc ≅ Frm^op : IsomorphismOfCategories ;
CATEGORY
[[ THEOREM LocaleFrameDuality ]] = "The assertion of the foundational duality that defines locale theory. It states that the category of 'spaces' (Loc) is constructed as the formal opposite of the category of 'algebras' (Frm). This principled construction is motivated by the desire to turn certain limits in Frm (like products of frames) into more geometrically intuitive colimits in Loc (coproducts of locales), thereby creating a category of spaces with better categorical properties." ;

}

TheoremDeclaration ::= "THEOREM" "FrmIsComplete" ":" "The category Frm of frames and frame homomorphisms is complete." ;
TYPING
(*
* This is an established result in the theory of frames. A category is complete if it has
* all small limits. For frames, this can be proven by explicitly constructing products
* and equalizers. The product of a family of frames is their cartesian product with
* pointwise-defined operations, and equalizers can also be constructed directly.
*)
Category("Frm") has all small limits.
--------------------------------------
Γ ⊢ THEOREM "FrmIsComplete" is a ProvableProposition ;
CATEGORY
[[ THEOREM "FrmIsComplete" ]] = "The assertion that Frm, the category of the 'algebras' of pointless topology, is a well-behaved algebraic category with respect to limits. This provides the solid foundation from which we will deduce properties of the 'spatial' category Loc." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LocIsCocomplete'" "FROM" "THEOREM" "'FrmIsComplete'" ;
TYPING
(*
* This is the core logical step of the section, formalized as an application of the Duality Principle.
* The logic proceeds as follows:
* 1. By the definition of an opposite category, a limit in a category C corresponds to a colimit in C^op.
* 2. Therefore, if a category C is complete (has all limits), its opposite C^op must be cocomplete (have all colimits).
* 3. We have the theorem "FrmIsComplete".
* 4. By the foundational duality, Loc ≅ Frm^op.
* 5. Therefore, Loc must be cocomplete.
*)
(Γ ⊢ Frm is COMPLETE)^op <==> (Γ ⊢ Frm^op is COCOMPLETE) <==> (Γ ⊢ Loc is COCOMPLETE)
------------------------------------------------------------------------------------
Conclusion: The category Loc has all small colimits. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof, via the Duality Principle, that the category of locales is cocomplete. This demonstrates the power of the abstract approach: instead of constructing coproducts and coequalizers of locales directly (which is difficult), we construct the simpler products and equalizers of frames and deduce the result via duality." ;

TheoremDeclaration ::= "THEOREM" "LocaleCoproductViaFrameProduct" ":" "The frame of the coproduct of locales is the product of their frames." ;
TYPING
(*
* This theorem makes the abstract deduction concrete for the most important colimit, the coproduct.
* Let L₁ and L₂ be locales, with corresponding frames F₁ and F₂.
* The coproduct in Loc is L₁ ∐ L₂.
* The product in Frm is F₁ × F₂.
* Because the functor Frame: Loc → Frm^op is an equivalence, it must turn coproducts into products.
* Frame(L₁ ∐ L₂) ≅ Frame(L₁) × Frame(L₂)
*)
Γ ⊢ L₁, L₂ : LOCALE
-----------------------------------------------------------------------
Γ ⊢ Frame(L₁ ∐ L₂) ≅ (Frame(L₁) × Frame(L₂)) : Isomorphism in Frm ;
CATEGORY
[[ THEOREM "LocaleCoproductViaFrameProduct" ]] = "The assertion of the concrete formula for the coproduct of locales. To find the coproduct (sum) of two 'pointless spaces', one takes the product of their 'algebras of opens'. This is a canonical example of how geometric constructions in Loc are realized by algebraic constructions in Frm." ;

(* ========================================================================================================== )
( == Section 1.5: Nuclei == )
( ========================================================================================================== )
(*
ELABORATION: This section provides the frame-theoretic tool for constructing sub-objects in the
category of locales. A "nucleus" on a frame acts as a closure operator, and its set of fixed points
canonically defines a sublocale. A deep elaboration requires us to formally deconstruct the definition
of a nucleus into its constituent axioms, then formalize the construction of the 'frame of fixed points'
that it induces, and finally, state the main theorem that connects this algebraic construction to the
geometric concept of a sublocale.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition of a Nucleus == )
( ========================================================================================================== )
(A nucleus is a function on a frame that satisfies four specific axioms.)

NucleusDeclaration ::= "NUCLEUS" Identifier "on" FrameDeclaration ;
TYPING
(*
* This typing rule checks the four defining axioms for a function j: F → F to be a nucleus.
* The first three define a closure operator, and the fourth ensures compatibility with the frame structure.
*)
Γ ⊢ j : Morphism(F, F) in Poset_Category
Axiom_Inflationary: ∀ a∈F, a ≤ j(a)
Axiom_Monotone: ∀ a,b∈F, (a≤b ⇒ j(a)≤j(b))
Axiom_Idempotent: ∀ a∈F, j(j(a)) == j(a)
Axiom_PreservesMeets: ∀ a,b∈F, j(a∧b) == j(a)∧j(b)
-----------------------------------------------------------------
Γ ⊢ NUCLEUS j on F is a valid declaration ;
CATEGORY
[[ NUCLEUS j on F ]] = "A closure operator on a frame that also respects the finite meet structure. It projects elements of the frame F onto a subset of 'j-closed' elements. Each nucleus corresponds to a way of embedding a smaller locale into a larger one." ;

(* ========================================================================================================== )
( == Part 2: The Construction of the Sublocale's Frame == )
( ========================================================================================================== )
(The set of fixed points of a nucleus itself forms a frame.)

FrameOfFixedPoints ::= "Fix" "(" NucleusDeclaration ")" ;
TYPING
(*
* This rule defines the new frame constructed from the fixed points of a nucleus j.
* The carrier set is the set of j-closed elements. The operations are mostly inherited,
* but the join operation must be 'closed' by applying j.
*)
Context: Γ ⊢ j : NUCLEUS on F
Carrier_F_j := { a ∈ F | j(a) == a }
Meet_in_F_j := Meet_in_F (since j preserves meets)
Join_in_F_j(S) := j(Join_in_F(S))
-------------------------------------------------------------------------------------------------------
Γ ⊢ Fix(j) : FRAME (whose carrier is Carrier_F_j and operations are defined as above) ;
CATEGORY
[[ Fix(j) ]] = "The frame of j-fixed-points, denoted F_j. This is the sub-poset of the original frame F consisting of all the elements that are 'closed' under the nucleus j. The theorem is that this collection of fixed points, with a slightly modified join operation, itself forms a new frame, which is the frame of the corresponding sublocale." ;

(* ========================================================================================================== )
( == Part 3: The Main Correspondence Theorem == )
( ========================================================================================================== )
(This theorem provides the crucial link between the algebraic tool and the geometric concept.)

SublocaleDeclaration ::= "SUBLOCALE" Identifier "of" LocaleDeclaration ;
TYPING
(* A sublocale corresponds to a quotient frame, which is represented by a surjective frame homomorphism. *)
Γ ⊢ L₁, L₂ : LOCALE
-----------------------------------------------------------------------------------------------
Γ ⊢ L₁ is SUBLOCALE of L₂ if the corresponding locale morphism L₁→L₂ is a monomorphism in Loc ;
CATEGORY
[[ S is SUBLOCALE of L ]] = "A locale S that is a subspace of a locale L. In the dual category of frames, this corresponds to a surjective frame homomorphism from Frame(L) onto Frame(S)." ;

TheoremDeclaration ::= "THEOREM" "SublocaleNucleusCorrespondence" ":"
"The sublocales of a locale L are in bijective correspondence with the nuclei on its frame F." ;
TYPING
(*
* This is the statement of the correspondence. The proof shows that every surjective frame homomorphism
* (defining a sublocale) gives rise to a nucleus, and every nucleus gives rise to a surjective
* frame homomorphism (onto its frame of fixed points).
*)
Let L be a LOCALE with Frame F.
Set1 := { S | Γ ⊢ S is SUBLOCALE of L }
Set2 := { j | Γ ⊢ j is NUCLEUS on F }
---------------------------------------------------------------------
Γ ⊢ Bijection(Set1, Set2) : IsomorphismOfPosets ;
CATEGORY
[[ THEOREM SublocaleNucleusCorrespondence ]] = "The fundamental theorem of sublocales. It establishes a perfect one-to-one correspondence between the geometric notion of a sublocale and the algebraic notion of a nucleus on the corresponding frame. This allows geometric questions about subspaces to be translated into algebraic questions about closure operators, which are often easier to analyze." ;

(* ELABORATION: These sections define special classes of locale morphisms that have good geometric

properties. The definitions are purely categorical, relying on the existence of adjoints to the

underlying frame homomorphism, which beautifully illustrates the power of adjoint functors to capture

geometric meaning. A deep elaboration requires deconstructing these adjunctional definitions.
*)

(*
ELABORATION: This section defines a special class of locale morphisms that mirrors the important topological
concept of an "open map." A continuous function h: X → Y is open if the image of any open set in X is
an open set in Y. This property is captured in the dual world of frames by a beautiful adjunctional
property of the corresponding frame homomorphism.

A deep elaboration requires us to deconstruct this adjunctional property, showing that the definition of
an "open" locale morphism is not arbitrary but is the precise categorical translation of its topological
counterpart.

Our formalization will proceed by:

Formalizing the "Direct Image" Functor: A locale morphism f:L₁→L₂ is represented by a frame
homomorphism g:F₂→F₁ (the "inverse image"). The topological notion of a "direct image" map becomes,
in this abstract setting, the left adjoint to g. We will formalize this left adjoint, g_!, as the
core new piece of structure.

Formalizing the "Good Behavior" Condition: The mere existence of a left adjoint is not quite enough.
The direct image of an intersection of open sets must be the intersection of their images. This translates
to the condition that the left adjoint g_! must preserve finite meets. We will formalize this as a distinct
property.

Constructing the Master Definition: We will define an OPEN_LOCALE_MORPHISM as one whose
underlying frame homomorphism possesses a left adjoint that also preserves finite meets. This combines
the previous two pieces into the complete, formal definition.
*)

(* ========================================================================================================== )
( == Part 1: The Left Adjoint (The "Direct Image" Analogue) == )
( ========================================================================================================== )

DirectImageFunctor_of_FrameHom ::= "g_!" "(" Identifier ")" ;
TYPING
(*
* This constructor defines the left adjoint g_! to a frame homomorphism g.
* The existence of this adjoint is the first condition for the original locale map to be open.
)
Context: Γ ⊢ g : FrameHomomorphism(from:F₂, to:F₁)
-------------------------------------------------------------------------------------------------
Γ ⊢ g_!(g) : Functor(F₁, F₂) is a valid declaration if ( ∃ Functor f s.t. f ⊣ g ) ;
CATEGORY
[[ g_!(g) ]] = "The left adjoint to the frame homomorphism g. In the topological setting where g is the inverse image map h⁻¹:Ω(Y)→Ω(X), this left adjoint g_! corresponds to the direct image map h_:Ω(X)→Ω(Y). Its existence is the categorical statement that a direct image map is well-defined on the frame." ;

(* ========================================================================================================== )
( == Part 2: The Good Behavior Condition (Preserving Meets) == )
( ========================================================================================================== )

FunctorProperty_PreservesMeets ::= Identifier "preserves" "FINITE_MEETS" ;
TYPING
(*
* This predicate asserts that a functor between frames (viewed as categories) preserves finite meets.
* This is the second condition the left adjoint must satisfy.
)
Γ ⊢ f : Functor(F₁, F₂) between Frames F₁, F₂
Condition_Top: f(1_{F₁}) == 1_{F₂}
Condition_Meets: ∀ a,b ∈ F₁, f(a ∧ b) == f(a) ∧ f(b)
------------------------------------------------------------------------------------------
Γ ⊢ f preserves FINITE_MEETS is TRUE if Condition_Top ∧ Condition_Meets ;
CATEGORY
[[ f preserves FINITE_MEETS ]] = "The property of a poset map being a Heyting algebra homomorphism. When applied to the left adjoint g_!, this condition corresponds to the topological property that the direct image map preserves finite intersections, i.e., h_(U₁∩U₂) = h_(U₁)∩h_(U₂)." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition of an Open Locale Morphism == )
( ========================================================================================================== )

OpenLocaleMorphismDeclaration ::= "OPEN" LocaleMorphismDeclaration ;
TYPING
(*
* This is the master definition, combining the previous two components. A locale morphism f is
* open if its corresponding frame homomorphism g has a left adjoint, g_!, and that left
* adjoint preserves finite meets.
*)
Γ ⊢ f : LocaleMorphism(from:L₁, to:L₂)
Let g be the frame_homomorphism(F₂, F₁) corresponding to f.
Premise1_AdjointExists: ∃ (left_adj = g_!(g))
Premise2_AdjointIsNice: Γ ⊢ left_adj preserves FINITE_MEETS
-------------------------------------------------------------------------------------------------
Γ ⊢ OPEN f is a valid declaration if Premise1_AdjointExists ∧ Premise2_AdjointIsNice ;
CATEGORY
[[ OPEN f : L₁ → L₂ ]] = "A locale morphism f whose corresponding frame homomorphism g:Frame(L₂)→Frame(L₁) possesses a left adjoint that preserves finite meets. The existence of this specific kind of left adjoint is the precise, abstract, categorical translation of the condition that the original continuous map of spaces was an open map. This definition demonstrates the power of adjoint functors to capture geometric properties in a purely algebraic setting." ;

(*
ELABORATION: This section defines "etale morphisms" of locales, which are the point-free, categorical
analogue of "local homeomorphisms" in classical topology. The definition is a beautiful example of how
deep geometric properties can be captured by abstract categorical conditions. It builds directly upon the
definition of an open morphism from the previous section by adding a powerful coherence law to the
underlying adjunction.

A deep elaboration requires us to deconstruct this extra coherence law—the Beck-Chevalley condition—and
show how it formally captures the geometric notion of being "stable under base change," which is the
hallmark of a local homeomorphism.

Our formalization will proceed by:

Formalizing the Beck-Chevalley Condition: We will first provide a formal declaration for the
Beck-Chevalley condition itself. This is a general property of an adjunction in a category with pullbacks,
asserting that the adjunction behaves well with respect to "changing the base" of a morphism.

Constructing the Master Definition: We will then define an ETALE_LOCALE_MORPHISM as a morphism that is
firstly an OPEN_LOCALE_MORPHISM, and secondly, whose defining frame-homomorphism adjunction
(g_! ⊣ g) satisfies this Beck-Chevalley condition.

Stating the Key Geometric Equivalence: Finally, we will state the main theorem that justifies this
entire construction: the assertion that a map between sober topological spaces is a local homeomorphism
if and only if its corresponding locale morphism is etale. This connects the abstract, adjunctional
definition back to its concrete geometric intuition.
*)

(* ========================================================================================================== )
( == Part 1: The Coherence Law (The Beck-Chevalley Condition) == )
( ========================================================================================================== )

BeckChevalleyCondition ::= "BECK_CHEVALLEY_CONDITION" "for_adjunction" "(" Identifier "⊣" Identifier ")" ;
TYPING
(*

The Beck-Chevalley condition for an adjunction F ⊣ G. In a category with pullbacks,

for any pullback square, a canonical natural transformation (the base change map)

relates the two ways of going around the square with the adjoints. The condition

asserts that this canonical transformation is always an isomorphism.
*)
Context: Γ ⊢ F ⊣ G : Adjunction(C,D), where C and D have pullbacks.
∀ (pullback_square in D), the canonical base change natural transformation
β : F_pullback ∘ G_base → G_pullback ∘ F_base is an ISOMORPHISM.

Γ ⊢ BECK_CHEVALLEY_CONDITION for (F ⊣ G) is a valid proposition ;
CATEGORY
[[ BECK_CHEVALLEY_CONDITION for (F ⊣ G) ]] = "A fundamental coherence law for an adjunction, ensuring its stability under base change (pullback). It guarantees that the process of 'pulling back along f then applying the right adjoint G' is naturally isomorphic to 'applying G then pulling back along the pullback of f'. This property is crucial for a structure to be considered truly 'geometric'." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of an Etale Morphism == )
( ========================================================================================================== )

EtaleLocaleMorphismDeclaration ::= "ETALE" LocaleMorphismDeclaration ;
TYPING
(*

An etale morphism is an open morphism whose defining adjunction is particularly well-behaved

with respect to pullbacks in the category of frames.

The definition requires two premises:

The morphism must first satisfy the conditions for being open.

The adjunction g_! ⊣ g that witnesses its openness must satisfy the Beck-Chevalley condition.
*)
Premise1_IsOpen: Γ ⊢ f is OPEN_LOCALE_MORPHISM
Let (g_! ⊣ g) be the adjunction for f in the category Frm.
Premise2_IsStable: The adjunction (g_! ⊣ g) satisfies the BECK_CHEVALLEY_CONDITION.

Γ ⊢ ETALE f is a valid declaration if Premise1_IsOpen ∧ Premise2_IsStable ;
CATEGORY
[[ ETALE f : L₁ → L₂ ]] = "A locale morphism that corresponds to a local homeomorphism of spaces. The definition builds on that of an open morphism by adding the stringent Beck-Chevalley condition to the adjunction g_! ⊣ g. This extra coherence axiom is the precise, abstract, categorical translation of the 'stability under base change' property that is characteristic of local homeomorphisms, demonstrating their fundamental geometric nature." ;

(* ========================================================================================================== )
( == Part 3: The Geometric Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "EtaleIsLocalHomeomorphism" ":"
"A continuous map h between sober spaces is a LOCAL_HOMEOMORPHISM"
"<==>"
"the corresponding locale morphism Ω(h) is ETALE." ;
TYPING
(* This theorem is the ultimate justification for the abstract definition of an etale morphism. *)
Context: Γ ⊢ h : Morphism(X, Y) in the subcategory of Sober Spaces.
P1 := (h is a LOCAL_HOMEOMORPHISM)
P2 := (The locale morphism Ω(h) corresponding to h is an ETALE_LOCALE_MORPHISM)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "EtaleIsLocalHomeomorphism" ]] = "The assertion of a perfect correspondence between a key geometric concept from classical topology (local homeomorphisms) and a purely algebraic, adjunctional property in locale theory (being an etale morphism). This theorem demonstrates the success of the locale-theoretic program in capturing geometric intuition in a point-free, categorical language." ;

(*
ELABORATION: These sections reveal the fundamental connection and duality between the world of classical,
point-set topology (Top) and the world of point-free, algebraic topology (Loc). This connection is
not an isomorphism, but a more subtle and powerful relationship: an adjunction. A deep elaboration
requires us to formally construct the two functors that bridge these worlds and then to use the
unit and counit of their adjunction to precisely define the "well-behaved" subcategories on which
this relationship becomes an equivalence.
*)

(* ========================================================================================================== )
( == Part 1: The Functors Bridging the Two Worlds == )
( ========================================================================================================== )
(We first formalize the two key functors: Ω, which extracts the "logic" from a space,
and pt, which reconstructs a "space" from a logic.)

OmegaFunctor ::= "Ω" ":" "Top → Loc" ;
TYPING
(* This functor takes a topological space and produces its locale of open sets. *)
ActionOnObjects( X : Object_in(Top) ):
Let F_X be the FRAME of open sets of X.
Ω(X) := the LOCALE whose frame is F_X.
ActionOnMorphisms( h : Morphism(X,Y) in Top ):
Let g_h : Frame(Ω(Y)) → Frame(Ω(X)) be the frame homomorphism defined by taking the inverse image, g_h(U) := h⁻¹(U).
Ω(h) := the LOCALE_MORPHISM corresponding to the frame homomorphism g_h.
--------------------------------------------------------------------------------
Γ ⊢ Ω : Functor(Top, Loc) ;
CATEGORY
[[ Ω : Top → Loc ]] = "The 'open sets' functor. It is a contravariant construction on the underlying frames, but covariant on the locales themselves. It extracts the observable, algebraic essence of a space, forgetting its underlying points." ;

PointsFunctor ::= "pt" ":" "Loc → Top" ;
TYPING
(* This functor takes a locale and constructs its space of 'points'. *)
ActionOnObjects( L : LOCALE ):
Let F_L := Frame(L).
Let Pts := { p | p is a FRAME_HOMOMORPHISM from F_L to the 2-element frame {0,1} }.
The topology on Pts is generated by opens of the form { p ∈ Pts | p(a) = 1 } for each a ∈ F_L.
pt(L) := the TopologicalSpace (Pts, topology).
ActionOnMorphisms( f : Morphism(L₁, L₂) in Loc):
Let g_f : Frame(L₂) → Frame(L₁) be the corresponding frame homomorphism.
pt(f) is the continuous map pt(L₁) → pt(L₂) that sends a point p:Frame(L₁)→{0,1} to the composite p ∘ g_f.
--------------------------------------------------------------------------------
Γ ⊢ pt : Functor(Loc, Top) ;
CATEGORY
[[ pt : Loc → Top ]] = "The 'points' functor. It provides the best possible reconstruction of a classical topological space from the purely algebraic data of a locale. It is the bridge from the point-free world back to the point-set world." ;

(* ========================================================================================================== )
( == Part 2: The Main Adjunction and its Unit/Counit == )
( ========================================================================================================== )
(The two functors are not inverse, but adjoint.)

TheoremDeclaration ::= "THEOREM" "OmegaIsLeftAdjointToPoints" ":" "The funtor Ω is left adjoint to the functor pt, (Ω ⊣ pt)." ;
TYPING
Γ ⊢ Ω : Functor(Top, Loc), Γ ⊢ pt : Functor(Loc, Top)
----------------------------------------------------------------------------------
Γ ⊢ Ω ⊣ pt : Adjunction(Top, Loc) <==> Hom_Loc(Ω(X), L) ≅ Hom_Top(X, pt(L)) ;
CATEGORY
[[ THEOREM "OmegaIsLeftAdjointToPoints" ]] = "The assertion of the fundamental adjunction between topology and locale theory. The natural bijection means that a continuous map from a space X to the 'space of points' of a locale L corresponds uniquely to a locale morphism from the 'locale of opens' of X to L. This is the central organizing principle of the theory." ;

UnitOfOmegaPtAdjunction ::= "η" ":" "Id_Top ⇒ pt ∘ Ω" ;
TYPING
(* The unit η_X of the adjunction is a continuous map from a space X to the space of points of its own locale of opens. *)
Γ ⊢ η : NaturalTransformation(Id_Top, pt ∘ Ω)
Component_at_X(η_X : X → pt(Ω(X))):
Maps a point x∈X to the frame homomorphism p_x: Ω(X)→{0,1} defined by p_x(U) = 1 iff x∈U.
--------------------------------------------------------------------------
Γ ⊢ η is the UNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ η ]] = "The unit of the adjunction. For each space X, the map η_X tests whether X can be fully recovered from its points. A space is 'sober' if this map is an isomorphism." ;

CounitOfOmegaPtAdjunction ::= "ε" ":" "Ω ∘ pt ⇒ Id_Loc" ;
TYPING
(* The counit ε_L is a locale morphism from the locale of opens of its space of points back to the original locale. *)
Γ ⊢ ε : NaturalTransformation(Ω ∘ pt, Id_Loc)
Component_at_L(ε_L : Ω(pt(L)) → L):
Defined by the frame homomorphism g_L: Frame(L) → Frame(Ω(pt(L))) that sends an element a∈Frame(L)
to the open set { p:Frame(L)→{0,1} | p(a)=1 }.
-------------------------------------------------------------------------
Γ ⊢ ε is the COUNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ ε ]] = "The counit of the adjunction. For each locale L, the map ε_L tests whether L has enough points to define its structure. A locale is 'spatial' if this map is an isomorphism." ;

(* ========================================================================================================== )
( == Part 3 (Elaborated): Sober Spaces, Spatial Locales, and the Equivalence == )
(* ELABORATION: This is a deep dive into the core result connecting topology to locale theory.

We will deconstruct the definitions of "sober" and "spatial", showing how they are precisely

the conditions required for the unit and counit of the fundamental Ω ⊣ pt adjunction to be isomorphisms.

This reveals that the equivalence is not an accident, but a direct consequence of the universal

properties that define the bridge between the two worlds.
*)

(* ========================================================================================================== )
( == 3a. The Unit of the Adjunction and the Test for Spaces (Sobriety) == )
( ========================================================================================================== )

UnitOfOmegaPtAdjunction ::= "η" ":" "Id_Top ⇒ pt ∘ Ω" ;
TYPING
(*
* This defines the unit of the adjunction, η. For each topological space X, η provides a
* canonical continuous map η_X from the space X itself to the space of points of its own locale of opens.
* We can define this map constructively:
* 1. The space pt(Ω(X)) has as its points the frame homomorphisms p: Frame(Ω(X)) → {0,1}.
* 2. Frame(Ω(X)) is just the lattice of open sets of X, denoted Open(X).
* 3. For any point x ∈ X, we can define such a homomorphism p_x by checking membership: p_x(U) = 1 iff x ∈ U.
* The map η_X is precisely the function that sends a point x to its corresponding homomorphism p_x.
*)
Component_at_X(η_X : X → pt(Ω(X))) := (x ↦ (p_x : Open(X)→{0,1}))
--------------------------------------------------------------------------
Γ ⊢ η is the UNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ η ]] = "The unit of the adjunction. For each space X, the map η_X tests whether the space X can be fully recovered from its own 'point-like structures' (the prime open filters). If this map is an isomorphism, the space is 'sober'." ;

SoberSpaceDeclaration ::= "SOBER_SPACE" Identifier ;
TYPING
(*
* A space X is defined as sober if the unit map η_X is a homeomorphism (an isomorphism in Top).
* η_X being injective means no two distinct points have the exact same collection of open neighborhoods.
* η_X being surjective means every frame homomorphism Open(X)→{0,1} (an abstract 'point') is realized
* by an actual point x ∈ X.
*)
Γ ⊢ X : Object_in(Top)
Let η_X be the X-component of the UnitOfOmegaPtAdjunction.
-----------------------------------------------------------
Γ ⊢ X is SOBER_SPACE is TRUE if (η_X is an ISOMORPHISM in Top) ;
CATEGORY
[[ SOBER_SPACE X ]] = "A topological space that has 'exactly the right amount' of points: no two points share the exact same open neighborhoods (a T₀-like property), and every collection of open sets that 'behaves like a point' (a prime open filter) actually corresponds to a unique concrete point. All Hausdorff spaces are sober." ;

(* ========================================================================================================== )
( == 3b. The Counit of the Adjunction and the Test for Locales (Spatiality) == )
( ========================================================================================================== )

CounitOfOmegaPtAdjunction ::= "ε" ":" "Ω ∘ pt ⇒ Id_Loc" ;
TYPING
(*
* This defines the counit ε. For each locale L, it is a locale morphism ε_L from the locale of opens of
* its space of points, Ω(pt(L)), back to the original locale L.
* This locale morphism is defined by its corresponding frame homomorphism g in the opposite direction: g_L: Frame(L) → Frame(Ω(pt(L))).
* 1. Frame(Ω(pt(L))) is the lattice of open sets of the space pt(L).
* 2. The map g_L sends an 'open' a ∈ Frame(L) to the concrete open set in pt(L) consisting of all
* points p that "satisfy" a.
* g_L(a) := { p ∈ pt(L) | p(a) = 1 }
*)
Component_at_L(ε_L : Ω(pt(L)) → L) is defined by the frame homomorphism:
g_L(a ∈ Frame(L)) ↦ {p:Frame(L)→{0,1} | p(a)=1 }
-------------------------------------------------------------------------
Γ ⊢ ε is the COUNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ ε ]] = "The counit of the adjunction. For each locale L, the map ε_L tests whether the locale can be fully recovered from its algebra of open sets. If this map is an isomorphism, the locale is 'spatial'." ;

SpatialLocaleDeclaration ::= "SPATIAL_LOCALE" Identifier ;
TYPING
(*
* A locale L is defined as spatial if the counit map ε_L is an isomorphism in Loc.
* This is equivalent to its underlying frame homomorphism g_L being an isomorphism in Frm.
* This holds if and only if for any two distinct elements a,b in Frame(L), there is some point
* p: Frame(L)→{0,1} that can distinguish them (i.e., p(a) ≠ p(b)).
*)
Γ ⊢ L : LOCALE
Let ε_L be the L-component of the CounitOfOmegaPtAdjunction.
--------------------------------------------------------------
Γ ⊢ L is SPATIAL_LOCALE is TRUE if (ε_L is an ISOMORPHISM in Loc) ;
CATEGORY
[[ SPATIAL_LOCALE L ]] = "A locale that is fully determined by its points; it has 'enough points' to separate all of its 'opens'. These are precisely the locales that arise as the lattice of open sets of some sober space." ;

(* ========================================================================================================== )
( == 3c. The Equivalence Theorem == )
( ========================================================================================================== )
(This theorem brings all the preceding definitions together into a single, powerful statement.)

CategoryOfSoberSpaces ::= "SoberTop" ;
TYPING
SoberObjects := { X ∈ Ob(Top) | Γ ⊢ X is SOBER_SPACE }
------------------------------------------------------------
Γ ⊢ SoberTop : FullSubcategory(Top) on objects SoberObjects ;
CATEGORY
[[ SoberTop ]] = "The category of sober spaces, which is the largest subcategory of Top on which the unit of the Ω⊣pt adjunction is an isomorphism. It is a reflective subcategory of Top." ;

CategoryOfSpatialLocales ::= "SpatialLoc" ;
TYPING
SpatialObjects := { L ∈ Ob(Loc) | Γ ⊢ L is SPATIAL_LOCALE }
----------------------------------------------------------------
Γ ⊢ SpatialLoc : FullSubcategory(Loc) on objects SpatialObjects ;
CATEGORY
[[ SpatialLoc ]] = "The category of spatial locales, which is the largest subcategory of Loc on which the counit of the Ω⊣pt adjunction is an isomorphism. It is a coreflective subcategory of Loc." ;

TheoremDeclaration ::= "THEOREM" "SoberSpatialEquivalence" ":"
"The Ω ⊣ pt adjunction restricts to an equivalence of categories between SoberTop and SpatialLoc." ;
TYPING
(*
* This is the main result. The properties of sobriety and spatiality are precisely the conditions
* needed for the unit and counit to be isomorphisms, which is a defining characteristic of an
* equivalence of categories mediated by an adjunction.
*)
Let Ω_res := the restriction of Ω to SoberTop.
Let pt_res := the restriction of pt to SpatialLoc.
------------------------------------------------------------------------------
Γ ⊢ Ω_res and pt_res form an EquivalenceOfCategories(SoberTop, SpatialLoc) ;
CATEGORY
[[ THEOREM "SoberSpatialEquivalence" ]] = "The culminating result of point-set topology's interaction with locale theory. It asserts that for the large and important class of sober spaces, no information is lost by shifting to the point-free perspective of locales, as there is a perfect, invertible dictionary between the two worlds. The functor Ω provides the translation from the spatial world to the algebraic/logical world, and the functor pt provides the translation back." ;

(* ELABORATION: These sections reveal the power of the locale-theoretic approach by demonstrating how

core topological properties like compactness and regularity can be defined in a completely "point-free"

manner, using only the algebraic structure of the frame of opens. A deep elaboration requires not just

stating these definitions, but deconstructing them to show how the point-free axioms are a direct

and faithful translation of the original topological intuition.
*)

(*
ELABORATION: This section defines the crucial topological property of compactness in the completely
point-free language of locales and their underlying frames. A deep elaboration requires not just stating
the final axiom, but deconstructing it to show how it is a direct and faithful algebraic translation
of the familiar topological phrase: "every open cover has a finite subcover."

This elaboration will proceed in three stages:

Formalizing the Pieces: We will create formal grammar rules for the algebraic concepts of
a "Frame Cover" (a set of frame elements whose join is the top element) and a
"Finite Subcover" (a finite subset of a cover that still joins to the top). This translates the
topological language into the algebraic language of the frame.

Constructing the Master Definition: We will then use these formalized pieces to build the master
definition of a COMPACT frame. A frame will be defined as compact if for every possible
FrameCover, there exists a FiniteSubcover. We then define a compact locale as one whose
frame is compact.

Stating the Justification Theorem: Finally, we will formalize the crucial theorem that justifies
this entire abstract enterprise. We will assert that for any well-behaved (sober) topological space,
it is compact in the classical sense if and only if its locale of opens is compact in this
new, point-free sense. This connects the abstract definition back to its concrete geometric origins.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Point-Free Axiom == )
( ========================================================================================================== )
(First, we translate the topological terms into the algebraic language of frames.)

FrameCover ::= "COVER" "of" FrameDeclaration "by" "{" {Identifier} "}" ;
TYPING
(*
* This defines a "cover" in the algebraic sense. A collection of "opens" (frame elements)
* is a cover if their union (join) is the whole space (the top element '1').
*)
Γ ⊢ F : FRAME
Γ ⊢ S : Set of ElementsOf(F)
---------------------------------------------------------
Γ ⊢ COVER of F by S is valid if (Join(S) == TopElement(F)) ;
CATEGORY
[[ COVER of F by S ]] = "An algebraic representation of an open cover. The set S is a subset of the frame F, and the condition that its join is the top element is the direct, point-free translation of the topological statement that the union of the corresponding open sets covers the entire space." ;

FiniteSubcover ::= "FINITE_SUBCOVER" "of" FrameCover "by" "{" {Identifier} "}" ;
TYPING
(*
* This defines a "finite subcover" in the algebraic sense. It is a finite subset of a
* given cover that is, itself, still a cover.
*)
Γ ⊢ C = (COVER of F by S)
Γ ⊢ S_fin : Set of ElementsOf(F)
Premise1_Subset: S_fin ⊆ S
Premise2_Finite: |S_fin| is finite
Premise3_Covers: Join(S_fin) == TopElement(F)
-------------------------------------------------------------------
Γ ⊢ FINITE_SUBCOVER of C by S_fin is a valid subcover ;
CATEGORY
[[ FINITE_SUBCOVER of C by S_fin ]] = "An algebraic representation of a finite subcover. It is a finite subset of the original covering set S that is still 'large enough' to join to the top element of the frame, meaning its corresponding union of open sets still covers the whole space." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition for Compactness == )
( ========================================================================================================== )

CompactFrameDeclaration ::= "COMPACT" FrameDeclaration ;
TYPING
(*
* This is the master definition, built from the pieces above. A frame is compact if for
* every possible cover, a finite subcover can be found.
*)
Γ ⊢ F : FRAME
Condition := ∀ (C : FrameCover of F), (∃ (S : FiniteSubcover of C))
-----------------------------------------------------------------
Γ ⊢ F is COMPACT is TRUE if Condition holds ;
CATEGORY
[[ COMPACT FRAME F ]] = "A frame that satisfies the point-free version of the Heine-Borel property. The definition is a direct, formal translation of 'every open cover has a finite subcover' into the algebraic language of joins in a complete lattice." ;

CompactLocaleDeclaration ::= "COMPACT" LocaleDeclaration ;
TYPING
(* A locale is defined as compact if and only if its underlying frame is compact. *)
Γ ⊢ L : LOCALE
----------------------------------------------------
Γ ⊢ L is COMPACT <==> (Frame(L) is COMPACT_FRAME) ;
CATEGORY
[[ COMPACT LOCALE L ]] = "A 'pointless space' that is compact. The property is defined not by reference to any points, but by reference to the algebraic compactness property of its associated frame of 'opens'." ;

(* ========================================================================================================== )
( == Part 3: The Justification (Connecting back to Topology) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CorrespondenceOfCompactness" ":"
"A sober space X is compact in the topological sense"
"<==>"
"its locale of opens Ω(X) is a COMPACT locale." ;
TYPING
(*
* This theorem asserts that our abstract, point-free definition is the 'correct' one,
* as it perfectly coincides with the classical definition for all well-behaved spaces.
*)
Context: Γ ⊢ X is SOBER_SPACE
P1_Topological := (X is a COMPACT_TOPOLOGICAL_SPACE)
P2_Localic := (Ω(X) is a COMPACT_LOCALE)
---------------------------------------------------
Γ ⊢ (P1_Topological <==> P2_Localic) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "CorrespondenceOfCompactness" ]] = "The assertion that the locale-theoretic definition of compactness is a faithful generalization of the topological definition. For the large and important class of sober spaces, the two definitions are equivalent, justifying the use of the more abstract, algebraic definition in the point-free setting." ;
}

(*
ELABORATION: This section defines the crucial topological separation property of regularity in the
completely point-free language of locales and their underlying frames. A deep elaboration requires not just
stating the final axiom, but deconstructing it to show how it is a direct and faithful algebraic
translation of the familiar topological idea: "a point can be separated from a closed set by disjoint
open neighborhoods." Since locales have no points, this must be rephrased. The key insight is to capture
this separation using a new relation, "way below" (≺), which formalizes the notion of one open set being
"securely nested" inside another.

This elaboration will proceed in three stages:

Formalizing the Core Tool (The "Way Below" Relation): We will formalize the ≺ relation,
which is the algebraic substitute for the topological idea of "closure of U is contained in V". This
is the fundamental building block for defining regularity without points.

Constructing the Master Definition: We will use the ≺ relation to define a regular frame as one
where every element is the join (union) of all the elements that are "way below" it. This is the
precise, point-free translation of the regularity axiom. We then define a regular locale as one whose
frame is regular.

Stating the Justification Theorem: We will formalize the crucial theorem that justifies this
entire abstract enterprise. We will assert that for any well-behaved (sober) topological space,
it is regular in the classical sense if and only if its locale of opens is regular in this
new, point-free sense. This connects the abstract definition back to its concrete geometric origins.
*)

(* ========================================================================================================== )
( == Part 1: The Core Tool - The "Way Below" Relation == )
( ========================================================================================================== )

WayBelowRelation ::= Expression "≺" Expression ;
TYPING
(*
* This rule formalizes the "way below" or "well inside" relation, b ≺ a.
* The intuition is that the closure of the open set corresponding to b is contained within the open set for a.
* The point-free definition captures this by asserting the existence of a "separating" open c (the
* complement of the closure of b) such that b and c are disjoint, but a and c together cover the whole space.
*)
Context: F is a FRAME. Γ ⊢ a,b: ElementsOf(F)
------------------------------------------------------------------
Γ ⊢ (b ≺ a) is TRUE if (∃c∈F s.t. b∧c==0 ∧ a∨c==1) ;
CATEGORY
[[ b ≺ a ]] = "The assertion that the element b is 'way below' the element a. This provides a point-free way to express that the closure of the open set corresponding to b is contained within the open set corresponding to a. It formalizes the notion of being 'securely nested' or 'well inside'." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of a Regular Locale == )
( ========================================================================================================== )

RegularFrameDeclaration ::= "REGULAR" FrameDeclaration ;
TYPING
(*
* A frame is defined as regular if every element 'a' can be reconstructed as the join of all the
* elements 'b' that are "way below" it. This means every open set can be built up from the
* collection of all open sets that are securely nested inside it. This is the precise algebraic
* translation of the T₃ separation axiom.
*)
Γ ⊢ F : FRAME
Condition_Regularity := ∀ (a ∈ Carrier(F)), ( a == ⋁{ b ∈ Carrier(F) | Γ ⊢ b ≺ a } )
------------------------------------------------------------------------------------
Γ ⊢ F is REGULAR is TRUE if Condition_Regularity holds ;
CATEGORY
[[ REGULAR FRAME F ]] = "A frame that satisfies the point-free version of the T₃ (regularity) separation axiom. This property ensures a high degree of 'separation' between the open sets of the frame, mirroring the ability to separate points from closed sets in a regular topological space." ;

RegularLocaleDeclaration ::= "REGULAR" LocaleDeclaration ;
TYPING
(* A locale is defined as regular if and only if its underlying frame is regular. *)
Γ ⊢ L : LOCALE
----------------------------------------------------
Γ ⊢ L is REGULAR <==> (Frame(L) is a REGULAR_FRAME) ;
CATEGORY
[[ REGULAR LOCALE L ]] = "A 'pointless space' that is regular. The property is defined not by reference to any points, but by reference to the algebraic regularity property of its associated frame of 'opens'." ;

(* ========================================================================================================== )
( == Part 3: The Justification (Connecting back to Topology) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CorrespondenceOfRegularity" ":"
"A sober space X is regular in the topological sense"
"<==>"
"its locale of opens Ω(X) is a REGULAR locale." ;
TYPING
(*
* This theorem asserts that our abstract, point-free definition is the 'correct' one,
* as it perfectly coincides with the classical definition for all well-behaved spaces.
*)
Context: Γ ⊢ X is SOBER_SPACE
P1_Topological := (X is a REGULAR_TOPOLOGICAL_SPACE)
P2_Localic := (Ω(X) is a REGULAR_LOCALE)
---------------------------------------------------
Γ ⊢ (P1_Topological <==> P2_Localic) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "CorrespondenceOfRegularity" ]] = "The assertion that the locale-theoretic definition of regularity is a faithful generalization of the topological definition. For the large and important class of sober spaces, the two definitions are equivalent, justifying the use of the more abstract, algebraic definition in the point-free setting." ;
