(* ========================================================================================================== )
( == Part 1: Deconstructing the General Product UMP == )
( ========================================================================================================== *)

ProductObjectDeclaration ::= Identifier "is" "PRODUCT" "of" "(" {Identifier} ")" ;
TYPING
(* This rule simply asserts that a given object P has the property of being the product of a family {A_i}. )
( The specific laws it must obey are given by the axioms below. *)
Γ ⊢ P : Object, Γ ⊢ {A_i} : set(Object)
----------------------------------------------------------
Γ ⊢ P is PRODUCT of ({A_i}) : CategoricalProperty ;
CATEGORY
[[ P is PRODUCT of ({A_i}) ]] = "The assertion that the object P is the apex of a limit cone over the discrete diagram formed by the objects {A_i}." ;

(* The structural projections and universal morphism constructor remain as before. *)
ProjectionMorphism ::= "proj_" Identifier ;
UniversalProductMorphism ::= "<" Expression { "," Expression } ">" ;

(* Now, we split the UMP into two explicit axioms: *)

UMP_ProductExistenceAxiom ::= "AXIOM" "ProductCommutativity" ":" "FOR_ALL" "cone" "{" {Identifier} "}" "," "proj_" Identifier "∘" "<" {Identifier} ">" "==" Identifier ;
TYPING
(*
* This axiom asserts the EXISTENCE part of the UMP. It guarantees that the universal morphism
* u = <f_i> constructed from a cone of morphisms {f_i} does, in fact, make the diagram commute.
* It defines the universal morphism by its behavior.
*)
Context: P is PRODUCT of {A_i}.
u = <{f_i}> where f_i : Morphism(X, A_i).
----------------------------------------------------------------------
∀i, Γ ⊢ (proj_{A_i} ∘ u) == f_i : ProvableEquality ;
CATEGORY
[[ AXIOM ProductCommutativity ... ]] = "The coherence law for the universal product morphism. It states that the universal map u is a valid mediating morphism for the cone with legs {f_i}." ;

UMP_ProductUniquenessAxiom ::= "AXIOM" "ProductUniqueness" ":" "IF" "(" Identifier "mediates" Cone ")" "THEN" Identifier "==" UniversalProductMorphism ;
TYPING
(*
* This axiom asserts the UNIQUENESS part of the UMP. It states that if any other morphism u_prime
* also makes the diagram commute (i.e., it "mediates" the cone), then u_prime must be equal
* to the one constructed by our UniversalProductMorphism syntax.
*)
Context: P is PRODUCT of {A_i}.
u = <{f_i}>.
u_prime mediates the cone {f_i} := ( ∀i, proj_{A_i} ∘ u_prime == f_i )
---------------------------------------------------------------------------
Γ ⊢ u_prime == u : ProvableEquality ;
CATEGORY
[[ AXIOM ProductUniqueness ... ]] = "The law formalizing the 'universal' aspect of the universal property. It states that the mediating morphism is unique, making the product object the 'best possible' solution." ;

(* ========================================================================================================== )
( == Part 2: Specializing the Product (Binary and Nullary Cases) == )
( ========================================================================================================== *)

BinaryProductExpression ::= Expression "×" Expression ;
TYPING
Γ ⊢ A : Object, Γ ⊢ B : Object
----------------------------------------------
Γ ⊢ (A × B) : PRODUCT of (A,B) ;
CATEGORY
[[ A × B ]] = "A convenient syntax for the binary product of objects A and B. It is a specific instance of the general product." ;

NullaryProductIsTerminalAxiom ::= "AXIOM" ":" "PRODUCT" "of" "()" "==" "TERMINAL_OBJECT" ;
TYPING
(* A product over an empty set of objects requires, for any test object X, a unique map u: X -> P. )
( This is precisely the definition of the terminal object. *)
Def1 := Definition_of(PRODUCT of ()).
Def2 := Definition_of(TERMINAL_OBJECT).
------------------------------------------
Γ ⊢ Def1 == Def2 : DefinitionalEquivalence ;
CATEGORY
[[ AXIOM: PRODUCT of () == TERMINAL_OBJECT ]] = "The formal assertion that the concept of an empty product and the concept of a terminal object are identical. This shows the coherence of the theory of limits." ;

(* ========================================================================================================== )
( == Part 3: Deriving the Coproduct via the Duality Principle == )
( ========================================================================================================== *)

(* Instead of defining Coproducts from scratch, we use the Duality Principle formalized in Chapter 1. *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CoproductCommutativity'" "FROM" "THEOREM" "'ProductCommutativity'" ;
TYPING
(*
* We apply the duality operator (-)^op to the UMP_ProductExistenceAxiom.
* The system applies the DUALITY_MAPPING dictionary:
* 1. proj_A_i (morphism out of product) -> inj_A_i (morphism into coproduct)
* 2. u = <{f_i}> (map INTO limit) -> u' = [{g_i}] (map OUT OF colimit)
* 3. Composition a ∘ b becomes b_op ∘_op a_op. So, proj ∘ u == f becomes u' ∘ inj == g.
* The result is the existence axiom for coproducts.
*)
Γ ⊢ THEOREM 'ProductCommutativity' : P_prod_exist
P_coprod_exist = rewrite(P_prod_exist, DualityMappings)
------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'CoproductCommutativity' : P_coprod_exist ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the coproduct's existence axiom, derived mechanically by applying the duality functor to the product's existence axiom." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CoproductUniqueness'" "FROM" "THEOREM" "'ProductUniqueness'" ;
TYPING
(* The same process is applied to the uniqueness axiom, proving its dual. *)
Γ ⊢ THEOREM 'ProductUniqueness' : P_prod_uniq
P_coprod_uniq = rewrite(P_prod_uniq, DualityMappings)
-------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'CoproductUniqueness' : P_coprod_uniq ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the coproduct's uniqueness axiom, derived via duality." ;

(* The outcome of these inferences are the formal rules for coproducts: *)
CoproductCommutativityAxiom ::= "AXIOM" "CoproductCommutativity" ":" "FOR_ALL" "cocone" "{" {Identifier} "}" "," "[" {Identifier} "]" "∘" "inj_" Identifier "==" Identifier ;
CoproductUniquenessAxiom ::= "AXIOM" "CoproductUniqueness" ":" "IF" "(" Identifier "mediates" CoCone ")" "THEN" Identifier "==" UniversalCoproductMorphism ;
BinaryCoproductExpression ::= Expression "+" Expression ;
NullaryCoproductIsInitialAxiom ::= "AXIOM" ":" "COPRODUCT" "of" "()" "==" "INITIAL_OBJECT" ;

}



(* ========================================================================================================== )
( == Part 1: Defining from First Principles (Universal Morphisms) == )
( ========================================================================================================== *)

ObjectPropertyDeclaration ::= Identifier "is" ("INITIAL_OBJECT" | "TERMINAL_OBJECT") ;
TYPING
(* This rule asserts a property about an object. The property's meaning is defined by the axioms below. *)
Γ ⊢ X : Object
-------------------------------------------
Γ ⊢ X is ... : PropositionAbout(X) ;
CATEGORY
[[ I is INITIAL_OBJECT ]] = "The assertion that the object I is the colimit of the empty diagram, i.e., it is the initial object 0." ;
[[ T is TERMINAL_OBJECT ]] = "The assertion that the object T is the limit of the empty diagram, i.e., it is the terminal object 1." ;

UniversalInitialMorphism ::= "unique_from_initial_to" "(" Identifier ")" ;
TYPING
(*
* EXISTENCE: If I is an initial object, this constructor gives us the guaranteed morphism to any other object X.
*)
Context: I is INITIAL_OBJECT
Γ ⊢ X : Object
--------------------------------------------------------------------
Γ ⊢ unique_from_initial_to(X) : Morphism(I, X) ;
CATEGORY
[[ unique_from_initial_to(X) ]] = "The unique morphism ! : I → X whose existence is guaranteed by the universal property of the initial object I." ;

InitialUniquenessAxiom ::= "AXIOM" "InitialUniqueness" ":" "FOR_ALL" "f" ":" Identifier "->" Identifier "," "f" "==" UniversalInitialMorphism ;
TYPING
(*
* UNIQUENESS: This axiom asserts that any morphism f you might find from I to X is necessarily
* the one constructed by our universal constructor. This formalizes the "unique" part of the definition.
*)
Context: I is INITIAL_OBJECT
Γ ⊢ f : Morphism(I,X)
----------------------------------------------------------------------------------
Γ ⊢ (f == unique_from_initial_to(X)) : ProvableEquality ;
CATEGORY
[[ AXIOM InitialUniqueness ... ]] = "The coherence law for initiality. It collapses the hom-set Hom(I, X) to a singleton, enforcing the uniqueness of the map from I." ;

(* --- The duals for the Terminal Object follow --- *)

UniversalTerminalMorphism ::= "unique_to_terminal_from" "(" Identifier ")" ;
TYPING
(* EXISTENCE (dual): The guaranteed morphism from any object X to the terminal object T. *)
Context: T is TERMINAL_OBJECT
Γ ⊢ X : Object
----------------------------------------------------------------------
Γ ⊢ unique_to_terminal_from(X) : Morphism(X, T) ;
CATEGORY
[[ unique_to_terminal_from(X) ]] = "The unique morphism ! : X → T whose existence is guaranteed by the universal property of the terminal object T." ;

TerminalUniquenessAxiom ::= "AXIOM" "TerminalUniqueness" ":" "FOR_ALL" "f" ":" Identifier "->" Identifier "," "f" "==" UniversalTerminalMorphism ;
TYPING
(* UNIQUENESS (dual): Any morphism into T must be the universal one. *)
Context: T is TERMINAL_OBJECT
Γ ⊢ f : Morphism(X,T)
------------------------------------------------------------------------------------
Γ ⊢ (f == unique_to_terminal_from(X)) : ProvableEquality ;
CATEGORY
[[ AXIOM TerminalUniqueness ... ]] = "The coherence law for terminality. It collapses the hom-set Hom(X, T) to a singleton, enforcing the uniqueness of the map to T." ;

(* ========================================================================================================== )
( == Part 2: Properties and Relation to General Limits == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "InitialObjectsAreIsomorphic" ":"
"(" Identifier "is INITIAL_OBJECT" "&&" Identifier "is INITIAL_OBJECT" ")" "==>" "(" Identifier "≅" Identifier ")" ;
TYPING
(* Proof Sketch: If I and J are initial, there is a unique map f:I->J and a unique map g:J->I.
The composite g∘f: I->I must be the unique map from I to itself, which is id_I.
Dually, f∘g = id_J. Thus, I and J are isomorphic. *)
Γ ⊢ I is INITIAL_OBJECT, Γ ⊢ J is INITIAL_OBJECT
---------------------------------------------------
Γ ⊢ (I ≅ J) : Isomorphism ;
CATEGORY
[[ THEOREM InitialObjectsAreIsomorphic ]] = "A proof that any two objects satisfying the universal property of initiality must be uniquely isomorphic. This establishes that 'the' initial object is a well-defined concept." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'TerminalObjectsAreIsomorphic'" "FROM" "THEOREM" "'InitialObjectsAreIsomorphic'" ;
TYPING
(* The exact same logic applies dually, which we can formally derive using our Duality Principle mechanism. *)
Γ ⊢ THEOREM 'InitialObjectsAreIsomorphic' : P_initial
--------------------------------------------------------------------------
Γ ⊢ THEOREM 'TerminalObjectsAreIsomorphic' : (P_initial)^op ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof that any two terminal objects are isomorphic, derived by mechanically applying the duality functor to the proof for initial objects." ;

TheoremDeclaration ::= "THEOREM" "TerminalIsNulllaryProduct" ":"
"(" Identifier "is TERMINAL_OBJECT" ")" "<==>" "(" Identifier "is PRODUCT of" "(" ")" ")" ;
TYPING
(* Proof Sketch: The UMP for a product of an empty family of objects requires that for any object X, there
is a unique morphism u: X -> P. This is precisely the definition of a terminal object. *)
IsTerminal(T) <==> IsLimitOfEmptyDiagram(T)
------------------------------------------------
Γ ⊢ ... : ProvableEquivalence ;
CATEGORY
[[ THEOREM TerminalIsNulllaryProduct ]] = "The formal assertion that the concept of a terminal object and the concept of a nullary (empty) product are identical. This connects the specific definition to the general theory of limits." ;

TheoremDeclaration ::= "THEOREM" "InitialIsNulllaryCoproduct" ":"
"(" Identifier "is INITIAL_OBJECT" ")" "<==>" "(" Identifier "is COPRODUCT of" "(" ")" ")" ;
TYPING
(* The dual argument holds. *)
IsInitial(I) <==> IsColimitOfEmptyDiagram(I)
--------------------------------------------------
Γ ⊢ ... : ProvableEquivalence ;
CATEGORY
[[ THEOREM InitialIsNulllaryCoproduct ]] = "The formal assertion that the concept of an initial object and the concept of a nullary (empty) coproduct are identical. This connects the specific definition to the general theory of colimits." ;
}



(* ========================================================================================================== )
( == Part 1: Defining the Diagram Shapes == )
( ========================================================================================================== )
( Before we can take the (co)limit, we must formalize the shape of the diagram we are taking the (co)limit of. *)

DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" Identifier "from" "{" {MorphismDeclaration} "}" ;
TYPING
Γ ⊢ name : Identifier
∀m ∈ morphisms, Γ ⊢ m : MorphismDeclaration
Graph(morphisms) is connected
--------------------------------------------------
Γ ⊢ DIAGRAM_SHAPE name ... : DiagramShape ;
CATEGORY
[[ DIAGRAM_SHAPE name ... ]] = "The definition of an index category J, which will serve as the shape for a diagram functor D: J -> C." ;

DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "ParallelPair" "from" "{" "f: A->B;" "g: A->B;" "}" ;
DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "Cospan" "from" "{" "f: A->C;" "g: B->C;" "}" ;
DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "Span" "from" "{" "f: C->A;" "g: C->B;" "}" ;

(* ========================================================================================================== )
( == Part 2: The Limit Constructions (Equalizer & Pullback) == )
( ========================================================================================================== *)

EqualizerAsLimit ::= "DEFINE" "Equalizer" "(" Identifier "," Identifier ")" "as" "LIMIT" "of" "DIAGRAM_SHAPE" "ParallelPair" ;
TYPING
(* This asserts that the Equalizer is by definition the limit of a parallel pair. *)
(Γ ⊢ Equalizer(f, g) : Object) ⇔ (Γ ⊢ LIMIT of DIAGRAM_SHAPE ParallelPair on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Equalizer ... ]] = "The formal definition of an equalizer as the limit of the diagram A ⇉ B. This construction universally finds the object E with a map e:E->A that solves the equation f ∘ e = g ∘ e." ;

EqualizerCommutativityAxiom ::= "AXIOM" ":" Expression "∘" Expression "==" Expression "∘" Expression ;
TYPING
(* This axiom states the defining property of the equalizer map e. *)
Context: (E, e) is the Equalizer of (f,g)
-------------------------------------------
Γ ⊢ (f ∘ e) == (g ∘ e) : ProvableEquality ;
CATEGORY
[[ AXIOM: f ∘ e == g ∘ e ]] = "The assertion that the equalizer cone commutes. This is the equation that the equalizer morphism e is constructed to solve." ;

PullbackAsLimit ::= "DEFINE" "Pullback" "(" Identifier "," Identifier ")" "as" "LIMIT" "of" "DIAGRAM_SHAPE" "Cospan" ;
TYPING
(* This asserts that the Pullback is by definition the limit of a cospan. *)
(Γ ⊢ Pullback(f, g) : Object) ⇔ (Γ ⊢ LIMIT of DIAGRAM_SHAPE Cospan on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Pullback ... ]] = "The formal definition of a pullback as the limit of the diagram A → C ← B. This universally constructs the object P (the 'fibered product') and maps p1:P->A, p2:P->B that form a commutative square." ;

PullbackCommutativityAxiom ::= "AXIOM" "PullbackSquare" ":" Expression "∘" "proj" "(" "1" ")" "==" Expression "∘" "proj" "(" "2" ")" ;
TYPING
(* This axiom asserts the commutativity of the pullback square. *)
Context: (P, p1, p2) is the Pullback of (f:A->C, g:B->C)
--------------------------------------------------------
Γ ⊢ (f ∘ p1) == (g ∘ p2) : ProvableEquality ;
CATEGORY
[[ AXIOM PullbackSquare ... ]] = "The assertion that the pullback cone diagram commutes. This square is the canonical example of a commutative diagram in category theory." ;

(* ========================================================================================================== )
( == Part 3: The Colimit Constructions (The Duals: Coequalizer & Pushout) == )
( ========================================================================================================== *)

CoequalizerAsColimit ::= "DEFINE" "Coequalizer" "(" Identifier "," Identifier ")" "as" "COLIMIT" "of" "DIAGRAM_SHAPE" "ParallelPair" ;
TYPING
(* The dual: the Coequalizer is the COLIMIT of the same parallel pair diagram. *)
(Γ ⊢ Coequalizer(f, g) : Object) ⇔ (Γ ⊢ COLIMIT of DIAGRAM_SHAPE ParallelPair on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Coequalizer ... ]] = "The formal definition of a coequalizer as the colimit of the diagram A ⇉ B. This construction universally finds the object Q with a map q:B->Q that solves the equation q ∘ f = q ∘ g." ;

CoequalizerCommutativityAxiom ::= "AXIOM" ":" Expression "∘" Expression "==" Expression "∘" Expression ;
TYPING
Context: (Q, q) is the Coequalizer of (f,g)
-------------------------------------------
Γ ⊢ (q ∘ f) == (q ∘ g) : ProvableEquality ;
CATEGORY
[[ AXIOM: q ∘ f == q ∘ g ]] = "The assertion that the coequalizer cocone commutes. This is the property the coequalizer morphism q is constructed to satisfy." ;

PushoutAsColimit ::= "DEFINE" "Pushout" "(" Identifier "," Identifier ")" "as" "COLIMIT" "of" "DIAGRAM_SHAPE" "Span" ;
TYPING
(* The dual: the Pushout is the COLIMIT of the dual diagram shape, the Span. *)
(Γ ⊢ Pushout(f, g) : Object) ⇔ (Γ ⊢ COLIMIT of DIAGRAM_SHAPE Span on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Pushout ... ]] = "The formal definition of a pushout as the colimit of the diagram A ← C → B. This universally constructs the object P (the 'amalgamated sum') and maps i1:A->P, i2:B->P that form a commutative square." ;

PushoutCommutativityAxiom ::= "AXIOM" "PushoutSquare" ":" "inj" "(" "1" ")" "∘" Expression "==" "inj" "(" "2" ")" "∘" Expression ;
TYPING
Context: (P, i1, i2) is the Pushout of (f:C->A, g:C->B)
----------------------------------------------------
Γ ⊢ (i1 ∘ f) == (i2 ∘ g) : ProvableEquality ;
CATEGORY
[[ AXIOM PushoutSquare ... ]] = "The assertion that the pushout cocone diagram commutes." ;

}

(* ========================================================================================================== )
( == Part 1: The Building Blocks (Diagrams and Cones) == )
( ========================================================================================================== *)

DiagramDeclaration ::= "DIAGRAM" Identifier "is" "Functor" "(" Identifier "->" Identifier ")" ;
TYPING
(* A Diagram D in a category C is formally just a functor from a (usually small) index category J to C. *)
Γ ⊢ D : Identifier, Γ ⊢ J : Category, Γ ⊢ C : Category
-----------------------------------------------------------------
Γ ⊢ DIAGRAM D is Functor(J -> C) : Diagram(J,C) ;
CATEGORY
[[ DIAGRAM D is Functor(J -> C) ]] = "The definition of a diagram D, which selects a pattern of objects and morphisms (the image of J) within a category C over which a limit or colimit can be computed." ;

ConeDeclaration ::= "CONE" Identifier "over" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(*
* A cone over a diagram D consists of an apex object A and a family of "leg" morphisms p_j
* for each object j in the diagram's shape J. These legs must be coherent with the
* diagram's own morphisms, meaning the defining triangle must commute.
)
Γ ⊢ D : Diagram(J,C), Γ ⊢ A : Object_in(C)
∀j ∈ Ob(J), Γ ⊢ p_j : Morphism(A, D(j))
∀(f: j -> k) ∈ Mor(J), Γ ⊢ (D(f) ∘ p_j == p_k) : ProvableEquality ( Coherence Condition *)
--------------------------------------------------------------------------------------
Γ ⊢ CONE cone_id over D is { Apex: A, ... } : Cone(D) ;
CATEGORY
[[ CONE ... over D ]] = "A cone is a potential candidate for a limit. It is an object A (the apex) equipped with a compatible family of morphisms (the legs) into the diagram D. Compatibility means all triangles A -> D(j) -> D(k) commute." ;

(* ========================================================================================================== )
( == Part 2: The Universal Structure (The Category of Cones) == )
( ========================================================================================================== *)

CategoryOfCones ::= "ConeCategory" "(" Identifier ")" ;
TYPING
(*
* For any diagram D, we can form a new category whose objects are cones over D and
* whose morphisms are structure-preserving maps between the apexes of cones.
*)
Γ ⊢ D : Diagram(J,C)
Objects(ConeCategory(D)) := {c | Γ ⊢ c : Cone(D)}
Morphisms(ConeCategory(D), from:c' to:c) := {u | Γ ⊢ u : Morphism(Apex(c'), Apex(c)) and u is a ConeMorphism }
--------------------------------------------------------------------------------------
Γ ⊢ ConeCategory(D) : Category ;
CATEGORY
[[ ConeCategory(D) ]] = "The category Cone(D,C) whose objects are all cones over the diagram D in C, and where a morphism between two cones (A', {p'_j}) and (A, {p_j}) is a morphism u: A' -> A such that p_j ∘ u = p'_j for all objects j in the index category J." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition (Limit as a Terminal Object) == )
( ========================================================================================================== *)

LimitAsTerminalInConeCategory ::= "LIMIT" "of" Identifier "is" "TERMINAL_OBJECT" "in" CategoryOfCones ;
TYPING
(*
* This is the master definition. A limit of a diagram D is precisely the terminal object
* in the category of all cones over D. The universal property of this terminal object
* (a unique morphism from any other object) is exactly the universal property of the limit cone
* (a unique mediating morphism from any other cone).
*)
Γ ⊢ D : Diagram(J,C)
Γ ⊢ L_cone : Cone(D)
IsTerminal(L_cone, ConeCategory(D))
----------------------------------------------------------------
Γ ⊢ (Apex(L_cone) is LIMIT of D) : ProvableProposition ;
CATEGORY
[[ LIMIT of D is TERMINAL_OBJECT in ConeCategory(D) ]] = "The fundamental definition of a limit as a universal cone. This asserts that the limit cone L is 'best' because for any other cone C over D, there exists a unique morphism from C to L in the ConeCategory. This single statement elegantly captures both the existence and uniqueness of the mediating morphism." ;

(* ========================================================================================================== )
( == Part 4: The Dual Theory (Colimits) == )
( ========================================================================================================== *)

CoconeDeclaration ::= "COCONE" Identifier "from" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(* Dual to Cone: arrows go from the diagram to the apex. )
Γ ⊢ D : Diagram(J,C), Γ ⊢ A : Object_in(C)
∀j ∈ Ob(J), Γ ⊢ p_j : Morphism(D(j), A)
∀(f: j -> k) ∈ Mor(J), Γ ⊢ (p_k ∘ D(f) == p_j) : ProvableEquality ( Coherence Condition *)
--------------------------------------------------------------------------------------
Γ ⊢ COCONE ... : Cocone(D) ;
CATEGORY
[[ COCONE ... from D ]] = "A candidate for a colimit. It is an object A (the apex) equipped with a compatible family of morphisms (the legs) from the diagram D." ;

CategoryOfCocones ::= "CoconeCategory" "(" Identifier ")" ;
TYPING
Γ ⊢ D : Diagram(J,C)
------------------------------------------------
Γ ⊢ CoconeCategory(D) : Category ;
CATEGORY
[[ CoconeCategory(D) ]] = "The dual category Cocone(D,C), whose objects are all cocones from the diagram D." ;

ColimitAsInitialInCoconeCategory ::= "COLIMIT" "of" Identifier "is" "INITIAL_OBJECT" "in" CategoryOfCocones ;
TYPING
(* The dual of the master definition. *)
Γ ⊢ D : Diagram(J,C)
Γ ⊢ L_cocone : Cocone(D)
IsInitial(L_cocone, CoconeCategory(D))
--------------------------------------------------------------------
Γ ⊢ (Apex(L_cocone) is COLIMIT of D) : ProvableProposition ;
CATEGORY
[[ COLIMIT of D is INITIAL_OBJECT in CoconeCategory(D) ]] = "The fundamental definition of a colimit as a universal cocone, which is precisely the initial object in the category of all cocones from the diagram D." ;

}



(* ========================================================================================================== )
( == Part 1: The Foundational Prerequisite (Smallness) == )
( ========================================================================================================== *)
( A category is "small" if its collection of objects and morphisms are sets, not proper classes. *)
( This is a crucial distinction to avoid set-theoretic paradoxes. *)

CategoryProperty_Small ::= Identifier "is" "SMALL" ;
TYPING
(* This predicate is true if the object and morphism collections are sets. *)
Γ ⊢ C : Category
IsSet(Objects(C))
IsSet(Morphisms(C))
--------------------------------------------------
Γ ⊢ C is SMALL : PropositionAbout(C) ;
CATEGORY
[[ C is SMALL ]] = "A foundational proposition about the size of a category C, asserting that it belongs to the universe of sets. This property is required for C to be used as an index category for limits in the definition of completeness." ;

(* ========================================================================================================== )
( == Part 2: The Object of Quantification (Small Diagrams) == )
( ========================================================================================================== *)
( Completeness quantifies over all "small" diagrams. We must formalize this. *)

SmallDiagramDeclaration ::= "small_diagram" Identifier ":" Identifier "->" Identifier ;
TYPING
(* A small_diagram is a functor whose domain (the index category) is explicitly small. *)
Γ ⊢ D : Functor(J, C)
Γ ⊢ J is SMALL
-------------------------------------------
Γ ⊢ small_diagram D:J->C : SmallDiagram ;
CATEGORY
[[ small_diagram D:J->C ]] = "A diagram D whose shape J is a small category. This is the class of diagrams over which completeness and cocompleteness are defined." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition (Completeness) == )
( ========================================================================================================== *)

CategoryProperty_Complete ::= Identifier "is" "COMPLETE" ;
TYPING
(*
* This is the formal definition. A category C is COMPLETE if for every conceivable small
* diagram D that can be drawn in it, a limit for that diagram exists within C.
* This is a universal quantification over the type SmallDiagram.
*)
Γ ⊢ C : Category
∀ (d : SmallDiagram in C), (HasLimit(d, C))
--------------------------------------------------
Γ ⊢ C is COMPLETE : PropositionAbout(C) ;
CATEGORY
[[ C is COMPLETE ]] = "The global property of a category asserting the existence of limits for all small diagrams. It signifies a rich internal structure, guaranteeing that any coherent system of constraints (a small diagram) has a universal solution (a limit)." ;

(* ========================================================================================================== )
( == Part 4: The Dual Concept (Cocompleteness) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COMPLETE" "IS" "COCOMPLETE" ;
TYPING
(* Adds a new entry to the system's duality dictionary. *)
---
------------------------------------------------------------
(Γ ⊢ (C is COMPLETE)^op) <==> (Γ ⊢ C^op is COCOMPLETE) ;
CATEGORY
[[ DUALITY_MAPPING FOR COMPLETE IS COCOMPLETE ]] = "An enrichment of the duality meta-theory. It formally defines COCOMPLETE as the dual of COMPLETE, allowing the entire theory of completeness to be mechanically dualized to a theory of cocompleteness." ;

CategoryProperty_Cocomplete ::= Identifier "is" "COCOMPLETE" ;
TYPING
(*
* The typing for COCOMPLETE is not defined from scratch but is derived from the Duality Mapping.
* It is equivalent to: ∀ (d : SmallDiagram in C), (HasColimit(d, C))
*)
IsDualOf("COMPLETE")
---------------------------------------------------
Γ ⊢ C is COCOMPLETE : PropositionAbout(C) ;
CATEGORY
[[ C is COCOMPLETE ]] = "The dual global property, asserting the existence of colimits for all small diagrams. It guarantees that any system of components (a small diagram) can be universally assembled into a whole (a colimit)." ;

(* ========================================================================================================== )
( == Part 5: Contextualizing the Property (The Existence Theorem) == )
( ========================================================================================================== *)
( This theorem, from Sec. 2.8, gives completeness its practical power. )

TheoremDeclaration ::= "THEOREM" "CompletenessCriteria" ":"
"(" Identifier "is COMPLETE" ")" "<==>" "(" Identifier "has AllSmallProducts" "&&" Identifier "has AllEqualizers" ")" ;
TYPING
(*
* This theorem provides a powerful, finite check for the property of completeness.
* The property "is COMPLETE" means "has limits for all small diagrams," an infinite number of conditions.
* The right-hand side provides just two sufficient and necessary conditions.
*)
Γ ⊢ C : Category
P1 := (C is COMPLETE)
P2 := (C has all products indexed by small sets) ∧ (C has all equalizers)
---------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CompletenessCriteria ]] = "The fundamental construction theorem for limits. It asserts that to verify the infinite set of conditions for completeness, one only needs to verify two: the existence of all small products (for gathering data) and all equalizers (for imposing constraints). This reduces an infinite problem to a finite, manageable one." ;
}



(* ========================================================================================================== )
( == Part 1: The Formal Statement of the Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CompletenessEquivalenceTheorem" ":"
"(" Identifier "is COMPLETE" ")" "<==>" "(" Identifier "has" "AllProducts" "&&" "AllEqualizers" ")" ;
TYPING
(*
* This theorem provides a powerful, finite check for the property of completeness.
* The property "is COMPLETE" means "has limits for all small diagrams," an infinite number of conditions.
* The right-hand side provides just two sufficient and necessary conditions.
*)
Γ ⊢ C : Category
P1 := (C is COMPLETE)
P2 := (C has all small products) ∧ (C has all equalizers)
---------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CompletenessEquivalenceTheorem ... ]] = "The fundamental construction theorem for limits. It asserts that the ability to form products (to gather all the diagram's data together) and the ability to form equalizers (to enforce all the diagram's coherence laws) is necessary and sufficient to construct a limit for any small diagram shape. This reduces an infinite problem to a finite, manageable one." ;

(* ========================================================================================================== )
( == Part 2: The Constructive Proof as a Grammatical Rule == )
( ========================================================================================================== *)

GeneralLimitConstructor ::= "CONSTRUCT_LIMIT" "of" Identifier "from" "ProductsAndEqualizers" "as" "{"
"STEP 1 (DATA_GATHERING):" ProductOfDiagramObjects ";"
"STEP 2 (LAW_ENCODING):" ParallelMorphismConstruction ";"
"STEP 3 (CONSTRAINT_APPLICATION):" EqualizerAsLimit ";"
"}" ;
TYPING
(*
* This rule does not define a term, but a meta-level proof strategy. It asserts that a limit
* for a diagram D can be constructed by following these three steps.
*)
Γ ⊢ D : Diagram(J, C)
Γ ⊢ P_obj = ProductOfDiagramObjects(D) : Object
Γ ⊢ (alpha, beta) = ParallelMorphismConstruction(D, P_obj) : pair(Morphism)
Γ ⊢ L = Equalizer(alpha, beta) : Object
------------------------------------------------------------------------------------------
Γ ⊢ (L is LIMIT of D) : ProvableProposition ;
CATEGORY
[[ CONSTRUCT_LIMIT D ... ]] = "The formal representation of the standard proof of the limit existence theorem. It is a canonical algorithm for constructing arbitrary limit objects from the simpler primitives of products and equalizers. This makes the theorem's proof a computable process within the logical system." ;

(* ========================================================================================================== )
( == Part 3: Defining the Intermediate Constructions == )
( ========================================================================================================== *)

ProductOfDiagramObjects ::= "Product_over_Objects" "(" Identifier ")" ;
TYPING
(* This is the product over all objects in the diagram D's shape J. P_obj = Π_{j ∈ Ob(J)} D(j) *)
Γ ⊢ D : Diagram(J, C)
-----------------------------------------------------------------
Γ ⊢ Product_over_Objects(D) : Object ;
CATEGORY
[[ Product_over_Objects(D) ]] = "[Step 1 of the proof] The construction of a single large object that holds all the component objects of the diagram D. This object represents the 'raw data' of the limit before any of the diagram's internal constraints (its arrows) are applied." ;

ParallelMorphismConstruction ::= "PARALLEL_MORPHISMS" "(" Identifier "," Identifier ")" "for" Identifier ;
TYPING
(*
* This defines the two crucial parallel morphisms, alpha and beta, that encode the diagram's laws.
* Let P_obj = Π_{j∈J} D(j) and P_mor = Π_{f:j→k ∈J} D(k). Then alpha, beta : P_obj -> P_mor.
* The f-th component of alpha is p_k (the projection to the codomain of f).
* The f-th component of beta is D(f) ∘ p_j (project to the domain of f, then apply the arrow).
*)
Γ ⊢ D : Diagram(J,C), Γ ⊢ P_obj : Product_over_Objects(D)
P_mor = Product_over_Morphisms_Codomains(D)
u_alpha = <{ p_{cod(f)} | f ∈ Mor(J) }>
u_beta = <{ D(f) ∘ p_{dom(f)} | f ∈ Mor(J) }>
---------------------------------------------------------------------
Γ ⊢ PARALLEL_MORPHISMS(u_alpha, u_beta) for D : pair(Morphism(P_obj, P_mor)) ;
CATEGORY
[[ PARALLEL_MORPHISMS ... ]] = "[Step 2 of the proof] The construction of two morphisms that embody the diagram's coherence laws. One morphism (alpha) picks out the 'target' side of each arrow-constraint, while the other (beta) picks out the 'source-then-composed' side. A cone c commutes if and only if alpha ∘ c = beta ∘ c." ;

EqualizerAsLimit ::= "Equalizer" "(" Identifier "," Identifier ")" ;
TYPING
(* This just re-uses the equalizer definition from a previous section. *)
Γ ⊢ alpha, beta : Morphism(A,B)
-------------------------------------------
Γ ⊢ Equalizer(alpha, beta) : Object ;
CATEGORY
[[ Equalizer(alpha, beta) ]] = "[Step 3 of the proof] The application of the equalizer. The equalizer e: L -> P_obj selects exactly those elements of the giant product P_obj for which the two parallel morphisms agree. This enforces all the diagram's laws simultaneously, yielding the true limit object L." ;

(* ========================================================================================================== )
( == Part 4: The Dual Theorem via the Duality Principle == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CocompletenessEquivalenceTheorem'" "FROM" "THEOREM" "'CompletenessEquivalenceTheorem'" ;
TYPING
(*
* By applying the duality principle, we derive the dual theorem for cocompleteness "for free".
* The system applies the duality dictionary:
* - COMPLETE becomes COCOMPLETE.
* - Products become Coproducts.
* - Equalizers become Coequalizers.
*)
Γ ⊢ THEOREM "CompletenessEquivalenceTheorem" : P
P_dual = rewrite(P, DualityMappings)
-----------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "CocompletenessEquivalenceTheorem" : P_dual ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the cocompleteness theorem, derived mechanically by applying the duality functor. It asserts that coproducts and coequalizers are the fundamental building blocks for constructing all possible colimits, providing a finite check for the property of cocompleteness." ;
}


(* ========================================================================================================== )
( == Part 1: Defining the Players (The Functors) == )
( ========================================================================================================== *)

DiagonalFunctorDeclaration ::= "DIAGONAL_FUNCTOR" "Δ" ":" Identifier "->" FunctorCategory ;
TYPING
(*
* The Diagonal Functor Δ takes an object X from a category C and maps it to the
* constant functor Δ_X in the functor category C^J. This constant functor maps
* every object of J to X and every morphism of J to id_X.
*)
Γ ⊢ C : Category, Γ ⊢ C_J = FunctorCategory(J, C)
-----------------------------------------------------
Γ ⊢ DIAGONAL_FUNCTOR Δ : C -> C_J : Functor(C, C_J) ;
CATEGORY
[[ DIAGONAL_FUNCTOR Δ ]] = "The functor Δ: C -> C^J which embeds C into the category of diagrams C^J as the full subcategory of constant diagrams. It is the functorial embodiment of 'making a constant diagram from an object'." ;

ColimitFunctorDeclaration ::= "COLIMIT_FUNCTOR" "colim" ":" FunctorCategory "->" Identifier ;
TYPING
(*
* The Colimit Functor colim is a functor from a diagram category C^J back to the
* base category C. It maps a diagram D to its colimit object. This functor is only
* well-defined (total) if the category C is cocomplete.
*)
Γ ⊢ C_J = FunctorCategory(J, C), Γ ⊢ C : Category
C is COCOMPLETE
--------------------------------------------------------------
Γ ⊢ COLIMIT_FUNCTOR colim : C_J -> C : Functor(C_J, C) ;
CATEGORY
[[ COLIMIT_FUNCTOR colim ]] = "The functor colim: C^J -> C which computes the colimit of every diagram. Its existence is conditional on the cocompleteness of C. It collapses a diagram down to its universal representative object." ;

(* ========================================================================================================== )
( == Part 2: The Key Insight (Cocones as Natural Transformations) == )
( ========================================================================================================== *)

CoconeAsNaturalTransformationAxiom ::= "AXIOM" ":" "SetOfCocones" "(" Identifier "," Identifier ")" "==" "Hom_in_FunctorCat" "(" Identifier "," "Δ" "(" Identifier ")" ")" ;
TYPING
(*
* This axiom formalizes the key representational insight. A cocone from a diagram D to an
* object X is a family of morphisms {g_j: D(j) -> X} such that g_k ∘ D(f) = g_j.
* A natural transformation α: D -> Δ_X is a family of morphisms {α_j: D(j) -> X} such that
* the naturality square id_X ∘ α_j = α_k ∘ D(f) commutes, which simplifies to α_j = α_k ∘ D(f).
* These are the same conditions.
*)
Γ ⊢ D : Functor(J, C), Γ ⊢ X : Object_in(C)
DefinitionOf(SetOfCocones(D, X)) == DefinitionOf(NatTrans(D, Δ(X)))
-------------------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ AXIOM CoconeAsNaturalTransformation... ]] = "The formal assertion of isomorphism between the set of cocones from D to X and the hom-set Hom_CJ(D, ΔX) in the functor category. This provides the crucial bridge, allowing us to replace the language of cocones with the language of natural transformations." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (The Adjunction) == )
( ========================================================================================================== *)

AdjunctionDeclaration ::= "ADJUNCTION" ":" "colim" "⊣" "Δ" ;
TYPING
(*
* This is the master theorem, stating that colim is the left adjoint to Δ.
* The universal property of the colimit states there is a bijection between cocones from D to X
* and morphisms from colim D to X. Using the axiom from Part 2, this is a bijection
* between Hom_CJ(D, ΔX) and Hom_C(colim D, X). This is the definition of an adjunction.
)
P1 := Hom_C(colim(D), X) ≅ SetOfCocones(D, X) ( UMP of colimit )
P2 := SetOfCocones(D, X) ≅ Hom_CJ(D, Δ(X)) ( Axiom from Part 2 *)
----------------------------------------------------------------------
Γ ⊢ Hom_C(colim(D), X) ≅ Hom_CJ(D, Δ(X)) : NaturalIsomorphism ;
CATEGORY
[[ ADJUNCTION: colim ⊣ Δ ]] = "The assertion that the Colimit functor is the left adjoint to the Diagonal functor (colim ⊣ Δ). This natural isomorphism Hom_C(colim D, X) ≅ Hom_CJ(D, ΔX) is the most abstract, powerful, and modern formulation of the universal property of colimits, capturing the UMP for all diagrams and test objects in a single statement." ;

(* ========================================================================================================== )
( == Part 4: Deriving the Dual Theory for Limits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LimitAdjunction'" "FROM" "THEOREM" "'ColimitAdjunction'" ;
TYPING
(*
* By applying the Duality Principle, we derive the entire dual theory for limits.
* The system dualizes the adjunction colim ⊣ Δ, which becomes Δ^op ⊣ colim^op.
* We know that colim^op is lim, and Δ^op is Δ on the opposite category.
* The result is the dual adjunction Δ ⊣ lim. The isomorphism becomes:
* Hom_C(ΔX, D) ≅ Hom_C(X, lim D).
* The left side represents cones from X to D (as per the dual of Part 2's axiom).
* The right side represents morphisms into the limit. This is the UMP for limits.
*)
Γ ⊢ colim ⊣ Δ
(colim ⊣ Δ)^op => (Δ^op ⊣ colim^op) => (Δ ⊣ lim)
------------------------------------------------------------
Conclusion: We have now proven that Δ is the left adjoint to lim (Δ ⊣ lim). ;
CATEGORY
[[ INFER_DUAL_THEOREM 'LimitAdjunction' ... ]] = "A constructive proof of the main theorem for limits, derived by a mechanical application of the Duality Principle. It asserts that the Diagonal functor is the left adjoint to the Limit functor (Δ ⊣ lim). This yields the natural isomorphism Hom_C(X, lim D) ≅ Hom_CJ(ΔX, D), which is the abstract formulation of the universal property of limits." ;

}



(* ========================================================================================================== )
( == Part 1: Preservation of Limits (Continuity) == )
( ========================================================================================================== )
( A functor preserves limits if it maps limit cones to limit cones. It's "continuous". *)

FunctorProperty ::= Identifier "preserves" "LIMITS" ;
TYPING
(*
* The formal definition of preservation: For any diagram in the source category C that has a limit,
* the functor F applied to that limit cone results in a limit cone in the target category D.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Diagram Diag in C), ( (LimitCone(c, Diag) in C) ⇒ (LimitCone(F(c), F(Diag)) in D) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F preserves LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F preserves LIMITS ]] = "The property of a functor F being continuous. It takes diagrams and their limits in C to diagrams and their limits in D. This is the most fundamental notion of a functor being 'compatible' with the limit structure of its domain." ;

(* ========================================================================================================== )
( == Part 2: Reflection of Limits (Conservativity) == )
( ========================================================================================================== )
( A functor reflects limits if, upon seeing a limit cone in its target, it can conclude the )
( source must also have been a limit cone. It is "conservative" about structure. *)

FunctorProperty ::= Identifier "reflects" "LIMITS" ;
TYPING
(*
* The formal definition of reflection: For any cone in C, if its image under F is a limit
* cone in D, then the original cone must have been a limit cone in C.
* This is the converse implication of preservation.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Cone c over Diag in C), ( (LimitCone(F(c), F(Diag)) in D) ⇒ (LimitCone(c, Diag) in C) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F reflects LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F reflects LIMITS ]] = "The property of a functor F being conservative. It doesn't necessarily create limits, but it reliably 'detects' them. If the image F(c) has the universal property of a limit, the functor is faithful enough to the structure to guarantee that c already had that property." ;

(* ========================================================================================================== )
( == Part 3: Creation of Limits (The Strongest Property) == )
( ========================================================================================================== )
( A functor creates limits if it not only reflects them, but provides a unique lift. *)

FunctorProperty ::= Identifier "creates" "LIMITS" ;
TYPING
(*
* The formal definition of creation: For any diagram in C whose image under F has a limit in D,
* there exists a unique cone in C which is a limit cone, AND this cone is mapped by F to the
* limit cone in D.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Diagram Diag in C),
( (HasLimit(F(Diag)) in D) ⇒ (∃! Cone c in C s.t. LimitCone(c, Diag) ∧ F(c) ≅ Limit(F(Diag))) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F creates LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F creates LIMITS ]] = "The strongest of the three properties. The functor F not only reflects limits but guarantees their existence and uniqueness in its domain based on their existence in the codomain. This is a crucial property for forgetful functors from categories of algebras (like Grp -> Set) and slice categories." ;

(* ========================================================================================================== )
( == Part 4: Key Interrelationships and Examples == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CreationImpliesReflection" ":"
"FOR_ALL" "functor" "F" "," "(" "F creates LIMITS" ")" "==>" "(" "F reflects LIMITS" ")" ;
TYPING
(* Proof sketch: If F creates limits and F(c) is a limit cone, then there exists a unique
* limit cone c' in C such that F(c') is a limit cone. By uniqueness of limits, F(c) must be
* isomorphic to F(c'), which implies c is isomorphic to c'. Thus c is a limit cone.
*)
IsProvable(Proposition)
-------------------------------------
Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
[[ THEOREM CreationImpliesReflection ]] = "The assertion of a strict hierarchy of properties. Creation is a stronger condition than reflection. Any functor that can create limits is necessarily conservative." ;

TheoremDeclaration ::= "THEOREM" "IsomorphismsOfCategoriesReflectLimits" ":"
"FOR_ALL" "functor" "F" "," "(" "F is an IsomorphismOfCategories" ")" "==>" "(" "F reflects LIMITS" ")" ;
TYPING
(* Functors that are part of an isomorphism (or more generally, an equivalence) of categories
are extremely well-behaved and reflect all structures. *)
Γ ⊢ F : IsomorphismOfCategories(C,D)
-----------------------------------------
Γ ⊢ F reflects LIMITS : ProvableProposition ;
CATEGORY
[[ THEOREM IsomorphismsOfCategoriesReflectLimits ]] = "An assertion that structurally equivalent categories are indistinguishable from the point of view of their limit structures. An isomorphism is the canonical example of a conservative functor." ;

TheoremDeclaration ::= "THEOREM" "RightAdjointsPreserveLimits" ":"
"FOR_ALL" "functor" "F" "," "(" "F is a Right Adjoint Functor" ")" "==>" "(" "F preserves LIMITS" ")" ;
TYPING
IsRightAdjoint(F)
----------------------
Γ ⊢ F preserves LIMITS : ProvableProposition ;
CATEGORY
[[ THEOREM RightAdjointsPreserveLimits ]] = "The most important source of continuous functors. Any functor that is a right adjoint must preserve all limits that exist in its domain. Dually, all left adjoints preserve colimits. This provides a powerful tool for proving continuity." ;

}

(* ========================================================================================================== )
( == Part 1: The Prerequisite - Preservation by a Single Functor == )
( ========================================================================================================== *)

PreservationPredicate ::= Identifier "preserves" "COLIMIT" "of" Identifier ;
TYPING
(*
* This predicate asserts that a specific functor F maps a specific colimit cocone in C
* to a colimit cocone in D.
*)
Γ ⊢ F : Functor(C,D)
Γ ⊢ L_cocone is COLIMIT of Diagram D in C
------------------------------------------------------------------------------------------
Γ ⊢ (F preserves COLIMIT of D) is TRUE ⇔ (F(L_cocone) is COLIMIT of (F ∘ D) in D) ;
CATEGORY
[[ F preserves COLIMIT of D ]] = "The proposition that the functor F is continuous with respect to the diagram D. It is a statement about a functor preserving a specific algebraic structure present in its domain." ;

(* ========================================================================================================== )
( == Part 2: The Abstract Definition - Absoluteness == )
( ========================================================================================================== *)

AbsoluteColimitDefinition ::= Identifier "is" "ABSOLUTE_COLIMIT" "of" Identifier ;
TYPING
(*
* An object L is the apex of an absolute colimit cocone if it is a colimit cocone, AND
* this structure is preserved by ALL functors originating from the category C.
* This is a universal quantification over functors.
*)
Γ ⊢ L_cocone is COLIMIT of D
∀ (Category D_prime), ∀ (Functor F : C -> D_prime), (F preserves colimit of D)
-----------------------------------------------------------------------------
Γ ⊢ L_cocone is ABSOLUTE_COLIMIT of D : Proposition ;
CATEGORY
[[ L_cocone is ABSOLUTE_COLIMIT of D ]] = "The property of a colimit cocone to be so structurally robust that its universal property holds even after being mapped by any functor into any other category. This implies the colimit is defined by an algebraic structure internal to C, not just by its external relationships." ;

(* ========================================================================================================== )
( == Part 3: The Concrete Condition - Split Coequalizers == )
( ========================================================================================================== *)

SplitCoequalizerCocone ::= Identifier "is" "SPLIT_COEQUALIZER_COCONE" "for" "(" Identifier "," Identifier ")" ;
TYPING
(*
* A cocone (q: B -> Q) for a parallel pair (f,g: A->B) is a SPLIT coequalizer cocone if
* it satisfies the coequalizer equation AND the morphism q is a split epimorphism,
* meaning it has a right-inverse (a section).
)
Γ ⊢ q : Morphism(B, Q), Γ ⊢ f : Morphism(A, B), Γ ⊢ g : Morphism(A, B)
(q ∘ f == q ∘ g) ( Condition 1: It coequalizes the pair. )
(q is SPLIT_EPIMORPHISM) ( Condition 2: It has an explicit algebraic "splitting". *)
--------------------------------------------------------------------------------
Γ ⊢ q is SPLIT_COEQUALIZER_COCONE for (f, g) : Proposition ;
CATEGORY
[[ q is SPLIT_COEQUALIZER_COCONE ... ]] = "A coequalizer cocone whose universality is not merely abstract but is constructively witnessed by a section s: Q -> B such that q ∘ s = id. This explicit algebraic witness is the source of its universal stability." ;

(* ========================================================================================================== )
( == Part 4: The Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AbsoluteColimitsAreSplit" ":"
"(" Identifier "is" "ABSOLUTE_COLIMIT" "of" DiagramShape_ParallelPair ")"
"<==>"
"(" Identifier "is" "SPLIT_COEQUALIZER_COCONE" ")" ;
TYPING
(* A colimit of a parallel pair is absolute if and only if it is a split coequalizer cocone. *)
Context: D is a parallel pair (f,g). C is the colimit cocone for D.
P1 := (C is ABSOLUTE_COLIMIT of D)
P2 := (C is SPLIT_COEQUALIZER_COCONE for (f,g))
-----------------------------------------------------
IsProvable(P1 <==> P2) ;
CATEGORY
[[ THEOREM AbsoluteColimitsAreSplit ]] = "The assertion of a foundational equivalence. It states that the abstract, universal property of being preserved by all functors is precisely the same as the concrete, algebraic property of being a split coequal-izer. This theorem provides a powerful, checkable criterion for the very strong property of absoluteness." ;

}



(* ========================================================================================================== )
( == Part 1: Deconstructing the Definition of a Filtered Category == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "FILTERED" ;
TYPING
(*
* The full definition of a filtered category J requires three conditions to be met,
* which we formalize here as separate propositonal checks.
*)
Γ ⊢ J : Category
IsNonEmpty(J)
∧ HasUpperBoundsForObjects(J)
∧ HasEqualizingMorphisms(J)
-------------------------------------------
Γ ⊢ J is FILTERED : PropositionAbout(J) ;
CATEGORY
[[ J is FILTERED ]] = "The property of an index category J being 'richly connected' in a forward-looking manner. This generalizes the notion of a directed set and is the categorical foundation for direct limits in algebra." ;

CategoryPropertyAxiom ::= "AXIOM" ("UpperBoundsForObjects" | "EqualizingMorphisms") "in" Identifier ;
TYPING
Γ ⊢ J : Category
CASE "UpperBoundsForObjects":
∀ (j1, j2 ∈ Ob(J)), ∃ (k ∈ Ob(J), f:j1->k, g:j2->k)
CASE "EqualizingMorphisms":
∀ (f,g : j1 -> j2 ∈ Mor(J)), ∃ (h : j2 -> k ∈ Mor(J)) s.t. (h ∘ f == h ∘ g)
------------------------------------------------------------------
Γ ⊢ AXIOM ... in J : PropositionAbout(J) ;
CATEGORY
[[ AXIOM UpperBoundsForObjects in J ]] = "The 'meet-me-later' property for objects. It guarantees that any two objects in the category can eventually be connected by arrows to a common successor object." ;
[[ AXIOM EqualizingMorphisms in J ]] = "The 'we'll-agree-later' property for morphisms. It guarantees that any disagreement between two parallel arrows can eventually be resolved (equalized) by composing them with a future arrow." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem on Filtered Colimits in Set == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "FINITE" ;
TYPING
(* A finite category is a small category with a finite set of objects and morphisms. *)
Γ ⊢ J : Category, J is SMALL
|Objects(J)| is finite ∧ |Morphisms(J)| is finite
--------------------------------------------------
Γ ⊢ J is FINITE : PropositionAbout(J) ;
CATEGORY
[[ J is FINITE ]] = "The property of an index category J being small in the strongest sense. This is the shape required for a 'finite limit'." ;

TheoremDeclaration ::= "THEOREM" "FilteredColimitsCommuteWithFiniteLimitsInSet" ":"
"IN_CATEGORY" "Set" "," "(" "I is FILTERED" "&&" "J is FINITE" ")" "==>"
"(" "colim_" "I" " lim_" "J" " ≅ " "lim_" "J" " colim_" "I" ")" ;
TYPING
(*
* This theorem formalizes the ability to interchange the order of a filtered colimit and a finite limit
* for any diagram D: I × J -> Set.
*)
Context: Category is Set
Γ ⊢ I is FILTERED
Γ ⊢ J is FINITE
Γ ⊢ D : Functor(I × J, Set)
----------------------------------------------------
Γ ⊢ colim_I(lim_J(D)) ≅ lim_J(colim_I(D)) : Isomorphism ;
CATEGORY
[[ THEOREM ... ]] = "A foundational result in algebra and logic. It establishes that in Set, the process of forming direct limits (filtered colimits) is 'continuous' with respect to finite algebraic structures (finite limits). For example, the direct limit of a product of groups is the product of their direct limits." ;

(* ========================================================================================================== )
( == Part 3: Deriving the Dual Concepts via Duality == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FILTERED" "IS" "COFILTERED" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COFILTERED" "IS" "FILTERED" ;
TYPING
(* Adds a new entry to the system's duality dictionary. *)
---
---------------------------------------------------------------
(Γ ⊢ (C is FILTERED)^op) <==> (Γ ⊢ C^op is COFILTERED) ;
CATEGORY
[[ DUALITY_MAPPING ... ]] = "An enrichment of the duality meta-theory. It defines the formal dual of the 'filtered' property, allowing for mechanical derivation of dual theorems." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CofilteredLimitsCommuteWithFiniteColimits'" "FROM" "THEOREM" "'FilteredColimitsCommuteWithFiniteLimitsInSet'" ;
TYPING
(*
* We apply the duality operator to the main theorem. The system uses the DualityMapping dictionary:
* 1. "FILTERED" -> "COFILTERED"
* 2. "FINITE" -> "FINITE" (finite is self-dual)
* 3. "colim" -> "lim"
* 4. "lim" -> "colim"
* The result is the exact dual theorem.
*)
Γ ⊢ THEOREM 'Filtered...' : P_filtered_commute
P_cofiltered_commute = rewrite(P_filtered_commute, DualityMappings)
-------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'Cofiltered...' : P_cofiltered_commute ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual commutation theorem, derived mechanically by applying the Duality Principle. It asserts that in Set, cofiltered limits commute with finite colimits, a result obtained 'for free' from the original theorem." ;
}

(* ========================================================================================================== )
( == Part 1: The Formal Structural Definition == )
( ========================================================================================================== )
( Before we can define finality, we need to formalize the comma category used in its definition. *)
OverCommaCategory ::= "(" Identifier "↓" Identifier ")" ;
TYPING
(*
* This defines the comma category of "objects under k via U". This is an instance of the
* general comma category (Δ_k ↓ U), where Δ_k is the constant functor selecting k.
* Its objects are pairs (j, f) where j is an object in U's domain, and f: k -> U(j).
* To check for finality, we only need the dual category, where the arrow is f: U(j) -> k.
* Let's correct this to use the proper comma category for the finality definition.
* The correct comma category for a final functor U:J->K, given k in K, is (k ↓ U) which is not standard.
* The standard definition is (U ↓ k), the comma category of "objects of J over k".
* Let's correct the rule to formalize this standard definition.
*)
Γ ⊢ U : Functor(J, K), Γ ⊢ k : Object_in(K)
--------------------------------------------------
Γ ⊢ (U ↓ k) : Category ;
CATEGORY
[[ (U ↓ k) ]] = "The comma category of objects of J over k. An object in (U ↓ k) is a pair (j, f) where j is an object in J and f: U(j) -> k is a morphism in K." ;
FunctorProperty_Final ::= Identifier "is" "FINAL" ;
TYPING
(*
* This is the local, structural definition of a final functor U.
* It is final if for every object k in its codomain, the comma category (U ↓ k)
* is non-empty and connected.
*)
Γ ⊢ U : Functor(J, K)
∀ k ∈ Objects(K),
( IsNonEmpty(Category("(U ↓ k)")) ∧ IsConnected(Category("(U ↓ k)")) )
-----------------------------------------------------------------------------
Γ ⊢ U is FINAL : PropositionAbout(U) ;
CATEGORY
[[ U is FINAL ]] = "The structural property of a functor U being 'cofinal' or 'sufficiently interwoven' in its codomain. This ensures that its domain J is rich enough to compute colimits on behalf of the entire codomain K." ;
(* ========================================================================================================== )
( == Part 2: The Behavioral Consequence == )
( ========================================================================================================== *)
FunctorBehavior_PreservesColimitsOnPrecomposition ::= Identifier "preserves_colimits_on_precomposition" ;
TYPING
(*
* This defines the desired global behavior. A functor U has this property if for any
* diagram F starting from U's codomain, the colimit of F is the same as the colimit
* of the composite diagram F ∘ U.
*)
Γ ⊢ U : Functor(J, K)
∀ C:Category, ∀ F:Functor(K,C), ( (colimit of F) ≅ (colimit of (F ∘ U)) )
-------------------------------------------------------------------------
Γ ⊢ U preserves_colimits_on_precomposition : PropositionAbout(U) ;
CATEGORY
[[ U preserves_colimits_on_precomposition ]] = "A global, behavioral property of a functor U. It asserts that for the purpose of computing colimits, one can safely restrict any diagram F over K to the potentially smaller domain J via U without changing the result." ;
(* ========================================================================================================== )
( == Part 3: The Equivalence Theorem == )
( ========================================================================================================== *)
TheoremDeclaration ::= "THEOREM" "FinalityEquivalence" ":"
"(" Identifier "is" "FINAL" ")" "<==>" "(" Identifier "preserves_colimits_on_precomposition" ")" ;
TYPING
(* This theorem asserts that the checkable, structural property is logically equivalent to the powerful, behavioral one. *)
Γ ⊢ U : Functor(J, K)
P_structural := (Γ ⊢ U is FINAL)
P_behavioral := (Γ ⊢ U preserves_colimits_on_precomposition)
-----------------------------------------------------------------
Γ ⊢ (P_structural <==> P_behavioral) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FinalityEquivalence ]] = "The assertion that the local, structural property of finality (based on comma categories) is the necessary and sufficient condition for the global, behavioral property of simplifying colimit computations. This theorem is what makes the concept of finality useful, providing a tangible check for an abstract behavior." ;
(* ========================================================================================================== )
( == Part 4: Deriving the Dual Theory of Initial Functors == )
( ========================================================================================================== *)
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FINAL" "IS" "INITIAL" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "INITIAL" "IS" "FINAL" ;
TYPING
---
-------------------------------------------------------
(Γ ⊢ (U is FINAL)^op) <==> (Γ ⊢ U^op is INITIAL) ;
CATEGORY
[[ DUALITY_MAPPING FOR FINAL IS INITIAL ]] = "An enrichment of the meta-theory, defining 'Initial Functor' as the formal dual of 'Final Functor'. This allows the entire theory to be dualized mechanically." ;
DualTheoremInference ::= "INFER_DUAL_THEOREM" "'InitialityEquivalence'" "FROM" "THEOREM" "'FinalityEquivalence'";
TYPING
(*
* By applying the duality operator to the FinalityEquivalence theorem, we derive the entire
* theory for Initial Functors "for free." The system performs these rewrites:
* 1. "FINAL" -> "INITIAL"
* 2. "preserves_colimits_on_precomposition" -> "preserves_limits_on_precomposition"
* 3. Comma category (U ↓ k) -> (k ↓ U)
* 4. "colimit" -> "limit"
* The result is the complete, correct, and dual theory.
*)
Γ ⊢ THEOREM "FinalityEquivalence" : P_final
P_initial = rewrite(P_final, DualityMappings)
-----------------------------------------------
Γ ⊢ THEOREM "InitialityEquivalence" : P_initial ;
CATEGORY
[[ INFER_DUAL_THEOREM 'InitialityEquivalence' ... ]] = "A constructive proof of the main theorem for Initial Functors, derived by a mechanical application of the Duality Principle. It asserts that a functor is Initial (a structural property on comma categories) if and only if it simplifies LIMIT computations (a global behavioral property)." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 2.12: Formalizing Interchange of Limits" ")" "==>" {

(* ========================================================================================================== )
( == Part 1: The Main Theorem on Limit Interchange == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitInterchange" ":"
"IN_CATEGORY" Identifier "C" "where" "C is COMPLETE" ","
"LIMIT_over" "(" Identifier "×" Identifier ")" "of" Identifier "≅"
"LIMIT_iterated" "(" Identifier "," Identifier ")" "of" Identifier ;
TYPING
(*
* This theorem asserts that in a complete category C, the limit over a product-shaped diagram D: I×J -> C
* is naturally isomorphic to the iterated limit. The precondition of completeness is essential, as it
* guarantees the existence of the inner limits needed to even form the iterated limit.
*)
Γ ⊢ C is COMPLETE
Γ ⊢ I, J : Category, Γ ⊢ D : Functor(I × J, C)
LHS := LIMIT of D
RHS := IteratedLimit(I, J, D)
-----------------------------------------------------------------------------------
Γ ⊢ LHS ≅ RHS : Isomorphism ;
CATEGORY
[[ THEOREM LimitInterchange ]] = "The assertion of the Fubini-style theorem for limits. It states that the limit of a product-shaped diagram can be computed by iterated limits. This reflects a fundamental coherence property of the category, showing that its limit structures compose in a predictable way." ;

(* ========================================================================================================== )
( == Part 2: Deconstructing the Iterated Limit Construction == )
( ========================================================================================================== *)

InnerDiagramConstructor ::= "InnerDiagram" "(" "Diagram" Identifier "," "fixed_at" Identifier ")" ;
TYPING
(*
* This is the first step of the iterated construction. It takes a diagram over a product index I×J
* and freezes the first index i, resulting in a new diagram whose shape is just J.
*)
Γ ⊢ D : Functor(I × J, C), Γ ⊢ i : Object_in(I)
-----------------------------------------------------------------
Γ ⊢ InnerDiagram(D, fixed_at i) : Functor(J, C) ;
CATEGORY
[[ InnerDiagram(D, fixed_at i) ]] = "The functor D(i, -): J -> C. This represents 'slicing' the larger product diagram D at a specific index i from the first category." ;

OuterDiagramOfLimitsConstructor ::= "OuterDiagramOfLimits" "(" "Diagram" Identifier ")" ;
TYPING
(*
* This is the second, crucial step. It constructs a new diagram whose shape is I.
* For each object i in I, it computes the limit of the corresponding InnerDiagram.
* The universal property of limits ensures that this mapping can be extended to morphisms,
* resulting in a well-defined functor L: I -> C.
*)
Γ ⊢ D : Functor(I × J, C)
Context: Domain(D) is I × J. Category C is COMPLETE.
------------------------------------------------------------------------------------------------
Γ ⊢ OuterDiagramOfLimits(D) : Functor(I, C) where L(i) = lim(InnerDiagram(D, i)) ;
CATEGORY
[[ OuterDiagramOfLimits(D) ]] = "The diagram L:I->C formed by taking limits over the second variable j for each fixed i. This is the diagram whose limit constitutes the result of the iterated procedure." ;

IteratedLimitDefinitionAxiom ::= "AXIOM" "IteratedLimitDefinition" ":"
"LIMIT_iterated" "(" Identifier "," Identifier ")" "of" Identifier
"==" "LIMIT" "of" OuterDiagramOfLimitsConstructor ;
TYPING
(*
* This axiom provides the formal definition for our "LIMIT_iterated" convenience syntax.
* It states that the iterated limit is, by definition, the limit of the diagram of inner limits.
*)
Γ ⊢ D : Functor(I × J, C)
-----------------------------------------------------------------------------------------------
(Γ ⊢ LIMIT_iterated(I,J) of D) <==> (Γ ⊢ LIMIT of (OuterDiagramOfLimits(D))) ;
CATEGORY
[[ AXIOM IteratedLimitDefinition ... ]] = "A definitional equivalence that unpacks the iterated limit construction. It makes the two-step process of (1) forming a diagram of inner limits and (2) taking the limit of that new diagram explicit within the formal grammar." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theorem for Colimits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'ColimitInterchange'" "FROM" "THEOREM" "'LimitInterchange'" ;
TYPING
(*
* By applying the Duality Principle, we obtain the dual theorem for cocomplete categories "for free."
* The system applies the duality dictionary:
* - COMPLETE becomes COCOMPLETE.
* - LIMIT becomes COLIMIT.
*)
Γ ⊢ THEOREM "LimitInterchange" : P_lim
P_colim = rewrite(P_lim, DualityMappings)
-------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "ColimitInterchange" : P_colim ;
CATEGORY
[[ INFER_DUAL_THEOREM 'ColimitInterchange' ... ]] = "A constructive proof of the Fubini-style theorem for colimits, derived mechanically by applying the duality functor. It asserts that in a cocomplete category, iterated colimits can be interchanged, a result obtained systematically from the theory of limits." ;

}


(* ========================================================================================================== )
( == Part 1: Defining the Players of the Pointwise World == )
( ========================================================================================================== *)

FunctorCategoryDeclaration ::= "FUNCTOR_CATEGORY" Identifier "->" Identifier ;
TYPING
Γ ⊢ J : Category, Γ ⊢ C : Category
----------------------------------------------------------------------
Γ ⊢ (J -> C) : Category ; (* This is C^J, or [J,C] *)
CATEGORY
[[ J -> C ]] = "The category C^J whose objects are functors from J to C and whose morphisms are natural transformations between these functors." ;

DiagramOfFunctorsDeclaration ::= "DIAGRAM_OF_FUNCTORS" Identifier ":" Identifier "->" FunctorCategoryDeclaration ;
TYPING
(* This is a diagram whose points are themselves diagrams. D: I -> C^J *)
Γ ⊢ I : Category, Γ ⊢ C_J : FunctorCategory
-----------------------------------------------------
Γ ⊢ DIAGRAM_OF_FUNCTORS ... : Functor(I, C_J) ;
CATEGORY
[[ DIAGRAM_OF_FUNCTORS D:I -> (J->C) ]] = "A diagram in the functor category. For each index object i in I, D(i) is a functor from J to C. For each arrow in I, D assigns a natural transformation." ;

EvaluationFunctor ::= "ev" "_" Identifier ;
TYPING
(* This functor is the formal mechanism for "evaluating at a point j". *)
Γ ⊢ C_J = FunctorCategory(J, C)
Γ ⊢ j : Object_in(J)
----------------------------------------------------------
Γ ⊢ ev_j : Functor(C_J, C) ;
CATEGORY
[[ ev_j ]] = "The evaluation functor at j. It is the projection ev_j : C^J → C that sends a functor F:J->C to its value F(j) and a natural transformation α:F=>G to its component α_j:F(j)->G(j)." ;

(* ========================================================================================================== )
( == Part 2: Constructing the Diagram of Points == )
( ========================================================================================================== *)

DiagramOfPointsConstructor ::= "PointwiseDiagram" "(" Identifier "," "at" ":" Identifier ")" ;
TYPING
(*
* This constructor formalizes the right-hand side of the pointwise theorem. It takes a diagram
* of functors D and an evaluation point j, and composes D with ev_j to produce a
* simple diagram of points in the base category C.
)
Γ ⊢ D : DiagramOfFunctors(I -> (J->C))
Γ ⊢ j : Object_in(J)
ev_j = EvaluationFunctor(at: j)
------------------------------------------------------------------------------------------
Γ ⊢ PointwiseDiagram(D, at:j) : Diagram(I -> C) ( This is the composition ev_j ∘ D *) ;
CATEGORY
[[ PointwiseDiagram(D, at:j) ]] = "The diagram of points obtained by evaluating each functor D(i) in the original diagram D at the specific point j. This transforms a diagram of diagrams into a simple diagram in the base category, ready for a standard limit computation." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem and its Dual == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitsInFunctorCategoriesArePointwise" ":"
"FOR_ALL" DiagramOfFunctorsDeclaration "D" ","
"(" "L" "is" "LIMIT" "of" "D" ")" "==>"
"(" "FOR_ALL" "point" "j" "," "(ev_j(L) ≅ LIMIT of PointwiseDiagram(D, at: j))" ")" ;
TYPING
(* This is the formal typing of the famous isomorphism: L(j) ≅ lim(D_i(j)) )
Context: All necessary limits exist.
Γ ⊢ D : Functor(I, C^J)
Γ ⊢ L = lim(D) : Object_in(C^J) ( L is a functor J->C *)
-----------------------------------------------------------------
∀j ∈ Ob(J), Γ ⊢ L(j) ≅ lim(PointwiseDiagram(D, at:j)) ;
CATEGORY
[[ THEOREM LimitsInFunctorCategoriesArePointwise ]] = "The fundamental theorem of limits in functor categories. It asserts that to compute a complex limit L (which is a functor), one can instead compute a series of simpler limits in the base category C for each 'point' j in J. The resulting collection of limit points assembles into the limit functor L." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LimitsInFunctorCategoriesArePointwise" "IS" "ColimitsInFunctorCategoriesArePointwise" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'ColimitsInFunctorCategoriesArePointwise'" "FROM" "THEOREM" "'LimitsInFunctorCategoriesArePointwise'" ;
TYPING
(*
* By applying the Duality Principle, we derive the dual theorem for colimits.
* The system applies the duality dictionary:
* - LIMIT becomes COLIMIT.
* The structure of the argument remains identical, proving that colimits are also computed pointwise.
*)
Γ ⊢ THEOREM "LimitsInFunctorCategoriesArePointwise" : P_lim
P_colim = rewrite(P_lim, DualityMappings)
-----------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "ColimitsInFunctorCategoriesArePointwise" : P_colim ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the pointwise nature of colimits in functor categories, derived mechanically by applying the duality functor to the theorem for limits. This demonstrates the symmetry of the principle and the power of formal duality." ;

}



(* ========================================================================================================== )
( == Part 1: Defining the Players (Slice Category and Forgetful Functor) == )
( ========================================================================================================== *)
SliceCategoryDeclaration ::= "CATEGORY" "Slice" "(" Identifier "," Identifier ")" ;
TYPING
(* Defines the slice category C/X. *)
Γ ⊢ C : Category, Γ ⊢ X : Object_in(C)
-------------------------------------------
Γ ⊢ CATEGORY Slice(C, X) : Category ;
CATEGORY
[[ CATEGORY Slice(C, X) ]] = "The slice category C/X. Its objects are pairs (A, f) where A is an object in C and f: A -> X is a morphism in C. Its morphisms from (A,f) to (B,g) are morphisms h:A->B in C such that g ∘ h = f (i.e., the triangle commutes)." ;
ForgetfulFunctor_Slice ::= "U_slice" "(" Identifier "," Identifier ")" ;
TYPING
(* Defines the forgetful functor U : C/X -> C. *)
Γ ⊢ C/X = Slice(C, X) : Category
-------------------------------------------------
Γ ⊢ U_slice(C, X) : Functor(C/X, C) ;
CATEGORY
[[ U_slice(C, X) ]] = "The forgetful functor U from the slice category C/X to the base category C. It maps an object (A,f) to its underlying object A, and a morphism h (a commuting triangle) to the underlying morphism h. It 'forgets' the arrow to X and the commutativity constraint." ;
(* ========================================================================================================== )
( == Part 2: Formalizing the Key Property (Creation of Limits) == )
( ========================================================================================================== *)
FunctorProperty ::= Identifier "creates" "LIMITS" ;
TYPING
(*
* This defines the property of "creating" limits, which is stronger than reflection.
* It means that for any diagram D in A, if its image U∘D has a limit L in B,
* then there must exist a unique limit cone L' for D in A that U maps onto L.
*)
Γ ⊢ U : Functor(A, B)
Condition := ∀ (Diagram D:J->A), ( (L = lim(U∘D) in B) ⇒ ∃! (L' = lim(D) in A) s.t. U(L') ≅ L )
--------------------------------------------------------------------------------------------------
Γ ⊢ U creates LIMITS : PropositionAbout(U) ;
CATEGORY
[[ U creates LIMITS ]] = "The property of a functor U to not only preserve and reflect limits but to guarantee the existence and uniqueness of a 'lifted' limit in its domain whenever a limit exists for the image in the codomain. This is a powerful structural guarantee." ;
(* ========================================================================================================== )
( == Part 3: The Main Theorem == )
( ========================================================================================================== *)
TheoremDeclaration ::= "THEOREM" "SliceFunctorCreatesLimits" ":"
"IF" "(" Identifier "C" "is COMPLETE" ")" "THEN" "(" "U_slice" "(" "C" "," Identifier "X" ")" "creates" "LIMITS" ")" ;
TYPING
(*
* This is the central theorem. It states that the 'niceness' (completeness) of the base
* category C endows the forgetful functor from any of its slices with the powerful
* property of creating limits.
*)
P1 := (Γ ⊢ C is COMPLETE)
P2 := (Γ ⊢ U_slice(C, X) creates LIMITS)
-----------------------------------------
Γ ⊢ (P1 ==> P2) : ProvableImplication ;
CATEGORY
[[ THEOREM SliceFunctorCreatesLimits ]] = "The fundamental theorem on the structure of slice categories. It asserts that the existence of all limits in a category C is a sufficient condition to guarantee that the forgetful functor from any of its slice categories C/X creates all limits. The proof involves constructing the apex of the limit cone in C/X and showing it is unique." ;
(* ========================================================================================================== )
( == Part 4: The Practical Corollary == )
( ========================================================================================================== *)
CorollaryDeclaration ::= "COROLLARY" "CompletenessOfSlice" "to" "SliceFunctorCreatesLimits" ":"
"(" Identifier "C" "is COMPLETE" ")" "==>" "(" "Slice" "(" "C" "," Identifier "X" ")" "is COMPLETE" ")" ;
TYPING
(*
* This corollary is a direct consequence of the main theorem and the definition of creation.
* If a functor U:A->B creates limits and its codomain B is complete, its domain A must be complete.
)
Γ ⊢ C is COMPLETE
Γ ⊢ U_slice(C,X) creates LIMITS ( Premise from Theorem *)
-----------------------------------------------------------------
Γ ⊢ Slice(C,X) is COMPLETE : ProvableProposition ;
CATEGORY
[[ COROLLARY CompletenessOfSlice ... ]] = "The practical and important consequence of the main theorem: the property of completeness is inherited by all of a category's slice categories. If C has all limits, then C/X does as well." ;
(* ========================================================================================================== )
( == Part 5: Deriving the Dual Theory for Coslice Categories == )
( ========================================================================================================== *)
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "SliceCategory" "IS" "CosliceCategory" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "creates LIMITS" "IS" "creates COLIMITS" ;
DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CosliceCocompleteness'" "FROM" "THEOREM" "'SliceFunctorCreatesLimits'" "and its corollary" ;
TYPING
(*
* By applying the Duality Principle, we mechanically derive the entire theory for Coslice categories.
* The system applies the dictionary:
* - Slice(C,X) becomes Coslice(C,X) (the category X\C).
* - COMPLETE becomes COCOMPLETE.
* - creates LIMITS becomes creates COLIMITS.
* The result is the complete dual theory.
*)
Γ ⊢ THEOREM "SliceFunctorCreatesLimits" and its Corollary
P_dual = rewrite(AllPropositions, DualityMappings)
----------------------------------------------------------
Conclusion: We have now proven the dual theorems:
1. IF C is COCOMPLETE THEN U_coslice: X\C -> C creates COLIMITS.
2. IF C is COCOMPLETE THEN X\C is COCOMPLETE. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the main theorem and corollary for coslice categories, derived mechanically by applying the duality functor. This demonstrates that cocompleteness is inherited by all coslice categories via a forgetful functor that creates colimits, a result obtained 'for free' from the original theorem." ;

