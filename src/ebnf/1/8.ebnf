MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 8: 'Internal category theory', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.1: Internal categories and functors" ")" "==>" {
(*

ELABORATION: To provide a deeper, more concrete elaboration of an internal category, we will
instantiate the abstract definition with the most fundamental and clarifying example: a monoid
viewed as a category with one object, internal to the category Set.

This process will show how the abstract components of the InternalCategoryDataDeclaration
(object of objects, object of morphisms, structure morphisms in E) map directly to concrete,
familiar concepts (a singleton set, the monoid's elements, the identity and multiplication functions).
Crucially, it will demonstrate how the abstract InternalCategoryAxioms (requiring commuting
diagrams in the ambient category E) become precisely the familiar equational axioms that define a monoid.

This example makes the power of internalization tangible: it's a machine for exporting concepts
from the well-understood category of sets into more exotic ambient categories like Manifolds or Toposes.

*)

(* ========================================================================================================== )
( == Example: Monoid as an Internal Category in Set == )
( ========================================================================================================== *)

InternalCategory_Example_Monoid_in_Set ::= "INTERNAL_CATEGORY" "MonoidAsCat" "in" "Set" "verified_by" "{"
InternalCategoryDataDeclaration ::= "INTERNAL_CAT_DATA" "MonoidData" "in" "Set" "consists_of" "{"
TYPING (* The ambient category E is Set. E must have pullbacks, which Set does (they are fibered products). *)
AmbientCategory := Category("Set")
------------------------------------------
Context(MonoidData) is Set ;
CATEGORY
[[ MonoidAsCat in Set ]] = "A formalization of the proposition 'a monoid is a category with a single object', internalized within the category of Sets." ;

Generated code
"ObjectOfObjects" ":" "C₀ singleton_set" ";"
    TYPING (* The 'object of objects' is a singleton set, representing the single object of the monoid-category. *)
        C₀ := { "*" }
        -----------------------------
        Γ ⊢ C₀ : Object_in(Set) ;
    CATEGORY
        [[ C₀ singleton_set ]] = "The single abstract object of the category." ;


    "ObjectOfMorphisms" ":" "C₁ monoid_carrier_set" ";"
    TYPING (* The 'object of morphisms' is the underlying set M of the monoid. Each element is an endomorphism on the single object. *)
        Let M be a monoid. C₁ := |M| (the carrier set)
        -----------------------------
        Γ ⊢ C₁ : Object_in(Set) ;
    CATEGORY
        [[ C₁ monoid_carrier_set ]] = "The set of all morphisms of the category. Since there is only one object, all morphisms are endomorphisms." ;


    "StructureMorphisms" ":" "{"
        "domain" ":" "d₀ unique_map_to_singleton" ","
        "codomain" ":" "d₁ unique_map_to_singleton" ","
        TYPING (* Since there is only one object `*`, the domain and codomain of any morphism `g ∈ M` must be `*`. So, d₀ and d₁ are the same unique function `!: M → {*}`. *)
            d₀ := λ(g∈M). *,  d₁ := λ(g∈M). *
            -------------------------------------------------
            Γ ⊢ d₀, d₁ : Morphism(C₁, C₀) in Set ;
        CATEGORY
            [[ unique_map_to_singleton ]] = "The function that maps every element of the monoid's carrier set to the single object, correctly identifying all of them as endomorphisms." ;


        "identity" ":" "i identity_element_picker" ","
        TYPING (* The identity morphism is a function from the single object `*` to the set of morphisms M, picking out the monoid's identity element `e`. *)
            i := λ(*). e_monoid
            -----------------------------------
            Γ ⊢ i : Morphism(C₀, C₁) in Set ;
        CATEGORY
            [[ identity_element_picker ]] = "The function that selects the identity element of the monoid to act as the identity morphism for the single object." ;


        "composition" ":" "m monoid_multiplication"
        TYPING (*
                * Composition takes a composable pair and returns their composite. The object of composable pairs
                * is the pullback C₁ ×_d₀ C₁, which in Set is { (g,h) ∈ M×M | d₀(g)=d₁(h) }.
                * Since d₀ and d₁ are constant maps to `*`, this condition is always true.
                * Thus, the pullback object is simply the Cartesian product M × M.
                * The composition morphism `m` is therefore the monoid's binary operation `μ: M×M → M`.
               *)
            ComposablePairs := C₁ ×_C₀ C₁ ≅ M × M
            m := μ_monoid : M × M → M
            -------------------------------------------------
            Γ ⊢ m : Morphism(ComposablePairs, C₁) in Set ;
        CATEGORY
            [[ monoid_multiplication ]] = "The binary operation of the monoid, reinterpreted as the composition of morphisms in the internal category." ;
    "}" ";"
"}" ";"


"AXIOMS" "(" "InternalAssociativity" "," "InternalLeftUnit" "," "InternalRightUnit" ")"
TYPING (*
        * Now we verify that the commuting diagrams for the internal category axioms become the
        * standard equational axioms for a monoid.
       *)
    CheckAssociativity:
        (* The diagram `m ∘ (m × id) == m ∘ (id × m)` must commute. *)
        (* In Set, this becomes the equation: μ(μ(g,h),k) == μ(g,μ(h,k)) for all g,h,k in M. This is the monoid associativity axiom. *)
        Assert(MonoidAssociativity Axiom Holds);
    CheckLeftUnit:
        (* The diagram `m ∘ <id, i ∘ d₁> == id` must commute. *)
        (* In Set, this becomes: μ(g, i(d₁(g))) == g => μ(g, i(*)) == g => μ(g, e) == g. This is the monoid right unit axiom. *)
        Assert(MonoidRightUnit Axiom Holds);
    CheckRightUnit:
        (* The diagram `m ∘ <i ∘ d₀, id> == id` must commute. *)
        (* In Set, this becomes: μ(i(d₀(g)), g) == g => μ(i(*), g) == g => μ(e, g) == g. This is the monoid left unit axiom. *)
        Assert(MonoidLeftUnit Axiom Holds);
------------------------------------------------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ AXIOMS hold for MonoidData ;


"}" ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.2: Internal base-valued functors" ")" "==>" {
(*

ELABORATION: A "base-valued functor" is a functor whose codomain is the base category E where
the internal category lives. The most fundamental examples are the internal Hom-functors and the
internal Yoneda embedding, which are the internal analogues of the familiar concepts from standard
category theory.

To elaborate, we will:

Formalize the Internal Presheaf: Define INTERNAL_PRESHEAF as the general term for a base-valued
functor with codomain E, i.e., a functor C^op → E.

Formalize the Internal Hom-Functor: Define the specific constructor IntHom_C(-, I)
which is the internal analogue of the representable Hom-functor Hom(-,object). This requires
the ambient category E to have pullbacks.

Formalize the Internal Yoneda Embedding: Define the InternalYonedaEmbedding (y_C) as the functor
that maps an internal object I to its representable internal presheaf, IntHom_C(-, I).

Formalize the Internal Yoneda Lemma: State the internal version of the Yoneda Lemma as a
fundamental theorem. It asserts a natural isomorphism between the object of natural transformations
from a representable y(I) to any other presheaf F, and the evaluation of F at I. This
demonstrates that the core principles of representation theory hold in the internal setting.

*)

(* ========================================================================================================== )
( == Part 1: Internal Presheaves and the Internal Hom-Functor == )
(* ========================================================================================================== *)

InternalPresheaf ::= "INTERNAL_PRESHEAF" Identifier "on" Identifier ;
TYPING
(* An internal presheaf on C is a functor from the opposite of the internal category C to the base category E. *)
Γ ⊢ C : InternalCategory_in(E)

Γ ⊢ INTERNAL_PRESHEAF F on C : Functor(C^op, E) ;
CATEGORY
[[ INTERNAL_PRESHEAF F on C ]] = "A functor that represents a 'variable object' in the base category E, indexed by the internal category C. This is the direct analogue of a presheaf in standard category theory." ;

InternalHomFunctor ::= "IntHom_" Identifier "(" "," Identifier ")" ;
TYPING
(*

For an internal category C in E (where E has pullbacks), the internal Hom-functor IntHom_C(-, I)

is a canonical internal presheaf. For a fixed internal object I (an 'element' of C₀),

this functor maps another internal object X to an object in the base category E that

represents the 'collection of morphisms' from X to I inside C.

The formal construction of this object requires pullbacks in E.
*)
Context: Γ ⊢ E : Category_with_Pullbacks
Γ ⊢ C : InternalCategory_in(E) with components (C₀, C₁, d₀, d₁)
Γ ⊢ I : Object_in(C₀)
FunctorActionOnObjects(X ∈ Ob(C₀)) := The pullback of (d₀: C₁→C₀) and (d₁: C₁→C₀) over (X,I).

Γ ⊢ IntHom_C(-, I) : InternalPresheaf on C ;
CATEGORY
[[ IntHom_C(-, I) ]] = "The internal Hom-functor, or representable internal presheaf. For a fixed internal object I, this functor acts as a 'probe', assigning to each object X the 'object of morphisms' from X to I. This is a primary example of a base-valued functor." ;

(* ========================================================================================================== )
( == Part 2: The Internal Yoneda Embedding and Lemma == )
(* ========================================================================================================== *)

InternalYonedaEmbedding ::= "y_" Identifier ;
TYPING
(* The internal Yoneda embedding y_C maps an object of C to its representable internal presheaf. )
Γ ⊢ C : InternalCategory_in(E)
ActionOnObjects(I ∈ Ob(C₀)) := IntHom_C(-, I)
ActionOnMorphisms... ( can be defined from universal properties *)

Γ ⊢ y_C : Functor( C, CategoryOf(InternalPresheaf on C) ) ;
CATEGORY
[[ y_C ]] = "The internal Yoneda embedding. It embeds the internal category C fully and faithfully into the category of internal presheaves on C, demonstrating that an internal category can be studied through its internal representations, just like a standard category." ;

InternalYonedaLemma ::= "THEOREM" "InternalYonedaLemma" ":"
"ObjectOfNatTrans(" "y_" Identifier "(" Identifier ")" "," Identifier ")" "≅" Identifier "(" Identifier ")" ;
TYPING
(*

The lemma states that for an internal category C, an internal presheaf F:C^op→E, and an

object I of C, the object of natural transformations (in E) from the representable presheaf

y_C(I) to F is naturally isomorphic (in E) to the evaluation F(I).
*)
Γ ⊢ C : InternalCategory_in(E)
Γ ⊢ F : InternalPresheaf on C
Γ ⊢ I : Object_in(C₀)
LHS := ObjectOfNaturalTransformations(y_C(I), F) in E
RHS := F(I) : Object_in(E)

Γ ⊢ LHS ≅ RHS : Isomorphism in E ;
CATEGORY
[[ THEOREM InternalYonedaLemma ]] = "The internal version of the Yoneda Lemma. This fundamental result asserts that an object I of an internal category is completely determined by its associated internal presheaf of morphisms into it. It shows that the deep relationship between objects and their representations via Hom is not limited to Set-based category theory but is a core principle that holds in any suitable internal setting." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.3: Internal limits and colimits" ")" "==>" {
(*

ELABORATION: This section defines limits and colimits of a diagram in an internal category.
The diagram's shape is a normal (external) category J, but its values lie within the internal
category C. The limit object and its cone must therefore also be objects and morphisms internal to C,
and the universal property must be expressed as a commuting diagram in the ambient category E.

To elaborate, we will:

Formalize the Internal Diagram: Define a diagram D of shape J in an internal category C as
a pair of maps that satisfy the functor axioms internally.

Formalize the Internal Cone: Define a cone for such a diagram, consisting of an internal apex
object and a family of internal cone leg morphisms.

Formalize the Internal Limit: Define the internal limit by its universal property. This involves
formalizing the unique mediating morphism u that makes the cone universal, and expressing this
uniqueness as a property within the ambient category E.

Derive the Dual Theory: Use the Duality Principle to mechanically derive the entire theory for
internal colimits.

*)

(* ========================================================================================================== )
( == Part 1: The Internal Diagram and Cone == )
(* ========================================================================================================== *)

InternalDiagramDeclaration ::= "INTERNAL_DIAGRAM" Identifier ":" Identifier "→" Identifier ;
TYPING
(* An internal diagram D of shape J (an external, small category) in an internal category C in E. *)
Γ ⊢ J : SmallCategory (External)
Γ ⊢ C : InternalCategory_in(E)
D_obj : Ob(J) → Ob(C₀) in Set (Map from J's objects to E's 'elements' of C₀)
D_mor : Mor(J) → Ob(C₁) in Set (Map from J's morphisms to E's 'elements' of C₁)
(These maps must satisfy the functor laws, expressed as commuting diagrams in E.)

Γ ⊢ INTERNAL_DIAGRAM D : J → C : InternalDiagram_in(C) ;
CATEGORY
[[ INTERNAL_DIAGRAM D ... ]] = "A diagram of shape J drawn inside the internal category C. It uses an external category J to select a pattern of objects and morphisms within C." ;

InternalConeDeclaration ::= "INTERNAL_CONE" Identifier "over" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" Identifier "}" "}" ;
TYPING
(* A cone over an internal diagram D. )
Γ ⊢ D : InternalDiagram_in(C)
Γ ⊢ A : Object_in(C₀) (* The apex is an internal object. *)
Legs := { p_j : Morphism(A, D_obj(j)) in C₁ | j ∈ Ob(J) }
(The cone commutativity diagram must hold internally.)

Γ ⊢ INTERNAL_CONE ... : InternalCone_over(D) ;
CATEGORY
[[ INTERNAL_CONE K ... ]] = "A cone over an internal diagram. Its apex is an object in C₀ and its legs are morphisms in C₁, all satisfying the internal coherence laws." ;

(* ========================================================================================================== )
( == Part 2: The Internal Limit and its Universal Property == )
(* ========================================================================================================== *)

InternalLimitDeclaration ::= "INTERNAL_LIMIT" "of" Identifier "is" InternalConeDeclaration ;
TYPING
(*

An internal cone L is an internal limit if for any other internal cone K, there exists

a UNIQUE morphism u:Apex(K)→Apex(L) in C₁ that makes the universal triangle commute.
*)
Let L be an INTERNAL_CONE over D.
UniversalProperty :=
∀ (K : InternalCone_over(D)),
∃! (u : Morphism(Apex(K), Apex(L)) in C₁),
s.t. ∀j∈Ob(J), (p_j_L ∘ u == p_j_K) (This comparison holds in C₁)

Γ ⊢ INTERNAL_LIMIT of D is L : ProvableProposition ;
CATEGORY
[[ INTERNAL_LIMIT of D is L ]] = "The universal internal cone for the diagram D. Its existence is a strong structural property of the internal category C, asserting that it has a way to find universal solutions to constraint problems defined by diagrams." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory for Internal Colimits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEORY" "'InternalColimitTheory'" "FROM" "THEORY" "'InternalLimitTheory'" ;
TYPING
(***

By applying the duality functor (-)^op to the entire theory for internal limits,

the system mechanically generates the correct dual theory for internal colimits.

Rewrites performed by the DualityMapping dictionary:

INTERNAL_CONE -> INTERNAL_COCONE (arrows point from diagram to apex)

INTERNAL_LIMIT -> INTERNAL_COLIMIT

Apex is Terminal in ConeCategory -> Apex is Initial in CoConeCategory

The resulting propositions are valid theorems in the dual theory.
***)
Γ ⊢ TheoryBlock["InternalLimitTheory"] : CoherentTheoryFragment

Γ ⊢ TheoryBlock["InternalColimitTheory"] := (TheoryBlock["InternalLimitTheory"])^op : CoherentTheoryFragment ;
CATEGORY
[[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the entire theory for 'internal colimits'. This process, derived by mechanically applying the duality functor, generates the definitions for internal cocones and internal colimits (which are universal cocones) without requiring separate proofs, showcasing the perfect symmetry of the underlying categorical concepts even in an internalized setting." ;

}
