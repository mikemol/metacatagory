MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 7: 'Bicategories and distributors', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.1: 2-categories" ")" "==>" {
(*

ELABORATION: A 2-category enhances a standard category by introducing "morphisms between morphisms,"
called 2-cells. This section formalizes the STRICT version of a 2-category, where composition of
1-morphisms is strictly associative and unital. The core idea is that for any two objects A and B,
the collection of morphisms between them, Hom(A,B), is not just a set but a category itself.

To elaborate, we will:

Formalize the Hom-Category: Define the category structure that exists between any two objects.

Formalize the Composition Functor: Define the composition of 1-morphisms not as a mere
operation, but as a functor. This functoriality is precisely what enforces the strict interchange law.

Formalize the Identity-on-Objects Functor: Show that the identity 1-morphisms are given
by an identity-on-objects functor from the terminal category.

Construct the 2-Category: Assemble these components into the master definition of a 2-category.

*)

(* ========================================================================================================== )
( == Part 1: The Building Blocks - Hom-Categories and Composition Functors == )
( ========================================================================================================== *)

HomCategoryDeclaration ::= "HOM_CATEGORY" "(" Identifier "," Identifier ")" "has" "{" "OneMorphisms" ":" "{" {Identifier} "}" ";" "TwoMorphisms" ":" "{" {MorphismDeclaration} "}" ";" "}" ;
TYPING
(*

This declares that the collection of morphisms between two objects A and B in a 2-category

forms a category itself. The objects of this "hom-category" are the 1-morphisms, and the

morphisms of the hom-category are the 2-morphisms (or 2-cells).
)
Γ ⊢ C/A, C/B : Object_in(_2Category)
Γ ⊢ OneMorphisms : Set(Identifier) ( These are the 1-morphisms, acting as objects )
Γ ⊢ TwoMorphisms : Set(MorphismDeclaration) ( These are the 2-morphisms, acting as arrows *)

Generated code
Γ ⊢ HOM_CATEGORY(C/A, C/B) ... : Category ;


CATEGORY
[[ HOM_CATEGORY(A, B) ... ]] = "The hom-category C(A,B). Its existence, for every pair of objects (A,B), is the defining feature of a 2-category. Its objects are 1-morphisms A→B and its morphisms are 2-morphisms between them. The composition in this category is 'vertical composition' of 2-cells." ;

CompositionFunctorDeclaration ::= "COMPOSITION_FUNCTOR" "∘" ":" HomCategoryDeclaration "×" HomCategoryDeclaration "→" HomCategoryDeclaration ;
TYPING
(* This asserts that composition of 1-morphisms is a functor. This elegantly captures the interchange law. *)
Γ ⊢ C(B,C) : HOM_CATEGORY(B,C)
Γ ⊢ C(A,B) : HOM_CATEGORY(A,B)
Γ ⊢ C(A,C) : HOM_CATEGORY(A,C)

Generated code
Γ ⊢ ∘ : Functor(C(B,C) × C(A,B), C(A,C)) ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ ∘ : C(B,C) × C(A,B) → C(A,C) ]] = "The horizontal composition functor. Its action on objects is the composition of 1-morphisms. Its action on morphisms (the 2-cells) is the horizontal composition of 2-cells, often denoted by ∗. The fact that ∘ is a functor is precisely the interchange law: (β' ⋅ β) ∗ (α' ⋅ α) = (β' ∗ α') ⋅ (β ∗ α), where ⋅ is vertical and ∗ is horizontal composition." ;

IdentityFunctorDeclaration ::= "IDENTITY_FUNCTOR" "Id" ":" "TerminalCategory" "→" HomCategoryDeclaration ;
TYPING
(* The identity 1-morphism for an object A is given by a functor from the terminal category 1. *)
Γ ⊢ C(A,A) : HOM_CATEGORY(A,A)

Generated code
Γ ⊢ Id : Functor(1, C(A,A)) ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ Id : 1 → C(A,A) ]] = "The identity-on-A functor. It selects the identity 1-morphism id_A from the hom-category C(A,A). The fact it is a functor is trivial but completes the structural definition." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition == )
( ========================================================================================================== *)

_2CategoryDeclaration ::= "_2CATEGORY" Identifier "{" "Objects" ":" {Identifier} ";" "HomCategories" ":" {HomCategoryDeclaration} ";" "CompositionFunctors" ":" {CompositionFunctorDeclaration} ";" "IdentityFunctors" ":" {IdentityFunctorDeclaration} ";" "}" ;
TYPING
(* A 2-category is defined by its collection of objects and these structured hom-sets. *)
Γ ⊢ Objs : Set(Identifier)
... all other components are well-typed ...
Coherence: Composition functors are associative and unital.

Generated code
Γ ⊢ _2CATEGORY ... : _2Category ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ _2CATEGORY C ... ]] = "A category enriched over the category of small categories (Cat). This is the strict definition, where the laws of associativity and identity for the composition functor hold on the nose, not just up to isomorphism. The canonical example is Cat itself, whose objects are categories, 1-morphisms are functors, and 2-morphisms are natural transformations." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.2: 2-functors and 2-natural transformations" ")" "==>" {
(*

ELABORATION: This section defines the structure-preserving maps between 2-categories. Just as
a functor preserves the structure of a category, a 2-functor preserves the structure of a
2-category. This means it preserves not only objects and 1-morphisms but also 2-morphisms
and both their vertical and horizontal compositions. A 2-natural transformation is the next
level up, being a "morphism" between 2-functors.

To elaborate, we will:

Formalize the 2-Functor: Define a 2-functor F by specifying its action on objects,
1-morphisms, and 2-morphisms, with the crucial condition that its action on each
hom-category is itself a functor.

Formalize the 2-Natural Transformation: Define a 2-natural transformation α between
two 2-functors F and G. Its components α_X will be 1-morphisms, and its naturality
condition will be a strictly commutative square of 1-morphisms.

*)

(* ========================================================================================================== )
( == Part 1: The 2-Functor == )
( ========================================================================================================== *)

_2FunctorDeclaration ::= "_2FUNCTOR" Identifier ":" Identifier "→" Identifier "{" "ActionOnObjects" ":" {ObjectMapping} ";" "ActionOnHomCats" ":" {HomCategoryFunctorMapping} ";" "}" ;
TYPING
(*

A 2-functor F from a 2-category C to a 2-category D is a map that preserves all structure.

This is captured by requiring that for each pair of objects (A,B) in C, the mapping F induces

on the hom-category is itself a functor.
*)
Γ ⊢ C, D : 2Category
ActionOnObjects is a valid function from Ob(C) to Ob(D).
∀ A,B in Ob(C), F{A,B} : C(A,B) → D(F(A),F(B)) is a Functor.

Γ ⊢ _2FUNCTOR F ... : _2Functor(C, D) ;
CATEGORY
[[ _2FUNCTOR F ... ]] = "A strict 2-functor, or a homomorphism of 2-categories. It preserves all structure on the nose: objects, 1-morphisms, 2-morphisms, vertical composition, horizontal composition, and identities." ;

HomCategoryFunctorMapping ::= "map_hom_cat" "(" Identifier "," Identifier ")" "to" "hom_cat" "(" Identifier "," Identifier ")" "via_functor" Identifier ;
TYPING
(* This is the typing rule for the component functor F_{A,B}. *)
Γ ⊢ C(A,B) : HOM_CATEGORY in C
Γ ⊢ D(F(A),F(B)) : HOM_CATEGORY in D

Γ ⊢ F_AB : Functor(C(A,B), D(F(A),F(B))) ;
CATEGORY
[[ map_hom_cat ... via_functor F_AB ]] = "The component of a 2-functor F that acts on a specific hom-category. The functoriality of F_AB ensures that F preserves 2-morphisms and their vertical composition. The preservation of horizontal composition is guaranteed by the coherence of these component functors." ;

(* ========================================================================================================== *)
(* == Part 2a: The Deconstructed Master Definition == )
(* ========================================================================================================== *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.1: 2-categories Part 2a: The Deconstructed Master Definition" ")" "==>" {
(*
* ELABORATION (Instantiation): The previous elaboration formalized the deconstructed master definition
* of a 2-category, separating its "Data" (the structures) from its "Axioms" (the laws).
* To provide a deeper elaboration, we will now instantiate this deconstructed definition with
* the canonical example: Cat, the 2-category of small categories, functors, and natural
* transformations.
*
* This example will meticulously fill in each part of the _2CategoryData block, explaining
* how categories, functors, and natural transformations fit into the framework of 0-cells, 1-cells,
* and 2-cells. It will then assert that this data satisfies the required _2CategoryAxioms,
* thereby proving that Cat is, indeed, a (strict) 2-category.
*)

Generated code
(* ========================================================================================================== *)
(* == Example Instantiation: The 2-Category of Categories, 'Cat' == )
(* ========================================================================================================== *)

_2CategoryDeclaration ::= "_2CATEGORY" "Cat" "{"
    _2CategoryData ::= "DATA" "{"
        "Objects" ":" "{" "C" "," "D" "," "A" "," "B" "}" ";"
        TYPING
            (* The objects (0-cells) of Cat are small categories themselves. *)
            Ob_Type := { c | c is a small Category }
            -----------------------------------
            Γ ⊢ Objects(Cat) : Ob_Type ;
        CATEGORY
            [[ Objects ]] = "The collection of all small categories." ;

        "HomCategories" ":" "{"
            HomCategoryDeclaration ::= "HOM_CATEGORY" "(" "C" "," "D" ")" ";"
            TYPING
                (* The hom-category Cat(C,D) has functors as its objects and natural transformations as its morphisms. *)
                Objects(Cat(C,D)) := { F | Γ ⊢ F : Functor(C, D) }
                Morphisms(Cat(C,D)) := { α | Γ ⊢ α : NaturalTransformation }
                ------------------------------------------------------------------
                Γ ⊢ HOM_CATEGORY(C, D) : Category ;
            CATEGORY
                [[ HOM_CATEGORY(C,D) ]] = "The functor category [C,D], whose objects are functors from C to D and whose morphisms are natural transformations between them. Vertical composition of 2-cells in Cat is the standard composition of natural transformations." ;
        "}" ";"

        "CompositionFunctors" ":" "{"
            CompositionAsFunctor ::= "∘" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ";"
            TYPING
                (* Composition in Cat is functor composition
                 * The action on objects is G ∘ F.
                 * The action on morphisms is horizontal composition β ∗ α.
                 * Functoriality of this operation IS the interchange law.
                *)
                Context: α:F→F', β:G→G'
                ActionOnObjects: (G, F) ↦ G∘F
                ActionOnMorphisms: (β, α) ↦ β∗α (horizontal composition of nat. trans.)
                ---------------------------------------------------------------------------
                Γ ⊢ ∘ : Functor( Cat(B,C)×Cat(A,B), Cat(A,C) ) ;
            CATEGORY
                [[ ∘ ]] = "Functor composition. The fact that this operation is a functor (i.e., that horizontal composition of natural transformations respects their vertical composition) is the interchange law, a cornerstone property of Cat." ;
        "}" ";"

        "IdentityFunctors" ":" "{"
            IdentityFunctorDeclaration ::= "IDENTITY_FUNCTOR" "Id_C" ":" "TerminalCategory" "→" "HOM_CATEGORY(C,C)" ";"
            TYPING
                (* The identity 1-morphism for an object C is the identity functor Id_C. *)
                ActionOnObject: * ↦ Id_C
                ---------------------------------------------------------------------------------
                Γ ⊢ Id_C : Functor(1, HOM_CATEGORY(C,C)) ;
            CATEGORY
                [[ IDENTITY_FUNCTOR Id_C ... ]] = "The identity functor on the category C, which acts as the identity 1-morphism for the object C within the 2-category Cat." ;
        "}" ";"
    "}" ";"

    _2CategoryAxioms ::= "AXIOMS" "{"
        AssociativityAxiom_2Cat ::= "AXIOM" "Associativity" "FOR_ALL_QUADS" "(A,B,C,D)" "," "..." ";"
        TYPING
            (* Functor composition H∘(G∘F) is definitionally equal to (H∘G)∘F. This is stricter than needed but holds. *)
            Holds(AssociativityAxiom, for: Cat) is TRUE.
            ----------------------------------------
            Γ ⊢ "Associativity holds for Cat" ;
        CATEGORY
            [[ Associativity Axiom for Cat ]] = "The assertion that functor composition is strictly associative, which is a fundamental property of functions and therefore of functors. This satisfies the pentagon axiom trivially." ;

        UnitalityAxiom_2Cat ::= "AXIOM" "Unitality" "FOR_ALL_PAIRS" "(A,B)" "," "..." ";"
        TYPING
            (* Composition with an identity functor is strictly unital: F∘Id_A = F and Id_B∘F = F. *)
            Holds(UnitalityAxiom, for: Cat) is TRUE.
            ----------------------------------
            Γ ⊢ "Unitality holds for Cat" ;
        CATEGORY
            [[ Unitality Axiom for Cat ]] = "The assertion that the identity functor acts as a strict unit for functor composition. This satisfies the triangle axiom trivially." ;
    "}" ";"
"}" ;

(*
 * CONCLUSION: This instantiation demonstrates the power of the deconstructed definition. By separating the DATA
 * from the AXIOMS, we can clearly declare the constituent parts of a complex structure like **Cat** and then
 * separately verify that this data satisfies the required laws. This makes the process of defining and
 * verifying higher-categorical structures rigorous and systematic.
*)


}

(* ========================================================================================================== *)
(* == Part 2b: The Coherence Axioms Formalized == )
(* ========================================================================================================== *)

AssociativityAxiom_2Cat ::= "AXIOM" "Associativity" ":" "FOR_ALL_QUADS" "(A,B,C,D)" "," Expression "==" Expression ;
TYPING
    (*
     * This formalizes the Pentagon Identity. For any four objects A,B,C,D, the following
     * diagram of functors must commute strictly. Let ∘_XYZ denote the composition functor
     * from HOM(Y,Z) × HOM(X,Y) to HOM(X,Z).
     * The axiom asserts: (∘_ACD ∘ (id × ∘_ABC)) == (∘_ABD ∘ (∘_BCD × id))
    *)
    Context: Γ ⊢ Data : _2CategoryData_Type
    f1 := ∘_ACD ∘ (Id_{C(C,D)} × ∘_ABC) : C(C,D)×C(B,C)×C(A,B) → C(A,D)
    f2 := ∘_ABD ∘ (∘_BCD × Id_{C(A,B)}) : C(C,D)×C(B,C)×C(A,B) → C(A,D)
    ---------------------------------------------------------------------
    Holds(AssociativityAxiom, for: Data) is TRUE if (f1 == f2) ;
CATEGORY
    [[ AXIOM Associativity ... ]] = "The formal assertion of the Pentagon Axiom for strict 2-categories. It states that the two ways of composing three 1-morphisms are not just equal, but that the functors defining these compositions are themselves equal. This guarantees that horizontal composition is strictly and unambiguously associative." ;

UnitalityAxiom_2Cat ::= "AXIOM" "Unitality" ":" "FOR_ALL_PAIRS" "(A,B)" "," Expression "==" Expression "&&" Expression "==" Expression ;
TYPING
    (*
     * This formalizes the Triangle Identity. For any f:A→B, we must have id_B ∘ f = f and f ∘ id_A = f.
     * As an equation of functors, this means composing with the Identity Functor is the Identity Natural Transformation.
    *)
    Context: Γ ⊢ Data : _2CategoryData_Type, Γ ⊢ C(A,B) : HomCategoryDeclaration
    LeftUnitality := (∘_AAB ∘ (Id_A × id_{C(A,B)})) == id_{C(A,B)}
    RightUnitality := (∘_ABB ∘ (id_{C(A,B)} × Id_B)) == id_{C(A,B)}
    ------------------------------------------------------------------------------------------
    Holds(UnitalityAxiom, for: Data) is TRUE if (LeftUnitality ∧ RightUnitality) ;
CATEGORY
    [[ AXIOM Unitality ... ]] = "The formal assertion of the Triangle Axiom for strict 2-categories. It states that the functors for left and right composition with an identity 1-morphism are equal to the identity functor on the relevant hom-category. This guarantees that identity 1-morphisms behave as strict units for horizontal composition." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.3: Modifications and n-categories" ")" "==>" {
(*

ELABORATION: This section introduces the next level of the categorical hierarchy: a "morphism between
morphisms between morphisms." A modification is a transformation between two 2-natural transformations.
This establishes the structure of a 3-category. The concept is then generalized to the idea of an
n-category, where one can have k-morphisms for any k < n.

To elaborate, we will:

Formalize the Modification: Define a modification μ between two 2-natural transformations
α and β. Its components μ_X will be 2-morphisms.

Formalize the 3Cat of 2-Categories: Assert that 2-categories, 2-functors, 2-natural
transformations, and modifications form a 3-category.

Define the n-Category Concept Recursively: Provide a meta-rule that defines an (n+1)-category
as a category enriched over the category of n-categories. This is the most elegant and formal
way to capture the general idea.

*)

(* ========================================================================================================== )
( == Part 1: Modifications == )
( ========================================================================================================== *)

ModificationDeclaration ::= "MODIFICATION" Identifier ":" Identifier "===>" Identifier ;
TYPING
(*

A modification μ is a transformation from one 2-natural transformation α: F==>G to another β: F==>G.

It consists of a family of 2-morphisms μ_X : α_X ⇒ β_X for each object X in the domain 2-category.

The coherence condition ensures compatibility with 1-morphisms.
*)
Γ ⊢ C,D : _2Category
Γ ⊢ α,β : _2NaturalTransformation(F, G)
μ is a family { μ_X : α_X ⇒ β_X is a 2-morphism in D(F(X),G(X)) | X ∈ Ob(C) }
CoherenceCondition: ∀(f:X→Y in C), (G(f) ∗ μ_X == μ_Y ∗ F(f)) (where ∗ is horizontal composition)

Γ ⊢ MODIFICATION μ : α ===> β : Modification ;
CATEGORY
[[ MODIFICATION μ : α ===> β ]] = "A 3-morphism in the 3-category of 2-categories. It is a transformation between 2-natural transformations, with components given by 2-cells, satisfying a coherence law that ensures it is a 'natural' family of 2-cells." ;

(* ========================================================================================================== )
( == Part 2: The Hierarchy of n-Categories == )
( ========================================================================================================== *)

CategoryLevelDeclaration ::= Identifier "is_a" "3-CATEGORY" ;
TYPING
(*

We can assert that the collection of 2-categories forms a 3-category.
*)
Let 2-Cat be a structure.
Objects(2-Cat) := { C | C is a _2Category }
1-Morphisms(2-Cat) := { F | F is a _2Functor }
2-Morphisms(2-Cat) := { α | α is a _2NaturalTransformation }
3-Morphisms(2-Cat) := { μ | μ is a Modification }

Γ ⊢ "2-Cat" is_a "3-CATEGORY" : Proposition;
CATEGORY
[[ "2-Cat" is_a "3-CATEGORY" ]] = "The assertion that the universe of (small) 2-categories, with 2-functors, 2-natural transformations, and modifications as its levels of morphisms, itself forms a 3-category." ;

nCategoryRecursiveDefinition ::= "DEFINE" "(" "n+1" ")" "-CATEGORY" "as" "CategoryEnrichedOver_n-Cat" ;
TYPING
(*

This is a meta-rule defining the concept of an n-category inductively.
*)
Let n-Cat be the category of all n-categories.
An (n+1)-Category is a category enriched over n-Cat.

Γ ⊢ nCategoryRecursiveDefinition : MetaAxiom ;
CATEGORY
[[ DEFINE (n+1)-CATEGORY as ... ]] = "The inductive definition of an n-category. It formalizes the idea that an (n+1)-category is a structure whose hom-sets are themselves n-categories, with composition being a functor. This captures the entire hierarchy in a single, powerful recursive statement." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.4: 2-limits and bilimits" ")" "==>" {
(*

ELABORATION: This section generalizes the concept of limits to the 2-categorical setting.
In a 1-category, a limit is a universal cone, where the universality guarantees a unique
mediating morphism. In a 2-category, "uniqueness" is often too strict a condition. The
concept is therefore weakened: the mediating morphism might only be unique up to a unique
invertible 2-cell. This gives rise to the bilimit (or 2-limit).

To elaborate properly, we will:

Formalize the "Cones": Deconstruct the different types of cones in a 2-category.

StrictCone: The triangles commute on the nose (= is equality).

PseudoCone or 2-Cone: The triangles commute up to a specified, invertible 2-cell (⇒ is a 2-isomorphism).

Formalize the "Universal Properties": Define the different notions of universality.

StrictTerminal: A unique mediating 1-morphism exists.

BiTerminal: A mediating 1-morphism exists and is unique up to a unique invertible 2-cell.

Combine Cones and Universality: Define the hierarchy of 2-limits by combining the above.

Strict 2-Limit: A universal StrictCone with a StrictTerminal property.

Pseudo-Limit: A universal StrictCone with a BiTerminal property.

Bilimit: A universal PseudoCone with a BiTerminal property. (This is the most general and useful notion).

*)

(* ========================================================================================================== )
( == Part 1: The Building Blocks - Cones and Universality == )
( ========================================================================================================== *)

StrictConeDeclaration ::= "STRICT_CONE" "over" Identifier "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(* A Strict Cone is a standard 1-categorical cone inside a 2-category. The triangles commute on the nose. *)
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is a 1-Morphism
∀ (f:j→k in J), (D(f) ∘ p_j == p_k)

Γ ⊢ STRICT_CONE ... : StrictCone(D) ;
CATEGORY
[[ STRICT_CONE ... ]] = "A cone in a 2-category whose commuting triangles hold with strict equality. All 2-cells witnessing commutativity are identities." ;

PseudoConeDeclaration ::= "PSEUDO_CONE" "over" Identifier "{" "Apex" ":" Identifier "," "Legs" ":" ... "," "Cells" ":" "{" {IsomorphismDeclaration} "}" "}" ;
TYPING
(* A Pseudo-Cone (or 2-Cone) weakens the equality to a specified isomorphism. )
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is a 1-Morphism
∀ (f:j→k in J), ∃ (α_f : D(f) ∘ p_j ⇒ p_k is a 2-ISOMORPHISM)
( Plus coherence conditions for the α's *)

Γ ⊢ PSEUDO_CONE ... : PseudoCone(D) ;
CATEGORY
[[ PSEUDO_CONE ... ]] = "A cone where the triangles are witnessed to commute by specified, invertible 2-cells. This is the natural notion of a cone in a bicategory, respecting the 'up to isomorphism' nature of the structure." ;

BiTerminalObjectProperty ::= Identifier "is" "BI_TERMINAL" "in" "2-Category" Identifier ;
TYPING
(* This property formalizes the weak notion of universality. *)
Γ ⊢ L : Object_in(_2Cat), Γ ⊢ _2Cat : _2Category
Condition := ∀ (X ∈ Ob(_2Cat)), the hom-category _2Cat(X, L) is equivalent to the terminal category 1.

Γ ⊢ L is BI_TERMINAL ... : PropositionAbout(L) ;
CATEGORY
[[ L is BI_TERMINAL ... ]] = "The property of being terminal 'up to equivalence'. For any object X, there exists a morphism from X to L, and any two such morphisms are connected by a unique isomorphism. This is the correct 2-categorical analogue of a terminal object." ;

(* ========================================================================================================== )
( == Part 2: The Hierarchy of Limits == )
( ========================================================================================================== *)

Strict2LimitDeclaration ::= "STRICT_2_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* The strongest form: a strictly universal strict cone. *)
Γ ⊢ L : StrictCone(D)
Let ConeCat_1(D) be the 1-category of strict cones over D.
L is TERMINAL_OBJECT in ConeCat_1(D)

Γ ⊢ STRICT_2_LIMIT of D is L : Proposition ;
CATEGORY
[[ STRICT_2_LIMIT ... ]] = "A limit in the underlying 1-category of the 2-category. This is a limit where the mediating 1-morphism is strictly unique. These are rare but important." ;

PseudoLimitDeclaration ::= "PSEUDO_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* A weakly universal strict cone. *)
Γ ⊢ L : StrictCone(D)
Let ConeCat_2(D) be the 2-category of strict cones over D.
L is BI_TERMINAL in ConeCat_2(D)

Γ ⊢ PSEUDO_LIMIT of D is L : Proposition ;
CATEGORY
[[ PSEUDO_LIMIT ... ]] = "A limit over a strictly commuting diagram, but whose universal property is weak. The mediating 1-morphism is only unique up to a unique invertible 2-cell. This is a common and useful intermediate notion." ;

BilimitDeclaration ::= "BILIMIT" "of" Identifier "is" PseudoConeDeclaration ;
TYPING
(* The weakest and most general form: a weakly universal pseudo-cone. *)
Γ ⊢ L : PseudoCone(D)
Let PseudoConeCat_2(D) be the 2-category of pseudo-cones over D.
L is BI_TERMINAL in PseudoConeCat_2(D)

Γ ⊢ BILIMIT of D is L : Proposition ;
CATEGORY
[[ BILIMIT ... ]] = "The most general and natural notion of a limit in a 2-category or bicategory. Both the cone itself and its universal property are defined 'up to coherent isomorphism', respecting the weak nature of the ambient category. This is often simply called a '2-limit'." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on 'Elaborate on Section 7.5: Lax functors and pseudo-functors'" ")" "==>" {
(*

ELABORATION (Deeper Dive): The previous elaboration on Section 7.5 established the hierarchy
of Strict 2-Functors, Pseudo-Functors, and Lax Functors. A deeper elaboration requires
formalizing the coherence laws that the comparison cells of a lax functor must satisfy. These laws
are the functorial equivalent of the pentagon and triangle identities for bicategories and are
the very heart of the definition.

This deeper elaboration will:

Deconstruct the Lax Functor: We will separate the data of a lax functor (the mappings
and the comparison cells) from the axioms it must satisfy.

Formalize the Coherence Axioms: We will provide formal declarations for the two crucial
coherence axioms—associativity and unitality—that constrain the comparison cells. These axioms
are commutative diagrams of 2-cells and are essential for a lax functor to be a well-defined
structure.

Provide a Concrete Example: We will show that a lax monoidal functor between two monoidal
categories (viewed as one-object bicategories) is a perfect, tangible example of a lax functor.
This will make the abstract comparison cells (φ) and their coherence laws concrete.

This approach transforms the definition from a statement of properties into a fully-formalized,
constructive object with explicit axioms.

*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Data of a Lax Functor == )
(* ========================================================================================================== *)

LaxFunctorData ::= "DATA_LaxFunctor" Identifier ":" Identifier "→" Identifier "{"
"ActionOnObjects" ":" {ObjectMapping} ";"
"ActionOn1Morphisms" ":" {MorphismMapping} ";"
"CompositionCells" ":" "{" {ComparisonCellComposition} "}" ";"
"IdentityCells" ":" "{" {ComparisonCellIdentity} "}" ";"
"}" ;
TYPING
(* This rule declares the raw data of a lax functor F: C → D, before axioms are checked. *)
Γ ⊢ C, D : Bicategory
F_Objs: Ob(C) → Ob(D)
F_1Mors: 1Mor(C) → 1Mor(D)
φ_comp: family of 2-cells F(g)∘F(f) ⇒ F(g∘f)
φ_id: family of 2-cells id_{F(A)} ⇒ F(id_A)
-----------------------------------------------------
Γ ⊢ DATA_LaxFunctor ... : LaxFunctorData_Type ;
CATEGORY
[[ DATA_LaxFunctor ... ]] = "The structural data for a lax functor, comprising its action on objects and 1-morphisms, along with the two families of comparison 2-cells that measure its failure to be a strict homomorphism." ;

ComparisonCellComposition ::= "φ_" "{" Identifier "," Identifier "}" ;
ComparisonCellIdentity ::= "φ_" "{" Identifier "}" ;

(* ========================================================================================================== )
(* == Part 2: The Coherence Axioms == )
(* ========================================================================================================== *)

LaxAssociativityAxiom ::= "AXIOM" "LaxAssociativity" "for" LaxFunctorData ;
TYPING
(*
* This axiom asserts the commutativity of the hexagonal diagram relating the functor's
* composition cells (φ) with the associators (α) of the domain and codomain bicategories.
* It ensures the lax functor respects associativity in a coherent way.
*)
Context: Γ ⊢ F_data : LaxFunctorData_Type for F: C→D
∀ composable f,g,h in C:
LHS := F(α_{h,g,f}) ⋅ φ_{h,g∘f} ⋅ (id_{F(h)} ∗ φ_{g,f})
RHS := φ_{h∘g,f} ⋅ (φ_{h,g} ∗ id_{F(f)}) ⋅ α_{F(h),F(g),F(f)}
-------------------------------------------------------------------------------------------------------
Γ ⊢ AXIOM LaxAssociativity holds if (LHS == RHS) ;
CATEGORY
[[ AXIOM LaxAssociativity ... ]] = "The coherence law for a lax functor's interaction with associativity. It ensures that the two ways of evaluating F applied to a composition of three morphisms, while moving parentheses and applying the comparison cells, are the same." ;

LaxUnitalityAxiom ::= "AXIOM" "LaxUnitality" "for" LaxFunctorData ;
TYPING
(*
* This axiom asserts the commutativity of the diagram relating the identity cells (φ)
* with the unitors (λ, ρ) and the composition cells (φ). It ensures coherence for identities.
*)
Context: Γ ⊢ F_data : LaxFunctorData_Type
∀ f:A→B in C:
(φ_{id_B, f} ⋅ (φ_B ∗ id_{Ff})) ⋅ F(λ_f) == id_{Ff}
and a similar diagram for the right unitor ρ.
--------------------------------------------------------------------------------------------------------
Γ ⊢ AXIOM LaxUnitality holds if conditions are met ;
CATEGORY
[[ AXIOM LaxUnitality ... ]] = "The coherence law for a lax functor's interaction with identity 1-morphisms. It ensures that the comparison cell for composing with an identity is compatible with the functor's identity cells and the bicategory's unitors." ;

(* ========================================================================================================== )
(* == Part 3: The Refined Master Definitions == )
(* ========================================================================================================== *)

LaxFunctorDeclaration ::= "LAX_FUNCTOR" Identifier ":" Identifier "→" Identifier "verifies" "{"
LaxFunctorData ";"
"PROVEN" "{" LaxAssociativityAxiom ";" LaxUnitalityAxiom ";" "}" ";"
"}" ;
TYPING
Γ ⊢ data : LaxFunctorData_Type
Γ ⊢ AXIOM LaxAssociativity for data
Γ ⊢ AXIOM LaxUnitality for data
-------------------------------------------
Γ ⊢ LAX_FUNCTOR ... : LaxFunctor ;
CATEGORY
[[ LAX_FUNCTOR ... ]] = "The fully-specified definition of a lax functor, comprising its structural data and the proofs that this data satisfies the necessary coherence axioms." ;

PseudoFunctorDeclaration ::= "PSEUDOFUNCTOR" Identifier ":" Identifier "→" Identifier ;
TYPING
(* The definition of a PseudoFunctor remains hierarchical, but is now built on the more robust LaxFunctor definition. *)
Premise1: Γ ⊢ F is a well-defined LAX_FUNCTOR
Premise2: All comparison cells (φ_comp and φ_id) defined in F's data are 2-ISOMORPHISMS.
------------------------------------------------------------------------------------------
Γ ⊢ PSEUDOFUNCTOR F ... : PseudoFunctor ;
CATEGORY
[[ PSEUDOFUNCTOR ... ]] = "A homomorphism of bicategories. It is a lax functor whose comparison 2-cells are all invertible, meaning it preserves identity and composition up to coherent isomorphism. This is the natural notion of a map between weak 2-categories." ;

(* ========================================================================================================== )
(* == Part 4: Concrete Example - Lax Monoidal Functors == )
(* ========================================================================================================== *)

LaxMonoidalFunctorAsLaxFunctor ::= "INSTANCE" LaxFunctorDeclaration "from_lax_monoidal_functor" ;
TYPING
(*
* A monoidal category (C, ⊗, I) can be seen as a bicategory with one object, *.
* This instance shows how a standard Lax Monoidal Functor F gives rise to a LAX_FUNCTOR.
)
Let (C, ⊗_C, I_C) and (D, ⊗_D, I_D) be monoidal categories.
Let F: C→D be a lax monoidal functor with comparison morphisms:
μ_{A,B} : F(A) ⊗_D F(B) → F(A ⊗_C B)
ε : I_D → F(I_C)
-- This data defines a Lax Functor F_bicat: B_C → B_D
Data(F_bicat).CompositionCells := { φ_{A,B} corresponding to μ_{A,B} }
Data(F_bicat).IdentityCells := { φ_ corresponding to ε }
-- The coherence axioms for the lax monoidal functor become the axioms for the LAX_FUNCTOR.
----------------------------------------------------------------------------------------------
Γ ⊢ INSTANCE ... : LaxFunctor ;
CATEGORY
[[ INSTANCE ... ]] = "A concrete realization of a lax functor. The comparison 2-cells φ of the abstract definition are instantiated as the concrete comparison morphisms μ and ε of the lax monoidal functor. If μ and ε are not isomorphisms, this provides a canonical example of a functor that is lax but not pseudo." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.6: Lax limits and pseudo-limits" ")" "==>" {
(*

ELABORATION: This section directly parallels Section 7.4, but generalizes the concepts to account
for the weaker structures introduced in 7.5 (like lax functors). It defines the weakest, most general
notions of cones and limits in a 2-categorical setting. A "lax limit" is a universal "lax cone,"
where the commutativity constraints are weakened as much as possible.

To elaborate, we will:

Formalize the Lax Cone: Explicitly define a "lax cone," the most general type of cone,
where the commuting triangles are filled by arbitrary (i.e., not necessarily invertible) 2-cells.

Formalize the Lax Limit: Define a lax limit as a universal lax cone. The universal property is
correspondingly weak, making it a terminal object in the 2-category of all possible lax cones.

Contrast with Pseudo-Limits: Re-formalize the definition of a Pseudo-Limit to provide a direct
comparison with the new concept of a Lax Limit.

Clarify the Hierarchy: Situate lax and pseudo-limits within the full hierarchy of limit
concepts introduced so far via a key theorem. This clarifies the relationships between all these
related but distinct concepts.

*)

(* ========================================================================================================== )
( == Part 1: The Lax Cone and Lax Limit == )
(* ========================================================================================================== *)
(This is the most general/weakest notion of a cone and limit.)

LaxConeDeclaration ::= "LAX_CONE" "over" _2FunctorDeclaration "{" "Apex" ":" Identifier "," "Legs" ":" "{" {Identifier} "}" "," "ComparisonCells" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(*
* A lax cone over a diagram D:J→C is the most general type of cone. It consists of an Apex A,
* a family of 1-morphism legs p_j:A→D(j), and for each morphism f:j→k in J, a "comparison"
* 2-cell µ_f : p_k ⇒ D(f) ∘ p_j. Unlike in a pseudo-cone or bilimit, these µ_f cells are NOT
* required to be isomorphisms.
*)
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is 1-morphism
∀ f:j→k ∈ Mor(J), Γ ⊢ µ_f : p_k ⇒ D(f) ∘ p_j is 2-morphism
(Coherence axioms for the µ's must also hold)
----------------------------------------------------------
Γ ⊢ LAX_CONE ... : LaxCone(D) ;
CATEGORY
[[ LAX_CONE ... ]] = "The most general notion of a cone in a 2-categorical context. The triangles of the cone do not need to commute; they are simply 'coherently filled' by arbitrary, specified 2-cells. This is the appropriate notion of a cone for diagrams involving lax functors." ;

LaxLimitDeclaration ::= "LAX_LIMIT" "of" Identifier "is" LaxConeDeclaration ;
TYPING
(*
* A lax limit is a terminal object in the 2-category of lax cones. This is the weakest
* possible universal property, making it the most general form of limit.
*)
Let LaxConeCat(D) be the 2-category of all lax cones over D.
Γ ⊢ L : LaxCone_over(D)
----------------------------------------------------------------------
Γ ⊢ L is LAX_LIMIT of D is TRUE if L is TerminalObject in LaxConeCat(D) ;
CATEGORY
[[ LAX_LIMIT of D ... ]] = "The universal lax cone. It provides a universal solution for mapping into a diagram in the weakest possible sense. While less common than bilimits, this concept is important in contexts where structure is only preserved laxly." ;

(* ========================================================================================================== )
( == Part 2: Contrast with Pseudo-Limits == )
(* ========================================================================================================== *)
(This is a stronger notion, using strict cones but with a weak universal property.)

PseudoLimitDeclaration ::= "PSEUDO_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* A pseudo-limit is a STRICT cone that is universal in the WEAK sense (bi-terminal). *)
Γ ⊢ L : StrictCone(D)
Let Cone2Cat(D) be the 2-category of strict cones over D.
------------------------------------------------------
Γ ⊢ L is PSEUDO_LIMIT of D is TRUE if L is BI_TERMINAL in Cone2Cat(D) ;
CATEGORY
[[ PSEUDO_LIMIT of D ... ]] = "A limit over a strictly commuting diagram, but whose universal property is weak. The mediating 1-morphism is only unique up to a unique invertible 2-cell. This is a common and useful intermediate notion, stronger than a lax limit." ;

(* ========================================================================================================== )
(* == Part 3: Clarifying the Hierarchy of Limits == )
(* ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitHierarchy" ":" "'Strict 2-Limit' ⇒ 'Pseudo-Limit' ⇒ 'Bilimit' ⇒ 'Lax Limit'" ;
TYPING
(*
* This theorem states that each limit concept is a special case of the one to its right.
* The implication ⇒ means "is a special case of".
*
* Proof sketch: A strict cone is a pseudo-cone (with identity isos), which is a lax cone. A strict universal property
* implies a bi-universal property. Therefore, any object satisfying a stricter
* definition also satisfies the weaker ones.
*)
(L is Strict_2_Limit) ⇒ (L is Pseudo_Limit)
(L is Pseudo_Limit) ⇒ (L is Bilimit)
(L is Bilimit) ⇒ (L is Lax_Limit)
-------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LimitHierarchy ]] = "The assertion of a clear hierarchy of limit concepts within a 2-category. The strength of a limit depends on two factors: the strictness of the cone (are the filler cells identities, isomorphisms, or arbitrary?) and the strictness of the universal property (is the mediating map strictly unique, or unique up to a unique isomorphism?). This theorem clarifies that 'Strict 2-Limit' is the strongest notion and 'Lax Limit' is the most general." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.7: Bicategories Part 1: The Definition of a Bicategory" ")" "==>" {
(*

ELABORATION (Deeper Dive): This elaboration focuses exclusively on Part 1 of the bicategory definition,
deconstructing it into its most fundamental typed components. A bicategory is not just a collection
of things; it is a highly structured record of data. We will formalize this by defining a bicategory's
DATA as a structured tuple containing:

0-cells: The objects of the bicategory.

Hom-Categories: For each pair of objects, a category of 1-cells (as objects) and 2-cells (as morphisms).

Composition Functors: The composition of 1-cells, formalized as a family of functors.

Identity Functors: The identity 1-cells, formalized as functors from the terminal category.

Constraint Natural Isomorphisms: The crucial associator and unitor 2-cells that govern the
weakness of the structure, formalized as natural isomorphisms between composition functors.

This deep dive exposes the definition as a single, large, typed data structure, setting the stage for
the coherence axioms (Pentagon, Triangle) which act upon this data.

*)

(* ========================================================================================================== )
( == The Master Definition as a Structured Record == )
(* ========================================================================================================== *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.7: Bicategories Part 1: The Definition of a Bicategory The Master Definition as a Structured Record by instantiating it with the canonical example, 'Dist'." ")" "==>" {
(*

ELABORATION (Instantiation): The previous turn defined the formal data structure for a bicategory.
This elaboration provides a meticulous instantiation of that structure with the most important
and canonical example of a non-strict bicategory: Dist, the bicategory of small categories,
distributors (profunctors), and natural transformations.

By filling in each field of the BicategoryDeclaration for Dist, we make the abstract
definitions concrete and demonstrate why the "weakness" (the non-trivial constraint isomorphisms)
is necessary and natural.

*)

BicategoryDeclaration ::= "BICATEGORY" "Dist" "is_defined_by" "{"
"DATA" "{"
"Objects" ":" "{" "A" "," "B" "," "C" "}" ";"
TYPING
(* The 0-cells of Dist are simply all small categories. *)
IsSmallCategory(A)
-----------------------
Γ ⊢ A : Object_in(Dist) ;
CATEGORY
[[ A : Object_in(Dist) ]] = "A small category, viewed as an object." ;

Generated code
"HomCategories" ":" "{"
        HomCategoryDeclaration ::= "HOM_CATEGORY" "(" "A" "," "B" ")" ";"
        TYPING
            (* The hom-category Dist(A,B) is the category of functors from B^op x A to Set. *)
            Objects(Dist(A,B)) := { D | Γ ⊢ D : Functor(B^op × A, Set) } (* These are Distributors *)
            Morphisms(Dist(A,B)) := { α | Γ ⊢ α : NaturalTransformation }
            ----------------------------------------------------------------------------------
            Γ ⊢ HOM_CATEGORY(A, B) : Category ;
        CATEGORY
            [[ HOM_CATEGORY(A, B) ]] = "The functor category `[B^op × A, Set]`. Its objects are distributors (profunctors) from A to B, and its morphisms are natural transformations between them. Vertical composition of 2-cells is the standard composition of natural transformations." ;
    "}" ";"

    "CompositionFunctors" ":" "{"
        BicategoryCompositionFunctor ::= "∘_ABC" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ";"
        TYPING
            (* Composition is the coend formula. It's a functor from the product of hom-categories. *)
            Action_on_Objects(D2, D1) := D2 ∘ D1 := ∫^{b∈B} D2(-,b) × D1(b,-)
            Action_on_Morphisms(β, α) := ... (the induced natural transformation on coends)
            --------------------------------------------------------------------------------
            Γ ⊢ ∘_ABC : Functor(Dist(B,C) × Dist(A,B), Dist(A,C)) ;
        CATEGORY
            [[ ∘_ABC ]] = "The composition of distributors via the coend formula. This operation is functorial." ;
    "}" ";"

    "IdentityFunctors" ":" "{"
        BicategoryIdentityFunctor ::= "Id_A" ":" "1 → HOM_CATEGORY(A,A)" ";"
        TYPING
            (* The identity distributor on A is its hom-functor, Hom_A(-,-). *)
            Action_on_Object(*) := Hom_A(-,-) : A^op × A → Set
            -------------------------------------------------
            Γ ⊢ Id_A : Functor(TerminalCategory, Dist(A,A)) ;
        CATEGORY
            [[ Id_A ]] = "The identity functor that picks out the hom-functor `Hom_A` as the identity distributor on object A. It serves as the identity 1-morphism in `Dist`." ;
    "}" ";"
"}" ";"

"CONSTRAINTS" "{"
    Constraint_Associator ::= "associator" "α" ":" "(∘)∘" "≅" "∘(∘)" ";"
    TYPING
        (* For distributors, composition is NOT strictly associative. *)
        (* (D3 ∘ D2) ∘ D1 is NOT equal to D3 ∘ (D2 ∘ D1). *)
        (* However, there is a canonical, natural ISOMORPHISM between them from properties of coends. *)
        LHS_Functor := ∘_ADC ∘ (Id × ∘_ABC)
        RHS_Functor := ∘_DBC ∘ (∘_ABC × Id)
        ------------------------------------------------------------------------------
        Γ ⊢ α : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ associator α ... ]] = "The non-trivial associator for distributor composition. The isomorphism arises from the fact that iterated coends can be reordered, i.e., ∫^{c} (∫^{b} D3(d,c)×D2(c,b)) × D1(b,a) ≅ ∫^{b} D3(d,c) × (∫^{c} D2(c,b)×D1(b,a)). This makes `Dist` a canonical example of a bicategory that is not a strict 2-category." ;

    Constraint_LeftUnitor ::= "left_unitor" "λ" ":" "Id∘" "≅" "Id" ";"
    TYPING
        (* The Hom_B functor is only a left unit up to isomorphism. Hom_B ∘ D is not equal to D. *)
        (* The Yoneda Lemma provides the canonical isomorphism: ∫^{b∈B} Hom_B(c,b) × D(b,a) ≅ D(c,a) *)
        LHS_Functor := ∘_ACB ∘ (Id_B × Id)
        RHS_Functor := Id_{Dist(A,B)}
        ------------------------------------------------
        Γ ⊢ λ : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ left_unitor λ ]] = "The non-trivial left unitor for distributor composition. Its existence and naturality are a direct consequence of the Yoneda Lemma, which provides the canonical isomorphism making the hom-functor a weak unit. This demonstrates how fundamental category theory results manifest as structural components in higher categories." ;

    Constraint_RightUnitor ::= "right_unitor" "ρ" ":" "∘Id" "≅" "Id" ";"
    TYPING
        (* Symmetrically, the right unit law holds only up to a canonical isomorphism given by the co-Yoneda Lemma. *)
        LHS_Functor := ∘_ABC ∘ (Id × Id_A)
        RHS_Functor := Id_{Dist(A,B)}
        -------------------------------------------------
        Γ ⊢ ρ : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ right_unitor ρ ]] = "The non-trivial right unitor for distributor composition, arising from the co-Yoneda Lemma. The necessity of these non-trivial associator and unitor isomorphisms is what makes `Dist` the quintessential example of a bicategory." ;
"}" ";"


"}" ;

}

(* ========================================================================================================== )
( == Part 1A: Deconstructing the DATA block == )
(* ========================================================================================================== *)

HomCategoryDeclaration ::= "HOM_CATEGORY" "(" Identifier "," Identifier ")" ;
TYPING
Context: C is a Bicategory
Γ ⊢ A, B : Object_in(C)
Objects(HOM_CATEGORY(A,B)) := {f | f is 1-morphism from A to B in C}
Morphisms(HOM_CATEGORY(A,B)) := {α | α is 2-morphism between 1-morphisms from A to B in C}
------------------------------------------------------------------------------------------------
Γ ⊢ HOM_CATEGORY(A, B) : Category ;
CATEGORY
[[ HOM_CATEGORY(A, B) ]] = "The hom-category C(A,B). Its objects are the 1-cells, its morphisms are the 2-cells, and its composition is vertical composition of 2-cells." ;

BicategoryCompositionFunctor ::= "∘_ABC" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ;
TYPING
(* Horizontal composition is not just an operation, it's a functor. *)
Γ ⊢ C_BC : HOM_CATEGORY(B,C), Γ ⊢ C_AB : HOM_CATEGORY(A,B), Γ ⊢ C_AC : HOM_CATEGORY(A,C)
-----------------------------------------------------------------------------------------
Γ ⊢ ∘_ABC : Functor( C_BC × C_AB, C_AC ) ;
CATEGORY
[[ ∘_ABC ]] = "The horizontal composition functor for the triple (A,B,C). Its functoriality weakly encodes the interchange law." ;

BicategoryIdentityFunctor ::= "Id_A" ":" "1 → HOM_CATEGORY(A,A)" ;
TYPING
(* The identity 1-cell is picked out by a functor. *)
Γ ⊢ C_AA : HOM_CATEGORY(A,A)
-------------------------------------------
Γ ⊢ Id_A : Functor( TerminalCategory, C_AA ) ;
CATEGORY
[[ Id_A ]] = "The identity functor for the object A, which selects the identity 1-morphism id_A from the hom-category C(A,A)." ;

(* ========================================================================================================== )
( == Part 1B: Deconstructing the CONSTRAINTS block == )
(* ========================================================================================================== *)

Constraint_Associator ::= "associator" "α" ":" "(∘)∘" "≅" "∘(∘)" ;
TYPING
(*
* This defines the associator α as a natural isomorphism. For any triple of composable functors
* F: A->B, G: B->C, H: C->D, its component is α_{H,G,F} : (H∘G)∘F ⇒ H∘(G∘F).
* It is a natural isomorphism between two functors from C(C,D)×C(B,C)×C(A,B) to C(A,D)
*)
CompFunctor1 := ∘_ACD ∘ (∘_ABC × Id)
CompFunctor2 := ∘_ABD ∘ (Id × ∘_BCD)
---------------------------------------------------------------------------------------
Γ ⊢ α : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ associator α ... ]] = "The associator isomorphism. It is a natural transformation whose components α_{h,g,f} are invertible 2-cells witnessing that composition is associative up to a coherent isomorphism." ;

Constraint_LeftUnitor ::= "left_unitor" "λ" ":" "Id∘" "≅" "Id" ;
TYPING
(* The left unitor λ is a natural isomorphism whose component λ_f witnesses that Id_B ∘ f is isomorphic to f. )
CompFunctor1 := ∘_ABB ∘ (Id_B × Id) ( Functor for composing with Id_B on the left )
CompFunctor2 := Id_{C(A,B)} ( The identity functor on the hom-category *)
------------------------------------------------------------------------------
Γ ⊢ λ : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ left_unitor λ ... ]] = "The left unitor isomorphism. It is a natural transformation whose components λ_f are invertible 2-cells witnessing that the identity 1-morphism acts as a left unit up to a coherent isomorphism." ;

Constraint_RightUnitor ::= "right_unitor" "ρ" ":" "∘Id" "≅" "Id" ;
TYPING
(* The right unitor ρ is a natural isomorphism whose component ρ_f witnesses that f ∘ Id_A is isomorphic to f. )
CompFunctor1 := ∘_AAB ∘ (Id × Id_A) ( Functor for composing with Id_A on the right )
CompFunctor2 := Id_{C(A,B)} ( The identity functor on the hom-category *)
-------------------------------------------------------------------------------
Γ ⊢ ρ : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ right_unitor ρ ... ]] = "The right unitor isomorphism. It is a natural transformation whose components ρ_f are invertible 2-cells witnessing that the identity 1-morphism acts as a right unit up to a coherent isomorphism." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.8: Distributors" ")" "==>" {
(*

ELABORATION: A distributor (also called a profunctor or bimodule) is a generalization of a relation
and of a functor. It provides a powerful way to relate two different categories. The collection of
all small categories forms a bicategory where the 1-morphisms are these distributors.

To elaborate, we will:

Formalize the Distributor: Define a distributor D: A ⇸ B as a functor B^op × A → Set.

Formalize Composition: Define the composition of distributors via the tensor product-like
coend formula.

Formalize the Bicategory of Distributors: Assert that small categories, distributors, and
natural transformations form a bicategory, Dist.

*)

(* ========================================================================================================== )
( == Part 1: The Distributor and its Composition == )
( ========================================================================================================== *)

DistributorDeclaration ::= "DISTRIBUTOR" Identifier ":" Identifier "⇸" Identifier ;
TYPING
(* A distributor D from A to B is a functor of type B^op × A → Set. *)
Γ ⊢ A, B : Category

Γ ⊢ DISTRIBUTOR D : A ⇸ B : Functor(B^op × A, Set) ;
CATEGORY
[[ DISTRIBUTOR D : A ⇸ B ]] = "A profunctor, or bimodule, from A to B. It can be seen as a 'category-indexed matrix of sets', providing a generalized way to relate objects from A to objects from B." ;

DistributorComposition ::= DistributorDeclaration "∘" DistributorDeclaration ;
TYPING
(*

The composition of D1:A⇸B and D2:B⇸C is a distributor D3:A⇸C defined by a coend integral.

This is a complex construction, which we represent abstractly.
*)
Γ ⊢ D1 : DISTRIBUTOR(A ⇸ B), Γ ⊢ D2 : DISTRIBUTOR(B ⇸ C)
D3(a, c) := ∫^{b ∈ B} D2(c, b) × D1(b, a) ( The coend formula *)

Γ ⊢ D2 ∘ D1 : DISTRIBUTOR(A ⇸ C) ;
CATEGORY
[[ D2 ∘ D1 ]] = "The composition of distributors, defined by the coend. This operation generalizes matrix multiplication and is the 1-morphism composition in the bicategory of distributors." ;

(* ========================================================================================================== )
( == Part 2: The Bicategory Dist == )
( ========================================================================================================== *)

BicategoryOfDistributors ::= "Dist" ;
TYPING
(* We can now formally describe the bicategory Dist. *)
Objects(Dist) := { C | C is a small Category }
1-Morphisms(Dist) from A to B := { D | D is a DISTRIBUTOR A ⇸ B }
2-Morphisms(Dist) from D1 to D2 := { α | α is a NaturalTransformation D1 ⇒ D2 }

Γ ⊢ Dist is a BICATEGORY ;
CATEGORY
[[ Dist ]] = "The bicategory of small categories, distributors, and natural transformations. The composition of distributors is only associative up to isomorphism, making this a canonical example of a non-strict 2-category (a true bicategory)." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.9: Cauchy completeness versus distributors" ")" "==>" {
(*

ELABORATION: This final section provides a powerful, modern characterization of Cauchy
completeness (from Chapter 6) in the language of distributors. It states that a category
is Cauchy complete if and only if its identity distributor is "idempotent" in the bicategory
Dist and this idempotent "splits". This gives a purely algebraic, representation-theoretic test
for what was previously defined via idempotent endomorphisms.

To elaborate, we will:

Formalize the Players: Define the IdentityDistributor (which is Hom_C(-,-)) and the OppositeDistributor (the transpose). These are the key objects in the main theorem.

Formalize the Theorem: State the theorem that a category C is Cauchy complete if and only if its identity distributor IdDist(C) can be factored as D^op ∘ D for some distributor D from the terminal category 1 to C.

Interpret the Theorem: Explain this factorization as a form of "matrix decomposition," where the distributor D acts like a "column vector" of objects, and D^op acts like a "row vector". This reveals that Cauchy completeness is equivalent to the identity being representable by a 'basis' of objects, making the connection to representation theory explicit.

*)

(* ========================================================================================================== )
( == Part 1: The Players == )
(* ========================================================================================================== *)
(The theorem relies on two specific distributor constructions.)

IdentityDistributor ::= "IdDist" "(" Identifier ")" ;
TYPING
(* The identity distributor on a category C is its Hom-functor. *)
Γ ⊢ C : Category
Hom_C : C^op × C → Set
---------------------------------------------------------------
Γ ⊢ IdDist(C) : DISTRIBUTOR(C ⇸ C) (where IdDist(C) == Hom_C) ;
CATEGORY
[[ IdDist(C) ]] = "The identity distributor on C, which is simply the hom-functor of C. It serves as the identity 1-morphism for the object C in the bicategory Dist." ;

OppositeDistributor ::= Identifier "^op" ;
TYPING
(* The opposite of a distributor D:A⇸B is a distributor D^op:B⇸A. *)
Γ ⊢ D : DISTRIBUTOR(A ⇸ B)
D^op(a, b) := D(b, a)
----------------------------------------
Γ ⊢ D^op : DISTRIBUTOR(B ⇸ A) ;
CATEGORY
[[ D^op ]] = "The opposite or transpose of a distributor D. If D is seen as a matrix, D^op is its transpose. This operation turns a distributor A⇸B into one from B⇸A." ;

(* ========================================================================================================== )
( == Part 2: The Characterization Theorem == )
(* ========================================================================================================== *)

IdempotentCompletenessAsDistributorFactorization ::= "THEOREM" "CauchyCompletenessViaDistributors" ":"
"(" Identifier "C is CAUCHY_COMPLETE" ")" "<==>"
"(∃ D:1⇸C s.t. IdDist(C) ≅ D^op ∘ D)" ;
TYPING
(*
* This is the formal typing of the main theorem.
* The existence of the factorization is equivalent to the idempotent-splitting property.
*)
P1 := (Γ ⊢ C is CAUCHY_COMPLETE)
P2 := ∃ (D : DISTRIBUTOR(1 ⇸ C)) s.t. (IdDist(C) ≅ (D^op ∘ D))
---------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CauchyCompletenessViaDistributors ]] = "A deep characterization theorem connecting two major concepts. It asserts that a category's internal structural property of being idempotent-complete (Cauchy complete) is equivalent to the external, representational property that its identity distributor can be 'factored' through the terminal category. The distributor D:1⇸C can be seen as picking out a single 'object of objects' (a presheaf), and the factorization D^op ∘ D reconstructs the original category's Hom sets from this single object. This reveals Cauchy completeness as a form of representability." ;
}
