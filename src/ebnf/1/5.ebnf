MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.1: Graphs and path categories" ")" "==>" {
(*

ELABORATION: This section lays the groundwork for categories of fractions by defining their
fundamental building block: the free category generated by a graph. To elaborate, we will:

Formalize the "Graph" (or Quiver) as the raw, lawless substrate for a category.
This is the same as the PreCategory defined previously, so we will establish that synonym.

Define a "Path" as a sequence of composable arrows in a graph.

Define the "Path Category" (or "Free Category") construction, which takes a graph and
generates a category whose morphisms are these paths.

Formalize the Universal Property of this construction, which states that the path category
functor is the left adjoint to the forgetful functor from Cat to Graph. This is the definition
of "freeness".

*)

(* ========================================================================================================== )
( == Part 1: The Substrate (Graphs/Quivers) == )
( ========================================================================================================== *)

GraphDeclaration ::= "GRAPH" Identifier "has" "{" "Vertices" ":" {Identifier} ";" "Arrows" ":" {MorphismDeclaration} ";" "}" ;
TYPING
(* This is definitionally identical to a PreCategory, which we defined in Chapter 1. *)
(Γ ⊢ GRAPH G ... : DirectedGraph) <==> (Γ ⊢ PRECATEGORY G ... : PreCategory) ;
CATEGORY
[[ GRAPH G ... ]] = "The definition of a directed multigraph (or quiver) G. This structure contains the data of vertices (nodes) and arrows (edges) but imposes no laws of composition or identity. It is the raw material from which a category can be freely generated." ;

(* ========================================================================================================== )
( == Part 2: The Morphisms (Paths) == )
( ========================================================================================================== *)

PathDeclaration ::= "PATH" "(" Identifier { "∘" Identifier } ")" "from" Identifier "to" Identifier ;
TYPING
(* A path is a sequence of one or more composable arrows from the underlying graph. *)
Context: Graph G
Path = (a_n, ..., a_1) where a_i : X_{i-1} -> X_i is an Arrow in G.
Domain = Source(a_1), Codomain = Target(a_n)
---------------------------------------------------------------------------------
Γ ⊢ PATH (a_n ∘ ... ∘ a_1) ... : PathIn(G) ;
CATEGORY
[[ PATH (a_n ∘ ... ∘ a_1) ... ]] = "A finite, non-empty sequence of composable arrows in the underlying graph. This represents a directed walk through the graph." ;

IdentityPathDeclaration ::= "id_path_at" "(" Identifier ")" ;
TYPING
(* An identity path is an empty path at a given vertex. *)
Context: Graph G
Γ ⊢ v : Vertex_in(G)
-------------------------------------------
Γ ⊢ id_path_at(v) : PathIn(G) ;
CATEGORY
[[ id_path_at(v) ]] = "The empty path at vertex v. This will become the identity morphism on object v in the resulting path category." ;

(* ========================================================================================================== )
( == Part 3: The Free Category Construction and its Universal Property == )
( ========================================================================================================== *)

PathCategoryConstructor ::= "FreeCategory" "(" Identifier ")" ;
TYPING
(* This constructor takes a graph and returns a category. *)
Γ ⊢ G : DirectedGraph
C_Objects := Vertices(G)
C_Morphisms := {p | Γ ⊢ p : PathIn(G)}
C_Composition := Path Concatenation
C_Identities := {id | Γ ⊢ id : IdentityPathDeclaration}
----------------------------------------------------------
Γ ⊢ FreeCategory(G) : Category ;
CATEGORY
[[ FreeCategory(G) ]] = "The path category generated by the graph G. Its objects are the vertices of G, and its morphisms are the paths in G. Composition is concatenation of paths. This is the 'freest' possible category satisfying the structure specified by G." ;

TheoremDeclaration ::= "THEOREM" "PathCategoryAdjunction" ":"
"(" "FreeCategory" "is" "LeftAdjoint" "to" "ForgetfulFunctor_CatToGraph" ")" ;
TYPING
(*
* This theorem formalizes the universal property of the path category.
* The forgetful functor U: Cat -> Graph "forgets" composition laws.
* The FreeCategory functor P: Graph -> Cat constructs the path category.
* The adjunction P ⊣ U means there is a natural isomorphism:
* Hom_Cat(P(G), C) ≅ Hom_Graph(G, U(C))
*)
Γ ⊢ P : Functor(Graph, Cat), Γ ⊢ U : Functor(Cat, Graph)
----------------------------------------------------------
Γ ⊢ P ⊣ U : Adjunction ;
CATEGORY
[[ THEOREM PathCategoryAdjunction ... ]] = "The assertion that the Free Category construction is left adjoint to the forgetful functor. This isomorphism means that a category homomorphism from the path category P(G) to any other category C is uniquely determined by a simple graph homomorphism from G to the graph underlying C. This is the formal definition of 'freeness'." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.2: Calculus of fractions" ")" "==>" {
(*

ELABORATION: This section introduces the "calculus of fractions," a set of conditions that,
when met, allow the abstract process of inverting morphisms to be described by a concrete
construction using "spans" (also known as "roofs"). To elaborate, we will:

Formalize the Abstract Goal: Define the category of fractions C[S⁻¹] and its universal
property, which is the abstract goal of localization.

Define the Conditions: Formalize the Ore Conditions for a (right) calculus of
fractions as a series of explicit axioms that a class of morphisms S must satisfy.

Formalize the Concrete Construction: Define the objects and morphisms (as spans/roofs)
of the category of fractions that can be built when the Ore conditions hold, and define
the equivalence relation between these spans.

State the Main Theorem: Assert the theorem that if S admits a calculus of fractions,
then the abstract category of fractions is equivalent to the one built via the concrete
span construction.

*)

(* ========================================================================================================== )
( == Part 1: The Abstract Goal (Localization) == )
( ========================================================================================================== *)

CategoryOfFractions ::= Identifier "[" Identifier "⁻¹" "]" ;
TYPING
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
-------------------------------------------------
Γ ⊢ C[S⁻¹] : Category ;
CATEGORY
[[ C[S⁻¹] ]] = "The category of fractions (or localization) of C with respect to S. It is a new category obtained by universally adding formal inverses for all morphisms in S." ;

LocalizationFunctor ::= "L" ":" Identifier "→" CategoryOfFractions ;
TYPING
(* This defines the localization functor and its universal property. *)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
UniversalProperty := ∀ (F:C→D where ∀s∈S, F(s) is ISOMORPHISM),
∃! (F_bar : C[S⁻¹] → D) s.t. (F_bar ∘ L == F)
----------------------------------------------------------------------------------------------------
Γ ⊢ L : C → C[S⁻¹] : FunctorWith(UniversalProperty) ;
CATEGORY
[[ L : C → C[S⁻¹] ]] = "The canonical localization functor. It is the universal solution for mapping C to a category where all morphisms in S become isomorphisms." ;

(* ========================================================================================================== )
( == Part 2: The Conditions for a Concrete Construction (Ore Conditions) == )
( ========================================================================================================== *)

admitsRightCalculusOfFractions ::= Identifier "admits" "RIGHT_CALCULUS_OF_FRACTIONS" ;
TYPING
(* A class of morphisms S admits a right calculus of fractions if it satisfies three axioms. *)
Γ ⊢ S : ClassOfMorphisms(C)
Axiom1(S): S contains all isomorphisms and is closed under composition.
Axiom2_Ore(S): ∀ (f:X→Y), ∀ (s:Z→Y∈S), ∃ pullback square for (f,s) with t:W→X∈S.
Axiom3_Cancel(S): ∀ (f,g:X→Y), (∃s:Z→X∈S s.t. f∘s == g∘s) ⇒ (∃t:Y→W∈S s.t. t∘f == t∘g).
---------------------------------------------------------------------------------------
Γ ⊢ S admits RIGHT_CALCULUS_OF_FRACTIONS : BooleanProposition ;
CATEGORY
[[ S admits RIGHT_CALCULUS_OF_FRACTIONS ]] = "The assertion that the class of morphisms S is 'well-behaved' enough to allow for the concrete construction of the category of fractions. The Ore condition is key, as it allows reordering of morphisms and fractions (composition of spans)." ;

(* ========================================================================================================== )
( == Part 3: The Concrete Construction (Spans/Roofs) == )
( ========================================================================================================== *)

RightFractionSpan ::= "SPAN" "(" "f" ":" Identifier "→" Identifier "," "s" ":" Identifier "→" Identifier ")" ;
TYPING
(*
* A right fraction is a morphism from X to Y represented by a span (an apex A with two legs).
* The leg s points to the domain X and must be in the class S.
* The leg f points to the codomain Y.
* Conventionally this is written f s⁻¹.
*)
Context: S admits RIGHT_CALCULUS_OF_FRACTIONS in C
Γ ⊢ A, X, Y : Object_in(C)
Γ ⊢ f : A -> Y, Γ ⊢ s : A -> X
s ∈ S
----------------------------------------------------------------------
Γ ⊢ SPAN(f,s) : Morphism(X, Y) in C[S⁻¹] ;
CATEGORY
[[ SPAN(f:A->Y, s:A->X) ]] = "A morphism in the category of fractions from X to Y, represented as a 'roof' or 'span' (Y ←f-- A --s→ X) where s ∈ S. It represents the abstract composition f ∘ (L(s))⁻¹." ;

EquivalenceOfRightFractions ::= RightFractionSpan "∼" RightFractionSpan ;
TYPING
(* Defines the equivalence relation on the spans. Two spans are equivalent if a third, 'narrower' span exists that makes them equal. *)
Γ ⊢ span1 = SPAN(f1:A1→Y, s1:A1→X)
Γ ⊢ span2 = SPAN(f2:A2→Y, s2:A2→X)
Condition := ∃ (A3:Object, g1:A3→A1, g2:A3→A2) s.t. ( (s1∘g1 == s2∘g2) ∧ (f1∘g1 == f2∘g2) )
-------------------------------------------------------------------------------------------
Γ ⊢ (span1 ∼ span2) is TRUE if Condition holds : EquivalenceRelation ;
CATEGORY
[[ span1 ∼ span2 ]] = "The equivalence relation on fractions. Two fractions are equivalent if they can be shown to be equal by extending them to a common 'denominator' domain." ;

(* ========================================================================================================== )
( == Part 4: The Main Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CalculusOfFractionsEquivalence" ":"
"IF" "(" Identifier "S" "admits" "RIGHT_CALCULUS_OF_FRACTIONS" ")" "THEN"
"(" Identifier "C" "[" Identifier "S" "⁻¹" "]" "≅" "CategoryOf(EquivClassOf(RightFractionSpan))" ")" ;
TYPING
P1 := (Γ ⊢ S admits RIGHT_CALCULUS_OF_FRACTIONS)
ConcreteCategory := Category whose morphisms are equivalence classes of RightFractionSpan
P2 := (Γ ⊢ C[S⁻¹] ≅ ConcreteCategory)
--------------------------------------------------------
Γ ⊢ (P1 ⇒ P2) : MetaTheorem ;
CATEGORY
[[ THEOREM CalculusOfFractionsEquivalence ]] = "The assertion that when the Ore conditions hold, the abstract, universal definition of the category of fractions and the concrete construction using equivalence classes of spans are equivalent. This provides a powerful tool for working with localizations in a tangible way." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.3: Reflecting subcategories as categories of fractions" ")" "==>" {
(*

ELABORATION: This section builds a crucial bridge between two major concepts: the abstract
notion of a reflective subcategory (from Chapter 3) and the more concrete mechanism of
localization (from the previous section). It shows that reflection is a form of localization.
To elaborate, we will:

Formalize the Bridge: Define the specific class of morphisms Σ_L that are inverted by
the reflector functor L of a reflective subcategory.

State the Main Theorem: Formalize the theorem that asserts the equivalence between
the reflective subcategory A and the category of fractions B[Σ_L⁻¹] of the ambient
category B.

Provide a Concrete Example: Illustrate this theorem with the canonical example of Ab
(Abelian Groups) as a reflective subcategory of Grp (Groups). This makes the abstract
equivalence tangible.

*)

(* ========================================================================================================== )
( == Part 1: The Bridge (Morphisms Inverted by a Functor) == )
( ========================================================================================================== *)

MorphismClassInvertedByFunctor ::= "Σ_" Identifier ;
TYPING
(*
* This constructor defines a class of morphisms in a functor's domain. The class consists
* of all morphisms that the functor maps to isomorphisms in its codomain.
*)
Γ ⊢ L : Functor(B, A)
---------------------------------------------------------------------------------------------
Γ ⊢ Σ_L : ClassOfMorphisms(B) where s ∈ Σ_L <==> (L(s) is ISOMORPHISM in A) ;
CATEGORY
[[ Σ_L ]] = "The class of morphisms in B that are 'L-equivalences'. The functor L does not distinguish between the domain and codomain of these morphisms, collapsing them into isomorphisms. This is the precise class of morphisms we need to formally invert." ;

(* ========================================================================================================== )
( == Part 2: The Main Equivalence Theorem == )
( ========================================================================================================== *)

ReflectiveSubcategoryAsLocalizationTheorem ::= "THEOREM" "ReflectiveSubcategoryAsLocalization" ":"
"IF" "(" Identifier "A" "is" "REFLECTIVE_IN" Identifier "B" "with reflector" Identifier "L" ")" "THEN"
"(" "A" "≅" Identifier "B" "[" "Σ_" Identifier "⁻¹" "]" ")" ;
TYPING
(* This is the formal typing of the main theorem. *)
Premise1: Γ ⊢ A is REFLECTIVE_IN B
Premise2: Γ ⊢ L = Reflector(B, A) : Functor(B, A)
Premise3: Γ ⊢ Σ_L = MorphismClassInvertedByFunctor(L)
Conclusion: Γ ⊢ A ≅ B[Σ_L⁻¹] : EquivalenceOfCategories
-------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ReflectiveSubcategoryAsLocalization ]] = "A fundamental theorem connecting reflection and localization. It asserts that any reflective subcategory A is equivalent to the localization of its ambient category B with respect to the class of morphisms that the reflector L inverts. This provides a powerful mechanism for understanding the structure of reflective subcategories." ;

(* ========================================================================================================== )
( == Part 3: A Concrete Example (Abelian Groups in Groups) == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "AbelianizationAsLocalization" "of" ReflectiveSubcategoryAsLocalizationTheorem ;
TYPING
(* Here we apply the general theorem to a specific, well-known case. *)
-- Define the context
A := Category("Ab")
B := Category("Grp")
-- Check the theorem's premises
P1: Γ ⊢ Ab is REFLECTIVE_IN Grp (This is a known result)
P2: L := AbelianizationFunctor : Functor(Grp, Ab) (This is the reflector)
P3: Σ_L := {s ∈ Mor(Grp) | L(s) is an isomorphism in Ab} (These are group homomorphisms whose kernel is contained within the commutator subgroup of the domain)

Generated code
-- Apply the theorem's conclusion
Conclusion: Γ ⊢ Ab ≅ Grp[Σ_L⁻¹] : EquivalenceOfCategories
-----------------------------------------------------------------------------------------
Γ ⊢ INSTANCE ... : ProvableProposition ;


CATEGORY
[[ INSTANCE AbelianizationAsLocalization ... ]] = "A concrete application of the main theorem. It states that the category of Abelian Groups (Ab) is equivalent to the category of all Groups (Grp) where all morphisms that 'kill' the commutator subgroup have been formally inverted. This shows that the process of 'abelianizing' a group is an instance of localization." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.4: The orthogonal subcategory problem" ")" "==>" {
(*

ELABORATION: This section addresses the question: when does the collection of objects "orthogonal"
to a given set of morphisms form a reflective subcategory? To elaborate, we will:

Formalize Orthogonality: Generalize the _ ⊥ _ predicate for orthogonality between
any two arbitrary morphisms.

Define the Orthogonal Subcategory: Construct the full subcategory whose objects are
defined by their orthogonality to a given class of morphisms. This formalizes S⊥.

State the Main Theorem: Formalize the theorem (a form of the Orthogonal Subcategory Theorem)
which provides sufficient conditions (namely, cocompleteness of the ambient category) for this
orthogonal subcategory to be reflective. This solves the "problem."

*)

(* ========================================================================================================== )
( == Part 1: Formalizing Orthogonality between Morphisms == )
( ========================================================================================================== *)

MorphismOrthogonality ::= Identifier "⊥" Identifier ;
TYPING
(*
* This defines the proposition e ⊥ m. It holds if for every commutative square
* involving e and m, there exists a unique diagonal filler. This generalizes the
* property used to define Strong Epimorphisms.
*)
Γ ⊢ e : A -> B, Γ ⊢ m : C -> D
Condition := ∀ (f:A→C, g:B→D s.t. g∘e == m∘f), ∃! (d:B→C s.t. d∘e==f ∧ m∘d==g)
--------------------------------------------------------------------------------
Γ ⊢ (e ⊥ m) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ e ⊥ m ]] = "The assertion that morphism e is left-orthogonal to morphism m. This is the fundamental 'diagonal fill-in' property. e acts like a quotienting map, while m acts like a subobject inclusion, and the property ensures they are compatible in a strong way." ;

(* ========================================================================================================== )
( == Part 2: Defining the Orthogonal Subcategory == )
( ========================================================================================================== *)

OrthogonalSubcategoryConstructor ::= Identifier "⊥" ;
TYPING
(*
* This constructor takes a class of morphisms S and produces a new category, S⊥.
* S⊥ is the full subcategory of the ambient category C whose objects are orthogonal
* to every morphism in S.
*)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
A_Objects := { X ∈ Ob(C) | Γ ⊢ IsSLocal(X, S) }
--------------------------------------------------------------------
Γ ⊢ S⊥ : FullSubcategory(C) on objects A_Objects ;
CATEGORY
[[ S⊥ ]] = "The full subcategory of S-local (or S-orthogonal) objects. This is the collection of all objects in the ambient category that 'see' no difference between the domain and codomain of any morphism in S." ;

IsSLocal ::= "IsSLocal" "(" Identifier "," Identifier ")" ;
TYPING
Γ ⊢ X : Object_in(C), Γ ⊢ S : ClassOfMorphisms(C)
Condition := ∀(s: A→B ∈ S), the map (f ↦ f∘s) : Hom_C(B,X) → Hom_C(A,X) is an ISOMORPHISM.
-------------------------------------------------
Γ ⊢ IsSLocal(X, S) : BooleanProposition ;
CATEGORY
[[ IsSLocal(X, S) ]] = "The property of an object X being 'S-local'. It means that from the perspective of X, all morphisms in S are already isomorphisms. This is the precise meaning of an object being 'orthogonal' to the class S." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Solving the Problem) == )
( ========================================================================================================== *)

OrthogonalSubcategoryTheorem ::= "THEOREM" "OrthogonalSubcategoryIsReflective" ":"
"IF" "(" Identifier "B" "is" "COCOMPLETE and WELL-POWERED" "and S is a set of morphisms" ")" "THEN"
"(" "S⊥" "is" "REFLECTIVE_IN" "B" ")" ;
TYPING
(* This is a classic result often proven using the Adjoint Functor Theorem. *)
Premise1: Γ ⊢ B : Category
Premise2: B is COCOMPLETE and WELL-POWERED (Sufficient conditions for small solution sets)
Premise3: S is a SET of morphisms in B.
Conclusion: Γ ⊢ S⊥ is REFLECTIVE_IN B
-------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM OrthogonalSubcategoryIsReflective ]] = "A powerful existence theorem that solves the orthogonal subcategory problem. It provides sufficient conditions on the ambient category B for the subcategory of S-orthogonal objects to be reflective. The proof typically involves showing that the inclusion functor of S⊥ has a left adjoint (the reflector), whose existence is guaranteed by an application of the Adjoint Functor Theorem." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.5: Factorization systems" ")" "==>" {
(*

ELABORATION: This section elevates the concept of factorization from an ad-hoc decomposition
to a fundamental structural property of a category. A factorization system (E, M) is a
pair of classes of morphisms that are perfectly "orthogonal" to each other, allowing every
morphism in the category to be uniquely factored through them. To elaborate, we will:

Formalize the Master Definition: We will refine the previous definition of a
Factorization System to be based on the elegant and powerful condition of orthogonality
between the two classes of morphisms, E ⊥ M.

Enumerate the Axioms: The definition requires that E and M are "well-behaved"
(contain isomorphisms, closed under composition), that every morphism has a factorization,
and that the classes are orthogonal. We will formalize these as axioms.

Connect to the Main Example: Re-state the theorem that the pair (StrongEpi, Mono)
forms a factorization system, explicitly showing how it satisfies the orthogonality axiom.

Derive the Dual System: Use the Duality Principle to show that the dual pair (Epi, StrongMono)
also forms a valid factorization system, demonstrating the symmetry of the concept.

*)

(* ========================================================================================================== )
( == Part 1: The Master Definition via Orthogonality == )
( ========================================================================================================== *)

FactorizationSystem ::= "(" Identifier "," Identifier ")" ;
TYPING
Γ ⊢ E : ClassOfMorphisms, Γ ⊢ M : ClassOfMorphisms
------------------------------------------------------
Γ ⊢ (E, M) : PutativeFactorizationSystem ;
CATEGORY
[[ (E, M) ]] = "A pair of classes of morphisms, E and M, intended to form a factorization system." ;

CategoryPropertyDefinition ::= Identifier "has" "FACTORIZATION_SYSTEM" FactorizationSystem ;
TYPING
(*
* This is the refined, modern definition. A category has a factorization system (E, M) if
* every morphism f has an (E, M)-factorization AND the two classes are orthogonal.
* The orthogonality E ⊥ M guarantees the uniqueness of the factorization up to isomorphism.
*)
Γ ⊢ C : Category, Γ ⊢ (E, M) : PutativeFactorizationSystem
Premise1: AllIsomorphisms(C) ⊆ E ∩ M
Premise2: ∀ (f ∈ Mor(C)), ∃ (e∈E, m∈M) s.t. f == m ∘ e
Premise3: E ⊥ M (Orthogonality Condition)
-------------------------------------------------------------------
Γ ⊢ C has FACTORIZATION_SYSTEM (E, M) : PropositionAbout(C) ;
CATEGORY
[[ C has FACTORIZATION_SYSTEM (E, M) ]] = "A fundamental property of a category C, ensuring that every arrow can be uniquely and functorially decomposed into an 'E-part' followed by an 'M-part'. The orthogonality of E and M is the key coherence condition that guarantees this uniqueness." ;

ClassOrthogonality ::= Identifier "⊥" Identifier ;
TYPING
(* This predicate asserts that every morphism in class E is left-orthogonal to every morphism in class M. *)
Γ ⊢ E : ClassOfMorphisms, Γ ⊢ M : ClassOfMorphisms
Condition := ∀ (e ∈ E), ∀ (m ∈ M), (Γ ⊢ e ⊥ m)
-----------------------------------------------------------
Γ ⊢ (E ⊥ M) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ E ⊥ M ]] = "The assertion of orthogonality between two classes of morphisms. This single, powerful condition ensures that the factorization of any morphism is unique up to a unique isomorphism." ;

(* ========================================================================================================== )
( == Part 2: The Canonical Example (StrongEpi, Mono) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "StrongEpiMonoIsFactorizationSystem" ":"
"IF" "(" Identifier "C has necessary (co)limits" ")" "THEN"
"(" "C has FACTORIZATION_SYSTEM" "(" "StrongEpi" "," "Mono" ")" ")" ;
TYPING
(*
* To prove this theorem, we must verify the axioms for the pair (StrongEpi, Mono).
* Premise 1 (isos) and Premise 2 (existence) are non-trivial but standard results.
* Premise 3, Orthogonality, holds by the very DEFINITION of a Strong Epimorphism.
*)
Context: Γ ⊢ C : Category
E := {f | f is STRONG_EPIMORPHISM}, M := {f | f is MONOMORPHISM}
OrthogonalityCheck: By definition, e ∈ StrongEpi means e ⊥ m for all m ∈ Mono. Thus, StrongEpi ⊥ Mono.
------------------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM StrongEpiMonoIsFactorizationSystem ]] = "The assertion that the classes of strong epimorphisms and monomorphisms form the canonical factorization system in many categories. The orthogonality required by the definition is satisfied by the very definition of a strong epimorphism, making this a natural and fundamental pairing." ;

(* ========================================================================================================== )
( == Part 3: The Dual System via Duality Principle == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'EpiStrongMonoIsFactorizationSystem'" "FROM" "THEOREM" "'StrongEpiMonoIsFactorizationSystem'" ;
TYPING
(*
* We apply the duality operator to the canonical theorem.
* The system uses the DualityMapping dictionary to perform rewrites:
* 1. StrongEpi -> StrongMono (dual-of definition from 4.3)
* 2. Mono -> Epi
* The result is the statement that (Epi, StrongMono) is also a factorization system.
*)
Γ ⊢ THEOREM 'StrongEpiMonoIsFactorizationSystem' : P_canonical
P_dual = rewrite(P_canonical, DualityMappings)
----------------------------------------------------------------
Γ ⊢ THEOREM 'EpiStrongMonoIsFactorizationSystem' : P_dual ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the existence of the dual factorization system (Epi, StrongMono). It is derived mechanically by applying the duality functor. This system decomposes a morphism into a regular epimorphism followed by a strong monomorphism. While less common, it highlights the perfect symmetry of the underlying categorical concepts." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.6: The case of localizations" ")" "==>" {
(*

ELABORATION: This section ties together the abstract concept of localization with the tangible
notion of a reflective subcategory. It shows that inverting a class of morphisms Σ is
equivalent to "reflecting" the entire category into the subcategory of objects that already
"see" Σ as isomorphisms. To elaborate, we will:

Formalize the Target Space: Define the property of an object being "Σ-local", meaning
it is orthogonal to the class Σ.

Formalize the Subcategory: Define the subcategory C_Σ of all Σ-local objects.

Formalize the Universal Map: Define a "Σ-localization" of an object as the universal
arrow from that object to the subcategory of Σ-local objects.

State the Main Theorem: Assert the theorem that the subcategory of Σ-local objects is
reflective, and that its reflector functor is precisely the one that performs the
Σ-localization for each object. This establishes that localization is a form of reflection.

*)

(* ========================================================================================================== )
( == Part 1: The Σ-Local Objects == )
( ========================================================================================================== *)

IsSLocal ::= "IsSLocal" "(" Identifier "," Identifier ")" ;
TYPING
(* This rule was introduced in 5.4, but it is central here. An object X is Σ-local if Hom(_, X) inverts Σ. *)
Γ ⊢ X : Object_in(C), Γ ⊢ S : ClassOfMorphisms(C)
Condition := ∀(s: A→B ∈ S), the map (f ↦ f∘s) : Hom_C(B,X) → Hom_C(A,X) is an ISOMORPHISM.
-------------------------------------------------
Γ ⊢ IsSLocal(X, S) : BooleanProposition ;
CATEGORY
[[ IsSLocal(X, S) ]] = "The property of an object X being 'local' with respect to the class of morphisms S. This means that from the point of view of mapping into X, all morphisms in S behave as if they are already isomorphisms. These objects form the natural target for the localization process." ;

(* ========================================================================================================== )
( == Part 2: The Subcategory of Local Objects == )
( ========================================================================================================== *)

LocalSubcategoryConstructor ::= "LocalObjectsSubcat" "(" Identifier ")" ;
TYPING
(* This constructor builds the full subcategory of all Σ-local objects within C. *)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
LocalObjs := { X ∈ Ob(C) | Γ ⊢ IsSLocal(X, S) }
----------------------------------------------------------------------------------
Γ ⊢ LocalObjectsSubcat(S) : FullSubcategory(C) on objects LocalObjs ;
CATEGORY
[[ LocalObjectsSubcat(S) ]] = "The full subcategory C_S of all S-local objects. This subcategory is the 'ideal world' where all morphisms in S have been inverted." ;

(* ========================================================================================================== )
( == Part 3: The Localization Map and The Main Theorem == )
( ========================================================================================================== *)

S_LocalizationMap ::= "S_localization_of" "(" Identifier ")" ;
TYPING
(*
* An S-localization of an object A is a universal arrow from A to the subcategory of S-local objects.
* It is a morphism l: A -> A' such that A' is S-local, and l is "S-inverting". The precise
* meaning is that it's the reflection of A into the subcategory of S-local objects.
*)
Context: Let A_S = LocalObjectsSubcat(S).
Let I = Inclusion(A_S, C). Assume I has a left adjoint L (the reflector).
Let η be the unit of the adjunction L ⊣ I.
Γ ⊢ A : Object_in(C)
--------------------------------------------------------------------------------------
Γ ⊢ S_localization_of(A) : Morphism (This morphism is η_A : A -> I(L(A))) ;
CATEGORY
[[ S_localization_of(A) ]] = "The universal morphism from an object A to an S-local object. This map is itself 'S-inverting' in a suitable sense and is the 'best approximation' of A within the subcategory of S-local objects." ;

TheoremDeclaration ::= "THEOREM" "LocalizationIsReflection" ":"
"IF" "(" Identifier "C" "is sufficiently complete/cocomplete" ")" "THEN"
"(" "LocalObjectsSubcat(S)" "is" "REFLECTIVE_IN" "C" ","
"and the reflector provides the S-localization for each object" ")" ;
TYPING
(*
* This theorem brings everything together.
* It relies on the Orthogonal Subcategory Theorem from 5.4, since C_S is S⊥.
*)
Premise: Γ ⊢ C has sufficient completeness properties.
Conclusion1: Γ ⊢ LocalObjectsSubcat(S) is REFLECTIVE_IN C
Conclusion2: The reflector functor L: C -> LocalObjectsSubcat(S) is such that for any object A,
the unit arrow η_A is the S_localization_of(A).
-----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocalizationIsReflection ]] = "The central theorem of this section, asserting that the process of localization is an instance of reflection. The subcategory of S-local objects is a reflective subcategory, and the reflector functor is the tool that performs the localization for each object in the category. This unifies the concepts of inverting morphisms and finding best approximations." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.7: Universal closure operations" ")" "==>" {
(*

ELABORATION: This section introduces a powerful algebraic tool on a category's subobject lattices:
the "universal closure operation." This structure is shown to be equivalent to a specific kind of
reflective subcategory. To elaborate, we will:

Formalize the Closure Operation: Define a closure operation on subobjects by its three
axioms (extensive, monotone, idempotent). This captures the essence of "closing" something.

Define Universality: Add the crucial fourth axiom for a universal closure operation:
compatibility with pullbacks. This makes the operation a structural feature of the category.

Define Closed Subobjects: Formalize what it means for a subobject to be "closed" with
respect to the operation and how these form their own subcategory.

State the Main Correspondence Theorem: Assert the fundamental theorem that establishes a
bijection between universal closure operations and reflective subcategories that are themselves
closed under subobjects.

*)

(* ========================================================================================================== )
( == Part 1: Defining a Closure Operation == )
( ========================================================================================================== *)

ClosureOperation ::= "ClosureOp" "(" { "cl_" Identifier } ")" ;
TYPING
(* A closure operation is a family of functions, one for each subobject lattice. )
Γ ⊢ C : Category
∀ X ∈ Ob(C), cl_X : Sub(X) → Sub(X) is a function s.t.
AxiomExtensive(cl_X): ∀S∈Sub(X), S ≤ cl_X(S)
AxiomMonotone(cl_X): ∀S1,S2∈Sub(X), (S1 ≤ S2) ⇒ (cl_X(S1) ≤ cl_X(S2))
AxiomIdempotent(cl_X): ∀S∈Sub(X), cl_X(cl_X(S)) ≤ cl_X(S) ( Equality follows from extensive *)
---------------------------------------------------------------------------------------------------------
Γ ⊢ ClosureOp({cl_X}) : ClosureOperationOn(C) ;
CATEGORY
[[ ClosureOp({cl_X}) ]] = "A family of maps on the subobject lattices of a category C that behaves like a topological closure, satisfying extension, monotonicity, and idempotence. It provides a way to systematically 'complete' subobjects." ;

(* ========================================================================================================== )
( == Part 2: Universality and Closed Subobjects == )
( ========================================================================================================== *)

UniversalClosureOperation ::= "Universal" ClosureOperation ;
TYPING
(* A closure operation is universal if it is stable under pullbacks. *)
Γ ⊢ cl : ClosureOperationOn(C)
AxiomUniversal: ∀ (f : Y→X), ∀ (S ∈ Sub(X)), PullbackSubobject(f, cl_X(S)) == cl_Y(PullbackSubobject(f, S))
---------------------------------------------------------------------------------------------------------
Γ ⊢ Universal cl : UniversalClosureOperationOn(C) ;
CATEGORY
[[ Universal cl ]] = "A closure operation that is compatible with the entire morphism structure of the category, as witnessed by its stability under pullback. This makes it a deeply structural, rather than ad-hoc, property." ;

ClosedSubobjectPredicate ::= Identifier "is" "cl_CLOSED" ;
TYPING
(* A subobject is closed if it is a fixed point of the closure operation. *)
Γ ⊢ S : SubobjectOf(X), Γ ⊢ cl : ClosureOperationOn(C)
---------------------------------------------------------
Γ ⊢ S is cl_CLOSED is TRUE if (cl_X(S) ≤ S) ;
CATEGORY
[[ S is cl_CLOSED ]] = "The property of a subobject being 'complete' with respect to the closure operation. These are the fixed points of the closure." ;

ClosedSubcategoryConstructor ::= "ClosedSubcat" "(" ClosureOperation ")" ;
TYPING
(* This builds the full subcategory consisting of all objects C whose identity subobject [id_C] is closed. *)
Γ ⊢ cl : ClosureOperationOn(C)
ClosedObjects := { X ∈ Ob(C) | [id_X] is cl_CLOSED }
--------------------------------------------------------------------
Γ ⊢ ClosedSubcat(cl) : FullSubcategory(C) on objects ClosedObjects ;
CATEGORY
[[ ClosedSubcat(cl) ]] = "The full subcategory of all objects that are 'closed' with respect to the closure operation. In many contexts, this means objects that are 'separated'." ;

(* ========================================================================================================== )
( == Part 3: The Main Correspondence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "ClosureSubcategoryCorrespondence" ":"
"BIJECTION" "between" "(" "UniversalClosureOperationOn" "(" Identifier ")" ")" "and"
"(" "SubobjectClosedReflectiveSubcategoryOf" "(" Identifier ")" ")" ;
TYPING
(* This is a meta-theorem asserting a bijection between two sets of structures on a category C. *)
Set1 := { cl | Γ ⊢ cl : UniversalClosureOperationOn(C) }
Set2 := { A | Γ ⊢ A is REFLECTIVE_IN C ∧ A is_closed_under SUBOBJECTS in C }
---------------------------------------------------------------------
Γ ⊢ Bijection(Set1, Set2) : DefinitionalIsomorphism ;
CATEGORY
[[ THEOREM ClosureSubcategoryCorrespondence ]] = "A fundamental theorem establishing a one-to-one correspondence between two seemingly different structures: algebraic closure operations on subobjects and geometric reflective subcategories (that are stable under subobjects). This reveals a deep connection between the internal lattice structure and the external reflective structure of a category." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.8: The calculus of bidense morphisms" ")" "==>" {
(*

ELABORATION: Section 5.8 represents a profound unification of the concepts from Chapter 5.
It brings together localization, reflective subcategories, factorization, and closure operations
under a single, elegant framework. The core idea is that a "closure operation" cl defines a
special class of "bidense" morphisms, and that inverting these morphisms is equivalent to
restricting the category to its "closed" objects.

To elaborate meticulously, we will:

Deconstruct the Players: Formally define the class Σ_cl of cl-bidense morphisms,
the absolute heart of this section.

Formalize the "Calculus": The phrase "calculus of fractions" means that the class Σ_cl
is well-behaved enough for localization. We will formalize this by stating the theorem
that Σ_cl admits a left calculus of fractions, defining this concept as the dual
of the right calculus from Section 5.2.

State the Grand Unification Theorem: Assert the main theorem of the section, which
states that the localization of the category C with respect to the cl-bidense
morphisms is equivalent to the subcategory of cl-closed objects. This reveals
that localization via bidense maps is reflection into the subcategory of closed objects.

*)

(* ========================================================================================================== )
( == Part 1: The Players - Bidense Morphisms as a Formal Class == )
( ========================================================================================================== *)

BidenseMorphism ::= Identifier "is" "cl_BIDENSE" ;
TYPING
(*
* This re-states the definition from 5.7 for clarity. A morphism f is bidense with
* respect to a universal closure operation cl if the closure of its image subobject
* is the entire codomain. This is a very strong notion of "surjectivity".
*)
Γ ⊢ f:A->B : Morphism, Γ ⊢ cl : UniversalClosureOperationOn(C)
Img_f := Image(f)
Max_Sub := [id_B] (the maximal subobject of B)
------------------------------------------------------------------
Γ ⊢ f is cl_BIDENSE is TRUE if (cl_B(Img_f) == Max_Sub) ;
CATEGORY
[[ f is cl_BIDENSE ]] = "A morphism that is 'dense' in the sense of the closure operation. Its image is so large that its closure fills the entire codomain B." ;

ClassOfBidenseMorphisms ::= "Σ" "" "(" "cl" ")" ;
TYPING
(*
* This constructor produces the specific class of all cl-bidense morphisms in a category.
* This class is the set S we will use to form the category of fractions C[S⁻¹].
*)
Γ ⊢ C : Category, Γ ⊢ cl : UniversalClosureOperationOn(C)
--------------------------------------------------------------------------------------
Γ ⊢ Σ(cl) : ClassOfMorphisms(C) where f ∈ Σ_(cl) <==> (f is cl_BIDENSE) ;
CATEGORY
[[ Σ_(cl) ]] = "The class of all cl-bidense morphisms. This is the set of arrows that the localization process will formally invert." ;

(* ========================================================================================================== )
( == Part 2: The "Calculus" Property == )
( ========================================================================================================== *)
( The term "calculus" implies that this class of morphisms is usable for localization. This means it must satisfy the (dual) Ore Conditions. )

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "RIGHT_CALCULUS_OF_FRACTIONS" "IS" "LEFT_CALCULUS_OF_FRACTIONS" ;

admitsLeftCalculusOfFractions ::= Identifier "admits" "LEFT_CALCULUS_OF_FRACTIONS" ;
TYPING
(* This is the dual of the right calculus defined in 5.2. *)
IsDualOf("admitsRIGHTCalculusOfFractions")
EquivalentTyping:
Γ ⊢ S : ClassOfMorphisms(C)
Axiom1(S): S contains all isomorphisms and is closed under composition.
Axiom2_DualOre(S): ∀ (f:Y→X, s:Y→Z∈S), ∃ pushout square with t:X→W∈S and g:Z→W.
Axiom3_DualCancel(S): ∀ (f,g:Y→X), (∃s:Y→Z∈S s.t. s∘f == s∘g) ⇒ (∃t:W→Y∈S s.t. f∘t == g∘t).
----------------------------------------------------------------------------------------
Γ ⊢ S admits LEFT_CALCULUS_OF_FRACTIONS : BooleanProposition ;
CATEGORY
[[ S admits LEFT_CALCULUS_OF_FRACTIONS ]] = "The dual assertion. The dual Ore condition allows reordering f s⁻¹ as t⁻¹ g, enabling the construction of the category of fractions using 'co-roofs' or 'cospans'." ;

TheoremDeclaration ::= "THEOREM" "BidenseMorphismsAdmitLeftCalculus" ":"
"IF" "(" Identifier "C" "has a UniversalClosureOperation and pushouts" ")" "THEN"
"(" "Σ_(cl)" "admits" "LEFT_CALCULUS_OF_FRACTIONS" ")" ;
TYPING
(* This is the key technical result that justifies the name "calculus". *)
Premise: Γ ⊢ C : Category
C has a UniversalClosureOperation cl.
C has pushouts.
----------------------------------------------------------------------
Γ ⊢ Σ_(cl) admits LEFT_CALCULUS_OF_FRACTIONS : MetaTheorem ;
CATEGORY
[[ THEOREM BidenseMorphismsAdmitLeftCalculus ]] = "The cornerstone theorem asserting that the class of cl-bidense morphisms is structurally sound, satisfying the necessary (dual) Ore Conditions to permit the construction of a category of fractions. The universality of the closure operation is crucial for the proof." ;

(* ========================================================================================================== )
( == Part 3: The Grand Unification Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "BidenseLocalizationIsReflectionToClosed" ":"
"Given a UniversalClosureOperation cl on a category C,"
"the localization C[Σ_(cl)⁻¹] is equivalent to the subcategory of cl-closed objects." ;
TYPING
(* This is the punchline, connecting all of Chapter 5's concepts. *)
Context: Γ ⊢ cl : UniversalClosureOperation on C
Σ_cl := ClassOfBidenseMorphisms determined by cl
C_cl := ClosedSubcat(cl) (The reflective subcategory of cl-closed objects)
----------------------------------------------------------------------
Γ ⊢ C[Σ_cl⁻¹] ≅ C_cl : EquivalenceOfCategories ;
CATEGORY
[[ THEOREM BidenseLocalizationIsReflectionToClosed ]] = "A deep theorem that unifies the main themes of Chapter 5. It shows that the subcategory of objects closed under a universal closure operation can be obtained by formally inverting all the 'bidense' morphisms. This provides an explicit link between the algebraic process of closure, the geometric process of reflection, and the syntactic process of localization." ;

}
