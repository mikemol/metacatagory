MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'The language of categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {
(* ========================================================================================================== *)
(* == Section 1.1: Logical foundations of the theory & Section 1.2: Categories and functors(*
 *  ELABORATION: The initial definitions of `CategoryDeclaration` and `FunctorDeclaration` were monolithic.
 *  An elaboration requires deconstructing them to reveal their logical foundations. We will show
 *  that a Category is fundamentally a 'PreCategory' (a graph) that satisfies specific axioms,
 *  and a Functor is a 'FunctorMap' (a graph homomorphism) that satisfies preservation axioms.
 *  This process makes the logical requirements explicit within the grammar.
*)

(* ========================================================================================================== *)
(* == Part 1: Deconstructing the Category - From Graph to Structure                                       == *)
(* ========================================================================================================== *)

PreCategoryDeclaration ::= "PRECATEGORY" Identifier "has" "{" "Objects" ":" {Identifier} ";" "Morphisms" ":" {MorphismDeclaration} ";" "}" ;
TYPING
    (*
     *  A PreCategory (or a directed multi-graph/quiver) is the raw substrate of a category.
     *  It has nodes (Objects) and directed edges (Morphisms), but no required laws of composition or identity.
     *  Its typing is purely about the structural declaration being self-consistent.
    *)
    Γ ⊢ G_id : Identifier
    AllIdentifiersUnique(Objects, MorphismIdentifiers)
    ∀m = (f: A->B) ∈ Morphisms, (A ∈ Objects) ∧ (B ∈ Objects)
    -----------------------------------------------------------------------------------------------------------------
    Γ ⊢ PRECATEGORY G_id has {...} : PreCategory ;
CATEGORY
    [[ PRECATEGORY G has {...} ]] = "The definition of a directed graph (or quiver) G. This structure contains the data of a category before the axioms of composition and identity are imposed." ;

CategoryPromotion ::= "PROMOTE" Identifier "to" "CATEGORY" "by proving" "{" {AxiomName} "}" ;
TYPING
    (*
     *  This rule formalizes the act of proving that a PreCategory is a Category.
     *  It is a well-typed promotion if the specified axioms (Identity, Associativity) can be proven to hold for the PreCategory.
    *)
    Γ ⊢ G : PreCategory
    Axioms = { "IdentityAxiom", "AssociativityAxiom" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(G, ax) : True
    ----------------------------------------------------
    Γ ⊢ PROMOTE G to CATEGORY... : Category ;
CATEGORY
    [[ PROMOTE G to CATEGORY... ]] = "An assertion that the graph structure G, endowed with a composition operation and identity morphisms, satisfies the required coherence laws. This is the constructor for the object 'Category' from the object 'PreCategory'." ;

(* ========================================================================================================== *)
(* == Part 2: Explicit Category Axioms (Re-stated for Elaboration)                                        == *)
(* ========================================================================================================== *)

AssociativityAxiom ::= "AXIOM" "Associativity" ":" "FOR_ALL" "f,g,h" "where" "IsComposable(h,g,f)" "," "(" Expression "∘" Expression ")" "∘" Expression "==" Expression "∘" "(" Expression "∘" Expression ")" ;
TYPING
    (* This is a predicate on a PreCategory. It is true if the law holds for all valid compositions. *)
    Γ ⊢ G : PreCategory
    ∀ (f:A->B, g:B->C, h:C->D) ∈ G, ((h ∘ g) ∘ f) == (h ∘ (g ∘ f))
    ------------------------------------------------------------------
    Γ ⊢ Proof(G, AssociativityAxiom) : True ;
CATEGORY
    [[ AXIOM Associativity... ]] = "The coherence law ensuring that composition is unambiguous for chains of morphisms. This is a foundational property for algebraic structure." ;

IdentityAxiom ::= "AXIOM" "Identity" ":" "FOR_ALL" "f" ":" "A->B" "," ("id(B) ∘ f == f" "&&" "f ∘ id(A) == f") ;
TYPING
    (* This is a predicate on a PreCategory equipped with identity morphisms. *)
    Γ ⊢ G : PreCategory
    ∀ (f:A->B) ∈ G, ( (id_B ∘ f) == f ) ∧ ( (f ∘ id_A) == f )
    ------------------------------------------------------------
    Γ ⊢ Proof(G, IdentityAxiom) : True ;
CATEGORY
    [[ AXIOM Identity... ]] = "The law asserting the existence of a neutral element for composition for every object, acting as a two-sided unit." ;

(* ========================================================================================================== *)
(* == Part 3: Deconstructing the Functor - From Map to Morphism                                           == *)
(* ========================================================================================================== *)

FunctorMapDeclaration ::= "FUNCTOR_MAP" Identifier ":" Identifier "->" Identifier "maps" "{" {ObjectMapping} {MorphismMapping} "}" ;
TYPING
    (*
     *  A FunctorMap is a homomorphism between PreCategories. It maps objects to objects
     *  and morphisms to morphisms, respecting the endpoints (domains and codomains).
     *  It does not yet need to preserve composition or identity.
    *)
    Γ ⊢ F : Identifier, Γ ⊢ C : PreCategory, Γ ⊢ D : PreCategory
    ∀ (obj_map: A |-> F(A)), (A ∈ Ob(C)) ⇒ (F(A) ∈ Ob(D))
    ∀ (mor_map: f |-> F(f)), (f:A->B ∈ Mor(C)) ⇒ (F(f):F(A)->F(B) ∈ Mor(D))
    ------------------------------------------------------------------------------
    Γ ⊢ FUNCTOR_MAP F ... : FunctorMap(C, D) ;
CATEGORY
    [[ FUNCTOR_MAP F... ]] = "A homomorphism of directed graphs. It is a structure-preserving map of the underlying substrate of the categories involved." ;

FunctorPromotion ::= "PROMOTE" Identifier "to" "FUNCTOR" "by proving" "{" {AxiomName} "}" ;
TYPING
    (*
     *  This rule formalizes the proof that a FunctorMap between two Categories is a Functor.
     *  The promotion is valid if the map can be proven to preserve identities and composition.
    *)
    Γ ⊢ F : FunctorMap(C, D), Γ ⊢ C : Category, Γ ⊢ D : Category
    Axioms = { "PreservesComposition", "PreservesIdentity" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(F, ax) : True
    ----------------------------------------------------------
    Γ ⊢ PROMOTE F to FUNCTOR... : Functor(C, D) ;
CATEGORY
    [[ PROMOTE F to FUNCTOR... ]] = "An assertion that the graph homomorphism F also respects the algebraic structure of the categories, thereby making it a morphism in the category of categories, `Cat`." ;

(* ========================================================================================================== *)
(* == Part 4: Explicit Functor Axioms                                                                     == *)
(* ========================================================================================================== *)

FunctorPreservesCompositionAxiom ::= "AXIOM" "PreservesComposition" ":" "FOR_ALL" "f,g" "where" "IsComposable(g,f)" "," "F(g ∘ f) == F(g) ∘ F(f)" ;
TYPING
    (* A predicate on a FunctorMap. *)
    Γ ⊢ F : FunctorMap(C, D)
    ∀ (f:A->B, g:B->C) ∈ C, F(g ∘ f) == F(g) ∘ F(f)
    ---------------------------------------------------
    Γ ⊢ Proof(F, PreservesComposition) : True ;
CATEGORY
    [[ AXIOM PreservesComposition... ]] = "The law ensuring a functor maps diagrams in the source category to diagrams of the same shape in the target category. It is the core structure-preservation property." ;

FunctorPreservesIdentityAxiom ::= "AXIOM" "PreservesIdentity" ":" "FOR_ALL" "object A" "," "F(id(A)) == id(F(A))" ;
TYPING
    (* A predicate on a FunctorMap. *)
    Γ ⊢ F : FunctorMap(C, D) 
    ∀ A ∈ Ob(C), F(id_A) == id_{F(A)}
    ------------------------------------
    Γ ⊢ Proof(F, PreservesIdentity) : True ;
CATEGORY
    [[ AXIOM PreservesIdentity... ]] = "The law ensuring a functor respects the neutral elements of composition. It maps identity arrows to identity arrows." ;


(*
 *  ELABORATION: A natural transformation is not a single entity, but a structured family of morphisms.
 *  To elaborate on this concept is to formalize:
 *  1.  The necessary precondition: that the functors involved are "parallel".
 *  2.  The constituent parts: the individual "component" morphisms of the transformation.
 *  3.  The defining law: the "naturality square" that these components must satisfy.
 *  We will introduce explicit grammar rules for each of these three aspects.
*)


(* ========================================================================================================== *)
(* == Part 1: The Precondition (Parallel Functors)                                                        == *)
(* ========================================================================================================== *)

ParallelFunctorsPredicate ::= "AreParallel" "(" Identifier "," Identifier ")" ;
TYPING
    (*
     *  This predicate is true if two functors share the exact same domain and codomain categories.
     *  This is a necessary precondition for a natural transformation to exist between them.
    *)
    Γ ⊢ F : Functor(C, D), Γ ⊢ G : Functor(C', D')
    C == C'
    D == D'
    -------------------------------------------------------------
    Γ ⊢ AreParallel(F, G) : BooleanProposition ;
CATEGORY
    [[ AreParallel(F, G) ]] = "An assertion that the functors F and G are parallel arrows in the category `Cat` of categories, i.e., they are objects in the slice category `Cat / (C × D)`." ;


(* ========================================================================================================== *)
(* == Part 2: The Components (The Family of Morphisms)                                                    == *)
(* ========================================================================================================== *)

TransformationComponent ::= Identifier "_at_" Identifier ;
TYPING
    (*
     *  This defines the syntax for a "component" of a natural transformation.
     *  If `alpha` is a transformation from `F` to `G`, and `X` is an object in their domain category,
     *  then `alpha_at_X` is the specific morphism in the codomain category from `F(X)` to `G(X)`.
    *)
    Γ ⊢ alpha : NaturalTransformation(F, G) where F,G : Functor(C,D)
    Γ ⊢ X : Object_in(C)
    ---------------------------------------------------------------------------------
    Γ ⊢ alpha_at_X : Morphism(F(X), G(X)) in D ;
CATEGORY
    [[ alpha_at_X ]] = "The component morphism of the natural transformation `alpha` at the object `X`. It is one specific arrow in the family that constitutes `alpha`." ;


(* ========================================================================================================== *)
(* == Part 3: The Declaration and The Law (Putting It Together)                                           == *)
(* ========================================================================================================== *)

NaturalTransformationDeclaration ::= "NATURAL_TRANSFORMATION" Identifier ":" Identifier "==>" Identifier ;
TYPING
    (*
     *  This rule is now refined. To declare a natural transformation `alpha`, we must be able to assert:
     *  1. The functors F and G are parallel.
     *  2. For every object X in the domain, a corresponding component morphism `alpha_at_X` can be constructed.
     *  3. The entire family of these components satisfies the Naturality Condition.
    *)
    Γ ⊢ AreParallel(F, G) : True
    ∀X ∈ Objects(Domain(F)), Γ ⊢ alpha_at_X : Morphism(F(X), G(X))
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : True
    -------------------------------------------------------------------------
    Γ ⊢ NATURAL_TRANSFORMATION alpha : F ==> G : NaturalTransformation(F,G) ;
CATEGORY
    [[ NATURAL_TRANSFORMATION alpha : F ==> G ]] = "The declaration of a 2-morphism `alpha` between the 1-morphisms (functors) `F` and `G` in the 2-category `Cat`. This object is itself defined by its family of components and the coherence law they satisfy." ;

NaturalityConditionAxiom ::= "AXIOM" "Naturality" ":" "FOR_ALL" Identifier ":" Identifier "->" Identifier "," Expression "∘" TransformationComponent "==" TransformationComponent "∘" Expression ;
TYPING
    (*
     *  This formalizes the famous commuting square diagram. For any natural transformation `alpha`
     *  and any morphism `f: X -> Y` in the domain category, this axiom must hold. It uses our
     *  new `TransformationComponent` syntax `_at_` to make the statement precise.
     *  The equality being asserted is: G(f) ∘ alpha_at_X == alpha_at_Y ∘ F(f)
    *)
    Γ ⊢ alpha : NaturalTransformation(F, G)
    ∀f:X->Y in Domain(F), (G(f) ∘ alpha_at_X) == (alpha_at_Y ∘ F(f))
    ---------------------------------------------------------------------
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : BooleanProposition ;
CATEGORY
    [[ AXIOM Naturality: ... ]] = "The fundamental coherence law for natural transformations. It ensures that the family of component morphisms is compatible with the entire morphism structure of the domain category, not just its objects." ;

(* ========================================================================================================== *)
(* == Part 1: The Definitional Equivalence (Unpacking the `^op`)                                          == *)
(* ========================================================================================================== *)

ContravariantFunctorAsFunctorOp ::= "DEFINE" Identifier "as" "CONTRAVARIANT_FUNCTOR" ":" Identifier "->" Identifier ;
TYPING
    (*
     *  This rule asserts that defining a CONTRAVARIANT_FUNCTOR `F: C -> D` is formally equivalent
     *  to defining a standard (covariant) FUNCTOR `F: C^op -> D`. This makes the `^op` idiom,
     *  a cornerstone of categorical thought, an explicit transformation within the grammar.
    *)
    Γ ⊢ F : Identifier, Γ ⊢ C : Category, Γ ⊢ D : Category
    ---------------------------------------------------------------------------------
    (Γ ⊢ DEFINE F as CONTRAVARIANT_FUNCTOR ... ) ⇔ (Γ ⊢ FUNCTOR F : C^op -> D) ;
CATEGORY
    [[ DEFINE F as CONTRAVARIANT_FUNCTOR... ]] = "An assertion of isomorphism in `Cat`. It states that the object representing contravariant functors from C to D is the same as the object representing covariant functors from C^op to D. This is the formal definition." ;

(* ========================================================================================================== *)
(* == Part 2: The Explicit Action on Morphisms (The Arrow Reversal)                                       == *)
(* ========================================================================================================== *)

ContravariantMap ::= Identifier "<~" Expression "~>" ;
TYPING
    (*
     *  This rule gives a concrete syntax for the arrow-reversing action of a contravariant functor.
     *  While `F(f)` is ambiguous, `F <~ f ~>` explicitly signifies the contravariant mapping.
     *  The typing rule makes the reversal of domain and codomain manifest.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C
    ------------------------------------------------------------------
    Γ ⊢ F <~f~> : Morphism(F(A), F(B)) in D ;  (* Note: F(A) and F(B) are the mapped objects *)
CATEGORY
    [[ F <~f~> ]] = "The morphism in D that results from the contravariant action of the functor F on the morphism f from C. The reversal of the arrow `A->B` to an arrow `F(B)->F(A)` is the essence of contravariance." ;

(* ========================================================================================================== *)
(* == Part 3: The Explicit Axioms (Identity and Composition)                                              == *)
(* ========================================================================================================== *)

ContravariantIdentityAxiom ::= "AXIOM" ":" Identifier "<~" "id" "(" Identifier ")" "~>" "==" "id" "(" Identifier ")" ;
TYPING
    (*
     *  This axiom asserts that a contravariant functor must preserve identity morphisms.
     *  `F(id_A)` must equal `id_{F(A)}`.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D), Γ ⊢ A : Object_in(C)
    (F <~id(A)~>) == id(F(A))
    -------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_identity : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~id(A)~> == id(F(A)) ]] = "The law ensuring a contravariant functor respects the neutral elements of composition. This property is identical to the covariant case." ;


ContravariantCompositionAxiom ::= "AXIOM" ":" Identifier "<~" Expression "∘" Expression "~>" "==" Identifier "<~" Expression "~>" "∘" Identifier "<~" Expression "~>" ;
TYPING
    (*
     *  This axiom asserts the law for composing contravariant mappings. Notice the crucial reversal
     *  of order on the right-hand side of the equality. F(g ∘ f) = F(f) ∘ F(g).
     *  This is the most distinctive feature of contravariance in action.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C, Γ ⊢ g : Morphism(B, C) in C
    ( F <~g ∘ f~> ) == ( F <~f~> ∘ F <~g~> )
    ------------------------------------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_composition : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~g ∘ f~> == F <~f~> ∘ F <~g~> ]] = "The law defining how a contravariant functor interacts with composition. The reversal of order `g∘f` to `F(f)∘F(g)` is the functional expression of reversing the arrows. This ensures that diagrams are mapped to dual diagrams." ;


(*
 *  ELABORATION: To elaborate on the Comma Category is to move from a single definition to
 *  formalizing its constituent parts and showing how special cases derive from the general one.
 *  We will:
 *  1. Formalize the general construction `(F ↓ G)`.
 *  2. Explicitly define the objects and morphisms of this general category.
 *  3. State the commutative diagram law for its morphisms as a formal axiom.
 *  4. Define the common "slice" and "coslice" categories as specific, simplified instances
 *     of the general construction, making their relationship explicit.
*)

(* ========================================================================================================== *)
(* == Part 1: The General Construction (F ↓ G)                                                            == *)
(* ========================================================================================================== *)

GeneralCommaCategory ::= "(" Identifier "↓" Identifier ")" ;
TYPING
    (*
     *  The general construction `(F ↓ G)` is a category built from two functors, F and G,
     *  that share the same codomain category C.
    *)
    Γ ⊢ F : Functor(A, C), Γ ⊢ G : Functor(B, C)
    -------------------------------------------
    Γ ⊢ (F ↓ G) : Category ;
CATEGORY
    [[ (F ↓ G) ]] = "The comma category constructed from functors F: A→C and G: B→C. It provides a canonical way to compare the outputs of F and G within C." ;

(* ========================================================================================================== *)
(* == Part 2: Objects and Morphisms of the General Comma Category                                         == *)
(* ========================================================================================================== *)

CommaObject ::= "Obj" "(" Identifier "," Identifier "," Identifier ")" ;
TYPING
    (*
     *  An object in the comma category `(F ↓ G)` is a triple `(a, b, h)`, where `a` is an
     *  object in F's domain, `b` is an object in G's domain, and `h` is a morphism in the
     *  shared codomain from `F(a)` to `G(b)`.
    *)
    ParentCategory = (F ↓ G)
    Γ ⊢ a : Object_in(Domain(F)), Γ ⊢ b : Object_in(Domain(G))
    Γ ⊢ h : Morphism(F(a), G(b)) in Codomain(F)
    -------------------------------------------------------------
    Γ ⊢ Obj(a,b,h) : Object_in(ParentCategory) ;
CATEGORY
    [[ Obj(a,b,h) ]] = "An object of the comma category, consisting of a pair of source objects (a, b) and a 'connecting morphism' h: F(a) -> G(b) in the target category." ;

CommaMorphism ::= "Mor" "(" Identifier "," Identifier ")" ;
TYPING
    (*
     *  A morphism in `(F ↓ G)` from `Obj(a,b,h)` to `Obj(a',b',h')` is a pair of morphisms
     *  `(f, g)` from the respective domain categories that satisfy the commutativity axiom.
    *)
    ParentCategory = (F ↓ G)
    Source = Obj(a,b,h), Target = Obj(a',b',h')
    Γ ⊢ f : Morphism(a, a') in Domain(F)
    Γ ⊢ g : Morphism(b, b') in Domain(G)
    Satisfies( (f,g), CommaMorphismCommutativityAxiom(h,h',f,g) )
    ------------------------------------------------------------------
    Γ ⊢ Mor(f,g) : Morphism(Source, Target) in ParentCategory ;
CATEGORY
    [[ Mor(f,g) ]] = "A morphism of the comma category, itself a pair of morphisms (f,g) from the underlying source categories which makes the defining diagram commute." ;

(* ========================================================================================================== *)
(* == Part 3: The Commutativity Axiom for Morphisms                                                       == *)
(* ========================================================================================================== *)

CommaMorphismCommutativityAxiom ::= "AXIOM" "CommaSquare" ":" Expression "∘" Identifier "==" Identifier "∘" Expression ;
TYPING
    (*
     *  This axiom formalizes the commutative square that a `CommaMorphism` `Mor(f,g)` must satisfy.
     *  The law is: `h' ∘ F(f) == G(g) ∘ h`. This ensures the structure is coherent.
    *)
    h' ∘ F(f) == G(g) ∘ h
    -----------------------------
    Γ ⊢ AXIOM ... : MetaTheorem ;
CATEGORY
    [[ AXIOM CommaSquare ... ]] = "The coherence law for morphisms in a comma category. It is the constraint that ties the components `f` and `g` together via the connecting morphisms `h` and `h'`." ;

(* ========================================================================================================== *)
(* == Part 4: Special Cases - Slice and Coslice Categories                                                == *)
(* ========================================================================================================== *)

IdentityFunctorConstructor ::= "Id" "(" Identifier ")" ;
TYPING
    Γ ⊢ C : Category
    -------------------------------
    Γ ⊢ Id(C) : Functor(C, C) ;
CATEGORY
    [[ Id(C) ]] = "The identity functor on category C, which maps all objects and morphisms to themselves." ;

ConstantFunctorConstructor ::= "Δ" "_" Identifier ;
TYPING
    (* The constant functor from the terminal category `1` to `C`, picking out object `X`. *)
    Γ ⊢ C : Category, Γ ⊢ X : Object_in(C)
    ---------------------------------------------------
    Γ ⊢ Δ_X : Functor(1, C) ;
CATEGORY
    [[ Δ_X ]] = "The constant functor that maps the single object of the terminal category `1` to the object `X` in C." ;

SliceCategory ::= Identifier "/" Identifier ;
TYPING
    (*
     *  A slice category `C/X` is defined as a specific instance of the general comma category.
     *  `C/X` is formally equivalent to `(Id(C) ↓ Δ_X)`. This rule asserts that equivalence.
    *)
    (Γ ⊢ C/X : Category) ⇔ (Γ ⊢ (Id(C) ↓ Δ_X) : Category)
    ------------------------------------------------------------
    Γ ⊢ "C/X is a well-defined slice category" : Proposition ;
CATEGORY
    [[ C/X ]] = "The slice category of objects over X. Its objects are arrows in C with codomain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Id(C) ↓ Δ_X)." ;

CosliceCategory ::= Identifier "\\" Identifier ;
TYPING
    (*
     *  Dually, a coslice category `X\C` is defined as `(Δ_X ↓ Id(C))`.
    *)
    (Γ ⊢ X\\C : Category) ⇔ (Γ ⊢ (Δ_X ↓ Id(C)) : Category)
    ------------------------------------------------------------
    Γ ⊢ "X\\C is a well-defined coslice category" : Proposition ;
CATEGORY
    [[ X\\C ]] = "The coslice category of objects under X. Its objects are arrows in C with domain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Δ_X ↓ Id(C))." ;

(*
 *  ELABORATION: To elaborate on these morphism types, we move beyond their basic cancellation definitions.
 *  We must formalize their interrelationships, their behavior under composition, and the stronger
 *  "splitting" properties that connect them directly to isomorphisms. This involves:
 *  1. Formalizing the notion of an inverse and properties of composition.
 *  2. Defining split monomorphisms and split epimorphisms, which have explicit retractions/sections.
 *  3. Stating key theorems that relate these classes of morphisms (e.g., an iso is always a mono and an epi).
 *  4. Defining a "balanced category" as one where the converse holds, making the distinction explicit.
*)


(* ========================================================================================================== *)
(* == Part 1: Formalizing Inverses and Compositional Properties                                           == *)
(* ========================================================================================================== *)


InverseMorphism ::= "inverse" "(" Identifier ")" ;
TYPING
    (*  The `inverse` constructor is only well-typed if applied to a proven isomorphism.
     *  It produces the unique two-sided inverse morphism.
    *)
    Γ ⊢ f is ISOMORPHISM,  f : Morphism(A,B)
    ----------------------------------------------------
    Γ ⊢ inverse(f) : Morphism(B,A) ;
CATEGORY
    [[ inverse(f) ]] = "The unique morphism `f⁻¹` such that `f⁻¹ ∘ f = id` and `f ∘ f⁻¹ = id`. Its existence is guaranteed by the fact that `f` is an isomorphism." ;


TheoremDeclaration ::= "THEOREM" string_literal ":" Proposition ;
TYPING
    (*  This rule asserts that a given proposition is a theorem of the system.
     *  This is stronger than an exercise; it's an axiom of our meta-theory of categories.
    *)
    IsProvable(Proposition)
    ----------------------------------------------
    Γ ⊢ THEOREM name : Proposition : MetaTheorem ;
CATEGORY
    [[ THEOREM name : Prop ]] = "The assertion that the proposition [[Prop]] holds true for all objects in the category being described. It is a proven fact." ;


TheoremDeclaration ::= "THEOREM" "CompositionOfMonomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfEpimorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is EPIMORPHISM" "&&" "g is EPIMORPHISM" ")" "==>" "(" "(g∘f) is EPIMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfIsomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is ISOMORPHISM" "&&" "g is ISOMORPHISM" ")" "==>" "(" "(g∘f) is ISOMORPHISM" ")" ;


(* ========================================================================================================== *)
(* == Part 2: Formalizing Split Monos/Epis (Retractions and Sections)                                      == *)
(* ========================================================================================================== *)


MorphismPropertyAssertion ::= Identifier "is" ("SPLIT_MONOMORPHISM" | "SPLIT_EPIMORPHISM") ;
TYPING
    Γ ⊢ f : Morphism(A, B)
    CASE "SPLIT_MONOMORPHISM": (* Has a left inverse, called a retraction *)
        ∃(r : Morphism(B, A)), (r ∘ f == id(A))
    CASE "SPLIT_EPIMORPHISM": (* Has a right inverse, called a section *)
        ∃(s : Morphism(B, A)), (f ∘ s == id(B))
    -------------------------------------------------------------
    Γ ⊢ f is ... : PropositionAbout(f) ;
CATEGORY
    [[ f is SPLIT_MONOMORPHISM ]] = "Property of being a monomorphism `f` for which there exists a retraction `r` that 'undoes' it. All split monos are monos." ;
    [[ f is SPLIT_EPIMORPHISM ]] = "Property of being an epimorphism `f` for which there exists a section `s` that 'selects' an element from each fiber. All split epis are epis." ;


(* ========================================================================================================== *)
(* == Part 3: Formalizing the Interrelationships and the Notion of a Balanced Category                     == *)
(* ========================================================================================================== *)


TheoremDeclaration ::= "THEOREM" "IsomorphismImpliesMonoAndEpi" ":"
    "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "==>" "(" "f is MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
TYPING
    (* Proof Sketch: If f is iso with inverse g, and f∘h1 = f∘h2, then g∘f∘h1 = g∘f∘h2 => id∘h1 = id∘h2 => h1=h2. Thus f is mono. Dually for epi. *)
    IsProvable(Proposition)
    --------------------------
    Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
 [[ THEOREM "IsoImpliesMonoAndEpi" ]] = "A fundamental fact stating that any structural equivalence (isomorphism) must also satisfy the cancellation properties of monomorphisms and epimorphisms." ;


CategoryPropertyDefinition ::= Identifier "is" "BALANCED" ;
TYPING
    (* This defines a property of an entire category. A category is balanced if the converse of the above theorem holds. *)
    Γ ⊢ C : Category
    ∀ (f in C), ( (f is MONOMORPHISM) ∧ (f is EPIMORPHISM) ) ⇒ (f is ISOMORPHISM)
    -----------------------------------------------------------------------------------
    Γ ⊢ C is BALANCED : PropositionAbout(C) ;
CATEGORY
    [[ C is BALANCED ]] = "The property of a category C where the classes of monomorphisms and epimorphisms are 'well-behaved' enough that their intersection contains only isomorphisms. The category of Sets is an example." ;


TheoremDeclaration ::= "THEOREM" "IsoEquivalenceForSplitMorphisms" ":"
    "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "<==>" "(" "f is SPLIT_MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
TYPING
    (* This provides a powerful criterion for proving a morphism is an isomorphism. *)
    IsProvable(Proposition)
    --------------------------
    Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
    [[ THEOREM "IsoEquivalenceForSplitMorphisms" ]] = "A key structural result: an isomorphism is precisely an epimorphism that is also a split monomorphism. This connects the abstract cancellation property of epis with the constructive existence of a retraction." ;

(*
 *  ELABORATION: To elaborate on the Duality Principle, we must formalize the very *mechanism* of duality.
 *  This requires more than just stating that it exists. We must integrate into our grammar:
 *  1.  An operator `(-)^op` that dualizes any statement.
 *  2.  A set of meta-axioms that define how this operator transforms specific concepts (e.g., Product -> Coproduct).
 *  3.  An explicit inference rule that allows us to construct a new, dual theorem from any existing theorem.
 *  This makes the Duality Principle a computable, syntactic transformation within our system, not just an informal idea.
*)

(* ========================================================================================================== *)
(* == Part 1: The Syntactic Operator for Duality                                                          == *)
(* ========================================================================================================== *)

DualStatement ::= "(" Proposition ")^op" ;
TYPING
    (*
     *  If `P` is a well-formed proposition in a category C, then `(P)^op` is a well-formed
     *  proposition in the opposite category C^op. This is the syntactic counterpart to `C^op`.
    *)
    Γ ⊢ P : Proposition in C
    ----------------------------------
    Γ ⊢ (P)^op : Proposition in C^op ;
CATEGORY
    [[ (P)^op ]] = "The dual proposition of [[P]], obtained by systematically reversing all morphisms, swapping the order of compositions, and replacing each concept with its dual concept." ;

(* ========================================================================================================== *)
(* == Part 2: Meta-Axioms Defining Specific Dual Mappings                                                 == *)
(* ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" ConceptName "IS" ConceptName ";" ;
TYPING
    (*
     *  This is a meta-theoretical rule. It does not define a term in the language, but asserts an
     *  equivalence within the metatheory itself. It establishes a dictionary for the `(-)^op` operator.
    *)
    IsConcept(C1), IsConcept(C2)
    -----------------------------------------------------------------------------------------
    (Γ ⊢ (X is C1)^op)  <==>  (Γ ⊢ (X is C2))   (* Adds a rewrite rule to the system *) ;
CATEGORY
    [[ DUALITY_MAPPING FOR C1 IS C2 ]] = "An assertion of isomorphism between the definitions of [[C1]] and [[C2]] under the duality functor. This axiom provides a concrete rule for translating between a concept and its dual." ;

(* --- Instantiate the Duality Dictionary --- *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "TERMINAL_OBJECT" "IS" "INITIAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "INITIAL_OBJECT" "IS" "TERMINAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PRODUCT" "IS" "COPRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COPRODUCT" "IS" "PRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PULLBACK" "IS" "PUSHOUT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PUSHOUT" "IS" "PULLBACK" ;
DualityMappingAxiom ::= "DUALITY_MIPPING" "FOR" "EQUALIZER" "IS" "COEQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COEQUALIZER" "IS" "EQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LIMIT" "IS" "COLIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COLIMIT" "IS" "LIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "MONOMORPHISM" "IS" "EPIMORPHISM" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "EPIMORPHISM" "IS" "MONOMORPHISM" ;

(* ========================================================================================================== *)
(* == Part 3: The Principle as a Formal Inference Rule                                                    == *)
(* ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" string_literal "FROM" "THEOREM" string_literal ;
TYPING
    (*
     *  This is the Duality Principle in action. If we have a proof for a theorem `T`, this rule allows
     *  us to formally construct a proof for its dual, `T_dual`. The system `rewrites` the original
     *  theorem using the `DualityMappingAxiom` dictionary to produce the new theorem.
    *)
    Γ ⊢ THEOREM T_orig_name : P_orig
    P_dual = rewrite(P_orig, DualityMappings)
    -------------------------------------------------------------
    Γ ⊢ INFER_DUAL_THEOREM T_dual_name ... : (THEOREM T_dual_name : P_dual) ;
CATEGORY
    [[ INFER_DUAL_THEOREM T_dual FROM T_orig ]] = "The application of the Duality Principle as a meta-inference rule. It is a functor from the category of proofs to itself, mapping the proof object `[[T_orig]]` to a newly constructed proof object `[[T_dual]]`." ;

(* --- Example of Applying the Inference Rule --- *)

TheoremDeclaration ::= "THEOREM" "'CompMono'" ":" "FOR_ALL" "f,g" "," 
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" "&&" "IsDefined(g∘f)" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CompEpi'" "FROM" "THEOREM" "'CompMono'" ;
TYPING
    (*
     *  1. Premise: We have the theorem 'CompMono'.
     *  2. Rewrite 'CompMono' using the duality dictionary:
     *     - "MONOMORPHISM" -> "EPIMORPHISM"
     *     - Composition `g∘f` in C becomes `f_op ∘_op g_op` in C^op. Re-lettering to `g'∘f'` for clarity.
     *  3. Resulting proposition: "FOR_ALL f',g', (f' is EPI && g' is EPI && IsDefined(g'∘f')) ==> ((g'∘f') is EPI)"
     *  4. Conclusion: This is a valid new theorem.
    *)
    Γ ⊢ THEOREM 'CompMono' : P_mono
    -------------------------------------------------
    Γ ⊢ THEOREM 'CompEpi' : P_epi ;
CATEGORY
    [[ INFER_DUAL_THEOREM 'CompEpi' FROM 'CompMono' ]] = "A constructive proof that the composition of two epimorphisms is an epimorphism, obtained not by first principles, but by a direct, mechanical application of the Duality Principle to the proof for monomorphisms." ;

