PreCategoryDeclaration ::= "PRECATEGORY" Identifier "has" "{" "Objects" ":" {Identifier} ";" "Morphisms" ":" {MorphismDeclaration} ";" "}" ;
TYPING
    Γ ⊢ G_id : Identifier
    AllIdentifiersUnique(Objects, MorphismIdentifiers)
    ∀m = (f: A->B) ∈ Morphisms, (A ∈ Objects) ∧ (B ∈ Objects)
    -----------------------------------------------------------------------------------------------------------------
    Γ ⊢ PRECATEGORY G_id has {...} : PreCategory ;
CATEGORY
    [[ PRECATEGORY G has {...} ]] = "The definition of a directed graph (or quiver) G. This structure contains the data of a category before the axioms of composition and identity are imposed." ;

CategoryPromotion ::= "PROMOTE" Identifier "to" "CATEGORY" "by proving" "{" {AxiomName} "}" ;
TYPING
    Γ ⊢ G : PreCategory
    Axioms = { "IdentityAxiom", "AssociativityAxiom" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(G, ax) : True
    ----------------------------------------------------
    Γ ⊢ PROMOTE G to CATEGORY... : Category ;
CATEGORY
    [[ PROMOTE G to CATEGORY... ]] = "An assertion that the graph structure G, endowed with a composition operation and identity morphisms, satisfies the required coherence laws. This is the constructor for the object 'Category' from the object 'PreCategory'." ;

AssociativityAxiom ::= "AXIOM" "Associativity" ":" "FOR_ALL" "f,g,h" "where" "IsComposable(h,g,f)" "," "(" Expression "∘" Expression ")" "∘" Expression "==" Expression "∘" "(" Expression "∘" Expression ")" ;
TYPING
    Γ ⊢ G : PreCategory
    ∀ (f:A->B, g:B->C, h:C->D) ∈ G, ((h ∘ g) ∘ f) == (h ∘ (g ∘ f))
    ------------------------------------------------------------------
    Γ ⊢ Proof(G, AssociativityAxiom) : True ;
CATEGORY
    [[ AXIOM Associativity... ]] = "The coherence law ensuring that composition is unambiguous for chains of morphisms. This is a foundational property for algebraic structure." ;

IdentityAxiom ::= "AXIOM" "Identity" ":" "FOR_ALL" "f" ":" "A->B" "," ("id(B) ∘ f == f" "&&" "f ∘ id(A) == f") ;
TYPING
    Γ ⊢ G : PreCategory
    ∀ (f:A->B) ∈ G, ( (id_B ∘ f) == f ) ∧ ( (f ∘ id_A) == f )
    ------------------------------------------------------------
    Γ ⊢ Proof(G, IdentityAxiom) : True ;
CATEGORY
    [[ AXIOM Identity... ]] = "The law asserting the existence of a neutral element for composition for every object, acting as a two-sided unit." ;

FunctorMapDeclaration ::= "FUNCTOR_MAP" Identifier ":" Identifier "->" Identifier "maps" "{" {ObjectMapping} {MorphismMapping} "}" ;
TYPING
    Γ ⊢ F : Identifier, Γ ⊢ C : PreCategory, Γ ⊢ D : PreCategory
    ∀ (obj_map: A |-> F(A)), (A ∈ Ob(C)) ⇒ (F(A) ∈ Ob(D))
    ∀ (mor_map: f |-> F(f)), (f:A->B ∈ Mor(C)) ⇒ (F(f):F(A)->F(B) ∈ Mor(D))
    ------------------------------------------------------------------------------
    Γ ⊢ FUNCTOR_MAP F ... : FunctorMap(C, D) ;
CATEGORY
    [[ FUNCTOR_MAP F... ]] = "A homomorphism of directed graphs. It is a structure-preserving map of the underlying substrate of the categories involved." ;

FunctorPromotion ::= "PROMOTE" Identifier "to" "FUNCTOR" "by proving" "{" {AxiomName} "}" ;
TYPING
    Γ ⊢ F : FunctorMap(C, D), Γ ⊢ C : Category, Γ ⊢ D : Category
    Axioms = { "PreservesComposition", "PreservesIdentity" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(F, ax) : True
    ----------------------------------------------------------
    Γ ⊢ PROMOTE F to FUNCTOR... : Functor(C, D) ;
CATEGORY
    [[ PROMOTE F to FUNCTOR... ]] = "An assertion that the graph homomorphism F also respects the algebraic structure of the categories, thereby making it a morphism in the category of categories, `Cat`." ;

FunctorPreservesCompositionAxiom ::= "AXIOM" "PreservesComposition" ":" "FOR_ALL" "f,g" "where" "IsComposable(g,f)" "," "F(g ∘ f) == F(g) ∘ F(f)" ;
TYPING
    Γ ⊢ F : FunctorMap(C, D)
    ∀ (f:A->B, g:B->C) ∈ C, F(g ∘ f) == F(g) ∘ F(f)
    ---------------------------------------------------
    Γ ⊢ Proof(F, PreservesComposition) : True ;
CATEGORY
    [[ AXIOM PreservesComposition... ]] = "The law ensuring a functor maps diagrams in the source category to diagrams of the same shape in the target category. It is the core structure-preservation property." ;

FunctorPreservesIdentityAxiom ::= "AXIOM" "PreservesIdentity" ":" "FOR_ALL" "object A" "," "F(id(A)) == id(F(A))" ;
TYPING
    Γ ⊢ F : FunctorMap(C, D) 
    ∀ A ∈ Ob(C), F(id_A) == id_{F(A)}
    ------------------------------------
    Γ ⊢ Proof(F, PreservesIdentity) : True ;
CATEGORY
    [[ AXIOM PreservesIdentity... ]] = "The law ensuring a functor respects the neutral elements of composition. It maps identity arrows to identity arrows." ;

ParallelFunctorsPredicate ::= "AreParallel" "(" Identifier "," Identifier ")" ;
TYPING
    (*
     *  This predicate is true if two functors share the exact same domain and codomain categories.
     *  This is a necessary precondition for a natural transformation to exist between them.
    *)
    Γ ⊢ F : Functor(C, D), Γ ⊢ G : Functor(C', D')
    C == C'
    D == D'
    -------------------------------------------------------------
    Γ ⊢ AreParallel(F, G) : BooleanProposition ;
CATEGORY
    [[ AreParallel(F, G) ]] = "An assertion that the functors F and G are parallel arrows in the category `Cat` of categories, i.e., they are objects in the slice category `Cat / (C × D)`." ;

TransformationComponent ::= Identifier "_at_" Identifier ;
TYPING
    Γ ⊢ alpha : NaturalTransformation(F, G) where F,G : Functor(C,D)
    Γ ⊢ X : Object_in(C)
    ---------------------------------------------------------------------------------
    Γ ⊢ alpha_at_X : Morphism(F(X), G(X)) in D ;
CATEGORY
    [[ alpha_at_X ]] = "The component morphism of the natural transformation `alpha` at the object `X`. It is one specific arrow in the family that constitutes `alpha`." ;

NaturalTransformationDeclaration ::= "NATURAL_TRANSFORMATION" Identifier ":" Identifier "==>" Identifier ;
TYPING
    Γ ⊢ AreParallel(F, G) : True
    ∀X ∈ Objects(Domain(F)), Γ ⊢ alpha_at_X : Morphism(F(X), G(X))
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : True
    -------------------------------------------------------------------------
    Γ ⊢ NATURAL_TRANSFORMATION alpha : F ==> G : NaturalTransformation(F,G) ;
CATEGORY
    [[ NATURAL_TRANSFORMATION alpha : F ==> G ]] = "The declaration of a 2-morphism `alpha` between the 1-morphisms (functors) `F` and `G` in the 2-category `Cat`. This object is itself defined by its family of components and the coherence law they satisfy." ;

NaturalityConditionAxiom ::= "AXIOM" "Naturality" ":" "FOR_ALL" Identifier ":" Identifier "->" Identifier "," Expression "∘" TransformationComponent "==" TransformationComponent "∘" Expression ;
TYPING
    Γ ⊢ alpha : NaturalTransformation(F, G)
    ∀f:X->Y in Domain(F), (G(f) ∘ alpha_at_X) == (alpha_at_Y ∘ F(f))
    ---------------------------------------------------------------------
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : BooleanProposition ;
CATEGORY
    [[ AXIOM Naturality: ... ]] = "The fundamental coherence law for natural transformations. It ensures that the family of component morphisms is compatible with the entire morphism structure of the domain category, not just its objects." ;

ContravariantFunctorAsFunctorOp ::= "DEFINE" Identifier "as" "CONTRAVARIANT_FUNCTOR" ":" Identifier "->" Identifier ;
TYPING
    Γ ⊢ F : Identifier, Γ ⊢ C : Category, Γ ⊢ D : Category
    ---------------------------------------------------------------------------------
    (Γ ⊢ DEFINE F as CONTRAVARIANT_FUNCTOR ... ) ⇔ (Γ ⊢ FUNCTOR F : C^op -> D) ;
CATEGORY
    [[ DEFINE F as CONTRAVARIANT_FUNCTOR... ]] = "An assertion of isomorphism in `Cat`. It states that the object representing contravariant functors from C to D is the same as the object representing covariant functors from C^op to D. This is the formal definition." ;

ContravariantMap ::= Identifier "<~" Expression "~>" ;
TYPING
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C
    ------------------------------------------------------------------
    Γ ⊢ F <~f~> : Morphism(F(A), F(B)) in D ;  (* Note: F(A) and F(B) are the mapped objects *)
CATEGORY
    [[ F <~f~> ]] = "The morphism in D that results from the contravariant action of the functor F on the morphism f from C. The reversal of the arrow `A->B` to an arrow `F(B)->F(A)` is the essence of contravariance." ;

ContravariantIdentityAxiom ::= "AXIOM" ":" Identifier "<~" "id" "(" Identifier ")" "~>" "==" "id" "(" Identifier ")" ;
TYPING
    Γ ⊢ F : ContravariantFunctor(C, D), Γ ⊢ A : Object_in(C)
    (F <~id(A)~>) == id(F(A))
    -------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_identity : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~id(A)~> == id(F(A)) ]] = "The law ensuring a contravariant functor respects the neutral elements of composition. This property is identical to the covariant case." ;

ContravariantCompositionAxiom ::= "AXIOM" ":" Identifier "<~" Expression "∘" Expression "~>" "==" Identifier "<~" Expression "~>" "∘" Identifier "<~" Expression "~>" ;
TYPING
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C, Γ ⊢ g : Morphism(B, C) in C
    ( F <~g ∘ f~> ) == ( F <~f~> ∘ F <~g~> )
    ------------------------------------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_composition : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~g ∘ f~> == F <~f~> ∘ F <~g~> ]] = "The law defining how a contravariant functor interacts with composition. The reversal of order `g∘f` to `F(f)∘F(g)` is the functional expression of reversing the arrows. This ensures that diagrams are mapped to dual diagrams." ;

GeneralCommaCategory ::= "(" Identifier "↓" Identifier ")" ;
TYPING
    Γ ⊢ F : Functor(A, C), Γ ⊢ G : Functor(B, C)
    -------------------------------------------
    Γ ⊢ (F ↓ G) : Category ;
CATEGORY
    [[ (F ↓ G) ]] = "The comma category constructed from functors F: A→C and G: B→C. It provides a canonical way to compare the outputs of F and G within C." ;

CommaObject ::= "Obj" "(" Identifier "," Identifier "," Identifier ")" ;
TYPING
    ParentCategory = (F ↓ G)
    Γ ⊢ a : Object_in(Domain(F)), Γ ⊢ b : Object_in(Domain(G))
    Γ ⊢ h : Morphism(F(a), G(b)) in Codomain(F)
    -------------------------------------------------------------
    Γ ⊢ Obj(a,b,h) : Object_in(ParentCategory) ;
CATEGORY
    [[ Obj(a,b,h) ]] = "An object of the comma category, consisting of a pair of source objects (a, b) and a 'connecting morphism' h: F(a) -> G(b) in the target category." ;

CommaMorphism ::= "Mor" "(" Identifier "," Identifier ")" ;
TYPING
    ParentCategory = (F ↓ G)
    Source = Obj(a,b,h), Target = Obj(a',b',h')
    Γ ⊢ f : Morphism(a, a') in Domain(F)
    Γ ⊢ g : Morphism(b, b') in Domain(G)
    Satisfies( (f,g), CommaMorphismCommutativityAxiom(h,h',f,g) )
    ------------------------------------------------------------------
    Γ ⊢ Mor(f,g) : Morphism(Source, Target) in ParentCategory ;
CATEGORY
    [[ Mor(f,g) ]] = "A morphism of the comma category, itself a pair of morphisms (f,g) from the underlying source categories which makes the defining diagram commute." ;

CommaMorphismCommutativityAxiom ::= "AXIOM" "CommaSquare" ":" Expression "∘" Identifier "==" Identifier "∘" Expression ;
TYPING
    h' ∘ F(f) == G(g) ∘ h
    -----------------------------
    Γ ⊢ AXIOM ... : MetaTheorem ;
CATEGORY
    [[ AXIOM CommaSquare ... ]] = "The coherence law for morphisms in a comma category. It is the constraint that ties the components `f` and `g` together via the connecting morphisms `h` and `h'`." ;

IdentityFunctorConstructor ::= "Id" "(" Identifier ")" ;
TYPING
    Γ ⊢ C : Category
    -------------------------------
    Γ ⊢ Id(C) : Functor(C, C) ;
CATEGORY
    [[ Id(C) ]] = "The identity functor on category C, which maps all objects and morphisms to themselves." ;

ConstantFunctorConstructor ::= "Δ" "_" Identifier ;
TYPING
    Γ ⊢ C : Category, Γ ⊢ X : Object_in(C)
    ---------------------------------------------------
    Γ ⊢ Δ_X : Functor(1, C) ;
CATEGORY
    [[ Δ_X ]] = "The constant functor that maps the single object of the terminal category `1` to the object `X` in C." ;

SliceCategory ::= Identifier "/" Identifier ;
TYPING
    (Γ ⊢ C/X : Category) ⇔ (Γ ⊢ (Id(C) ↓ Δ_X) : Category)
    ------------------------------------------------------------
    Γ ⊢ "C/X is a well-defined slice category" : Proposition ;
CATEGORY
    [[ C/X ]] = "The slice category of objects over X. Its objects are arrows in C with codomain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Id(C) ↓ Δ_X)." ;

CosliceCategory ::= Identifier "\\" Identifier ;
TYPING
    (Γ ⊢ X\\C : Category) ⇔ (Γ ⊢ (Δ_X ↓ Id(C)) : Category)
    ------------------------------------------------------------
    Γ ⊢ "X\\C is a well-defined coslice category" : Proposition ;
CATEGORY
    [[ X\\C ]] = "The coslice category of objects under X. Its objects are arrows in C with domain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Δ_X ↓ Id(C))." ;

InverseMorphism ::= "inverse" "(" Identifier ")" ;
TYPING
    Γ ⊢ f is ISOMORPHISM,  f : Morphism(A,B)
    ----------------------------------------------------
    Γ ⊢ inverse(f) : Morphism(B,A) ;
CATEGORY
    [[ inverse(f) ]] = "The unique morphism `f⁻¹` such that `f⁻¹ ∘ f = id` and `f ∘ f⁻¹ = id`. Its existence is guaranteed by the fact that `f` is an isomorphism." ;

TheoremDeclaration ::= "THEOREM" string_literal ":" Proposition ;
TYPING
    IsProvable(Proposition)
    ----------------------------------------------
    Γ ⊢ THEOREM name : Proposition : MetaTheorem ;
CATEGORY
    [[ THEOREM name : Prop ]] = "The assertion that the proposition [[Prop]] holds true for all objects in the category being described. It is a proven fact." ;


TheoremDeclaration ::= "THEOREM" "CompositionOfMonomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfEpimorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is EPIMORPHISM" "&&" "g is EPIMORPHISM" ")" "==>" "(" "(g∘f) is EPIMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfIsomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is ISOMORPHISM" "&&" "g is ISOMORPHISM" ")" "==>" "(" "(g∘f) is ISOMORPHISM" ")" ;
    MorphismPropertyAssertion ::= Identifier "is" ("SPLIT_MONOMORPHISM" | "SPLIT_EPIMORPHISM") ;
    TYPING
        Γ ⊢ f : Morphism(A, B)
        CASE "SPLIT_MONOMORPHISM":
            ∃(r : Morphism(B, A)), (r ∘ f == id(A))
        CASE "SPLIT_EPIMORPHISM":
            ∃(s : Morphism(B, A)), (f ∘ s == id(B))
        -------------------------------------------------------------
        Γ ⊢ f is ... : PropositionAbout(f) ;
    CATEGORY
        [[ f is SPLIT_MONOMORPHISM ]] = "Property of being a monomorphism `f` for which there exists a retraction `r` that 'undoes' it. All split monos are monos." ;
        [[ f is SPLIT_EPIMORPHISM ]] = "Property of being an epimorphism `f` for which there exists a section `s` that 'selects' an element from each fiber. All split epis are epis." ;

    TheoremDeclaration ::= "THEOREM" "IsomorphismImpliesMonoAndEpi" ":"
        "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "==>" "(" "f is MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
    TYPING
        IsProvable(Proposition)
        --------------------------
        Γ ⊢ THEOREM... : MetaTheorem ;
    CATEGORY
     [[ THEOREM "IsoImpliesMonoAndEpi" ]] = "A fundamental fact stating that any structural equivalence (isomorphism) must also satisfy the cancellation properties of monomorphisms and epimorphisms." ;

    CategoryPropertyDefinition ::= Identifier "is" "BALANCED" ;
    TYPING
        Γ ⊢ C : Category
        ∀ (f in C), ( (f is MONOMORPHISM) ∧ (f is EPIMORPHISM) ) ⇒ (f is ISOMORPHISM)
        -----------------------------------------------------------------------------------
        Γ ⊢ C is BALANCED : PropositionAbout(C) ;
    CATEGORY
        [[ C is BALANCED ]] = "The property of a category C where the classes of monomorphisms and epimorphisms are 'well-behaved' enough that their intersection contains only isomorphisms. The category of Sets is an example." ;

    TheoremDeclaration ::= "THEOREM" "IsoEquivalenceForSplitMorphisms" ":"
        "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "<==>" "(" "f is SPLIT_MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
    TYPING
        IsProvable(Proposition)
        --------------------------
        Γ ⊢ THEOREM... : MetaTheorem ;
    CATEGORY
        [[ THEOREM "IsoEquivalenceForSplitMorphisms" ]] = "A key structural result: an isomorphism is precisely an epimorphism that is also a split monomorphism. This connects the abstract cancellation property of epis with the constructive existence of a retraction." ;

DualStatement ::= "(" Proposition ")^op" ;
TYPING
    Γ ⊢ P : Proposition in C
    ----------------------------------
    Γ ⊢ (P)^op : Proposition in C^op ;
CATEGORY
    [[ (P)^op ]] = "The dual proposition of [[P]], obtained by systematically reversing all morphisms, swapping the order of compositions, and replacing each concept with its dual concept." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" ConceptName "IS" ConceptName ";" ;
TYPING
    IsConcept(C1), IsConcept(C2)
    -----------------------------------------------------------------------------------------
    (Γ ⊢ (X is C1)^op)  <==>  (Γ ⊢ (X is C2)) ;
CATEGORY
    [[ DUALITY_MAPPING FOR C1 IS C2 ]] = "An assertion of isomorphism between the definitions of [[C1]] and [[C2]] under the duality functor. This axiom provides a concrete rule for translating between a concept and its dual." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "TERMINAL_OBJECT" "IS" "INITIAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "INITIAL_OBJECT" "IS" "TERMINAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PRODUCT" "IS" "COPRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COPRODUCT" "IS" "PRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PULLBACK" "IS" "PUSHOUT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PUSHOUT" "IS" "PULLBACK" ;
DualityMappingAxiom ::= "DUALITY_MIPPING" "FOR" "EQUALIZER" "IS" "COEQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COEQUALIZER" "IS" "EQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LIMIT" "IS" "COLIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COLIMIT" "IS" "LIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "MONOMORPHISM" "IS" "EPIMORPHISM" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "EPIMORPHISM" "IS" "MONOMORPHISM" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" string_literal "FROM" "THEOREM" string_literal ;
TYPING
    Γ ⊢ THEOREM T_orig_name : P_orig
    P_dual = rewrite(P_orig, DualityMappings)
    -------------------------------------------------------------
    Γ ⊢ INFER_DUAL_THEOREM T_dual_name ... : (THEOREM T_dual_name : P_dual) ;
CATEGORY
    [[ INFER_DUAL_THEOREM T_dual FROM T_orig ]] = "The application of the Duality Principle as a meta-inference rule. It is a functor from the category of proofs to itself, mapping the proof object `[[T_orig]]` to a newly constructed proof object `[[T_dual]]`." ;

TheoremDeclaration ::= "THEOREM" "'CompMono'" ":" "FOR_ALL" "f,g" "," 
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" "&&" "IsDefined(g∘f)" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CompEpi'" "FROM" "THEOREM" "'CompMono'" ;
TYPING
    Γ ⊢ THEOREM 'CompMono' : P_mono
    -------------------------------------------------
    Γ ⊢ THEOREM 'CompEpi' : P_epi ;
CATEGORY
    [[ INFER_DUAL_THEOREM 'CompEpi' FROM 'CompMono' ]] = "A constructive proof that the composition of two epimorphisms is an epimorphism, obtained not by first principles, but by a direct, mechanical application of the Duality Principle to the proof for monomorphisms." ;
