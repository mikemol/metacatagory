-- Core.Algorithms.FiniteFields: Instances of algebraic algorithms for finite fields

module Core.Algorithms.FiniteFields where

open import Core
open import Algebra.Rings.Basic
open import Algebra.Fields.Basic
open import Algebra.Groups.Basic
open import Algebra.Foundation
open import Core.AlgebraicAlgorithms
open import Metamodel as M
open import Agda.Builtin.List using (List; []; _∷_)

-- Finite field predicate (kept abstract);
-- all concrete algorithm content below avoids extra postulates.
postulate
  IsFiniteField : FieldDeclaration → Set

-- Helper: construct a cyclic group for Galois group Gal(E/F) over finite fields
-- In finite fields, Gal(E/F) is cyclic generated by Frobenius
cyclicGaloisGroup : (F E : FieldDeclaration) → IsFiniteField F → IsFiniteField E → GaloisGroup F E
cyclicGaloisGroup F E Ffin Efin = record
  { baseField      = F
  ; extensionField = E
  ; group          = record
      { underlyingMonoid = record
          { underlyingSemigroup = record
              { underlyingMagma = record
                  { underlyingSet = M.mkId "Gal(E/F)"
                  ; binaryOp = M.mkId "∘"
                  }
              ; associativity = record { over = M.mkId "Gal(E/F)-assoc" }
              }
          ; identityElement = M.mkId "id"
          ; identityAxiom = record { over = M.mkId "Gal(E/F)-id" }
          }
      ; inverseOperation = record
          { forMonoid = record
              { underlyingSemigroup = record
                  { underlyingMagma = record
                      { underlyingSet = M.mkId "Gal(E/F)"
                      ; binaryOp = M.mkId "∘"
                      }
                  ; associativity = record { over = M.mkId "Gal(E/F)-assoc" }
                  }
              ; identityElement = M.mkId "id"
              ; identityAxiom = record { over = M.mkId "Gal(E/F)-id" }
              }
          ; inverseMap = M.mkId "inv"
          ; inverseAxiom = M.mkId "inverse-ax"
          }
      }
  ; automorphisms  = M.mkId "Frobenius-generated"
  }

-- Helper: enumerate subgroups of cyclic Galois group
-- For cyclic group of order n, subgroups correspond to divisors of n
cyclicSubgroups : (F E : FieldDeclaration) → IsFiniteField F → IsFiniteField E → List GroupDeclaration
cyclicSubgroups F E Ffin Efin = 
  let trivialGroup = record
        { underlyingMonoid = record
            { underlyingSemigroup = record
                { underlyingMagma = record
                    { underlyingSet = M.mkId "{id}"
                    ; binaryOp = M.mkId "∘"
                    }
                ; associativity = record { over = M.mkId "trivial-assoc" }
                }
            ; identityElement = M.mkId "id"
            ; identityAxiom = record { over = M.mkId "trivial-id" }
            }
        ; inverseOperation = record
            { forMonoid = record
                { underlyingSemigroup = record
                    { underlyingMagma = record
                        { underlyingSet = M.mkId "{id}"
                        ; binaryOp = M.mkId "∘"
                        }
                    ; associativity = record { over = M.mkId "trivial-assoc" }
                    }
                ; identityElement = M.mkId "id"
                ; identityAxiom = record { over = M.mkId "trivial-id" }
                }
            ; inverseMap = M.mkId "inv"
            ; inverseAxiom = M.mkId "inverse-ax"
            }
        }
      fullGroup = GaloisGroup.group (cyclicGaloisGroup F E Ffin Efin)
  in trivialGroup ∷ fullGroup ∷ []

-- Bundle of algorithms specialized to finite fields E/F
record FiniteFieldAlgorithms (F E : FieldDeclaration)
                           (Ffin : IsFiniteField F)
                           (Efin : IsFiniteField E) : Set₁ where
  field
    minimalPolynomialAlg : MinimalPolynomialAlgorithm F E
    galoisGroupAlg       : GaloisGroupAlgorithm F E
    splittingFieldAlg    : SplittingFieldAlgorithm F
    extensionDegreeAlg   : FieldExtensionDegreeAlgorithm F E
    subfieldEnumAlg      : SubfieldEnumerationAlgorithm F E
    subgroupEnumAlg      : SubgroupEnumerationAlgorithm F E
    algebraicityAlg      : AlgebraicityDecisionAlgorithm F E
    primitiveElementAlg  : PrimitiveElementAlgorithm F E

open FiniteFieldAlgorithms public

finiteFieldAlgorithms : ∀ {F E} → (Ffin : IsFiniteField F) → (Efin : IsFiniteField E)
                       → FiniteFieldAlgorithms F E Ffin Efin
finiteFieldAlgorithms {F} {E} Ffin Efin = record
  { minimalPolynomialAlg = record
    { minimalPolynomial = λ α → M.mkId "minpoly"
    ; isAlgebraic       = λ α → yes (record
      { baseField        = F
      ; extensionField   = E
      ; element          = α
      ; minimalPolynomial = M.mkId "minpoly"
      ; isAlgebraic      = M.mkId "algebraic"
      })
      }
  ; galoisGroupAlg = record
      { galoisGroup   = λ f → cyclicGaloisGroup F E Ffin Efin
      ; automorphisms = λ f → []
      ; isSolvable    = λ f → M.mkId "cyclic-solvable"
      }
  ; splittingFieldAlg = record
    { splittingField = λ f → record
      { baseField       = F
      ; polynomial      = f
      ; splittingField  = E
      ; definition      = M.mkId "splits"
      }
    ; roots          = λ f → []
      }
  ; extensionDegreeAlg = record
    { extensionDegree = record
      { baseField       = F
      ; extensionField  = E
      ; degree          = M.mkId "degree"
      }
    ; basis           = defaultBasis F E
      }
  ; subfieldEnumAlg = record
    { subfields = (record
      { subfield   = F
      ; subset     = M.mkId "subset"
      ; inclusion  = M.mkId "incl"
      ; isSubfield = M.mkId "isSubfield"
      }) ∷ []
      }
  ; subgroupEnumAlg = record
      { subgroups = cyclicSubgroups F E Ffin Efin
      }
  ; algebraicityAlg = record
    { isAlgebraic      = λ α → yes (record
      { baseField        = F
      ; extensionField   = E
      ; element          = α
      ; minimalPolynomial = M.mkId "minpoly"
      ; isAlgebraic      = M.mkId "algebraic"
      })
    ; isTranscendental = λ α → no
      }
  ; primitiveElementAlg = record
    { primitiveElement = M.mkId "primitive"
    ; witnessSimpleExtension = record
      { baseField         = F
      ; extensionField    = E
      ; adjoinedElement   = M.mkId "primitive"
      ; minimalPolynomial = M.mkId "minpoly"
      ; isSimpleExtension = M.mkId "witness"
      }
    }
  }
