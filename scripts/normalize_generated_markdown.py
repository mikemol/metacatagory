#!/usr/bin/env python3
"""
Normalize generated markdown files with markdownlint.

This ensures all Agda/Python-generated markdown files comply with
the project's markdown style guide.
"""

import subprocess
import sys
import re
from pathlib import Path

try:
    import yaml  # type: ignore
except ImportError:
    yaml = None

REPO_ROOT = Path(__file__).parent.parent

# Files generated by Agda or Python that should be normalized
GENERATED_FILES = [
    "README.md",
    "CONTRIBUTING.md",
    "docs/NAVIGATION.md",
    "docs/planning/ROADMAP.md",
    "docs/status/DEFERRED-TRACKING.md",
    "docs/status/deferred-items.md",
    "docs/architecture/FRAMEWORK-INTEROPERABILITY.md",
    "build/reports/test-report.md",
]

def find_markdownlint() -> Path | None:
    """
    Locate markdownlint-cli2. Prefer local node_modules; fall back to PATH.

    Returning None lets callers bail out with a clear message instead of
    hanging on an interactive npx install prompt.
    """
    local_bin = REPO_ROOT / "node_modules" / ".bin" / "markdownlint-cli2"
    if local_bin.exists():
        return local_bin
    from shutil import which
    found = which("markdownlint-cli2")
    return Path(found) if found else None

def extract_frontmatter(content: str):
    """Parse all YAML code blocks and return list of dicts."""
    blocks = re.findall(r'```yaml\n(.*?)\n```', content, re.DOTALL)
    parsed = []
    if yaml is None:
        # Fallback: record presence but skip strict parsing
        return [{"__parse_error__": "yaml module missing"} for _ in blocks]

    for block in blocks:
        try:
            data = yaml.safe_load(block)
            if isinstance(data, dict):
                parsed.append(data)
            else:
                parsed.append({"__parse_error__": "non-dict yaml block"})
        except yaml.YAMLError as e:
            parsed.append({"__parse_error__": str(e)})
    return parsed

def normalize_markdown(filepath: Path) -> bool:
    """Run markdownlint --fix on a file."""
    if not filepath.exists():
        print(f"⚠️  Skipping {filepath} (does not exist)")
        return True

    before_content = filepath.read_text(encoding="utf-8")
    fm_before = extract_frontmatter(before_content)
    if any('__parse_error__' in fm for fm in fm_before):
        print(f"✗ Frontmatter parse error before lint in {filepath}")
        return False

    tool = find_markdownlint()
    if tool is None:
        print("✗ markdownlint-cli2 not found. Please run `make node-deps` first.")
        return False

    try:
        result = subprocess.run(
            [str(tool), "--fix", str(filepath)],
            cwd=REPO_ROOT,
            capture_output=True,
            text=True,
        )
        
        if result.returncode == 0:
            after_content = filepath.read_text(encoding="utf-8")
            fm_after = extract_frontmatter(after_content)

            if fm_before != fm_after:
                print(f"✗ Frontmatter changed by normalization in {filepath}")
                return False

            print(f"✓ Normalized {filepath}")
            return True
        else:
            print(f"✗ Failed to normalize {filepath}")
            print(result.stdout)
            print(result.stderr)
            return False
    except Exception as e:
        print(f"✗ Error normalizing {filepath}: {e}")
        return False

def main():
    """Normalize all generated markdown files."""
    print("Normalizing generated markdown files...")
    print()
    
    success_count = 0
    total_count = 0
    
    for file_path in GENERATED_FILES:
        total_count += 1
        abs_path = REPO_ROOT / file_path
        if normalize_markdown(abs_path):
            success_count += 1
    
    print()
    print(f"Normalized {success_count}/{total_count} files")
    
    if success_count < total_count:
        sys.exit(1)

if __name__ == "__main__":
    main()
