module Core where

-- Core re-exports: a stable surface for downstream modules
-- Import the syntactic/metamodel layer and the unified proof layer

open import Metamodel public
open import Level1 public
open import PropertyRegistry public
module PropertyRegistry where

open import Metamodel as M

-- Stable identifiers for commonly used properties/classes/operations
-- These are plain Identifiers to be used with the generic scaffolding subjects.

-- Category-level properties
RegularCategoryId : M.Identifier
RegularCategoryId = "RegularCategory"

ExactCategoryId : M.Identifier
ExactCategoryId = "ExactCategory"

BarrExactCategoryId : M.Identifier
BarrExactCategoryId = "BarrExactCategory"

FiniteLimitsId : M.Identifier
FiniteLimitsId = "FiniteLimits"

-- Relation effectiveness property
EffectiveEquivalenceRelationsId : M.Identifier
EffectiveEquivalenceRelationsId = "EffectiveEquivalenceRelations"

-- Morphism classes and closure notions
RegularEpiClassId : M.Identifier
RegularEpiClassId = "RegularEpi"

-- Operations / contexts for closure and stability
CompositionOpId : M.Identifier
CompositionOpId = "Composition"

PullbackContextId : M.Identifier
PullbackContextId = "Pullback"

-- Chapter 3: Algebraic categories and related properties
AlgebraicCategoryId : M.Identifier
AlgebraicCategoryId = "AlgebraicCategory"

CompleteCategoryId : M.Identifier
CompleteCategoryId = "Complete"

CocompleteCategoryId : M.Identifier
CocompleteCategoryId = "Cocomplete"

SymmetricMonoidalCategoryId : M.Identifier
SymmetricMonoidalCategoryId = "SymmetricMonoidalCategory"

-- Free/forgetful adjunction existence (algebraic categories)
HasFreeForgetfulAdjunctionId : M.Identifier
HasFreeForgetfulAdjunctionId = "HasFreeForgetfulAdjunction"

-- Lattice-level properties (used for Subobject lattices etc.)
AlgebraicLatticeId : M.Identifier
AlgebraicLatticeId = "AlgebraicLattice"

-- Beck characterization: generator properties
HasRegularProjectiveGeneratorId : M.Identifier
HasRegularProjectiveGeneratorId = "HasRegularProjectiveGenerator"

RegularlyCoveredByGeneratorId : M.Identifier
RegularlyCoveredByGeneratorId = "RegularlyCoveredByGenerator"

-- Category has a (possibly non-regular-projective) generator
HasGeneratorId : M.Identifier
HasGeneratorId = "HasGenerator"

-- Functor-level properties
AlgebraicFunctorId : M.Identifier
AlgebraicFunctorId = "AlgebraicFunctor"
module Metamodel where

-- Minimal builtins to avoid external stdlib dependencies
open import Agda.Builtin.Equality using (_≡_; refl)
open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Nat      using (Nat)
open import Agda.Builtin.Char     using (Char)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)

------------------------------------------------------------------------
-- I. Metamodel Structural Definition (Agda encoding of metamodel.ebnf)
------------------------------------------------------------------------

-- Utilities
record NonEmpty (A : Set) : Set where
  constructor ne
  field
    head : A
    tail : List A
open NonEmpty public

-- Identifiers and Terminals
record Identifier : Set where
  constructor mkId
  field name : String
open Identifier public

record Terminal : Set where
  constructor mkTerm
  field literal : String
open Terminal public

-- Denotations (semantic side used by CATEGORY rules)
data DenotationExpr : Set where
  dId  : Identifier -> DenotationExpr
  dStr : String -> DenotationExpr

------------------------------------------------------------------------
-- II. Syntax Primitives
------------------------------------------------------------------------

mutual
  -- Expression ::= Term { "|" Term }
  record Expression : Set where
    constructor alt
    field alts : NonEmpty Term
  open Expression public

  -- Term ::= Factor { "," Factor }
  record Term : Set where
    constructor seq
    field factors : NonEmpty Factor
  open Term public

  -- Factor ::= Identifier | Terminal | "(" Expression ")"
  --         |  "[" Expression "]" | "{" Expression "}"
  data Factor : Set where
    FIdentifier : Identifier  -> Factor
    FTerminal   : Terminal    -> Factor
    FParen      : Expression  -> Factor
    FBrackets   : Expression  -> Factor
    FBraces     : Expression  -> Factor

------------------------------------------------------------------------
-- III. Typing and Category Primitives
------------------------------------------------------------------------

-- Context ::= "Γ" | Context "," Identifier ":" Type
-- We model the empty context by Γ, and extension with a constructor.
record Type : Set where
  constructor make-type
  field ident : Identifier
open Type public

data Context : Set where
  Γ      : Context                      -- empty context
  extend : Context -> Identifier -> Type -> Context

-- Judgment ::= Context "|-" Expression ":" Type
record Judgment : Set where
  constructor make-judgment
  field
    ctx  : Context
    expr : Expression
    typ  : Type
open Judgment public

-- PremiseList ::= { Judgment }
PremiseList : Set
PremiseList = List Judgment

-- Syntactic, Typing, and Category rules encoded as records
record SyntaxDef : Set where
  constructor define-syntax
  field
    id   : Identifier
    expr : Expression
open SyntaxDef public

record TypingDef : Set where
  constructor define-typing
  field
    premises  : List Judgment
    conclusion: Judgment
open TypingDef public

record CategoryDef : Set where
  constructor define-category
  field
    subject : Identifier
    meaning : DenotationExpr
open CategoryDef public

-- AugmentedRule ::= SyntacticRule "TYPING" TypingRule "CATEGORY" CategoricalRule
-- Coherent rule that couples syntax, typing, and categorical meaning
record CoherentRule : Set where
  constructor make-rule
  field
    syn : SyntaxDef
    typ : TypingDef
    cat : CategoryDef
open CoherentRule public

-- Treat AugmentedRule as CoherentRule
AugmentedRule : Set
AugmentedRule = CoherentRule

-- ComputableGrammar ::= { AugmentedRule }
ComputableGrammar : Set
ComputableGrammar = List AugmentedRule

------------------------------------------------------------------------
-- IV. Lexical Definition (predicates as postulates)
------------------------------------------------------------------------

postulate
  is-valid-identifier-string : String -> Bool
  is-string-literal          : String -> Bool
  is-alphabetic-char         : Char   -> Bool
  is-numeric-char            : Char   -> Bool
  is-printable-ascii-char    : Char   -> Bool

------------------------------------------------------------------------
-- V. Embedded Declarative Parser Logic (Earley-style skeleton)
------------------------------------------------------------------------

-- Abstract parser-state items; details are left abstract.
postulate
  EarleyItem            : Set
  ParseState            : Set
  CompletedParseState   : Set

-- Parsing steps as structured records reflecting the EBNF surface
record Prediction : Set where
  constructor PREDICT
  field
    produced : EarleyItem
    from     : EarleyItem

record Scan : Set where
  constructor SCAN
  field
    produced : EarleyItem
    from     : EarleyItem

record Completion : Set where
  constructor COMPLETE
  field
    produced : EarleyItem
    from₁    : EarleyItem
    from₂    : EarleyItem

-- ParseSuccess ::= "ACCEPT" Terminal
record ParseSuccess : Set where
  constructor ACCEPT
  field token : Terminal

-- Abstract parsing relations referenced by the typing block in EBNF
postulate
  System     : Set
  StartRule  : System -> AugmentedRule -> Set
  IsComplete : AugmentedRule -> Nat -> Nat -> System -> Set
  Input      : System -> String
  AcceptedString : Set
  success    : String -> AcceptedString

------------------------------------------------------------------------
-- VI. Embedded Semantic Correspondences (Curry–Howard–Lambek stubs)
------------------------------------------------------------------------

-- Abstract universes for logic, type theory, and category levels
postulate
  Proposition : Set
  Type′       : Set       -- object-language types (distinct from Agda's Set)
  Object′     : Set       -- object-language categorical objects

-- Logical constructors and their bridges
postulate
  implies    : Proposition -> Proposition -> Proposition
  and        : Proposition -> Proposition -> Proposition
  CH         : Proposition -> Type′
  HL         : Type′       -> Object′
  func_type  : Type′ -> Type′ -> Type′
  prod_type  : Type′ -> Type′ -> Type′
  exp_obj    : Object′ -> Object′ -> Object′
  prod_obj   : Object′ -> Object′ -> Object′

-- Dependent families and Π/Σ across logic, types, and categories
postulate
  forall     : (A : Set) -> (P : A -> Proposition) -> Proposition
  exists     : (A : Set) -> (P : A -> Proposition) -> Proposition
  Pi_type    : (A : Set) -> ((x : A) -> Type′)   -> Type′
  Sigma_type : (A : Set) -> ((x : A) -> Type′)   -> Type′
  Pi_obj     : (A : Set) -> ((x : A) -> Object′) -> Object′
  Sigma_obj  : (A : Set) -> ((x : A) -> Object′) -> Object′

-- Correspondence axioms (isomorphisms stated as equalities)
postulate
  CH-implies : (p q : Proposition)
             -> CH (implies p q) ≡ func_type (CH p) (CH q)
  HL-exp     : (p q : Proposition)
             -> HL (func_type (CH p) (CH q)) ≡ exp_obj (HL (CH p)) (HL (CH q))

  CH-and     : (p q : Proposition)
             -> CH (and p q) ≡ prod_type (CH p) (CH q)
  HL-prod    : (p q : Proposition)
             -> HL (prod_type (CH p) (CH q)) ≡ prod_obj (HL (CH p)) (HL (CH q))

  CH-forall  : (A : Set) (P : A -> Proposition)
             -> CH (forall A P) ≡ Pi_type A (λ x -> CH (P x))
  HL-Pi      : (A : Set) (P : A -> Proposition)
             -> HL (Pi_type A (λ x -> CH (P x))) ≡ Pi_obj A (λ x -> HL (CH (P x)))

  CH-exists  : (A : Set) (P : A -> Proposition)
             -> CH (exists A P) ≡ Sigma_type A (λ x -> CH (P x))
  HL-Sigma   : (A : Set) (P : A -> Proposition)
             -> HL (Sigma_type A (λ x -> CH (P x))) ≡ Sigma_obj A (λ x -> HL (CH (P x)))

------------------------------------------------------------------------
-- Notes
------------------------------------------------------------------------
-- This Agda module provides a faithful structural counterpart to the
-- provided EBNF, encoding grammar constructs as data, and the typing and
-- category annotations as records/postulates. Where the EBNF leaves
-- definitions schematic (e.g., EarleyItem, semantic domains), we keep
-- them abstract via postulates so the file remains self-contained.
module Level1 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Equality using (_≡_)

-- Reuse basic identifiers/terminals and logical propositions from the metamodel
open import Metamodel as M
open import PropertyRegistry as P

------------------------------------------------------------------------
-- Helpers
------------------------------------------------------------------------
record NonEmpty (A : Set) : Set where
  constructor ne
  field head : A
        tail : List A
open NonEmpty public

------------------------------------------------------------------------
-- Supporting primitives for this level
------------------------------------------------------------------------

-- Names of axioms referenced in promotions
data AxiomName : Set where
  IdentityAxiomName         : AxiomName
  AssociativityAxiomName    : AxiomName
  PreservesCompositionName  : AxiomName
  PreservesIdentityName     : AxiomName
  NaturalityName            : AxiomName
  -- Level 2 (products) axioms
  ProductCommutativityName  : AxiomName
  ProductUniquenessName     : AxiomName
  -- Level 2 (coproducts) axioms
  CoproductCommutativityName : AxiomName
  CoproductUniquenessName    : AxiomName
  -- Level 2 (initial/terminal) axioms
  InitialUniquenessName     : AxiomName
  TerminalUniquenessName    : AxiomName
  -- Level 3 (adjunctions) axioms
  TriangleIdentitiesName    : AxiomName
  RightAdjPreservesLimitsName : AxiomName
  LeftAdjPreservesColimitsName : AxiomName
  -- Level 4 (generators/projectives/factorization) axioms
  FactorizationUniquenessName : AxiomName
  SubobjectLatticeCompletenessName : AxiomName
  CanonicalFactorizationSystemName : AxiomName
  ProjectiveLiftingName : AxiomName
  InjectiveLiftingName : AxiomName
  -- Level 7 (2-categories, lax functors, limit hierarchy)
  TwoCatAssociativityName : AxiomName
  TwoCatUnitalityName     : AxiomName
  LaxAssociativityName    : AxiomName
  LaxUnitalityName        : AxiomName
  LimitHierarchyName      : AxiomName
  CauchyViaDistributorsName : AxiomName
  -- Level 8 (internal category theory)
  InternalAssociativityName : AxiomName
  InternalLeftUnitName      : AxiomName
  InternalRightUnitName     : AxiomName
  YonedaLemmaName           : AxiomName
  InternalLimitUniversalName : AxiomName
  InternalColimitDualityName : AxiomName
  InternalColimitUniversalName : AxiomName
  -- Level 2 (additive / abelian extensions)
  ZeroObjectPropertyName : AxiomName
  KernelAsEqualizerName  : AxiomName
  CokernelAsCoequalizerName : AxiomName
  AdditiveCategoryName   : AxiomName
  AbelianCategoryName    : AxiomName
  AdditivityViaBiproductMapIsoName : AxiomName
  CoimageImageIsomorphismName : AxiomName
  ShortExactSequenceExactnessName : AxiomName
  SplittingLemmaName : AxiomName
  LongExactSequenceExactnessName : AxiomName
  LeftExactFunctorName  : AxiomName
  RightExactFunctorName : AxiomName
  ExactFunctorName      : AxiomName
  AdditiveFunctorPreservesBiproductsName : AxiomName
  CovariantHomLeftExactName : AxiomName
  ExactHomProjectiveCharacterizationName : AxiomName
  InjectiveHomDualityName : AxiomName
  SubobjectLatticeModularName : AxiomName
  FiveLemmaName : AxiomName
  SnakeLemmaName : AxiomName
  ThreeByThreeLemmaName : AxiomName
  TorsionOrthogonalityName : AxiomName
  TorsionDecompositionName : AxiomName
  TorsionClassClosedUnderQuotientsName : AxiomName
  TorsionFreeClosedUnderSubobjectsName : AxiomName
  TorsionReflectiveName : AxiomName
  TorsionFreeCoreflectiveName : AxiomName
  TorsionTheoryAxiomsName : AxiomName
  -- Level 2 (regular / exact / Barr-exact categories)
  RegularCategoryName : AxiomName
  RegularEpiPropertyName : AxiomName
  RegularEpisAreStrongName : AxiomName
  KernelPairEquivRelName : AxiomName
  EffectiveRelationsName : AxiomName
  ExactCategoryName : AxiomName
  BarrExactCategoryName : AxiomName
  BarrEmbeddingTheoremName : AxiomName
  PreservesRegularEpisName : AxiomName
  PreservesFiniteLimitsName : AxiomName
  -- Generic property scaffolding (scales across chapters)
  HasPropertyName : AxiomName
  ClosedUnderName : AxiomName
  StableUnderName : AxiomName
  PreservesPropertyName : AxiomName
  ReflectsPropertyName  : AxiomName
  CreatesPropertyName   : AxiomName

-- Subjects about which axioms speak (captures kind-specific payload)
data Subject : Set where
  PreCategoryS : (G : M.Identifier) -> Subject
  FunctorMapS  : (F : M.Identifier) (C : M.Identifier) (D : M.Identifier) -> Subject
  -- Subject for a product object P over a family of parts
  ProductS     : (P : M.Identifier) (parts : List M.Identifier) -> Subject
  -- Subject for a coproduct object Q over a family of parts
  CoproductS   : (Q : M.Identifier) (parts : List M.Identifier) -> Subject
  -- Subject for initial/terminal objects (single object carrier)
  InitialS     : (I : M.Identifier) -> Subject
  TerminalS    : (T : M.Identifier) -> Subject
  -- Subject for adjunctions (pair of functors)
  AdjunctionS  : (F G : M.Identifier) (C D : M.Identifier) -> Subject
  -- Subject for factorization systems
  FactorizationS : (C : M.Identifier) (E M : M.Identifier) -> Subject
  -- Subject for projective objects
  ProjectiveS  : (P : M.Identifier) -> Subject
  -- Subject for injective objects
  InjectiveS   : (I : M.Identifier) -> Subject
  -- Subject for category-level properties (well-powered, complete, etc.)
  CategoryPropertyS : (C : M.Identifier) -> Subject
  -- Level 7 subjects
  TwoCategoryS : (C : M.Identifier) -> Subject
  LaxFunctorS  : (F : M.Identifier) (C : M.Identifier) (D : M.Identifier) -> Subject
  BicategoryS  : (B : M.Identifier) -> Subject
  DistributorS : (A B : M.Identifier) (D : M.Identifier) -> Subject
  -- Level 8 subjects
  InternalCategoryS : (IC : M.Identifier) (ambient : M.Identifier) -> Subject
  InternalDiagramS  : (D : M.Identifier) (IC : M.Identifier) -> Subject
  InternalLimitS    : (L : M.Identifier) (D : M.Identifier) (IC : M.Identifier) -> Subject
  InternalColimitS  : (L : M.Identifier) (D : M.Identifier) (IC : M.Identifier) -> Subject
  -- Level 2 additive/abelian subjects
  ZeroObjectS : (C Z : M.Identifier) -> Subject
  KernelEqualizerS : (f : M.Identifier) (C : M.Identifier) -> Subject
  CokernelCoequalizerS : (f : M.Identifier) (C : M.Identifier) -> Subject
  AdditiveCategoryS : (C : M.Identifier) -> Subject
  AbelianCategoryS  : (C : M.Identifier) -> Subject
  BiproductComparisonS : (C : M.Identifier) -> Subject
  CoimageImageIsoS : (f : M.Identifier) (C : M.Identifier) -> Subject
  ShortExactSequenceS : (seq : M.Identifier) -> Subject
  SplittingLemmaS : (seq : M.Identifier) -> Subject
  LongExactSequenceS : (seq : M.Identifier) -> Subject
  FunctorExactnessS : (F : M.Identifier) (C : M.Identifier) (D : M.Identifier) -> Subject
  AdditiveFunctorS : (F : M.Identifier) (C : M.Identifier) (D : M.Identifier) -> Subject
  SubobjectLatticeS : (C X : M.Identifier) -> Subject
  DiagramLemmaS : (lemma : M.Identifier) -> Subject
  TorsionOrthogonalityS : (T F C : M.Identifier) -> Subject
  TorsionDecompositionS : (X T F C : M.Identifier) -> Subject
  TorsionClassClosureQuotientsS : (T C : M.Identifier) -> Subject
  TorsionFreeClosureSubobjectsS : (F C : M.Identifier) -> Subject
  TorsionReflectiveS : (T C : M.Identifier) -> Subject
  TorsionFreeCoreflectiveS : (F C : M.Identifier) -> Subject
  TorsionTheoryS : (T F C : M.Identifier) -> Subject
  -- Regular / exact / Barr-exact subjects
  RegularCategoryS : (C : M.Identifier) -> Subject
  RegularEpiS : (e A B C : M.Identifier) -> Subject
  RegularEpisAreStrongS : (C e : M.Identifier) -> Subject
  KernelPairEquivRelS : (C f K k1 k2 : M.Identifier) -> Subject
  EffectiveRelationsS : (C : M.Identifier) -> Subject
  ExactCategoryS : (C : M.Identifier) -> Subject
  BarrExactCategoryS : (C : M.Identifier) -> Subject
  BarrEmbeddingS : (C K F : M.Identifier) -> Subject
  PreservesRegularEpisS : (F C D : M.Identifier) -> Subject
  PreservesFiniteLimitsS : (F C D : M.Identifier) -> Subject
  -- Generic property scaffolding subjects
  CategoryHasPropertyS : (C prop : M.Identifier) -> Subject
  ClassClosedUnderS    : (C classId opId : M.Identifier) -> Subject
  ClassStableUnderS    : (C classId contextId : M.Identifier) -> Subject
  FunctorPreservesPropertyS : (F C D prop : M.Identifier) -> Subject
  FunctorReflectsPropertyS  : (F C D prop : M.Identifier) -> Subject
  FunctorCreatesPropertyS   : (F C D prop : M.Identifier) -> Subject
  -- Generic functor-level property (beyond preserve/reflect/create)
  FunctorHasPropertyS       : (F C D prop : M.Identifier) -> Subject

-- Bridge from object-language propositions to Agda witnesses
postulate
  Holds     : M.Proposition -> Set
  AxiomProp : (subject : Subject) -> (ax : AxiomName) -> M.Proposition

-- Concrete proposition constructors reflecting the EBNF typing prose
postulate
  AssocProp    : (G : M.Identifier) -> M.Proposition
  IdProp       : (G : M.Identifier) -> M.Proposition
  PresCompProp : (F C D : M.Identifier) -> M.Proposition
  PresIdProp   : (F C D : M.Identifier) -> M.Proposition
  -- Level 2 product propositions
  ProductCommProp : (P : M.Identifier) -> (parts : List M.Identifier) -> M.Proposition
  ProductUniqProp : (P : M.Identifier) -> (parts : List M.Identifier) -> M.Proposition
  -- Level 2 coproduct propositions
  CoproductCommProp : (Q : M.Identifier) -> (parts : List M.Identifier) -> M.Proposition
  CoproductUniqProp : (Q : M.Identifier) -> (parts : List M.Identifier) -> M.Proposition
  -- Level 2 initial/terminal uniqueness propositions
  InitialUniqProp : (I : M.Identifier) -> M.Proposition
  TerminalUniqProp : (T : M.Identifier) -> M.Proposition
  -- Level 3 adjunction propositions
  TriangleIdentitiesProp : (F G C D : M.Identifier) -> M.Proposition
  RightAdjPreservesLimitsProp : (G C D : M.Identifier) -> M.Proposition
  LeftAdjPreservesColimitsProp : (F C D : M.Identifier) -> M.Proposition
  -- Level 4 factorization/generators/projectives propositions
  FactorizationUniqueProp : (C E M : M.Identifier) -> M.Proposition
  SubobjectLatticeCompleteProp : (C : M.Identifier) -> M.Proposition
  CanonicalFactorizationProp : (C E M : M.Identifier) -> M.Proposition
  ProjectiveLiftProp : (P : M.Identifier) -> M.Proposition
  InjectiveLiftProp : (I : M.Identifier) -> M.Proposition
  -- Level 7 propositions
  TwoCatAssociativityProp : (C : M.Identifier) -> M.Proposition
  TwoCatUnitalityProp     : (C : M.Identifier) -> M.Proposition
  LaxAssociativityProp    : (F C D : M.Identifier) -> M.Proposition
  LaxUnitalityProp        : (F C D : M.Identifier) -> M.Proposition
  LimitHierarchyProp      : (C : M.Identifier) -> M.Proposition
  CauchyViaDistributorsProp : (C : M.Identifier) -> M.Proposition
  -- Level 8 propositions
  InternalAssocProp   : (IC ambient : M.Identifier) -> M.Proposition
  InternalLeftUnitProp : (IC ambient : M.Identifier) -> M.Proposition
  InternalRightUnitProp : (IC ambient : M.Identifier) -> M.Proposition
  YonedaLemmaProp      : (IC : M.Identifier) (ambient : M.Identifier) -> M.Proposition
  InternalLimitUniversalProp : (L D IC : M.Identifier) -> M.Proposition
  InternalColimitDualityProp : (IC : M.Identifier) (ambient : M.Identifier) -> M.Proposition
  InternalColimitUniversalProp : (L D IC : M.Identifier) -> M.Proposition
  -- Level 2 additive / abelian propositions
  ZeroObjectProp : (C Z : M.Identifier) -> M.Proposition
  KernelAsEqualizerProp : (f C : M.Identifier) -> M.Proposition
  CokernelAsCoequalizerProp : (f C : M.Identifier) -> M.Proposition
  AdditiveCategoryProp : (C : M.Identifier) -> M.Proposition
  AbelianCategoryProp  : (C : M.Identifier) -> M.Proposition
  AdditivityViaBiproductMapIsoProp : (C : M.Identifier) -> M.Proposition
  CoimageImageIsoProp : (f C : M.Identifier) -> M.Proposition
  ShortExactSequenceProp : (seq : M.Identifier) -> M.Proposition
  SplittingLemmaProp : (seq : M.Identifier) -> M.Proposition
  LongExactSequenceProp : (seq : M.Identifier) -> M.Proposition
  LeftExactFunctorProp  : (F C D : M.Identifier) -> M.Proposition
  RightExactFunctorProp : (F C D : M.Identifier) -> M.Proposition
  ExactFunctorProp      : (F C D : M.Identifier) -> M.Proposition
  AdditiveFunctorPreservesBiproductsProp : (F C D : M.Identifier) -> M.Proposition
  CovariantHomLeftExactProp : (F C D : M.Identifier) -> M.Proposition
  ExactHomProjectiveCharacterizationProp : (F C D : M.Identifier) -> M.Proposition
  InjectiveHomDualityProp : (F C D : M.Identifier) -> M.Proposition
  SubobjectLatticeModularProp : (C X : M.Identifier) -> M.Proposition
  FiveLemmaProp : (lemma : M.Identifier) -> M.Proposition
  SnakeLemmaProp : (lemma : M.Identifier) -> M.Proposition
  ThreeByThreeLemmaProp : (lemma : M.Identifier) -> M.Proposition
  TorsionOrthogonalityProp : (T F C : M.Identifier) -> M.Proposition
  TorsionDecompositionProp : (X T F C : M.Identifier) -> M.Proposition
  TorsionClassClosureQuotientsProp : (T C : M.Identifier) -> M.Proposition
  TorsionFreeClosureSubobjectsProp : (F C : M.Identifier) -> M.Proposition
  TorsionReflectiveProp : (T C : M.Identifier) -> M.Proposition
  TorsionFreeCoreflectiveProp : (F C : M.Identifier) -> M.Proposition
  TorsionTheoryAxiomsProp : (T F C : M.Identifier) -> M.Proposition
  -- Regular / exact / Barr-exact propositions
  RegularCategoryProp : (C : M.Identifier) -> M.Proposition
  RegularEpiProp : (e A B C : M.Identifier) -> M.Proposition
  RegularEpisAreStrongProp : (C e : M.Identifier) -> M.Proposition
  KernelPairEquivRelProp : (C f K k1 k2 : M.Identifier) -> M.Proposition
  EffectiveRelationsProp : (C : M.Identifier) -> M.Proposition
  ExactCategoryProp : (C : M.Identifier) -> M.Proposition
  BarrExactCategoryProp : (C : M.Identifier) -> M.Proposition
  BarrEmbeddingTheoremProp : (C K F : M.Identifier) -> M.Proposition
  PreservesRegularEpisProp : (F C D : M.Identifier) -> M.Proposition
  PreservesFiniteLimitsProp : (F C D : M.Identifier) -> M.Proposition
  -- Generic property scaffolding propositions
  CategoryHasPropertyProp : (C prop : M.Identifier) -> M.Proposition
  ClassClosedUnderProp    : (C classId opId : M.Identifier) -> M.Proposition
  ClassStableUnderProp    : (C classId contextId : M.Identifier) -> M.Proposition
  FunctorPreservesPropertyProp : (F C D prop : M.Identifier) -> M.Proposition
  FunctorReflectsPropertyProp  : (F C D prop : M.Identifier) -> M.Proposition
  FunctorCreatesPropertyProp   : (F C D prop : M.Identifier) -> M.Proposition
  FunctorHasPropertyProp       : (F C D prop : M.Identifier) -> M.Proposition

  -- Canonicalization of some specific propositions into generic property form
  RegularCategoryProp-Canonical
    : (C : M.Identifier)
    -> RegularCategoryProp C ≡ CategoryHasPropertyProp C P.RegularCategoryId
  ExactCategoryProp-Canonical
    : (C : M.Identifier)
    -> ExactCategoryProp C ≡ CategoryHasPropertyProp C P.ExactCategoryId
  BarrExactCategoryProp-Canonical
    : (C : M.Identifier)
    -> BarrExactCategoryProp C ≡ CategoryHasPropertyProp C P.BarrExactCategoryId
  PreservesFiniteLimitsProp-Canonical
    : (F C D : M.Identifier)
    -> PreservesFiniteLimitsProp F C D ≡ FunctorPreservesPropertyProp F C D P.FiniteLimitsId
  PreservesRegularEpisProp-Canonical
    : (F C D : M.Identifier)
    -> PreservesRegularEpisProp F C D ≡ FunctorPreservesPropertyProp F C D P.RegularEpiClassId
  EffectiveRelationsProp-Canonical
    : (C : M.Identifier)
    -> EffectiveRelationsProp C ≡ CategoryHasPropertyProp C P.EffectiveEquivalenceRelationsId

-- AxiomProp equations binding subjects/axioms to concrete propositions
postulate
  AxiomProp-Assoc
    : (G : M.Identifier)
    -> AxiomProp (PreCategoryS G) AssociativityAxiomName ≡ AssocProp G

  AxiomProp-Id
    : (G : M.Identifier)
    -> AxiomProp (PreCategoryS G) IdentityAxiomName ≡ IdProp G

  AxiomProp-PresComp
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorMapS F C D) PreservesCompositionName ≡ PresCompProp F C D

  AxiomProp-PresId
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorMapS F C D) PreservesIdentityName ≡ PresIdProp F C D

  -- Product axioms
  AxiomProp-ProductComm
    : (P : M.Identifier) (parts : List M.Identifier)
    -> AxiomProp (ProductS P parts) ProductCommutativityName ≡ ProductCommProp P parts

  AxiomProp-ProductUniq
    : (P : M.Identifier) (parts : List M.Identifier)
    -> AxiomProp (ProductS P parts) ProductUniquenessName ≡ ProductUniqProp P parts

  -- Coproduct axioms
  AxiomProp-CoproductComm
    : (Q : M.Identifier) (parts : List M.Identifier)
    -> AxiomProp (CoproductS Q parts) CoproductCommutativityName ≡ CoproductCommProp Q parts

  AxiomProp-CoproductUniq
    : (Q : M.Identifier) (parts : List M.Identifier)
    -> AxiomProp (CoproductS Q parts) CoproductUniquenessName ≡ CoproductUniqProp Q parts

  -- Initial/Terminal uniqueness axioms
  AxiomProp-InitialUniq
    : (I : M.Identifier)
    -> AxiomProp (InitialS I) InitialUniquenessName ≡ InitialUniqProp I

  AxiomProp-TerminalUniq
    : (T : M.Identifier)
    -> AxiomProp (TerminalS T) TerminalUniquenessName ≡ TerminalUniqProp T

  -- Adjunction axioms
  AxiomProp-TriangleIds
    : (F G C D : M.Identifier)
    -> AxiomProp (AdjunctionS F G C D) TriangleIdentitiesName ≡ TriangleIdentitiesProp F G C D

  AxiomProp-RightAdjPreservesLimits
    : (G C D : M.Identifier)
    -> (F : M.Identifier)
    -> AxiomProp (AdjunctionS F G C D) RightAdjPreservesLimitsName ≡ RightAdjPreservesLimitsProp G C D

  AxiomProp-LeftAdjPreservesColimits
    : (F C D : M.Identifier)
    -> (G : M.Identifier)
    -> AxiomProp (AdjunctionS F G C D) LeftAdjPreservesColimitsName ≡ LeftAdjPreservesColimitsProp F C D

  -- Factorization system axioms
  AxiomProp-FactorizationUnique
    : (C E M : M.Identifier)
    -> AxiomProp (FactorizationS C E M) FactorizationUniquenessName ≡ FactorizationUniqueProp C E M

  AxiomProp-SubobjectLatticeComplete
    : (C : M.Identifier)
    -> AxiomProp (CategoryPropertyS C) SubobjectLatticeCompletenessName ≡ SubobjectLatticeCompleteProp C

  AxiomProp-CanonicalFactorization
    : (C E M : M.Identifier)
    -> AxiomProp (FactorizationS C E M) CanonicalFactorizationSystemName ≡ CanonicalFactorizationProp C E M

  -- Projective/Injective lifting axioms
  AxiomProp-ProjectiveLift
    : (P : M.Identifier)
    -> AxiomProp (ProjectiveS P) ProjectiveLiftingName ≡ ProjectiveLiftProp P

  AxiomProp-InjectiveLift
    : (I : M.Identifier)
    -> AxiomProp (InjectiveS I) InjectiveLiftingName ≡ InjectiveLiftProp I
  -- 2-category axioms
  AxiomProp-TwoCatAssoc
    : (C : M.Identifier)
    -> AxiomProp (TwoCategoryS C) TwoCatAssociativityName ≡ TwoCatAssociativityProp C
  AxiomProp-TwoCatUnit
    : (C : M.Identifier)
    -> AxiomProp (TwoCategoryS C) TwoCatUnitalityName ≡ TwoCatUnitalityProp C
  -- Bicategory coherence axioms (reuse 2-category proposition forms)
  AxiomProp-BicategoryAssoc
    : (B : M.Identifier)
    -> AxiomProp (BicategoryS B) TwoCatAssociativityName ≡ TwoCatAssociativityProp B
  AxiomProp-BicategoryUnit
    : (B : M.Identifier)
    -> AxiomProp (BicategoryS B) TwoCatUnitalityName ≡ TwoCatUnitalityProp B
  -- Lax functor coherence axioms
  AxiomProp-LaxAssoc
    : (F C D : M.Identifier)
    -> AxiomProp (LaxFunctorS F C D) LaxAssociativityName ≡ LaxAssociativityProp F C D
  AxiomProp-LaxUnit
    : (F C D : M.Identifier)
    -> AxiomProp (LaxFunctorS F C D) LaxUnitalityName ≡ LaxUnitalityProp F C D
  -- Limit hierarchy meta-theorem
  AxiomProp-LimitHierarchy
    : (C : M.Identifier)
    -> AxiomProp (CategoryPropertyS C) LimitHierarchyName ≡ LimitHierarchyProp C
  -- Cauchy completeness via distributors
  AxiomProp-CauchyViaDistributors
    : (C : M.Identifier)
    -> AxiomProp (CategoryPropertyS C) CauchyViaDistributorsName ≡ CauchyViaDistributorsProp C
  -- Internal category axioms
  AxiomProp-InternalAssoc
    : (IC ambient : M.Identifier)
    -> AxiomProp (InternalCategoryS IC ambient) InternalAssociativityName ≡ InternalAssocProp IC ambient
  AxiomProp-InternalLeftUnit
    : (IC ambient : M.Identifier)
    -> AxiomProp (InternalCategoryS IC ambient) InternalLeftUnitName ≡ InternalLeftUnitProp IC ambient
  AxiomProp-InternalRightUnit
    : (IC ambient : M.Identifier)
    -> AxiomProp (InternalCategoryS IC ambient) InternalRightUnitName ≡ InternalRightUnitProp IC ambient
  -- Internal Yoneda lemma
  AxiomProp-YonedaLemma
    : (IC ambient : M.Identifier)
    -> AxiomProp (InternalCategoryS IC ambient) YonedaLemmaName ≡ YonedaLemmaProp IC ambient
  -- Internal limit universal property
  AxiomProp-InternalLimitUniversal
    : (L D IC : M.Identifier)
    -> AxiomProp (InternalLimitS L D IC) InternalLimitUniversalName ≡ InternalLimitUniversalProp L D IC
  -- Internal colimit duality correctness
  AxiomProp-InternalColimitDuality
    : (IC ambient : M.Identifier)
    -> AxiomProp (InternalCategoryS IC ambient) InternalColimitDualityName ≡ InternalColimitDualityProp IC ambient
  -- Internal colimit universal property
  AxiomProp-InternalColimitUniversal
    : (L D IC : M.Identifier)
    -> AxiomProp (InternalColimitS L D IC) InternalColimitUniversalName ≡ InternalColimitUniversalProp L D IC
  -- Additive / abelian equations
  AxiomProp-ZeroObject
    : (C Z : M.Identifier)
    -> AxiomProp (ZeroObjectS C Z) ZeroObjectPropertyName ≡ ZeroObjectProp C Z
  AxiomProp-KernelAsEqualizer
    : (f C : M.Identifier)
    -> AxiomProp (KernelEqualizerS f C) KernelAsEqualizerName ≡ KernelAsEqualizerProp f C
  AxiomProp-CokernelAsCoequalizer
    : (f C : M.Identifier)
    -> AxiomProp (CokernelCoequalizerS f C) CokernelAsCoequalizerName ≡ CokernelAsCoequalizerProp f C
  AxiomProp-AdditiveCategory
    : (C : M.Identifier)
    -> AxiomProp (AdditiveCategoryS C) AdditiveCategoryName ≡ AdditiveCategoryProp C
  AxiomProp-AbelianCategory
    : (C : M.Identifier)
    -> AxiomProp (AbelianCategoryS C) AbelianCategoryName ≡ AbelianCategoryProp C
  AxiomProp-AdditivityViaBiproductMapIso
    : (C : M.Identifier)
    -> AxiomProp (BiproductComparisonS C) AdditivityViaBiproductMapIsoName ≡ AdditivityViaBiproductMapIsoProp C
  AxiomProp-CoimageImageIso
    : (f C : M.Identifier)
    -> AxiomProp (CoimageImageIsoS f C) CoimageImageIsomorphismName ≡ CoimageImageIsoProp f C
  AxiomProp-ShortExactSequenceExactness
    : (seq : M.Identifier)
    -> AxiomProp (ShortExactSequenceS seq) ShortExactSequenceExactnessName ≡ ShortExactSequenceProp seq
  AxiomProp-SplittingLemma
    : (seq : M.Identifier)
    -> AxiomProp (SplittingLemmaS seq) SplittingLemmaName ≡ SplittingLemmaProp seq
  AxiomProp-LongExactSequenceExactness
    : (seq : M.Identifier)
    -> AxiomProp (LongExactSequenceS seq) LongExactSequenceExactnessName ≡ LongExactSequenceProp seq
  AxiomProp-LeftExactFunctor
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) LeftExactFunctorName ≡ LeftExactFunctorProp F C D
  AxiomProp-RightExactFunctor
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) RightExactFunctorName ≡ RightExactFunctorProp F C D
  AxiomProp-ExactFunctor
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) ExactFunctorName ≡ ExactFunctorProp F C D
  AxiomProp-AdditiveFunctorPreservesBiproducts
    : (F C D : M.Identifier)
    -> AxiomProp (AdditiveFunctorS F C D) AdditiveFunctorPreservesBiproductsName ≡ AdditiveFunctorPreservesBiproductsProp F C D
  AxiomProp-CovariantHomLeftExact
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) CovariantHomLeftExactName ≡ CovariantHomLeftExactProp F C D
  AxiomProp-ExactHomProjectiveCharacterization
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) ExactHomProjectiveCharacterizationName ≡ ExactHomProjectiveCharacterizationProp F C D
  AxiomProp-InjectiveHomDuality
    : (F C D : M.Identifier)
    -> AxiomProp (FunctorExactnessS F C D) InjectiveHomDualityName ≡ InjectiveHomDualityProp F C D
  AxiomProp-SubobjectLatticeModular
    : (C X : M.Identifier)
    -> AxiomProp (SubobjectLatticeS C X) SubobjectLatticeModularName ≡ SubobjectLatticeModularProp C X
  AxiomProp-FiveLemma
    : (lemma : M.Identifier)
    -> AxiomProp (DiagramLemmaS lemma) FiveLemmaName ≡ FiveLemmaProp lemma
  AxiomProp-SnakeLemma
    : (lemma : M.Identifier)
    -> AxiomProp (DiagramLemmaS lemma) SnakeLemmaName ≡ SnakeLemmaProp lemma
  AxiomProp-ThreeByThreeLemma
    : (lemma : M.Identifier)
    -> AxiomProp (DiagramLemmaS lemma) ThreeByThreeLemmaName ≡ ThreeByThreeLemmaProp lemma
  AxiomProp-TorsionOrthogonality
    : (T F C : M.Identifier)
    -> AxiomProp (TorsionOrthogonalityS T F C) TorsionOrthogonalityName ≡ TorsionOrthogonalityProp T F C
  AxiomProp-TorsionDecomposition
    : (X T F C : M.Identifier)
    -> AxiomProp (TorsionDecompositionS X T F C) TorsionDecompositionName ≡ TorsionDecompositionProp X T F C
  AxiomProp-TorsionClassClosureQuotients
    : (T C : M.Identifier)
    -> AxiomProp (TorsionClassClosureQuotientsS T C) TorsionClassClosedUnderQuotientsName ≡ TorsionClassClosureQuotientsProp T C
  AxiomProp-TorsionFreeClosureSubobjects
    : (F C : M.Identifier)
    -> AxiomProp (TorsionFreeClosureSubobjectsS F C) TorsionFreeClosedUnderSubobjectsName ≡ TorsionFreeClosureSubobjectsProp F C
  AxiomProp-TorsionReflective
    : (T C : M.Identifier)
    -> AxiomProp (TorsionReflectiveS T C) TorsionReflectiveName ≡ TorsionReflectiveProp T C
  AxiomProp-TorsionFreeCoreflective
    : (F C : M.Identifier)
    -> AxiomProp (TorsionFreeCoreflectiveS F C) TorsionFreeCoreflectiveName ≡ TorsionFreeCoreflectiveProp F C
  AxiomProp-TorsionTheoryAxioms
    : (T F C : M.Identifier)
    -> AxiomProp (TorsionTheoryS T F C) TorsionTheoryAxiomsName ≡ TorsionTheoryAxiomsProp T F C
  -- Regular / exact / Barr-exact equations
  AxiomProp-RegularCategory
    : (C : M.Identifier)
    -> AxiomProp (RegularCategoryS C) RegularCategoryName ≡ RegularCategoryProp C
  AxiomProp-RegularEpi
    : (e A B C : M.Identifier)
    -> AxiomProp (RegularEpiS e A B C) RegularEpiPropertyName ≡ RegularEpiProp e A B C
  AxiomProp-RegularEpisAreStrong
    : (C e : M.Identifier)
    -> AxiomProp (RegularEpisAreStrongS C e) RegularEpisAreStrongName ≡ RegularEpisAreStrongProp C e
  AxiomProp-KernelPairEquivRel
    : (C f K k1 k2 : M.Identifier)
    -> AxiomProp (KernelPairEquivRelS C f K k1 k2) KernelPairEquivRelName ≡ KernelPairEquivRelProp C f K k1 k2
  AxiomProp-EffectiveRelations
    : (C : M.Identifier)
    -> AxiomProp (EffectiveRelationsS C) EffectiveRelationsName ≡ EffectiveRelationsProp C
  AxiomProp-ExactCategory
    : (C : M.Identifier)
    -> AxiomProp (ExactCategoryS C) ExactCategoryName ≡ ExactCategoryProp C
  AxiomProp-BarrExactCategory
    : (C : M.Identifier)
    -> AxiomProp (BarrExactCategoryS C) BarrExactCategoryName ≡ BarrExactCategoryProp C
  AxiomProp-BarrEmbeddingTheorem
    : (C K F : M.Identifier)
    -> AxiomProp (BarrEmbeddingS C K F) BarrEmbeddingTheoremName ≡ BarrEmbeddingTheoremProp C K F
  AxiomProp-PreservesRegularEpis
    : (F C D : M.Identifier)
    -> AxiomProp (PreservesRegularEpisS F C D) PreservesRegularEpisName ≡ PreservesRegularEpisProp F C D
  AxiomProp-PreservesFiniteLimits
    : (F C D : M.Identifier)
    -> AxiomProp (PreservesFiniteLimitsS F C D) PreservesFiniteLimitsName ≡ PreservesFiniteLimitsProp F C D
  -- Generic property scaffolding equations
  AxiomProp-CategoryHasProperty
    : (C prop : M.Identifier)
    -> AxiomProp (CategoryHasPropertyS C prop) HasPropertyName ≡ CategoryHasPropertyProp C prop
  AxiomProp-ClassClosedUnder
    : (C classId opId : M.Identifier)
    -> AxiomProp (ClassClosedUnderS C classId opId) ClosedUnderName ≡ ClassClosedUnderProp C classId opId
  AxiomProp-ClassStableUnder
    : (C classId contextId : M.Identifier)
    -> AxiomProp (ClassStableUnderS C classId contextId) StableUnderName ≡ ClassStableUnderProp C classId contextId
  AxiomProp-FunctorPreservesProperty
    : (F C D prop : M.Identifier)
    -> AxiomProp (FunctorPreservesPropertyS F C D prop) PreservesPropertyName ≡ FunctorPreservesPropertyProp F C D prop
  AxiomProp-FunctorReflectsProperty
    : (F C D prop : M.Identifier)
    -> AxiomProp (FunctorReflectsPropertyS F C D prop) ReflectsPropertyName ≡ FunctorReflectsPropertyProp F C D prop
  AxiomProp-FunctorCreatesProperty
    : (F C D prop : M.Identifier)
    -> AxiomProp (FunctorCreatesPropertyS F C D prop) CreatesPropertyName ≡ FunctorCreatesPropertyProp F C D prop
  AxiomProp-FunctorHasProperty
    : (F C D prop : M.Identifier)
    -> AxiomProp (FunctorHasPropertyS F C D prop) HasPropertyName ≡ FunctorHasPropertyProp F C D prop

-- A proof is a witness that the axiom proposition for a subject holds
Proof : (subject : Subject) -> (ax : AxiomName) -> Set
Proof subject ax = Holds (AxiomProp subject ax)

------------------------------------------------------------------------
-- Bridge: From concrete axiom records to proof witnesses
------------------------------------------------------------------------

postulate
  -- Precategory structure axioms
  assocProofFromAxiom
    : (ax : AssociativityAxiom)
    -> Proof (PreCategoryS (AssociativityAxiom.over ax)) AssociativityAxiomName

  idProofFromAxiom
    : (ax : IdentityAxiom)
    -> Proof (PreCategoryS (IdentityAxiom.over ax)) IdentityAxiomName

  -- Functor structure preservation axioms (require stating domain/codomain)
  preservesCompositionProof
    : (ax : FunctorPreservesCompositionAxiom)
    -> (C D : M.Identifier)
    -> Proof (FunctorMapS (FunctorPreservesCompositionAxiom.forF ax) C D) PreservesCompositionName

  preservesIdentityProof
    : (ax : FunctorPreservesIdentityAxiom)
    -> (C D : M.Identifier)
    -> Proof (FunctorMapS (FunctorPreservesIdentityAxiom.forF ax) C D) PreservesIdentityName

------------------------------------------------------------------------
-- Smart constructors: build promotions from axiom records
------------------------------------------------------------------------

promoteToCategoryFromAxioms
  : (idAx : IdentityAxiom)
  -> (assocAx : AssociativityAxiom)
  -> CategoryPromotion
promoteToCategoryFromAxioms idAx assocAx =
  PROMOTE_to_CATEGORY
    (IdentityAxiom.over idAx)
    (idProofFromAxiom idAx)
    (assocProofFromAxiom assocAx)

promoteToFunctorFromAxioms
  : (C D : M.Identifier)
  -> (pcAx : FunctorPreservesCompositionAxiom)
  -> (piAx : FunctorPreservesIdentityAxiom)
  -> FunctorPromotion
promoteToFunctorFromAxioms C D pcAx piAx =
  PROMOTE_to_FUNCTOR
    (FunctorPreservesCompositionAxiom.forF pcAx)
    C D
    (preservesCompositionProof pcAx C D)
    (preservesIdentityProof    piAx C D)

-- Concepts mentioned by duality axioms
data ConceptName : Set where
  TERMINAL_OBJECT : ConceptName
  INITIAL_OBJECT  : ConceptName
  PRODUCT         : ConceptName
  COPRODUCT       : ConceptName
  PULLBACK        : ConceptName
  PUSHOUT         : ConceptName
  EQUALIZER       : ConceptName
  COEQUALIZER     : ConceptName
  LIMIT           : ConceptName
  COLIMIT         : ConceptName
  MONOMORPHISM    : ConceptName
  EPIMORPHISM     : ConceptName

-- Morphism declarations for a precategory signature
record MorphismDeclaration : Set where
  constructor mor
  field
    name : M.Identifier
    dom  : M.Identifier
    cod  : M.Identifier
open MorphismDeclaration public

-- Object and morphism mapping atoms as they appear in FUNCTOR_MAP blocks
record ObjectMapping : Set where
  constructor obj↦
  field src : M.Identifier
        dst : M.Identifier
open ObjectMapping public

record MorphismMapping : Set where
  constructor mor↦
  field src : M.Identifier
        dst : M.Identifier
open MorphismMapping public

------------------------------------------------------------------------
-- Declarations mirroring the EBNF productions
------------------------------------------------------------------------

-- PreCategoryDeclaration ::= PRECATEGORY ...
record PreCategoryDeclaration : Set where
  constructor PRECATEGORY_has
  field
    G-id      : M.Identifier
    Objects   : List M.Identifier
    Morphisms : List MorphismDeclaration
-- CATEGORY: A directed graph (quiver) prior to imposing identities and composition laws.

-- CategoryPromotion ::= PROMOTE G to CATEGORY by proving { Axioms }
record CategoryPromotion : Set where
  constructor PROMOTE_to_CATEGORY
  field
    G      : M.Identifier
    -- Explicit witnesses instead of just names
    hasIdentity      : Proof (PreCategoryS G) IdentityAxiomName
    hasAssociativity : Proof (PreCategoryS G) AssociativityAxiomName
-- CATEGORY: Constructor from PreCategory to Category once axioms are proven.

-- Associativity and Identity axioms (proofs are opaque at this level)
record AssociativityAxiom : Set where
  constructor AXIOM_Associativity
  field over : M.Identifier
-- CATEGORY: Composition is associative.

record IdentityAxiom : Set where
  constructor AXIOM_Identity
  field over : M.Identifier
-- CATEGORY: Identities act as two-sided units.

-- FunctorMapDeclaration ::= FUNCTOR_MAP F : C -> D maps { ... }
record FunctorMapDeclaration : Set where
  constructor FUNCTOR_MAP_maps
  field
    F        : M.Identifier
    C        : M.Identifier
    D        : M.Identifier
    onObj    : List ObjectMapping
    onMor    : List MorphismMapping
-- CATEGORY: Graph homomorphism between underlying quivers.

-- FunctorPromotion ::= PROMOTE F to FUNCTOR by proving { ... }
record FunctorPromotion : Set where
  constructor PROMOTE_to_FUNCTOR
  field
    F      : M.Identifier
    -- domain and codomain categories (as identifiers)
    C      : M.Identifier
    D      : M.Identifier
    -- Explicit proof witnesses of the required axioms
    preservesComposition : Proof (FunctorMapS F C D) PreservesCompositionName
    preservesIdentity    : Proof (FunctorMapS F C D) PreservesIdentityName
-- CATEGORY: Asserts structure preservation (composition, identity).

record FunctorPreservesCompositionAxiom : Set where
  constructor AXIOM_PreservesComposition
  field forF : M.Identifier

record FunctorPreservesIdentityAxiom : Set where
  constructor AXIOM_PreservesIdentity
  field forF : M.Identifier

-- Parallel functors predicate
record AreParallel : Set where
  constructor AreParallel_of
  field F G : M.Identifier
-- CATEGORY: F and G share same domain and codomain categories.

-- Components of a natural transformation
record TransformationComponent : Set where
  constructor _at_
  field alpha : M.Identifier
        X     : M.Identifier
-- CATEGORY: Component arrow alpha_X : F(X) -> G(X).

-- Natural transformation declaration
record NaturalTransformationDeclaration : Set where
  constructor NATURAL_TRANSFORMATION_⇒
  field
    alpha : M.Identifier
    F     : M.Identifier
    G     : M.Identifier
-- CATEGORY: 2-morphism between functors in Cat.

record NaturalityConditionAxiom : Set where
  constructor AXIOM_Naturality
  field
    alpha : M.Identifier
    F     : M.Identifier
    G     : M.Identifier
-- CATEGORY: Coherence law G(f) ∘ alpha_X = alpha_Y ∘ F(f).

-- Contravariant functors as covariant on op
record ContravariantFunctorAsFunctorOp : Set where
  constructor DEFINE_as_CONTRAVARIANT_FUNCTOR
  field
    F : M.Identifier
    C : M.Identifier
    D : M.Identifier
-- CATEGORY: Equivalence with FUNCTOR C^op -> D.

-- Contravariant action on morphisms (notation F <~f~>)
record ContravariantMap : Set where
  constructor _<~_~>
  field F : M.Identifier
        f : M.Identifier

record ContravariantIdentityAxiom : Set where
  constructor AXIOM_contravariant_identity
  field F A : M.Identifier

record ContravariantCompositionAxiom : Set where
  constructor AXIOM_contravariant_composition
  field F f g : M.Identifier

-- Comma category and its objects/morphisms
record GeneralCommaCategory : Set where
  constructor _↓_
  field F G : M.Identifier
-- CATEGORY: (F ↓ G) formed from F : A→C and G : B→C.

record CommaObject : Set where
  constructor Obj
  field a b h : M.Identifier
-- CATEGORY: Object (a,b,h) with h : F a -> G b.

record CommaMorphism : Set where
  constructor Mor
  field f g : M.Identifier
-- CATEGORY: Pair (f,g) commuting with h,h'.

record CommaMorphismCommutativityAxiom : Set where
  constructor AXIOM_CommaSquare
  field h h' f g : M.Identifier

-- Identity and constant functors
record IdentityFunctorConstructor : Set where
  constructor Id
  field C : M.Identifier

record ConstantFunctorConstructor : Set where
  constructor Δ_  -- pronounced "Delta sub X"
  field X : M.Identifier

-- Slice and coslice categories
record SliceCategory : Set where
  constructor _/_
  field C X : M.Identifier

record CosliceCategory : Set where
  constructor _\\_  -- backslash escaped
  field X C : M.Identifier

-- Inverse morphism
record InverseMorphism : Set where
  constructor inverse
  field f : M.Identifier

-- Theorems
record TheoremDeclaration : Set where
  constructor THEOREM_:
  field name : String
        prop : M.Proposition

-- Morphism property assertions
data MorphismProperty : Set where
  SPLIT_MONOMORPHISM : MorphismProperty
  SPLIT_EPIMORPHISM  : MorphismProperty

record MorphismPropertyAssertion : Set where
  constructor _is_
  field f : M.Identifier
        P : MorphismProperty

-- Category property: balanced
record CategoryPropertyDefinition : Set where
  constructor _is_BALANCED
  field C : M.Identifier

-- Dual statements and mappings
postulate
  op : M.Proposition -> M.Proposition

record DualStatement : Set where
  constructor _^op
  field P : M.Proposition

-- General duality mapping axiom
record DualityMappingAxiom : Set where
  constructor DUALITY_MAPPING_FOR_IS
  field C1 C2 : ConceptName

-- Fixed mapping presets captured by constructors
DualityMappingPreset : Set
DualityMappingPreset = List (ConceptName × ConceptName)

infixr 4 _,_
record _×_ (A B : Set) : Set where
  constructor _,_
  field fst : A
        snd : B

-- Example canonical preset list (TERMINAL↔INITIAL, PRODUCT↔COPRODUCT, ...)
DUALITY_PRESET : DualityMappingPreset
DUALITY_PRESET =
  (TERMINAL_OBJECT , INITIAL_OBJECT) ∷
  (INITIAL_OBJECT  , TERMINAL_OBJECT) ∷
  (PRODUCT         , COPRODUCT)      ∷
  (COPRODUCT       , PRODUCT)        ∷
  (PULLBACK        , PUSHOUT)        ∷
  (PUSHOUT         , PULLBACK)       ∷
  (EQUALIZER       , COEQUALIZER)    ∷
  (COEQUALIZER     , EQUALIZER)      ∷
  (LIMIT           , COLIMIT)        ∷
  (COLIMIT         , LIMIT)          ∷
  (MONOMORPHISM    , EPIMORPHISM)    ∷
  (EPIMORPHISM     , MONOMORPHISM)   ∷
  []

-- Dual theorem inference
record DualTheoremInference : Set where
  constructor INFER_DUAL_THEOREM_FROM
  field dualName : String
        origName : String
-- CATEGORY: Functorial mapping of proofs under duality.

------------------------------------------------------------------------
-- Notes: This file mirrors src/ebnf/1/1.ebnf as Agda records/enums.
-- The typing/CATEGORY annotations are preserved as comments or opaque
-- proof placeholders (⊤) when appropriate would be added later.
------------------------------------------------------------------------
module Level1_2 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Local helpers

-- A simple stand-in for expression-like terms appearing in EBNF equations
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: Products and the UMP
------------------------------------------------------------------------

record ProductObjectDeclaration : Set where
  constructor _is_PRODUCT_of_
  field P : M.Identifier
        parts : List M.Identifier
-- CATEGORY: P is the apex of a limit cone over the discrete diagram {A_i}.

data ProjectionMorphism : Set where
  proj_ : M.Identifier -> ProjectionMorphism

record UniversalProductMorphism : Set where
  constructor ⟨_⟩
  field components : M.NonEmpty Expr

record UMP_ProductExistenceAxiom : Set where
  constructor AXIOM_ProductCommutativity
  field P : M.Identifier
        apex : M.Identifier
        legs : List M.Identifier
-- CATEGORY: The universal morphism u makes each triangle commute: proj Ai ∘ u = f_i.

record UMP_ProductUniquenessAxiom : Set where
  constructor AXIOM_ProductUniqueness
  field u′ : Expr
        u  : Expr
-- CATEGORY: Any mediating morphism u′ equals the universal u.

-- Bridges from Level 2 axioms to Level 1 structured proofs
postulate
  productCommutativityProof
    : (decl : ProductObjectDeclaration)
    -> (ax : UMP_ProductExistenceAxiom)
    -> C.Proof (C.ProductS (ProductObjectDeclaration.P decl)
                            (ProductObjectDeclaration.parts decl))
               C.ProductCommutativityName

  productUniquenessProof
    : (decl : ProductObjectDeclaration)
    -> (ax : UMP_ProductUniquenessAxiom)
    -> C.Proof (C.ProductS (ProductObjectDeclaration.P decl)
                            (ProductObjectDeclaration.parts decl))
               C.ProductUniquenessName

record BinaryProduct : Set where
  constructor _×_
  field A B : M.Identifier

record NullaryProductIsTerminalAxiom : Set where
  constructor AXIOM_NullaryProductIsTerminal
  field unit : ⊤
-- CATEGORY: PRODUCT of () equals TERMINAL_OBJECT.

-- Coproduct via duality (derived theorems and axioms)
record CoproductObjectDeclaration : Set where
  constructor _is_COPRODUCT_of_
  field Q : M.Identifier
        parts : List M.Identifier

record CoproductCommutativityAxiom : Set where
  constructor AXIOM_CoproductCommutativity
  field cocone : M.Identifier
        injOf  : List M.Identifier

record CoproductUniquenessAxiom : Set where
  constructor AXIOM_CoproductUniqueness
  field mediator′ : Expr
        mediator  : Expr

record BinaryCoproduct : Set where
  constructor _+_
  field A B : M.Identifier

record NullaryCoproductIsInitialAxiom : Set where
  constructor AXIOM_NullaryCoproductIsInitial
  field unit : ⊤

-- Bridges for coproduct axioms to Level 1 structured proofs
postulate
  coproductCommutativityProof
    : (decl : CoproductObjectDeclaration)
    -> (ax : CoproductCommutativityAxiom)
    -> C.Proof (C.CoproductS (CoproductObjectDeclaration.Q decl)
                              (CoproductObjectDeclaration.parts decl))
               C.CoproductCommutativityName

  coproductUniquenessProof
    : (decl : CoproductObjectDeclaration)
    -> (ax : CoproductUniquenessAxiom)
    -> C.Proof (C.CoproductS (CoproductObjectDeclaration.Q decl)
                              (CoproductObjectDeclaration.parts decl))
               C.CoproductUniquenessName

------------------------------------------------------------------------
-- Part 2: Initial and Terminal Objects
------------------------------------------------------------------------

data ObjectProperty : Set where
  INITIAL_OBJECT  : ObjectProperty
  TERMINAL_OBJECT : ObjectProperty

record ObjectPropertyDeclaration : Set where
  constructor _is_
  field X : M.Identifier
        P : ObjectProperty

record UniversalInitialMorphism : Set where
  constructor unique_from_initial_to
  field X : M.Identifier

record InitialUniquenessAxiom : Set where
  constructor AXIOM_InitialUniqueness
  field f : M.Identifier
        X : M.Identifier

record UniversalTerminalMorphism : Set where
  constructor unique_to_terminal_from
  field X : M.Identifier

record TerminalUniquenessAxiom : Set where
  constructor AXIOM_TerminalUniqueness
  field f : M.Identifier
        X : M.Identifier

record InitialObjectsAreIsomorphic : Set where
  constructor THEOREM_InitialObjectsAreIsomorphic
  field I J : M.Identifier

record TerminalIsNullaryProduct : Set where
  constructor THEOREM_TerminalIsNullaryProduct
  field T : M.Identifier

record InitialIsNullaryCoproduct : Set where
  constructor THEOREM_InitialIsNullaryCoproduct
  field I : M.Identifier

-- Bridges for initial/terminal uniqueness axioms to Level 1 structured proofs
postulate
  initialUniquenessProof
    : (decl : ObjectPropertyDeclaration)  -- expects decl.P ≡ INITIAL_OBJECT (informally)
    -> (ax : InitialUniquenessAxiom)
    -> C.Proof (C.InitialS (ObjectPropertyDeclaration.X decl)) C.InitialUniquenessName

  terminalUniquenessProof
    : (decl : ObjectPropertyDeclaration)  -- expects decl.P ≡ TERMINAL_OBJECT (informally)
    -> (ax : TerminalUniquenessAxiom)
    -> C.Proof (C.TerminalS (ObjectPropertyDeclaration.X decl)) C.TerminalUniquenessName

------------------------------------------------------------------------
-- Part 3: Diagram Shapes and (Co)Limits
------------------------------------------------------------------------

record MorphismDecl : Set where
  constructor _:_→_
  field name dom cod : M.Identifier

record DiagramShapeDeclaration : Set where
  constructor DIAGRAM_SHAPE_from
  field name : M.Identifier
        morphisms : List MorphismDecl

-- Canonical small shapes
record DiagramShape_ParallelPair : Set where
  constructor ParallelPair
  field A B f g : M.Identifier

record DiagramShape_Cospan : Set where
  constructor Cospan
  field A B C f g : M.Identifier

record DiagramShape_Span : Set where
  constructor Span
  field A B C f g : M.Identifier

-- Limit constructions
record EqualizerAsLimit : Set where
  constructor DEFINE_Equalizer_as_LIMIT_of_ParallelPair
  field f g : M.Identifier

record EqualizerCommutativityAxiom : Set where
  constructor AXIOM_EqualizerCommutativity
  field f e g : M.Identifier

record PullbackAsLimit : Set where
  constructor DEFINE_Pullback_as_LIMIT_of_Cospan
  field f g : M.Identifier

record PullbackCommutativityAxiom : Set where
  constructor AXIOM_PullbackSquare
  field f p1 g p2 : M.Identifier

-- Colimit constructions (duals)
record CoequalizerAsColimit : Set where
  constructor DEFINE_Coequalizer_as_COLIMIT_of_ParallelPair
  field f g : M.Identifier

record CoequalizerCommutativityAxiom : Set where
  constructor AXIOM_CoequalizerCommutativity
  field q f g : M.Identifier

record PushoutAsColimit : Set where
  constructor DEFINE_Pushout_as_COLIMIT_of_Span
  field f g : M.Identifier

record PushoutCommutativityAxiom : Set where
  constructor AXIOM_PushoutSquare
  field i1 f i2 g : M.Identifier

-- Diagrams, (co)cones, and categories of cones
record DiagramDeclaration : Set where
  constructor DIAGRAM_is_Functor
  field D J C : M.Identifier

record ConeDeclaration : Set where
  constructor CONE_over_has
  field coneId : M.Identifier
        D      : M.Identifier
        apex   : M.Identifier
        legs   : List MorphismDecl

record CategoryOfCones : Set where
  constructor ConeCategory
  field D : M.Identifier

record LimitAsTerminalInConeCategory : Set where
  constructor LIMIT_of_is_TERMINAL_in_ConeCategory
  field D : M.Identifier
        Lcone : M.Identifier

record CoconeDeclaration : Set where
  constructor COCONE_from_has
  field coconeId : M.Identifier
        D        : M.Identifier
        apex     : M.Identifier
        legs     : List MorphismDecl

record CategoryOfCocones : Set where
  constructor CoconeCategory
  field D : M.Identifier

record ColimitAsInitialInCoconeCategory : Set where
  constructor COLIMIT_of_is_INITIAL_in_CoconeCategory
  field D : M.Identifier
        Lcocone : M.Identifier

------------------------------------------------------------------------
-- Part 4: Completeness and Cocompleteness
------------------------------------------------------------------------

record CategoryProperty_Small : Set where
  constructor _is_SMALL
  field C : M.Identifier

record SmallDiagramDeclaration : Set where
  constructor small_diagram_∶_→_
  field D J C : M.Identifier

record CategoryProperty_Complete : Set where
  constructor _is_COMPLETE
  field C : M.Identifier

record CategoryProperty_Cocomplete : Set where
  constructor _is_COCOMPLETE
  field C : M.Identifier

record CompletenessCriteria : Set where
  constructor THEOREM_CompletenessCriteria
  field C : M.Identifier

record CompletenessEquivalenceTheorem : Set where
  constructor THEOREM_CompletenessEquivalenceTheorem
  field C : M.Identifier

record GeneralLimitConstructor : Set where
  constructor CONSTRUCT_LIMIT_from_ProductsAndEqualizers
  field D : M.Identifier

record ProductOfDiagramObjects : Set where
  constructor Product_over_Objects
  field D : M.Identifier

record ParallelMorphismConstruction : Set where
  constructor PARALLEL_MORPHISMS_for
  field D : M.Identifier
        uα uβ : M.Identifier

record EqualizerAsLimitStep : Set where
  constructor Equalizer_step
  field α β : M.Identifier

------------------------------------------------------------------------
-- Part 5: Colimit Adjunction and Dual Limit Adjunction
------------------------------------------------------------------------

record DiagonalFunctorDeclaration : Set where
  constructor DIAGONAL_FUNCTOR_Δ
  field C CJ : M.Identifier

record ColimitFunctorDeclaration : Set where
  constructor COLIMIT_FUNCTOR_colim
  field CJ C : M.Identifier

record CoconeAsNaturalTransformationAxiom : Set where
  constructor AXIOM_CoconeAsNaturalTransformation
  field D X : M.Identifier

record AdjunctionDeclaration : Set where
  constructor ADJUNCTION_colim_⊣_Δ
  field unit : ⊤

record LimitAdjunctionDual : Set where
  constructor INFER_DUAL_THEOREM_LimitAdjunction
  field unit : ⊤

------------------------------------------------------------------------
-- Part 6: Functor properties (preserve/reflect/create limits)
------------------------------------------------------------------------

record FunctorPreservesLimits : Set where
  constructor _preserves_LIMITS
  field F : M.Identifier

record FunctorReflectsLimits : Set where
  constructor _reflects_LIMITS
  field F : M.Identifier

record FunctorCreatesLimits : Set where
  constructor _creates_LIMITS
  field F : M.Identifier

record CreationImpliesReflection : Set where
  constructor THEOREM_CreationImpliesReflection
  field F : M.Identifier

record IsomorphismsOfCategoriesReflectLimits : Set where
  constructor THEOREM_IsomorphismsOfCategoriesReflectLimits
  field F : M.Identifier

record RightAdjointsPreserveLimits : Set where
  constructor THEOREM_RightAdjointsPreserveLimits
  field F : M.Identifier

------------------------------------------------------------------------
-- Part 7: Absolute colimits and split coequalizers
------------------------------------------------------------------------

record PreservationPredicate : Set where
  constructor _preserves_COLIMIT_of_
  field F D : M.Identifier

record AbsoluteColimitDefinition : Set where
  constructor _is_ABSOLUTE_COLIMIT_of_
  field L D : M.Identifier

record SplitCoequalizerCocone : Set where
  constructor _is_SPLIT_COEQUALIZER_COCONE_for_
  field q fg : M.Identifier

record AbsoluteColimitsAreSplit : Set where
  constructor THEOREM_AbsoluteColimitsAreSplit
  field C D : M.Identifier

------------------------------------------------------------------------
-- Part 8: Filtered categories and commuting results
------------------------------------------------------------------------

record CategoryIsFiltered : Set where
  constructor _is_FILTERED
  field J : M.Identifier

record CategoryAxiom_UpperBoundsForObjects : Set where
  constructor AXIOM_UpperBoundsForObjects_in
  field J : M.Identifier

record CategoryAxiom_EqualizingMorphisms : Set where
  constructor AXIOM_EqualizingMorphisms_in
  field J : M.Identifier

record CategoryIsFinite : Set where
  constructor _is_FINITE
  field J : M.Identifier

record FilteredColimitsCommuteWithFiniteLimitsInSet : Set where
  constructor THEOREM_FilteredColimitsCommuteWithFiniteLimitsInSet
  field I J : M.Identifier

record DualityMapping_Filtered_Cofiltered : Set where
  constructor DUALITY_MAPPING_FILTERED_COFILTERED
  field unit : ⊤

record CofilteredLimitsCommuteWithFiniteColimits : Set where
  constructor INFER_DUAL_THEOREM_CofilteredLimitsCommuteWithFiniteColimits
  field unit : ⊤

------------------------------------------------------------------------
-- Part 9: Final functors and equivalence
------------------------------------------------------------------------

record OverCommaCategory : Set where
  constructor _↓_
  field U k : M.Identifier

record FunctorProperty_Final : Set where
  constructor _is_FINAL
  field U : M.Identifier

record FunctorBehavior_PreservesColimitsOnPrecomposition : Set where
  constructor _preserves_colimits_on_precomposition
  field U : M.Identifier

record FinalityEquivalence : Set where
  constructor THEOREM_FinalityEquivalence
  field U : M.Identifier

record DualityMapping_Final_Initial : Set where
  constructor DUALITY_MAPPING_FINAL_INITIAL
  field unit : ⊤

record InitialityEquivalence : Set where
  constructor INFER_DUAL_THEOREM_InitialityEquivalence
  field unit : ⊤

------------------------------------------------------------------------
-- Notes: This module mirrors src/ebnf/1/2.ebnf with structural records.
-- Many fields are simplified to Identifiers and Strings (Expr) to keep
-- the module self-contained. CATEGORY narratives are preserved as comments.
------------------------------------------------------------------------
module Level1_3 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Lightweight expression placeholder for formulæ in CATEGORY prose
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: Two core definitions of adjunction
------------------------------------------------------------------------

-- Hom-set style declaration F ⊣ G : (C, D)
record AdjunctionHomDecl : Set where
  constructor _⊣_:_·_
  field F G C D : M.Identifier
-- CATEGORY: F ⊣ G declared via hom-set natural isomorphism.

-- Unit–counit data
record UnitCounitPair : Set where
  constructor UNIT_COϵ
  field η ε : M.Identifier  -- natural transformations (by name)

record TriangleIdentitiesAxiom : Set where
  constructor AXIOM_TriangleIdentities
  field pair : UnitCounitPair

-- Unit–counit style adjunction declaration
record AdjunctionFromUnitCounit : Set where
  constructor ADJUNCTION_from
  field data : UnitCounitPair

-- Hom-set natural isomorphism witness
record HomSetIsomorphism : Set where
  constructor Hom_≅Hom
  field
    C D : M.Identifier
    F G : M.Identifier

-- Equivalence of the two definitions
record EquivalenceOfAdjunctionDefinitions : Set where
  constructor THEOREM_AdjunctionEquivalence
  field F G C D : M.Identifier

-- Example 1: Free–Forgetful
record CategoryDeclaration : Set where
  constructor CATEGORY
  field name : M.Identifier

record ForgetfulFunctor : Set where
  constructor FORGET_from_to
  field U src dst : M.Identifier

record FreeFunctor : Set where
  constructor FREE_on_from_to
  field F on src dst : M.Identifier

record SpecializedAdjunction_FreeForget : Set where
  constructor FREE_⊣_FORGET
  field F U : M.Identifier

record UnitComponent : Set where
  constructor η_
  field S : M.Identifier

record CounitComponent : Set where
  constructor ε_
  field G : M.Identifier

-- Example 2: Δ ⊣ Π
record ProductCategory : Set where
  constructor _×_
  field C1 C2 : M.Identifier

record Functor_Delta : Set where
  constructor Δ
  field C : M.Identifier

record Functor_Pi : Set where
  constructor Π
  field C : M.Identifier

record Adjunction_Delta_Pi : Set where
  constructor Δ_⊣_Π
  field C : M.Identifier

------------------------------------------------------------------------
-- Part 2: Adjoint Functor Theorems (left) and duals (right)
------------------------------------------------------------------------

record SolutionSetCondition : Set where
  constructor _satisfies_SolutionSetCondition
  field G : M.Identifier

record WellPowered : Set where
  constructor _is_WELL_POWERED
  field C : M.Identifier

record FunctorProperty_Faithful : Set where
  constructor _is_FAITHFUL
  field F : M.Identifier

record HasCogenerator : Set where
  constructor _has_COGENERATOR
  field D : M.Identifier

-- GAFT / SAFT (left adjoints)
data AdjointFunctorTheoremLeft : Set where
  GAFT : M.Identifier -> Set  -- parameterize by G id
  SAFT : M.Identifier -> Set

-- Dual inference to right adjoints
record AdjointFunctorTheoremRight : Set where
  constructor INFER_DUAL_THEOREM_GAFT_SAFT
  field unit : ⊤

------------------------------------------------------------------------
-- Part 3: Properties of adjoint functors
------------------------------------------------------------------------

record RightAdjointsPreserveLimits : Set where
  constructor THEOREM_RightAdjointsPreserveLimits
  field G : M.Identifier

record LeftAdjointsPreserveColimits : Set where
  constructor INFER_DUAL_THEOREM_LeftAdjointsPreserveColimits
  field unit : ⊤

-- Universal arrows via comma categories
record UniversalArrowCategory_X↓G : Set where
  constructor _X_↓_G
  field X G : M.Identifier

record UniversalArrowCategory_F↓Y : Set where
  constructor _F_↓_Y
  field F Y : M.Identifier

record AdjunctionsViaUniversalArrows : Set where
  constructor THEOREM_AdjunctionsViaUniversalArrows
  field F G : M.Identifier

record AdjointsAreUnique : Set where
  constructor THEOREM_AdjointsAreUnique
  field F F′ G : M.Identifier

------------------------------------------------------------------------
-- Part 4: Fully faithful adjoint functors
------------------------------------------------------------------------

record FunctorProperty_Full : Set where
  constructor _is_FULL
  field F : M.Identifier

record FunctorProperty_FullyFaithful : Set where
  constructor _is_FULLY_FAITHFUL
  field F : M.Identifier

record RightAdjointFaithfulnessCriteria : Set where
  constructor THEOREM_RightAdjointFaithfulnessCriteria
  field F G : M.Identifier

record LeftAdjointFaithfulnessCriteria : Set where
  constructor INFER_DUAL_THEOREM_LeftAdjointFaithfulnessCriteria
  field unit : ⊤

------------------------------------------------------------------------
-- Part 5: Reflective subcategories
------------------------------------------------------------------------

record FullSubcategoryDeclaration : Set where
  constructor FULL_SUBCATEGORY_of_on
  field A B : M.Identifier
        objs : List M.Identifier

record InclusionFunctorDeclaration : Set where
  constructor INCLUSION_↪
  field I A B : M.Identifier

record ReflectiveSubcategoryDeclaration : Set where
  constructor _is_REFLECTIVE_IN_
  field A B : M.Identifier

record ReflectorFunctor : Set where
  constructor Reflector
  field A B : M.Identifier

record ReflectionArrow : Set where
  constructor reflection_of
  field b : M.Identifier

record ReflectionCounitIsomorphism : Set where
  constructor THEOREM_ReflectionCounitIsomorphism
  field A B : M.Identifier

------------------------------------------------------------------------
-- Part 6: Epireflective subcategories and duals
------------------------------------------------------------------------

record EpireflectiveSubcategoryDeclaration : Set where
  constructor _is_EPIREFLECTIVE_IN_
  field A B : M.Identifier

-- Closedness properties

data ClosednessKind : Set where
  PRODUCTS   : ClosednessKind
  SUBOBJECTS : ClosednessKind

record CategoryClosednessProperty : Set where
  constructor _is_closed_under_in_
  field A kind B : M.Identifier

record EpireflectiveCriterion : Set where
  constructor THEOREM_EpireflectiveCriterion
  field A B : M.Identifier

record Example_Grp_in_Mon_Epireflective : Set where
  constructor THEOREM_Grp_is_EPIREFLECTIVE_IN_Mon
  field unit : ⊤

-- Dual notions
record MonoreflectiveSubcategoryDeclaration : Set where
  constructor _is_MONOREFLECTIVE_IN_
  field A B : M.Identifier

record MonoreflectiveCriterion : Set where
  constructor INFER_DUAL_THEOREM_MonoreflectiveCriterion
  field unit : ⊤

------------------------------------------------------------------------
-- Part 7: Kan extensions
------------------------------------------------------------------------

record KanExtensionContext : Set where
  constructor CONTEXT_KAN
  field K T : M.Identifier
        C A B : M.Identifier

record LeftKanCandidate : Set where
  constructor L_CANDIDATE
  field M β : M.Identifier

record RightKanCandidate : Set where
  constructor R_CANDIDATE
  field M δ : M.Identifier

record LeftKanExtensionIsInitialObject : Set where
  constructor LeftKanExtension_IS_INITIAL
  field K T : M.Identifier

record RightKanExtensionIsTerminalObject : Set where
  constructor RightKanExtension_IS_TERMINAL
  field K T : M.Identifier

record PointwiseKanFormulaTheorem : Set where
  constructor THEOREM_KanExtensionAsLimit
  field K T : M.Identifier

record CommaObjectUnderFunctor : Set where
  constructor _↓_
  field a K : M.Identifier

record AdjointsAsKanExtensions : Set where
  constructor THEOREM_AdjointsAsKanExtensions
  field F G : M.Identifier

------------------------------------------------------------------------
-- Part 8: Tensor product of set-valued functors
------------------------------------------------------------------------

record PresheafDeclaration : Set where
  constructor PRESHEAF_on
  field F C : M.Identifier

record CopresheafDeclaration : Set where
  constructor COPRESHEAF_on
  field G C : M.Identifier

record TensorAsCoequalizer : Set where
  constructor DEFINE_⊗_as_Coequalizer
  field F G C α β : M.Identifier

record TensorSummand_Objects : Set where
  constructor SumOverObjects
  field F G : M.Identifier

record TensorSummand_Morphisms : Set where
  constructor SumOverMorphisms
  field F G : M.Identifier

record TensorParallelArrowsAxiom : Set where
  constructor AXIOM_TensorParallelArrows
  field alpha beta : M.Identifier
        S_mor S_obj : M.Identifier

record TensorHomAdjunctionTheorem : Set where
  constructor THEOREM_TensorHomAdjunction
  field C G : M.Identifier

record C_BalancedMapDeclaration : Set where
  constructor C_BALANCED_MAP_→
  field β F G S : M.Identifier

record TensorUniversalPropertyTheorem : Set where
  constructor THEOREM_TensorUP
  field F G S : M.Identifier

------------------------------------------------------------------------
-- Bridge postulates: Level 3 theorems to Core.Proof
------------------------------------------------------------------------

postulate
  -- Triangle identities proof bridge
  triangleIdentitiesProof
    : (adjDecl : AdjunctionHomDecl)  -- or UnitCounitPair with metadata
    -> (ax : TriangleIdentitiesAxiom)
    -> C.Proof (C.AdjunctionS (AdjunctionHomDecl.F adjDecl)
                               (AdjunctionHomDecl.G adjDecl)
                               (AdjunctionHomDecl.C adjDecl)
                               (AdjunctionHomDecl.D adjDecl))
               C.TriangleIdentitiesName

  -- Right adjoint preserves limits
  rightAdjPreservesLimitsProof
    : (adjDecl : AdjunctionHomDecl)
    -> (thm : RightAdjointsPreserveLimits)
    -> C.Proof (C.AdjunctionS (AdjunctionHomDecl.F adjDecl)
                               (RightAdjointsPreserveLimits.G thm)
                               (AdjunctionHomDecl.C adjDecl)
                               (AdjunctionHomDecl.D adjDecl))
               C.RightAdjPreservesLimitsName

  -- Left adjoint preserves colimits (dual)
  leftAdjPreservesColimitsProof
    : (adjDecl : AdjunctionHomDecl)
    -> (thm : LeftAdjointsPreserveColimits)
    -> C.Proof (C.AdjunctionS (AdjunctionHomDecl.F adjDecl)
                               (AdjunctionHomDecl.G adjDecl)
                               (AdjunctionHomDecl.C adjDecl)
                               (AdjunctionHomDecl.D adjDecl))
               C.LeftAdjPreservesColimitsName

------------------------------------------------------------------------
-- Notes: Structural encoding of 1/3.ebnf. CATEGORY narratives preserved
-- as comments near each construct. Bridge functions into the unified proof
-- layer (Core.Proof) can be added incrementally where needed.
------------------------------------------------------------------------
module Level1_4 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Lightweight expression placeholder
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: Subobjects and equivalence relation
------------------------------------------------------------------------

record MonomorphismEquivalence : Set where
  constructor _≈_Sub_
  field m1 m2 X : M.Identifier
-- CATEGORY: Equivalence relation on monomorphisms into X.

record SubobjectAsEquivalenceClass : Set where
  constructor [_]_X
  field m X : M.Identifier
-- CATEGORY: Subobject as equivalence class [m]_X.

record SubobjectOrdering : Set where
  constructor _≤_
  field s1 s2 : M.Identifier
-- CATEGORY: Ordering on subobjects.

record SubobjectLattice : Set where
  constructor Sub
  field X : M.Identifier
-- CATEGORY: Poset of subobjects of X.

record WellPoweredCategory : Set where
  constructor _is_WELL_POWERED
  field C : M.Identifier
-- CATEGORY: Every object has only a set of subobjects.

record InferDualTheory_WellCopowered : Set where
  constructor INFER_DUAL_THEORY_Well_Copowered
  field unit : ⊤
-- CATEGORY: Dual of well-powered derived via duality.

------------------------------------------------------------------------
-- Part 2: Intersection and union (lattice operations)
------------------------------------------------------------------------

record WidePullbackDiagram : Set where
  constructor DIAGRAM_for_Intersection
  field subobjects : List M.Identifier

record IntersectionConstructor : Set where
  constructor LIMIT_OF
  field diagram : WidePullbackDiagram

record BinaryIntersection : Set where
  constructor _∩_
  field s1 s2 : M.Identifier

record UnionConstructor : Set where
  constructor Image_of_UniversalCoproductMap
  field subobjects : List M.Identifier

record BinaryUnion : Set where
  constructor _∪_
  field s1 s2 : M.Identifier

record LatticePropertyDefinition : Set where
  constructor _is_COMPLETE_LATTICE
  field P : M.Identifier

record SubobjectLatticeIsComplete : Set where
  constructor THEOREM_SubobjectLatticeIsComplete
  field unit : ⊤

------------------------------------------------------------------------
-- Part 3: Strong epimorphisms and orthogonality
------------------------------------------------------------------------

record CommutativeSquareForOrthogonalityTest : Set where
  constructor ORTHOGONALITY_SQUARE_with
  field e m f g : M.Identifier

record DiagonalFillerProperty : Set where
  constructor HasUniqueDiagonalFiller
  field sq : M.Identifier

record StrongEpimorphism : Set where
  constructor _is_STRONG_EPIMORPHISM
  field e : M.Identifier

record CanonicalFactorizationSystem : Set where
  constructor THEOREM_CanonicalFactorizationSystem
  field unit : ⊤

record StrongMonomorphism : Set where
  constructor _is_STRONG_MONOMORPHISM
  field m : M.Identifier

record DualFactorizationSystem : Set where
  constructor INFER_DUAL_THEOREM_DualFactorizationSystem
  field unit : ⊤

------------------------------------------------------------------------
-- Part 4: Epi-mono factorizations
------------------------------------------------------------------------

record MorphismFactorization : Set where
  constructor Factorization_of_is_via
  field f e m I : M.Identifier

record FactorizationUniquenessAxiom : Set where
  constructor AXIOM_FactorizationIsUniqueUpToIsomorphism
  field unit : ⊤

record HasFactorizationSystem : Set where
  constructor _has_FACTORIZATION_SYSTEM
  field C E M : M.Identifier

record ImageOfMorphism : Set where
  constructor Image
  field f : M.Identifier

record CoimageOfMorphism : Set where
  constructor Coimage
  field f : M.Identifier

record StandardFactorizationSystem : Set where
  constructor THEOREM_StandardFactorizationSystem
  field C : M.Identifier

record AlternateFactorizationSystem : Set where
  constructor INFER_DUAL_THEOREM_AlternateFactorizationSystem
  field unit : ⊤

------------------------------------------------------------------------
-- Part 5: Generators
------------------------------------------------------------------------

record HasGeneratorObject : Set where
  constructor _has_GENERATOR_
  field C G : M.Identifier
-- CATEGORY: G is a generator if Hom(G,-) is faithful.

------------------------------------------------------------------------
-- Part 6: Projectives
------------------------------------------------------------------------

record ProjectiveLiftingProblem : Set where
  constructor LIFTING_PROBLEM_against_epi
  field f e : M.Identifier

record HasLiftSolution : Set where
  constructor HAS_LIFT
  field problem : M.Identifier

record ProjectiveObject : Set where
  constructor _is_PROJECTIVE
  field P : M.Identifier

record ProjectiveFunctorialEquivalence : Set where
  constructor THEOREM_ProjectiveFunctorialEquivalence
  field P : M.Identifier

record FreeObjectsAreProjective : Set where
  constructor THEOREM_FreeObjectsAreProjective
  field unit : ⊤

record HasEnoughProjectives : Set where
  constructor _has_ENOUGH_PROJECTIVES
  field C : M.Identifier

record InferDualTheory_Injective : Set where
  constructor INFER_DUAL_THEORY_InjectiveTheory
  field unit : ⊤

------------------------------------------------------------------------
-- Part 7: Injectives and cogenerators
------------------------------------------------------------------------

record InjectiveObject : Set where
  constructor _is_INJECTIVE
  field I : M.Identifier

record InjectiveExtensionProblem : Set where
  constructor EXTENSION_PROBLEM_from_mono_with_map
  field m f : M.Identifier

record InjectiveLiftingEquivalence : Set where
  constructor THEOREM_InjectiveLiftingEquivalence
  field I : M.Identifier

record CogeneratorObject : Set where
  constructor _is_COGENERATOR
  field C : M.Identifier

record HasEnoughInjectives : Set where
  constructor _has_ENOUGH_INJECTIVES
  field C : M.Identifier

------------------------------------------------------------------------
-- Bridge postulates: Connect axiom records to typed Proof witnesses
------------------------------------------------------------------------

open C using (Subject; AxiomName; Proof)
open C using (FactorizationS; ProjectiveS; InjectiveS; CategoryPropertyS)
open C using (FactorizationUniquenessName; SubobjectLatticeCompletenessName; CanonicalFactorizationSystemName; ProjectiveLiftingName; InjectiveLiftingName)

postulate
  -- Factorization uniqueness proof
  factorizationUniquenessProof
    : (ax : FactorizationUniquenessAxiom)
    -> (C E M : M.Identifier)
    -> Proof (FactorizationS C E M) FactorizationUniquenessName

  -- Subobject lattice completeness proof
  subobjectLatticeCompleteProof
    : (thm : SubobjectLatticeIsComplete)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) SubobjectLatticeCompletenessName

  -- Canonical factorization system proof
  canonicalFactorizationProof
    : (thm : CanonicalFactorizationSystem)
    -> (C E M : M.Identifier)
    -> Proof (FactorizationS C E M) CanonicalFactorizationSystemName

  -- Projective lifting proof
  projectiveLiftingProof
    : (obj : ProjectiveObject)
    -> Proof (ProjectiveS (ProjectiveObject.P obj)) ProjectiveLiftingName

  -- Injective lifting proof
  injectiveLiftingProof
    : (obj : InjectiveObject)
    -> Proof (InjectiveS (InjectiveObject.I obj)) InjectiveLiftingName

------------------------------------------------------------------------
-- Notes: Structural encoding of 1/4.ebnf. CATEGORY prose preserved as
-- comments. Bridge postulates connect axiom records to Core.Proof.
------------------------------------------------------------------------
module Level1_5 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Lightweight expression placeholder
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: Graphs and Path Categories (Section 5.1)
------------------------------------------------------------------------

-- CATEGORY: The definition of a directed multigraph (or quiver) G.
record GraphDeclaration : Set where
  constructor GRAPH_has_vertices_arrows
  field
    graphName : M.Identifier
    vertices  : List M.Identifier
    arrows    : List M.Identifier

-- CATEGORY: A finite, non-empty sequence of composable arrows in the underlying graph.
record PathDeclaration : Set where
  constructor PATH_from_to
  field
    composableArrows : List M.Identifier
    source           : M.Identifier
    target           : M.Identifier

-- CATEGORY: The empty path at vertex v.
record IdentityPathDeclaration : Set where
  constructor id_path_at
  field vertex : M.Identifier

-- CATEGORY: The path category generated by the graph G.
record PathCategoryConstructor : Set where
  constructor FreeCategory
  field graph : M.Identifier

-- CATEGORY: The assertion that the Free Category construction is left adjoint to the forgetful functor.
record PathCategoryAdjunction : Set where
  constructor THEOREM_PathCategoryAdjunction
  field
    freeCatFunctor    : M.Identifier
    forgetfulFunctor  : M.Identifier

------------------------------------------------------------------------
-- Part 2: Calculus of Fractions (Section 5.2)
------------------------------------------------------------------------

-- CATEGORY: The category of fractions (or localization) of C with respect to S.
record CategoryOfFractions : Set where
  constructor _[_⁻¹]
  field
    category : M.Identifier
    morphismClass : M.Identifier

-- CATEGORY: The canonical localization functor.
record LocalizationFunctor : Set where
  constructor L_to_Localization
  field
    source : M.Identifier
    target : CategoryOfFractions

-- CATEGORY: The assertion that the class of morphisms S is 'well-behaved' enough
-- to allow for the concrete construction of the category of fractions.
record AdmitsRightCalculusOfFractions : Set where
  constructor _admits_RIGHT_CALCULUS_OF_FRACTIONS
  field
    morphismClass : M.Identifier
    axiom1 : M.Identifier  -- Contains isomorphisms, closed under composition
    axiom2_Ore : M.Identifier  -- Ore condition
    axiom3_Cancel : M.Identifier  -- Cancellation

-- CATEGORY: A morphism in the category of fractions from X to Y,
-- represented as a 'roof' or 'span'.
record RightFractionSpan : Set where
  constructor SPAN
  field
    f : M.Identifier  -- apex -> codomain
    s : M.Identifier  -- apex -> domain (must be in S)
    apex : M.Identifier
    domain : M.Identifier
    codomain : M.Identifier

-- CATEGORY: The equivalence relation on fractions.
record EquivalenceOfRightFractions : Set where
  constructor _∼_
  field
    span1 : RightFractionSpan
    span2 : RightFractionSpan
    witness : M.Identifier  -- Common refinement

-- CATEGORY: The assertion that when the Ore conditions hold, the abstract, universal
-- definition of the category of fractions and the concrete construction using
-- equivalence classes of spans are equivalent.
record CalculusOfFractionsEquivalence : Set where
  constructor THEOREM_CalculusOfFractionsEquivalence
  field
    category : M.Identifier
    morphismClass : M.Identifier

------------------------------------------------------------------------
-- Part 3: Reflective Subcategories as Categories of Fractions (Section 5.3)
------------------------------------------------------------------------

-- CATEGORY: The class of morphisms in B that are 'L-equivalences'.
record MorphismClassInvertedByFunctor : Set where
  constructor Σ_
  field functor : M.Identifier

-- CATEGORY: A fundamental theorem connecting reflection and localization.
record ReflectiveSubcategoryAsLocalizationTheorem : Set where
  constructor THEOREM_ReflectiveSubcategoryAsLocalization
  field
    reflectiveSubcat : M.Identifier
    ambientCategory : M.Identifier
    reflector : M.Identifier

-- CATEGORY: A concrete application of the main theorem to abelianization.
record TheoremInstantiation : Set where
  constructor INSTANCE_AbelianizationAsLocalization
  field
    instance_of : ReflectiveSubcategoryAsLocalizationTheorem

------------------------------------------------------------------------
-- Part 4: Orthogonal Subcategory Problem (Section 5.4)
------------------------------------------------------------------------

-- CATEGORY: The assertion that morphism e is left-orthogonal to morphism m.
record MorphismOrthogonality : Set where
  constructor _⊥_
  field
    leftMorphism : M.Identifier
    rightMorphism : M.Identifier

-- CATEGORY: The full subcategory of S-local (or S-orthogonal) objects.
record OrthogonalSubcategoryConstructor : Set where
  constructor _⊥
  field morphismClass : M.Identifier

-- CATEGORY: The property of an object X being 'S-local'.
record IsSLocal : Set where
  constructor IsSLocal
  field
    object : M.Identifier
    morphismClass : M.Identifier

-- CATEGORY: A powerful existence theorem that solves the orthogonal subcategory problem.
record OrthogonalSubcategoryTheorem : Set where
  constructor THEOREM_OrthogonalSubcategoryIsReflective
  field
    ambientCategory : M.Identifier
    morphismClass : M.Identifier

------------------------------------------------------------------------
-- Part 5: Factorization Systems (Section 5.5)
------------------------------------------------------------------------

-- CATEGORY: A pair of classes of morphisms, E and M, intended to form a factorization system.
record FactorizationSystemPair : Set where
  constructor FactSys
  field
    E : M.Identifier
    M : M.Identifier

-- CATEGORY: A fundamental property of a category C, ensuring that every arrow
-- can be uniquely and functorially decomposed.
record CategoryHasFactorizationSystem : Set where
  constructor _has_FACTORIZATION_SYSTEM_
  field
    category : M.Identifier
    system : FactorizationSystemPair

-- CATEGORY: The assertion of orthogonality between two classes of morphisms.
record ClassOrthogonality : Set where
  constructor Class_⊥_Class
  field
    E : M.Identifier
    M : M.Identifier

-- CATEGORY: The assertion that the classes of strong epimorphisms and monomorphisms
-- form the canonical factorization system.
record StrongEpiMonoIsFactorizationSystem : Set where
  constructor THEOREM_StrongEpiMonoIsFactorizationSystem
  field category : M.Identifier

-- CATEGORY: A constructive proof of the existence of the dual factorization system (Epi, StrongMono).
record EpiStrongMonoIsFactorizationSystem : Set where
  constructor INFER_DUAL_THEOREM_EpiStrongMonoIsFactorizationSystem
  field unit : ⊤

------------------------------------------------------------------------
-- Part 6: Localization as Reflection (Section 5.6)
------------------------------------------------------------------------

-- CATEGORY: The full subcategory C_S of all S-local objects.
record LocalSubcategoryConstructor : Set where
  constructor LocalObjectsSubcat
  field morphismClass : M.Identifier

-- CATEGORY: The universal morphism from an object A to an S-local object.
record SLocalizationMap : Set where
  constructor S_localization_of
  field object : M.Identifier

-- CATEGORY: The central theorem asserting that the process of localization
-- is an instance of reflection.
record LocalizationIsReflection : Set where
  constructor THEOREM_LocalizationIsReflection
  field
    category : M.Identifier
    morphismClass : M.Identifier

------------------------------------------------------------------------
-- Part 7: Universal Closure Operations (Section 5.7)
------------------------------------------------------------------------

-- CATEGORY: A family of maps on the subobject lattices that behaves like
-- a topological closure.
record ClosureOperation : Set where
  constructor ClosureOp
  field
    closureMaps : List M.Identifier
    extensiveAxiom : M.Identifier
    monotoneAxiom : M.Identifier
    idempotentAxiom : M.Identifier

-- CATEGORY: A closure operation that is compatible with the entire morphism
-- structure of the category.
record UniversalClosureOperation : Set where
  constructor Universal
  field
    closureOp : ClosureOperation
    universalAxiom : M.Identifier

-- CATEGORY: The property of a subobject being 'complete' with respect to
-- the closure operation.
record ClosedSubobjectPredicate : Set where
  constructor _is_cl_CLOSED
  field subobject : M.Identifier

-- CATEGORY: The full subcategory of all objects that are 'closed' with
-- respect to the closure operation.
record ClosedSubcategoryConstructor : Set where
  constructor ClosedSubcat
  field closureOp : ClosureOperation

-- CATEGORY: A fundamental theorem establishing a one-to-one correspondence
-- between closure operations and reflective subcategories.
record ClosureSubcategoryCorrespondence : Set where
  constructor THEOREM_ClosureSubcategoryCorrespondence
  field category : M.Identifier

------------------------------------------------------------------------
-- Part 8: Calculus of Bidense Morphisms (Section 5.8)
------------------------------------------------------------------------

-- CATEGORY: A morphism that is 'dense' in the sense of the closure operation.
record BidenseMorphism : Set where
  constructor _is_cl_BIDENSE
  field
    morphism : M.Identifier
    closureOp : M.Identifier

-- CATEGORY: The class of all cl-bidense morphisms.
record ClassOfBidenseMorphisms : Set where
  constructor Σ_cl
  field closureOp : M.Identifier

-- CATEGORY: Dual of right calculus of fractions.
record AdmitsLeftCalculusOfFractions : Set where
  constructor _admits_LEFT_CALCULUS_OF_FRACTIONS
  field
    morphismClass : M.Identifier
    axiom1 : M.Identifier
    axiom2_DualOre : M.Identifier
    axiom3_DualCancel : M.Identifier

-- CATEGORY: The cornerstone theorem asserting that the class of cl-bidense
-- morphisms is structurally sound.
record BidenseMorphismsAdmitLeftCalculus : Set where
  constructor THEOREM_BidenseMorphismsAdmitLeftCalculus
  field
    category : M.Identifier
    closureOp : M.Identifier

-- CATEGORY: A deep theorem that unifies the main themes of Chapter 5.
record BidenseLocalizationIsReflectionToClosed : Set where
  constructor THEOREM_BidenseLocalizationIsReflectionToClosed
  field
    category : M.Identifier
    closureOp : M.Identifier

------------------------------------------------------------------------
-- Bridge postulates: Connect axiom records to typed Proof witnesses
------------------------------------------------------------------------

open C using (Subject; AxiomName; Proof)
open C using (CategoryPropertyS; FactorizationS)
open C using (FactorizationUniquenessName; CanonicalFactorizationSystemName)

postulate
  -- Path category adjunction proof
  pathCategoryAdjunctionProof
    : (thm : PathCategoryAdjunction)
    -> (G : M.Identifier)  -- Graph
    -> (C : M.Identifier)  -- Cat category
    -> Proof (C.AdjunctionS (PathCategoryAdjunction.freeCatFunctor thm) 
                            (PathCategoryAdjunction.forgetfulFunctor thm) G C)
             C.TriangleIdentitiesName

  -- Calculus of fractions equivalence proof
  calculusOfFractionsEquivProof
    : (thm : CalculusOfFractionsEquivalence)
    -> (C E M : M.Identifier)
    -> Proof (FactorizationS C E M) CanonicalFactorizationSystemName

  -- Reflective subcategory as localization proof
  reflectiveSubcatAsLocalizationProof
    : (thm : ReflectiveSubcategoryAsLocalizationTheorem)
    -> (A B : M.Identifier)
    -> Proof (CategoryPropertyS B) C.SubobjectLatticeCompletenessName

  -- Orthogonal subcategory theorem proof
  orthogonalSubcategoryProof
    : (thm : OrthogonalSubcategoryTheorem)
    -> (B : M.Identifier)
    -> Proof (CategoryPropertyS B) C.SubobjectLatticeCompletenessName

  -- Strong epi/mono factorization system proof
  strongEpiMonoFactorizationProof
    : (thm : StrongEpiMonoIsFactorizationSystem)
    -> (C E M : M.Identifier)
    -> Proof (FactorizationS C E M) CanonicalFactorizationSystemName

  -- Localization is reflection proof
  localizationIsReflectionProof
    : (thm : LocalizationIsReflection)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Closure-subcategory correspondence proof
  closureSubcategoryCorrespondenceProof
    : (thm : ClosureSubcategoryCorrespondence)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Bidense localization is reflection to closed proof
  bidenseLocalizationProof
    : (thm : BidenseLocalizationIsReflectionToClosed)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

------------------------------------------------------------------------
-- Notes: Structural encoding of 1/5.ebnf covering graphs, path categories,
-- calculus of fractions, orthogonal subcategories, factorization systems,
-- and universal closure operations. CATEGORY prose preserved as comments.
-- Bridge postulates connect theorem records to Core.Proof.
------------------------------------------------------------------------
module Level1_6 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Lightweight expression placeholder
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: Exact Functors (Section 6.1)
------------------------------------------------------------------------

-- CATEGORY: The property of an index category J being small in the strongest sense.
record CategoryIsFinite : Set where
  constructor _is_FINITE
  field category : M.Identifier

-- CATEGORY: A limit of a diagram whose shape J is a finite category.
record FiniteLimit : Set where
  constructor FINITE_LIMIT
  field
    limit : M.Identifier
    diagram : M.Identifier
    indexCategory : M.Identifier

-- CATEGORY: The property of a functor being 'left continuous'.
record FunctorIsLeftExact : Set where
  constructor _is_LEFT_EXACT
  field functor : M.Identifier

-- CATEGORY: The dual property of being 'right continuous'.
record FunctorIsRightExact : Set where
  constructor _is_RIGHT_EXACT
  field functor : M.Identifier

-- CATEGORY: The powerful property of a functor that preserves all finite
-- limit and colimit structures.
record FunctorIsExact : Set where
  constructor _is_EXACT
  field
    functor : M.Identifier
    leftExact : FunctorIsLeftExact
    rightExact : FunctorIsRightExact

-- CATEGORY: Duality mapping between left and right exactness
record DualityMappingLeftRightExact : Set where
  constructor DUALITY_MAPPING_FOR_LEFT_EXACT_IS_RIGHT_EXACT
  field unit : ⊤

-- CATEGORY: A classic and practical result in homological algebra.
record LeftExactnessViaKernels : Set where
  constructor THEOREM_LeftExactnessViaKernels
  field
    abelianCategory : M.Identifier
    functor : M.Identifier

------------------------------------------------------------------------
-- Part 2: Left Exact Reflection (Section 6.2)
------------------------------------------------------------------------

-- CATEGORY: The category of left exact functors from C to D.
record LeftExactFunctorSubcategory : Set where
  constructor Lex
  field
    domain : M.Identifier
    codomain : M.Identifier

-- CATEGORY: The fundamental theorem asserting that the subcategory of
-- left exact functors is reflective.
record LexIsReflective : Set where
  constructor THEOREM_LexIsReflective
  field
    domain : M.Identifier
    codomain : M.Identifier

-- CATEGORY: The left exact reflection of the functor F.
record LeftExactReflection : Set where
  constructor L_lex
  field functor : M.Identifier

-- CATEGORY: The universal natural transformation η_F : F ⇒ L(F).
record LeftExactReflectionArrow : Set where
  constructor lex_reflection_of
  field functor : M.Identifier

------------------------------------------------------------------------
-- Part 3: Flat Functors (Section 6.3)
------------------------------------------------------------------------

-- CATEGORY: The property of a presheaf F that makes it behave like a 'flat module'.
record FunctorIsFlat : Set where
  constructor _is_FLAT
  field presheaf : M.Identifier

-- CATEGORY: The representable presheaf on C associated with the object X.
record RepresentableFunctor : Set where
  constructor y
  field object : M.Identifier

-- CATEGORY: The property of a presheaf being constructible as a 'direct limit'.
record FunctorAsFilteredColimitOfRepresentables : Set where
  constructor _is_FilteredColimitOfRepresentables
  field functor : M.Identifier

-- CATEGORY: A fundamental theorem of presheaf theory.
record FlatFunctorEquivalence : Set where
  constructor THEOREM_FlatFunctorEquivalence
  field functor : M.Identifier

------------------------------------------------------------------------
-- Part 4: Regular Cardinals (Section 6.4)
------------------------------------------------------------------------

-- CATEGORY: A type of 'well-behaved' infinite cardinal.
record RegularCardinal : Set where
  constructor REGULAR_CARDINAL
  field cardinal : M.Identifier

-- CATEGORY: A limit whose diagram shape is 'small' relative to the regular cardinal α.
record AlphaLimit : Set where
  constructor α_LIMIT
  field
    limit : M.Identifier
    cardinal : RegularCardinal

-- CATEGORY: The generalization of a filtered category to size α.
record AlphaFilteredCategory : Set where
  constructor α_FILTERED_CATEGORY
  field
    category : M.Identifier
    cardinal : RegularCardinal

-- CATEGORY: The property of a functor preserving all limits of size less than α.
record FunctorIsAlphaContinuous : Set where
  constructor _is_α_CONTINUOUS
  field
    functor : M.Identifier
    cardinal : RegularCardinal

-- CATEGORY: The property of a functor being 'flat' up to size α.
record FunctorIsAlphaFlat : Set where
  constructor _is_α_FLAT
  field
    functor : M.Identifier
    cardinal : RegularCardinal

-- CATEGORY: The generalization of the Flat Functor Equivalence theorem.
record AlphaFunctorEquivalenceGeneralization : Set where
  constructor THEOREM_AlphaFunctorEquivalenceGeneralization
  field cardinal : RegularCardinal

------------------------------------------------------------------------
-- Part 5: Splitting of Idempotents (Section 6.5)
------------------------------------------------------------------------

-- CATEGORY: An endomorphism that acts like a projection operator.
record MorphismIsIdempotent : Set where
  constructor _is_IDEMPOTENT
  field morphism : M.Identifier

-- CATEGORY: A concrete realization of the abstract idempotent e.
record SplittingOfIdempotent : Set where
  constructor SPLITTING_OF_is
  field
    idempotent : M.Identifier
    retraction : M.Identifier
    section : M.Identifier
    intermediateObject : M.Identifier

-- CATEGORY: An object in the Karoubi envelope.
record KaroubiObject : Set where
  constructor KarObj
  field
    obj : M.Identifier
    idem : M.Identifier

-- CATEGORY: A morphism in the Karoubi envelope.
record KaroubiMorphism : Set where
  constructor KarMor
  field
    mor : M.Identifier
    source : KaroubiObject
    target : KaroubiObject

-- CATEGORY: The Karoubi envelope of C.
record KaroubiEnvelope : Set where
  constructor Kar
  field category : M.Identifier

-- CATEGORY: The property of a category being 'idempotent complete'.
record CategoryIsCauchyComplete : Set where
  constructor _is_CAUCHY_COMPLETE
  field category : M.Identifier

-- CATEGORY: A foundational result connecting different forms of completeness.
record EqualizersImplyCauchyCompleteness : Set where
  constructor THEOREM_EqualizersImplyCauchyCompleteness
  field category : M.Identifier

-- CATEGORY: The canonical Yoneda-like embedding of a category C into its Karoubi envelope.
record KaroubiEmbeddingFunctor : Set where
  constructor Y_Kar
  field
    source : M.Identifier
    target : KaroubiEnvelope

-- CATEGORY: The refined assertion that the Karoubi envelope is the universal solution
-- to making a category Cauchy complete.
record KaroubiEnvelopeIsUniversalRefined : Set where
  constructor THEOREM_KaroubiEnvelopeIsUniversal_Refined
  field category : M.Identifier

------------------------------------------------------------------------
-- Part 6: General Adjoint Functor Theorem (Section 6.6)
------------------------------------------------------------------------

-- CATEGORY: A proof that the property of completeness is 'lifted' from a functor's domain D
-- to the comma category (c↓G).
record InheritedCompletenessOfCommaCategory : Set where
  constructor THEOREM_InheritedCompletenessOfCommaCategory
  field
    domain : M.Identifier
    codomain : M.Identifier
    functor : M.Identifier

-- CATEGORY: A formalization of the complete proof strategy for the General Adjoint Functor Theorem.
record GeneralAdjointFunctorTheoremConstructiveProof : Set where
  constructor PROOF_OF_GAFT
  field
    functor : M.Identifier
    domain : M.Identifier
    codomain : M.Identifier

-- CATEGORY: The core constructive step of the GAFT proof.
record InitialObjectConstructorFromWeaklyInitialSet : Set where
  constructor ConstructInitialObject_in_using
  field
    category : M.Identifier
    weaklyInitialSet : M.Identifier

-- CATEGORY: An assertion of definitional equivalence.
record UniversalArrowFromInitialObject : Set where
  constructor UniversalArrow_for_is_InitialObject_of
  field
    object : M.Identifier
    commaCategory : M.Identifier

-- CATEGORY: The theorem which provides the final step of the GAFT proof.
record AdjunctionsFromUniversalArrows : Set where
  constructor THEOREM_AdjunctionsFromUniversalArrows
  field functor : M.Identifier

------------------------------------------------------------------------
-- Bridge postulates: Connect axiom records to typed Proof witnesses
------------------------------------------------------------------------

open C using (Subject; AxiomName; Proof)
open C using (CategoryPropertyS; FunctorMapS)
open C using (PreservesCompositionName; PreservesIdentityName)

postulate
  -- Left exactness via kernels proof
  leftExactnessViaKernelsProof
    : (thm : LeftExactnessViaKernels)
    -> (F C D : M.Identifier)
    -> Proof (FunctorMapS F C D) PreservesCompositionName

  -- Lex is reflective proof
  lexIsReflectiveProof
    : (thm : LexIsReflective)
    -> (C D : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Flat functor equivalence proof
  flatFunctorEquivalenceProof
    : (thm : FlatFunctorEquivalence)
    -> (F C D : M.Identifier)
    -> Proof (FunctorMapS F C D) PreservesCompositionName

  -- Alpha functor equivalence generalization proof
  alphaFunctorEquivalenceProof
    : (thm : AlphaFunctorEquivalenceGeneralization)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Equalizers imply Cauchy completeness proof
  equalizersImplyCauchyProof
    : (thm : EqualizersImplyCauchyCompleteness)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Karoubi envelope is universal refined proof
  karoubiEnvelopeUniversalProof
    : (thm : KaroubiEnvelopeIsUniversalRefined)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) C.SubobjectLatticeCompletenessName

  -- Inherited completeness of comma category proof
  inheritedCompletenessProof
    : (thm : InheritedCompletenessOfCommaCategory)
    -> (D : M.Identifier)
    -> Proof (CategoryPropertyS D) C.SubobjectLatticeCompletenessName

  -- Adjunctions from universal arrows proof
  adjunctionsFromUniversalArrowsProof
    : (thm : AdjunctionsFromUniversalArrows)
    -> (F G C D : M.Identifier)
    -> Proof (C.AdjunctionS F G C D) C.TriangleIdentitiesName

------------------------------------------------------------------------
-- Notes: Structural encoding of 1/6.ebnf covering exact functors, left exact
-- reflection, flat functors, regular cardinals, Cauchy completeness, and the
-- general adjoint functor theorem. CATEGORY prose preserved as comments.
-- Bridge postulates connect theorem records to Core.Proof.
------------------------------------------------------------------------
module Level1_7 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Lightweight expression placeholder
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Part 1: 2-Categories (Section 7.1)
------------------------------------------------------------------------

-- CATEGORY: The hom-category C(A,B). Its existence, for every pair of objects (A,B),
-- is the defining feature of a 2-category.
record HomCategoryDeclaration : Set where
  constructor HOM_CATEGORY_has_OneMorphisms_TwoMorphisms
  field
    obj1 : M.Identifier
    obj2 : M.Identifier
    oneMorphisms : List M.Identifier  -- 1-morphisms as objects
    twoMorphisms : List M.Identifier  -- 2-morphisms as morphisms

-- CATEGORY: The horizontal composition functor.
record CompositionFunctorDeclaration : Set where
  constructor COMPOSITION_FUNCTOR_∘
  field
    source1 : HomCategoryDeclaration
    source2 : HomCategoryDeclaration
    target : HomCategoryDeclaration

-- CATEGORY: The identity-on-A functor.
record IdentityFunctorDeclaration : Set where
  constructor IDENTITY_FUNCTOR_Id
  field
    object : M.Identifier
    targetHomCat : HomCategoryDeclaration

-- CATEGORY: A category enriched over the category of small categories (Cat).
record TwoCategoryDeclaration : Set where
  constructor _2CATEGORY
  field
    name : M.Identifier
    objects : List M.Identifier
    homCategories : List HomCategoryDeclaration
    compositionFunctors : List CompositionFunctorDeclaration
    identityFunctors : List IdentityFunctorDeclaration

------------------------------------------------------------------------
-- Part 2: 2-Functors and 2-Natural Transformations (Section 7.2)
------------------------------------------------------------------------

-- CATEGORY: Mapping between hom-categories
record HomCategoryFunctorMapping : Set where
  constructor map_hom_cat_to_hom_cat_via_functor
  field
    sourceObj1 : M.Identifier
    sourceObj2 : M.Identifier
    targetObj1 : M.Identifier
    targetObj2 : M.Identifier
    functor : M.Identifier

-- CATEGORY: A strict 2-functor, or a homomorphism of 2-categories.
record TwoFunctorDeclaration : Set where
  constructor _2FUNCTOR
  field
    name : M.Identifier
    source : M.Identifier
    target : M.Identifier
    actionOnObjects : List M.Identifier
    actionOnHomCats : List HomCategoryFunctorMapping

-- CATEGORY: The assertion of the Pentagon Axiom for strict 2-categories.
record AssociativityAxiomTwoCat : Set where
  constructor AXIOM_Associativity
  field
    forAllQuads : M.Identifier  -- (A,B,C,D)
    equation : M.Identifier

-- CATEGORY: The assertion of the Triangle Axiom for strict 2-categories.
record UnitalityAxiomTwoCat : Set where
  constructor AXIOM_Unitality
  field
    forAllPairs : M.Identifier  -- (A,B)
    leftEquation : M.Identifier
    rightEquation : M.Identifier

------------------------------------------------------------------------
-- Part 3: Modifications and n-Categories (Section 7.3)
------------------------------------------------------------------------

-- CATEGORY: A 3-morphism in the 3-category of 2-categories.
record ModificationDeclaration : Set where
  constructor MODIFICATION
  field
    name : M.Identifier
    source : M.Identifier  -- 2-natural transformation α
    target : M.Identifier  -- 2-natural transformation β
    components : List M.Identifier  -- μ_X for each object X

-- CATEGORY: The assertion that the universe of (small) 2-categories forms a 3-category.
record CategoryLevelDeclaration : Set where
  constructor _is_a_3-CATEGORY
  field category : M.Identifier

-- CATEGORY: The inductive definition of an n-category.
record NCategoryRecursiveDefinition : Set where
  constructor DEFINE_n+1_CATEGORY_as_CategoryEnrichedOver_n-Cat
  field level : M.Identifier

------------------------------------------------------------------------
-- Part 4: 2-Limits and Bilimits (Section 7.4)
------------------------------------------------------------------------

-- CATEGORY: A cone in a 2-category whose commuting triangles hold with strict equality.
record StrictConeDeclaration : Set where
  constructor STRICT_CONE_over
  field
    diagram : M.Identifier
    apex : M.Identifier
    legs : List M.Identifier

-- CATEGORY: A cone where the triangles are witnessed to commute by specified,
-- invertible 2-cells.
record PseudoConeDeclaration : Set where
  constructor PSEUDO_CONE_over
  field
    diagram : M.Identifier
    apex : M.Identifier
    legs : List M.Identifier
    cells : List M.Identifier  -- isomorphisms witnessing commutativity

-- CATEGORY: The property of being terminal 'up to equivalence'.
record BiTerminalObjectProperty : Set where
  constructor _is_BI_TERMINAL_in
  field
    object : M.Identifier
    twoCategory : M.Identifier

-- CATEGORY: A limit in the underlying 1-category of the 2-category.
record StrictTwoLimitDeclaration : Set where
  constructor STRICT_2_LIMIT_of_is
  field
    diagram : M.Identifier
    limit : StrictConeDeclaration

-- CATEGORY: A limit over a strictly commuting diagram with weak universal property.
record PseudoLimitDeclaration : Set where
  constructor PSEUDO_LIMIT_of_is
  field
    diagram : M.Identifier
    limit : StrictConeDeclaration

-- CATEGORY: The most general and natural notion of a limit in a 2-category or bicategory.
record BilimitDeclaration : Set where
  constructor BILIMIT_of_is
  field
    diagram : M.Identifier
    limit : PseudoConeDeclaration

------------------------------------------------------------------------
-- Part 5: Lax Functors and Pseudo-Functors (Section 7.5)
------------------------------------------------------------------------

-- CATEGORY: Comparison cell for composition
record ComparisonCellComposition : Set where
  constructor φ_comp
  field
    morph1 : M.Identifier
    morph2 : M.Identifier

-- CATEGORY: Comparison cell for identity
record ComparisonCellIdentity : Set where
  constructor φ_id
  field object : M.Identifier

-- CATEGORY: The structural data for a lax functor.
record LaxFunctorData : Set where
  constructor DATA_LaxFunctor
  field
    name : M.Identifier
    source : M.Identifier
    target : M.Identifier
    actionOnObjects : List M.Identifier
    actionOn1Morphisms : List M.Identifier
    compositionCells : List ComparisonCellComposition
    identityCells : List ComparisonCellIdentity

-- CATEGORY: The coherence law for a lax functor's interaction with associativity.
record LaxAssociativityAxiom : Set where
  constructor AXIOM_LaxAssociativity_for
  field
    laxFunctorData : LaxFunctorData
    equation : M.Identifier

-- CATEGORY: The coherence law for a lax functor's interaction with identity.
record LaxUnitalityAxiom : Set where
  constructor AXIOM_LaxUnitality_for
  field
    laxFunctorData : LaxFunctorData
    equation : M.Identifier

-- CATEGORY: The fully-specified definition of a lax functor.
record LaxFunctorDeclaration : Set where
  constructor LAX_FUNCTOR_verifies
  field
    functorData : LaxFunctorData
    associativityProof : LaxAssociativityAxiom
    unitalityProof : LaxUnitalityAxiom

-- CATEGORY: A homomorphism of bicategories.
record PseudoFunctorDeclaration : Set where
  constructor PSEUDOFUNCTOR
  field
    name : M.Identifier
    source : M.Identifier
    target : M.Identifier
    underlyingLaxFunctor : LaxFunctorDeclaration

-- CATEGORY: A concrete realization of a lax functor via lax monoidal functors.
record LaxMonoidalFunctorAsLaxFunctor : Set where
  constructor INSTANCE_from_lax_monoidal_functor
  field laxMonoidalFunctor : M.Identifier

------------------------------------------------------------------------
-- Part 6: Lax Limits and Pseudo-Limits (Section 7.6)
------------------------------------------------------------------------

-- CATEGORY: The most general notion of a cone in a 2-categorical context.
record LaxConeDeclaration : Set where
  constructor LAX_CONE_over
  field
    diagram : M.Identifier
    apex : M.Identifier
    legs : List M.Identifier
    comparisonCells : List M.Identifier  -- not necessarily isomorphisms

-- CATEGORY: The universal lax cone.
record LaxLimitDeclaration : Set where
  constructor LAX_LIMIT_of_is
  field
    diagram : M.Identifier
    limit : LaxConeDeclaration

-- CATEGORY: The assertion of a clear hierarchy of limit concepts.
record LimitHierarchyTheorem : Set where
  constructor THEOREM_LimitHierarchy
  field unit : ⊤

------------------------------------------------------------------------
-- Part 7: Bicategories (Section 7.7)
------------------------------------------------------------------------

-- CATEGORY: The hom-category for a bicategory (functor category).
record BicategoryHomCategory : Set where
  constructor HOM_CATEGORY_Bicat
  field
    obj1 : M.Identifier
    obj2 : M.Identifier

-- CATEGORY: The horizontal composition functor for bicategories.
record BicategoryCompositionFunctor : Set where
  constructor ∘_ABC
  field
    objA : M.Identifier
    objB : M.Identifier
    objC : M.Identifier

-- CATEGORY: The identity functor for bicategories.
record BicategoryIdentityFunctor : Set where
  constructor Id_Bicat
  field object : M.Identifier

-- CATEGORY: The associator isomorphism.
record ConstraintAssociator : Set where
  constructor associator_α
  field naturalIso : M.Identifier

-- CATEGORY: The left unitor isomorphism.
record ConstraintLeftUnitor : Set where
  constructor left_unitor_λ
  field naturalIso : M.Identifier

-- CATEGORY: The right unitor isomorphism.
record ConstraintRightUnitor : Set where
  constructor right_unitor_ρ
  field naturalIso : M.Identifier

-- CATEGORY: The complete bicategory structure
record BicategoryDeclaration : Set where
  constructor BICATEGORY
  field
    name : M.Identifier
    objects : List M.Identifier
    homCategories : List BicategoryHomCategory
    compositionFunctors : List BicategoryCompositionFunctor
    identityFunctors : List BicategoryIdentityFunctor
    associator : ConstraintAssociator
    leftUnitor : ConstraintLeftUnitor
    rightUnitor : ConstraintRightUnitor

------------------------------------------------------------------------
-- Part 8: Distributors (Section 7.8)
------------------------------------------------------------------------

-- CATEGORY: A profunctor, or bimodule, from A to B.
record DistributorDeclaration : Set where
  constructor DISTRIBUTOR
  field
    name : M.Identifier
    source : M.Identifier
    target : M.Identifier

-- CATEGORY: The composition of distributors, defined by the coend.
record DistributorComposition : Set where
  constructor _∘_Dist
  field
    distributor1 : DistributorDeclaration
    distributor2 : DistributorDeclaration

-- CATEGORY: The bicategory of small categories, distributors, and natural transformations.
record BicategoryOfDistributors : Set where
  constructor Dist
  field unit : ⊤

------------------------------------------------------------------------
-- Part 9: Cauchy Completeness versus Distributors (Section 7.9)
------------------------------------------------------------------------

-- CATEGORY: The identity distributor on C, which is simply the hom-functor of C.
record IdentityDistributor : Set where
  constructor IdDist
  field category : M.Identifier

-- CATEGORY: The opposite or transpose of a distributor D.
record OppositeDistributor : Set where
  constructor _^op
  field distributor : DistributorDeclaration

-- CATEGORY: A deep characterization theorem connecting Cauchy completeness to
-- distributor factorization.
record IdempotentCompletenessAsDistributorFactorization : Set where
  constructor THEOREM_CauchyCompletenessViaDistributors
  field category : M.Identifier

------------------------------------------------------------------------
-- Bridge postulates: Connect axiom records to typed Proof witnesses
------------------------------------------------------------------------

open C using (Subject; AxiomName; Proof)
open C using (CategoryPropertyS; AdjunctionS)
open C using (TriangleIdentitiesName; SubobjectLatticeCompletenessName)

postulate
  -- 2-category associativity coherence bridge
  twoCatAssociativityProof
    : (ax : AssociativityAxiomTwoCat)
    -> (C : M.Identifier) -- identifier of the 2-category
    -> Proof (TwoCategoryS C) TwoCatAssociativityName

  -- 2-category unitality (triangle) coherence bridge
  twoCatUnitalityProof
    : (ax : UnitalityAxiomTwoCat)
    -> (C : M.Identifier)
    -> Proof (TwoCategoryS C) TwoCatUnitalityName

  -- Limit hierarchy meta-theorem bridge
  limitHierarchyProof
    : (thm : LimitHierarchyTheorem)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) LimitHierarchyName

  -- Lax functor associativity coherence bridge
  laxAssociativityProof
    : (ax : LaxAssociativityAxiom)
    -> (F C D : M.Identifier) -- lax functor name, source, target
    -> Proof (LaxFunctorS F C D) LaxAssociativityName

  -- Lax functor unitality coherence bridge
  laxUnitalityProof
    : (ax : LaxUnitalityAxiom)
    -> (F C D : M.Identifier)
    -> Proof (LaxFunctorS F C D) LaxUnitalityName

  -- Bicategory overall coherence (associator/unitor constraints) bridge
  bicategoryCoherenceAssociativityProof
    : (bicat : BicategoryDeclaration)
    -> (B : M.Identifier)
    -> Proof (BicategoryS B) TwoCatAssociativityName

  bicategoryCoherenceUnitalityProof
    : (bicat : BicategoryDeclaration)
    -> (B : M.Identifier)
    -> Proof (BicategoryS B) TwoCatUnitalityName

  -- Cauchy completeness via distributors bridge
  cauchyViaDistributorsProof
    : (thm : IdempotentCompletenessAsDistributorFactorization)
    -> (C : M.Identifier)
    -> Proof (CategoryPropertyS C) CauchyViaDistributorsName

------------------------------------------------------------------------
-- Notes: Structural encoding of 1/7.ebnf covering 2-categories, 2-functors,
-- modifications, n-categories, 2-limits, bilimits, lax functors, pseudo-functors,
-- bicategories, distributors, and Cauchy completeness via distributors.
-- CATEGORY prose preserved as comments. Bridge postulates connect axiom
-- records to Core.Proof.
------------------------------------------------------------------------
module Level1_8 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Placeholder expression type (categorical terms described textually)
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Section 8.1: Internal Categories and Functors (Monoid example)
------------------------------------------------------------------------

-- DATA portion of an internal category (generic shape)
record InternalCategoryData : Set where
  constructor INTERNAL_CAT_DATA_consists_of
  field
    ambient         : M.Identifier      -- Ambient category E
    objectOfObjects : M.Identifier      -- C₀
    objectOfMorphisms : M.Identifier    -- C₁
    domainMap       : M.Identifier      -- d₀ : C₁ → C₀
    codomainMap     : M.Identifier      -- d₁ : C₁ → C₀
    identityMap     : M.Identifier      -- i : C₀ → C₁
    compositionMap  : M.Identifier      -- m : (C₁ ×_{C₀} C₁) → C₁

-- AXIOMS portion (associativity + left/right units internalized)
record InternalCategoryAxioms : Set where
  constructor INTERNAL_CATEGORY_AXIOMS
  field
    associativityDiagram : M.Identifier
    leftUnitDiagram      : M.Identifier
    rightUnitDiagram     : M.Identifier

-- Complete internal category specification
record InternalCategory : Set where
  constructor INTERNAL_CATEGORY_verified_by
  field
    name  : M.Identifier
    data  : InternalCategoryData
    axioms : InternalCategoryAxioms

-- Example: Monoid internalized in Set
record InternalCategoryExample_Monoid_in_Set : Set where
  constructor INTERNAL_CATEGORY_MonoidAsCat_in_Set
  field
    monoidCarrier : M.Identifier
    identityElementPicker : M.Identifier
    multiplicationMap : M.Identifier
    proofsAssoc : M.Identifier
    proofsLeftUnit : M.Identifier
    proofsRightUnit : M.Identifier

------------------------------------------------------------------------
-- Section 8.2: Internal Base-Valued Functors (Presheaves, Yoneda)
------------------------------------------------------------------------

-- Internal presheaf F : C^op → E
record InternalPresheaf : Set where
  constructor INTERNAL_PRESHEAF_on
  field
    presheafName : M.Identifier
    overInternalCategory : InternalCategory
    actionEncoding : M.Identifier -- placeholder for action on objs/morphisms

-- Internal Hom functor IntHom_C(-, I)
record InternalHomFunctor : Set where
  constructor IntHom_C_of
  field
    internalCategory : InternalCategory
    targetObject     : M.Identifier  -- I in C₀
    constructionData : M.Identifier  -- pullback-based specification

-- Internal Yoneda embedding y_C
record InternalYonedaEmbedding : Set where
  constructor y_C_embedding
  field
    internalCategory : InternalCategory
    fullFaithfulnessSketch : M.Identifier

-- Internal Yoneda Lemma statement
record InternalYonedaLemma : Set where
  constructor THEOREM_InternalYonedaLemma
  field
    internalCategory : InternalCategory
    presheaf         : InternalPresheaf
    objectPicked     : M.Identifier    -- internal object I
    naturalIsoWitness : M.Identifier

------------------------------------------------------------------------
-- Section 8.3: Internal Diagrams, Cones, Limits, Duality to Colimits
------------------------------------------------------------------------

-- Internal diagram D : J → C (J external small, C internal)
record InternalDiagramDeclaration : Set where
  constructor INTERNAL_DIAGRAM
  field
    shapeCategory   : M.Identifier  -- external J
    internalCategory : InternalCategory
    objectMapping    : M.Identifier -- encoding Ob(J) → C₀
    morphismMapping  : M.Identifier -- encoding Mor(J) → C₁

-- Internal cone over D
record InternalConeDeclaration : Set where
  constructor INTERNAL_CONE_over_has
  field
    diagram : InternalDiagramDeclaration
    apex    : M.Identifier          -- internal object in C₀
    legsEncoding : M.Identifier     -- family of legs

-- Internal limit as universal cone
record InternalLimitDeclaration : Set where
  constructor INTERNAL_LIMIT_of_is
  field
    diagram : InternalDiagramDeclaration
    limitCone : InternalConeDeclaration
    universalPropertyWitness : M.Identifier

-- Dual theory inference for internal colimits
record InternalColimitDualityInference : Set where
  constructor INFER_DUAL_THEORY_InternalColimitTheory_FROM_InternalLimitTheory
  field
    sourceTheoryFragment : M.Identifier
    dualConstructionSketch : M.Identifier

-- Explicit internal cocone (dual of internal cone)
record InternalCoconeDeclaration : Set where
  constructor INTERNAL_COCONE_under_has
  field
    diagram : InternalDiagramDeclaration
    apex    : M.Identifier          -- internal object in C₀ (colim(D))
    legsEncoding : M.Identifier     -- family of morphisms from objects of diagram to apex

-- Explicit internal colimit as universal cocone
record InternalColimitDeclaration : Set where
  constructor INTERNAL_COLIMIT_of_is
  field
    diagram : InternalDiagramDeclaration
    colimitCocone : InternalCoconeDeclaration
    universalPropertyWitness : M.Identifier

------------------------------------------------------------------------
-- Bridge Postulates tying internal categorical concepts to Proof layer
------------------------------------------------------------------------
open C using (Subject; AxiomName; Proof)
open C using (CategoryPropertyS)
open C using (SubobjectLatticeCompletenessName; TriangleIdentitiesName)

postulate
  -- Internal category associativity axiom bridge
  internalAssociativityProof
    : (IC : InternalCategory)
    -> Proof (InternalCategoryS (InternalCategory.name IC)
                                   (InternalCategoryData.ambient (InternalCategory.data IC)))
             InternalAssociativityName

  -- Internal category left unit axiom bridge
  internalLeftUnitProof
    : (IC : InternalCategory)
    -> Proof (InternalCategoryS (InternalCategory.name IC)
                                   (InternalCategoryData.ambient (InternalCategory.data IC)))
             InternalLeftUnitName

  -- Internal category right unit axiom bridge
  internalRightUnitProof
    : (IC : InternalCategory)
    -> Proof (InternalCategoryS (InternalCategory.name IC)
                                   (InternalCategoryData.ambient (InternalCategory.data IC)))
             InternalRightUnitName

  -- Internal Yoneda lemma bridge
  internalYonedaLemmaProof
    : (thm : InternalYonedaLemma)
    -> (IC ambient : M.Identifier)
    -> Proof (InternalCategoryS IC ambient) YonedaLemmaName

  -- Internal limit universal property bridge
  internalLimitUniversalProof
    : (lim : InternalLimitDeclaration)
    -> (L D IC : M.Identifier)
    -> Proof (InternalLimitS L D IC) InternalLimitUniversalName

  -- Internal colimit duality correctness bridge
  internalColimitDualityProof
    : (inf : InternalColimitDualityInference)
    -> (IC : M.Identifier) (ambient : M.Identifier)
    -> Proof (InternalCategoryS IC ambient) InternalColimitDualityName
  -- Internal colimit universal property bridge
  internalColimitUniversalProof
    : (col : InternalColimitDeclaration)
    -> (L D IC : M.Identifier)
    -> Proof (InternalColimitS L D IC) InternalColimitUniversalName

------------------------------------------------------------------------
-- Notes: Structural encoding of Chapter 8 (Internal Category Theory).
-- Records mirror EBNF productions. Bridge postulates connect new constructs
-- to unified Proof system via ambient category properties.
------------------------------------------------------------------------
module EBNF1.Index where

-- Aggregates chapter 1 Agda modules for convenient downstream imports

open import Level1 public
open import Level1_2 public
open import Level1_3 public
open import Level1_4 public
open import Level1_5 public
open import Level1_6 public
open import Level1_7 public
open import Level1_8 public
module Level2_1 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Expression placeholder (for equations / witnesses appearing textually)
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Section 2.1: Zero objects, kernels, cokernels (Abelian setting foundations)
------------------------------------------------------------------------

-- Zero object property: C has_a ZERO_OBJECT
record HasZeroObjectProperty : Set where
  constructor _has_a_ZERO_OBJECT
  field
    category : M.Identifier
    zeroObj  : M.Identifier
-- CATEGORY: zeroObj is simultaneously initial and terminal (pointed category).

-- Unique zero morphism zero_mor(from:A, to:B)
record ZeroMorphismDeclaration : Set where
  constructor zero_mor
  field
    from : M.Identifier
    to   : M.Identifier
    viaZeroObject : M.Identifier  -- the chosen zero object Z
    factorizationLeft  : M.Identifier -- A -> Z
    factorizationRight : M.Identifier -- Z -> B
-- CATEGORY: Unique morphism A -> B factoring A -> Z -> B.

-- Kernel as Equalizer definition: DEFINE ker(f) as Equalizer(f, zero_mor)
record KernelAsEqualizerDefinition : Set where
  constructor DEFINE_ker_as_Equalizer
  field
    morphism     : M.Identifier  -- f : A -> B
    domain       : M.Identifier  -- A
    codomain     : M.Identifier  -- B
    zeroMorphism : ZeroMorphismDeclaration
    equalizerObject : M.Identifier  -- ker(f)
    equalizerMono   : M.Identifier  -- inclusion ker(f) -> A
-- CATEGORY: ker(f) definitionally equal to Equalizer(f, 0_{A,B}).

-- Predicate: m is_kernel_of(f)
record IsKernelOfPredicate : Set where
  constructor _is_kernel_of_
  field
    mono      : M.Identifier  -- m : K -> A
    morphism  : M.Identifier  -- f : A -> B
    kernelRep : M.Identifier  -- ker(f)
-- CATEGORY: mono represents the kernel subobject of f.

-- Duality mapping axioms (KERNEL <-> COKERNEL, Equalizer <-> Coequalizer)
record DualityMappingKernelCokernel : Set where
  constructor DUALITY_MAPPING_FOR_KERNEL_IS_COKERNEL
  field unit : ⊤

record DualityMappingEqualizerCoequalizer : Set where
  constructor DUALITY_MAPPING_FOR_Equalizer_IS_Coequalizer
  field unit : ⊤

-- Inferred dual axiom: cokernel as coequalizer
record CokernelAsCoequalizerInference : Set where
  constructor INFER_DUAL_AXIOM_CokernelAsCoequalizer_FROM_KernelAsEqualizer
  field
    originalKernelDef : KernelAsEqualizerDefinition
    cokernelObject    : M.Identifier  -- coker(f)
    coequalizerArrow  : M.Identifier  -- B -> coker(f)
-- CATEGORY: coker(f) definitionally equal to Coequalizer(f, 0_{A,B}).

------------------------------------------------------------------------
-- Section 2.2: Additive categories & biproducts
------------------------------------------------------------------------

-- Enrichment property: C is ENRICHED_OVER M
record EnrichedOverProperty : Set where
  constructor _is_ENRICHED_OVER_
  field
    category : M.Identifier
    monoidal : M.Identifier  -- e.g. Ab
-- CATEGORY: Hom-objects live in monoidal and composition is a morphism there.

-- Biproduct object A ⊕ B
record BiproductObject : Set where
  constructor _⊕_
  field
    left  : M.Identifier
    right : M.Identifier
    object : M.Identifier         -- A⊕B
    projectionLeft  : M.Identifier -- pA
    projectionRight : M.Identifier -- pB
    injectionLeft   : M.Identifier -- iA
    injectionRight  : M.Identifier -- iB
-- CATEGORY: Simultaneously product and coproduct with standard identities.

-- Additive category declaration
record AdditiveCategoryDeclaration : Set where
  constructor ADDITIVE_CATEGORY
  field
    category : M.Identifier
    hasZeroObject : HasZeroObjectProperty
    enrichment    : EnrichedOverProperty
    biproductWitnesses : List BiproductObject
-- CATEGORY: Zero object, Ab-enrichment, all binary biproducts.

-- Structural theorem: Additivity equivalence via canonical biproduct map
record AdditivityEquivalenceTheorem : Set where
  constructor THEOREM_AdditivityEquivalence
  field
    category : M.Identifier
    premiseHasFinProducts : Bool
    premiseHasFinCoproducts : Bool
    canonicalMapIsomorphismWitness : M.Identifier
-- CATEGORY: Canonical map Coproduct -> Product is iso iff category additive.

------------------------------------------------------------------------
-- Section 2.3: Additive functors
------------------------------------------------------------------------

-- Functor additivity property: F is ADDITIVE
record FunctorAdditiveProperty : Set where
  constructor _is_ADDITIVE
  field
    functor : M.Identifier
    source  : M.Identifier
    target  : M.Identifier
    homGroupPreservationWitness : M.Identifier
-- CATEGORY: Induced maps on hom-sets are group homomorphisms.

-- Additive functor biproduct preservation equivalence theorem
record AdditiveFunctorBiproductEquivalenceTheorem : Set where
  constructor THEOREM_AdditiveFunctorBiproductEquivalence
  field
    functor : M.Identifier
    source  : M.Identifier
    target  : M.Identifier
    preservesBiproductWitness : M.Identifier
-- CATEGORY: Functor additive iff it preserves biproducts.

-- Canonical example: Hom_C(A,-) is additive
record HomFunctorIsAdditiveTheorem : Set where
  constructor THEOREM_HomFunctorIsAdditive
  field
    category : M.Identifier
    objectA  : M.Identifier
    homFunctor : M.Identifier
    bilinearityWitness : M.Identifier
-- CATEGORY: Bilinearity of composition ensures additivity.

------------------------------------------------------------------------
-- Section 2.4: Abelian categories
------------------------------------------------------------------------

-- Normal monomorphism property
record NormalMonomorphismProperty : Set where
  constructor _is_NORMAL_MONOMORPHISM
  field
    mono          : M.Identifier  -- m
    kernelCokernelWitness : M.Identifier -- witness of m ≅ ker(coker(m))
-- CATEGORY: Mono arises as kernel of its cokernel.

-- Normal epimorphism property (dual)
record NormalEpimorphismProperty : Set where
  constructor _is_NORMAL_EPIMORPHISM
  field
    epi           : M.Identifier  -- e
    cokernelKernelWitness : M.Identifier -- witness of e ≅ coker(ker(e))
-- CATEGORY: Epi arises as cokernel of its kernel.

-- Abelian category declaration
record AbelianCategoryDeclaration : Set where
  constructor ABELIAN_CATEGORY
  field
    category : M.Identifier
    additive : AdditiveCategoryDeclaration
    hasAllKernels : Bool
    hasAllCokernels : Bool
    monosNormalWitness : Bool
    episNormalWitness  : Bool
-- CATEGORY: Additive + all kernels/cokernels + normality of monos/epis.

-- Coimage and Image constructs
record CoimageOfMorphism : Set where
  constructor Coim
  field
    morphism : M.Identifier
    quotientObject : M.Identifier -- coker(ker(f))

record ImageOfMorphism : Set where
  constructor Im
  field
    morphism : M.Identifier
    subobjectMono : M.Identifier -- ker(coker(f))

-- First isomorphism theorem (coimage ≅ image)
record FirstIsomorphismTheoremForCategories : Set where
  constructor THEOREM_FirstIsomorphismTheoremForCategories
  field
    category : M.Identifier
    morphism : M.Identifier
    isoWitness : M.Identifier
-- CATEGORY: Coim(f) ≅ Im(f) encapsulating exactness.

-- Canonical examples: Ab, R-Mod
record AbelianCategoryExampleAb : Set where
  constructor ABELIAN_CATEGORY_Ab
  field unit : ⊤

record AbelianCategoryExampleRMod : Set where
  constructor ABELIAN_CATEGORY_RMod
  field ring : M.Identifier
               ; unit : ⊤

------------------------------------------------------------------------
-- Section 2.5 & 2.6: Exactness & additivity properties (reinforcement)
------------------------------------------------------------------------

-- Re-declared Coim/Im constructors (exactness focus)
record CoimConstructor : Set where
  constructor Coim'
  field morphism : M.Identifier; domain : M.Identifier; codomain : M.Identifier

record ImConstructor : Set where
  constructor Im'
  field morphism : M.Identifier; domain : M.Identifier; codomain : M.Identifier

-- Canonical morphism f_bar : Coim(f) -> Im(f)
record CanonicalMorphism_f_bar : Set where
  constructor f_bar
  field
    morphism : M.Identifier
    sourceCoimage : M.Identifier
    targetImage   : M.Identifier
    factorizationWitness : M.Identifier

record FirstIsomorphismForAbelianCategoriesTheorem : Set where
  constructor THEOREM_FirstIsomorphismForAbelianCategories
  field
    category : M.Identifier
    morphism : M.Identifier
    isomorphismWitness : M.Identifier
-- CATEGORY: f_bar(f) iso for all f.

-- Canonical map from coproduct to product
record CanonicalMapCoproductToProduct : Set where
  constructor canonical_map
  field
    coproductObj : M.Identifier
    productObj   : M.Identifier
    map          : M.Identifier

record AdditivityViaBiproductCoincidenceTheorem : Set where
  constructor THEOREM_AdditivityViaBiproductCoincidence
  field
    category : M.Identifier
    hasZeroObject : Bool
    hasFiniteProducts : Bool
    hasFiniteCoproducts : Bool
    comparisonMapIsIsoWitness : M.Identifier
-- CATEGORY: Additive iff comparison map iso.

------------------------------------------------------------------------
-- Section 2.7: Union of subobjects (modular lattice)
------------------------------------------------------------------------

-- Join (union) of subobjects
record UnionOfSubobjects : Set where
  constructor Join
  field
    ambientObject : M.Identifier
    subobjectDomainCoproduct : M.Identifier
    inducedMap : M.Identifier
    imageMono  : M.Identifier
-- CATEGORY: Image of universal coproduct map.

-- Meet (intersection) of subobjects
record IntersectionOfSubobjects : Set where
  constructor Meet
  field
    ambientObject : M.Identifier
    pullbackObject : M.Identifier
    limitConeWitness : M.Identifier
-- CATEGORY: Wide pullback of monomorphisms.

-- Modular lattice property
record ModularLatticeProperty : Set where
  constructor _is_MODULAR_LATTICE
  field lattice : M.Identifier; modularLawWitness : M.Identifier

record SubobjectLatticeModularityTheorem : Set where
  constructor THEOREM_SubobjectLatticeInAbelianIsModular
  field
    category : M.Identifier
    object   : M.Identifier
    modularityWitness : M.Identifier
-- CATEGORY: Sub(X) modular for all X.

------------------------------------------------------------------------
-- Section 2.8: Exact sequences (SES, splitting lemma, long exact sequences)
------------------------------------------------------------------------

-- Exactness at an object
record ExactSequenceAtProperty : Set where
  constructor _is_EXACT_AT_
  field
    sequenceId : M.Identifier
    objectAt   : M.Identifier
    imageMono  : M.Identifier
    kernelMono : M.Identifier
    comparisonIso : M.Identifier

-- Short exact sequence (SES)
record ShortExactSequenceDeclaration : Set where
  constructor SES_0→A→B→C→0
  field
    zeroObj   : M.Identifier
    A         : M.Identifier
    B         : M.Identifier
    C         : M.Identifier
    monoAB    : M.Identifier  -- A -> B
    epiBC     : M.Identifier  -- B -> C
    exactAtA  : Bool
    exactAtB  : Bool
    exactAtC  : Bool

-- Split mono / split epi properties
record HasRetractionProperty : Set where
  constructor _has_retraction
  field mono : M.Identifier; retraction : M.Identifier

record HasSectionProperty : Set where
  constructor _has_section
  field epi : M.Identifier; section : M.Identifier

-- Splitting lemma theorem
record SplittingLemmaForSESTheorem : Set where
  constructor THEOREM_SplittingLemmaForSES
  field
    sequence : ShortExactSequenceDeclaration
    hasRetractionWitness : M.Identifier
    hasSectionWitness    : M.Identifier
    biproductIsoWitness  : M.Identifier
-- CATEGORY: Conditions equivalent to splitting.

-- Long exact sequence declaration
record LongExactSequenceDeclaration : Set where
  constructor LONG_EXACT_SEQUENCE
  field
    objectsChain : List M.Identifier
    exactnessFlags : List Bool  -- positional flags for internal exactness

------------------------------------------------------------------------
-- Section 2.9 & 2.10: Diagram chasing & lemmas
------------------------------------------------------------------------

-- Proof by diagram chase technique
record ProofByDiagramChaseTechnique : Set where
  constructor PROOF_by_DIAGRAM_CHASE
  field justification : M.Identifier

-- Diagrammatic assertion (premises container)
record DiagrammaticAssertion : Set where
  constructor DIAGRAMMATIC_ASSERTION
  field
    name      : M.Identifier
    diagramId : M.Identifier
    premises  : List M.Identifier

-- Generic theorem from diagram chase
record DiagramChaseTheorem : Set where
  constructor THEOREM_from_DIAGRAM_CHASE
  field
    assertion : DiagrammaticAssertion
    conclusion : M.Identifier
    proofTechnique : ProofByDiagramChaseTechnique

-- Concrete lemmas
record FiveLemmaTheorem : Set where
  constructor THEOREM_TheFiveLemma
  field
    setup : DiagrammaticAssertion
    conclusionIso : M.Identifier
    proof : ProofByDiagramChaseTechnique

record SnakeLemmaTheorem : Set where
  constructor THEOREM_TheSnakeLemma
  field
    setup : DiagrammaticAssertion
    connectingHom : M.Identifier
    exactnessWitness : M.Identifier
    proof : ProofByDiagramChaseTechnique

record ThreeByThreeLemmaTheorem : Set where
  constructor THEOREM_The3x3Lemma
  field
    setup : DiagrammaticAssertion
    topRowSESWitness : M.Identifier
    proof : ProofByDiagramChaseTechnique

------------------------------------------------------------------------
-- Section 2.11: Exact functors (left/right/exact preservation)
------------------------------------------------------------------------

-- Left exact property (kernel preservation)
record LeftExactFunctorProperty : Set where
  constructor _is_LEFT_EXACT_in_Abelian
  field
    functor : M.Identifier; source : M.Identifier; target : M.Identifier
    preservesKernelsWitness : M.Identifier

-- Right exact property (cokernel preservation)
record RightExactFunctorProperty : Set where
  constructor _is_RIGHT_EXACT_in_Abelian
  field
    functor : M.Identifier; source : M.Identifier; target : M.Identifier
    preservesCokernelsWitness : M.Identifier

-- Exact functor property (both)
record ExactFunctorProperty : Set where
  constructor _is_EXACT_FUNCTOR_in_Abelian
  field
    functor : M.Identifier; source : M.Identifier; target : M.Identifier
    leftExactWitness  : LeftExactFunctorProperty
    rightExactWitness : RightExactFunctorProperty

-- Exactness via preservation of SES
record ExactnessViaShortExactSequencesTheorem : Set where
  constructor THEOREM_ExactnessViaShortExactSequences
  field
    functor : M.Identifier; source : M.Identifier; target : M.Identifier
    sesPreservationWitness : M.Identifier

-- Covariant Hom left exactness
record CovariantHomIsLeftExactTheorem : Set where
  constructor THEOREM_CovariantHomIsLeftExact
  field
    category : M.Identifier
    objectA  : M.Identifier
    homFunctor : M.Identifier
    kernelPreservationWitness : M.Identifier

-- Projective characterization via exact Hom
record ExactHomCharacterizesProjectivesTheorem : Set where
  constructor THEOREM_ExactHomCharacterizesProjectives
  field
    objectP : M.Identifier
    category : M.Identifier
    homFunctor : M.Identifier
    equivalenceWitness : M.Identifier

-- Injective duality inference
record InjectiveTheoryDualityInference : Set where
  constructor INFER_DUAL_THEORY_InjectiveTheoryFromHom_FROM_ProjectiveTheoryFromHom
  field
    projectiveTheoryFragment : M.Identifier
    injectiveTheoryFragment  : M.Identifier

------------------------------------------------------------------------
-- Section 2.12: Torsion theories (orthogonality & decomposition)
------------------------------------------------------------------------

-- Orthogonality T ⊥ F
record OrthogonalObjectClassesProperty : Set where
  constructor _⊥_
  field
    torsionClass     : M.Identifier
    torsionFreeClass : M.Identifier
    homOrthogonalityWitness : M.Identifier

-- (Further torsion theory constructs would continue here: decomposition sequence, etc.)
-- Torsion decomposition sequence: 0 -> tX -> X -> fX -> 0
record TorsionDecompositionSequence : Set where
  constructor TORSION_DECOMPOSITION_SEQ
  field
    category      : M.Identifier
    objectX       : M.Identifier
    torsionPart   : M.Identifier -- tX
    torsionFreePart : M.Identifier -- fX
    monoTorsionInclusion : M.Identifier -- tX -> X
    epiQuotientProjection : M.Identifier -- X -> fX
    shortExactWitness : M.Identifier -- witness of 0→tX→X→fX→0 exactness
    torsionClassId     : M.Identifier -- identifier for torsion class T
    torsionFreeClassId : M.Identifier -- identifier for torsion-free class F

-- Torsion theory declaration bundling orthogonality + universal decomposition
record TorsionTheoryDeclaration : Set where
  constructor TORSION_THEORY
  field
    category      : M.Identifier
    torsionClass  : M.Identifier
    torsionFreeClass : M.Identifier
    orthogonality : OrthogonalObjectClassesProperty
    decompositionSequences : List TorsionDecompositionSequence
    closureQuotientsWitness : M.Identifier  -- T closed under quotients
    closureSubobjectsWitness : M.Identifier -- F closed under subobjects
    reflectiveWitness  : M.Identifier       -- T coreflective / left adjoint inclusion
    coreflectiveWitness : M.Identifier      -- F reflective / right adjoint inclusion

------------------------------------------------------------------------
-- Bridge postulates placeholder (integration with unified proof layer pending)
------------------------------------------------------------------------

postulate
  -- Placeholder examples (to be refined when proof layer extended for Chapter 2)
  zeroObjectBridge
    : (prop : HasZeroObjectProperty)
    -> C.Proof (C.ZeroObjectS (HasZeroObjectProperty.category prop)
                               (HasZeroObjectProperty.zeroObj prop)) C.ZeroObjectPropertyName

  kernelAsEqualizerBridge
    : (def : KernelAsEqualizerDefinition)
    -> C.Proof (C.KernelEqualizerS (KernelAsEqualizerDefinition.morphism def)
                                   (KernelAsEqualizerDefinition.domain def)) C.KernelAsEqualizerName

  cokernelAsCoequalizerBridge
    : (inf : CokernelAsCoequalizerInference)
    -> C.Proof (C.CokernelCoequalizerS (KernelAsEqualizerDefinition.morphism (CokernelAsCoequalizerInference.originalKernelDef inf))
                                       (KernelAsEqualizerDefinition.domain (CokernelAsCoequalizerInference.originalKernelDef inf))) C.CokernelAsCoequalizerName

  additiveCategoryBridge
    : (decl : AdditiveCategoryDeclaration)
    -> C.Proof (C.AdditiveCategoryS (AdditiveCategoryDeclaration.category decl)) C.AdditiveCategoryName

  abelianCategoryBridge
    : (decl : AbelianCategoryDeclaration)
    -> C.Proof (C.AbelianCategoryS (AbelianCategoryDeclaration.category decl)) C.AbelianCategoryName

  biproductComparisonBridge
    : (thm : AdditivityEquivalenceTheorem)
    -> C.Proof (C.BiproductComparisonS (AdditivityEquivalenceTheorem.category thm)) C.AdditivityViaBiproductMapIsoName

  coimageImageIsoBridge
    : (thm : FirstIsomorphismTheoremForCategories)
    -> C.Proof (C.CoimageImageIsoS (FirstIsomorphismTheoremForCategories.morphism thm)
                                    (FirstIsomorphismTheoremForCategories.category thm)) C.CoimageImageIsomorphismName

  shortExactSequenceBridge
    : (ses : ShortExactSequenceDeclaration)
    -> C.Proof (C.ShortExactSequenceS (ShortExactSequenceDeclaration.B ses)) C.ShortExactSequenceExactnessName

  splittingLemmaBridge
    : (thm : SplittingLemmaForSESTheorem)
    -> C.Proof (C.SplittingLemmaS (ShortExactSequenceDeclaration.B (SplittingLemmaForSESTheorem.sequence thm))) C.SplittingLemmaName

  leftExactFunctorBridge
    : (prop : LeftExactFunctorProperty)
    -> C.Proof (C.FunctorExactnessS (LeftExactFunctorProperty.functor prop)
                                    (LeftExactFunctorProperty.source prop)
                                    (LeftExactFunctorProperty.target prop)) C.LeftExactFunctorName

  rightExactFunctorBridge
    : (prop : RightExactFunctorProperty)
    -> C.Proof (C.FunctorExactnessS (RightExactFunctorProperty.functor prop)
                                    (RightExactFunctorProperty.source prop)
                                    (RightExactFunctorProperty.target prop)) C.RightExactFunctorName

  exactFunctorBridge
    : (prop : ExactFunctorProperty)
    -> C.Proof (C.FunctorExactnessS (ExactFunctorProperty.functor prop)
                                    (ExactFunctorProperty.source prop)
                                    (ExactFunctorProperty.target prop)) C.ExactFunctorName

  covariantHomLeftExactBridge
    : (thm : CovariantHomIsLeftExactTheorem)
    -> C.Proof (C.FunctorExactnessS (CovariantHomIsLeftExactTheorem.homFunctor thm)
                                    (CovariantHomIsLeftExactTheorem.category thm)
                                    (CovariantHomIsLeftExactTheorem.category thm)) C.CovariantHomLeftExactName

  exactHomProjectiveCharBridge
    : (thm : ExactHomCharacterizesProjectivesTheorem)
    -> C.Proof (C.FunctorExactnessS (ExactHomCharacterizesProjectivesTheorem.homFunctor thm)
                                    (ExactHomCharacterizesProjectivesTheorem.category thm)
                                    (ExactHomCharacterizesProjectivesTheorem.category thm)) C.ExactHomProjectiveCharacterizationName

  subobjectLatticeModularBridge
    : (thm : SubobjectLatticeModularityTheorem)
    -> C.Proof (C.SubobjectLatticeS (SubobjectLatticeModularityTheorem.category thm)
                                     (SubobjectLatticeModularityTheorem.object thm)) C.SubobjectLatticeModularName

  fiveLemmaBridge
    : (thm : FiveLemmaTheorem)
    -> C.Proof (C.DiagramLemmaS (FiveLemmaTheorem.setup thm .DiagrammaticAssertion.name)) C.FiveLemmaName

  snakeLemmaBridge
    : (thm : SnakeLemmaTheorem)
    -> C.Proof (C.DiagramLemmaS (SnakeLemmaTheorem.setup thm .DiagrammaticAssertion.name)) C.SnakeLemmaName

  threeByThreeLemmaBridge
    : (thm : ThreeByThreeLemmaTheorem)
    -> C.Proof (C.DiagramLemmaS (ThreeByThreeLemmaTheorem.setup thm .DiagrammaticAssertion.name)) C.ThreeByThreeLemmaName
  
  torsionDecompositionBridge
    : (seq : TorsionDecompositionSequence)
    -> C.Proof (C.TorsionDecompositionS (TorsionDecompositionSequence.objectX seq)
                                        (TorsionDecompositionSequence.torsionPart seq)
                                        (TorsionDecompositionSequence.torsionFreePart seq)
                                        (TorsionDecompositionSequence.category seq)) C.TorsionDecompositionName
  
  torsionClassClosureQuotientsBridge
    : (decl : TorsionTheoryDeclaration)
    -> C.Proof (C.TorsionClassClosureQuotientsS (TorsionTheoryDeclaration.torsionClass decl)
                                               (TorsionTheoryDeclaration.category decl)) C.TorsionClassClosedUnderQuotientsName

  torsionFreeClosureSubobjectsBridge
    : (decl : TorsionTheoryDeclaration)
    -> C.Proof (C.TorsionFreeClosureSubobjectsS (TorsionTheoryDeclaration.torsionFreeClass decl)
                                               (TorsionTheoryDeclaration.category decl)) C.TorsionFreeClosedUnderSubobjectsName

  torsionReflectiveBridge
    : (decl : TorsionTheoryDeclaration)
    -> C.Proof (C.TorsionReflectiveS (TorsionTheoryDeclaration.torsionClass decl)
                                     (TorsionTheoryDeclaration.category decl)) C.TorsionReflectiveName

  torsionFreeCoreflectiveBridge
    : (decl : TorsionTheoryDeclaration)
    -> C.Proof (C.TorsionFreeCoreflectiveS (TorsionTheoryDeclaration.torsionFreeClass decl)
                                          (TorsionTheoryDeclaration.category decl)) C.TorsionFreeCoreflectiveName

  torsionTheoryAxiomsBridge
    : (decl : TorsionTheoryDeclaration)
    -> C.Proof (C.TorsionTheoryS (TorsionTheoryDeclaration.torsionClass decl)
                                 (TorsionTheoryDeclaration.torsionFreeClass decl)
                                 (TorsionTheoryDeclaration.category decl)) C.TorsionTheoryAxiomsName

------------------------------------------------------------------------
-- End of structural encoding for 2/1.ebnf (Abelian categories & related concepts)
------------------------------------------------------------------------
module Level2_2 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Placeholder for more structured expressions
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Section 2.1 & 2.2: Regular Categories (Finite limits, regular epis, stability)
------------------------------------------------------------------------

-- Property: C has FINITE_LIMITS
record FiniteLimitsProperty : Set where
  constructor _has_FINITE_LIMITS
  field
    category : M.Identifier
    hasTerminalWitness : M.Identifier
    hasPullbacksWitness : M.Identifier
-- CATEGORY: Terminal object + all pullbacks.

-- Morphism property: e is REGULAR_EPIMORPHISM
record RegularEpimorphismProperty : Set where
  constructor _is_REGULAR_EPIMORPHISM
  field
    morphism : M.Identifier
    domain   : M.Identifier
    codomain : M.Identifier
    presentingPairSource : M.Identifier -- X in (f,g : X -> domain)
    parallelPair_f : M.Identifier       -- f : X -> A
    parallelPair_g : M.Identifier       -- g : X -> A
    coequalizerWitness : M.Identifier   -- coequalizer(f,g) ≅ morphism
-- CATEGORY: Arises as a coequalizer of a parallel pair.

-- Class stability under pullback: E is STABLE_UNDER_PULLBACK
record StabilityUnderPullbackProperty : Set where
  constructor _is_STABLE_UNDER_PULLBACK
  field
    classId : M.Identifier            -- identifier for class E
    pullbackClosureWitness : M.Identifier -- proof that all pullbacks stay in E
-- CATEGORY: Pullback of a member remains in the class.

-- Regular category declaration
record RegularCategoryDeclaration : Set where
  constructor REGULAR_CATEGORY
  field
    category : M.Identifier
    finiteLimits : FiniteLimitsProperty
    regularEpiMonoFactorizationWitness : M.Identifier -- FACTORIZATION_SYSTEM(RegularEpi, Mono)
    regularEpiStability : StabilityUnderPullbackProperty
-- CATEGORY: Finite limits + (RegEpi, Mono) factorization + stability.

-- Theorem: RegularEpisAreStrong
record RegularEpisAreStrongTheorem : Set where
  constructor THEOREM_RegularEpisAreStrong
  field
    category : M.Identifier
    epi      : RegularEpimorphismProperty
    strongEpiWitness : M.Identifier
-- CATEGORY: Regular epi implies strong epi.

------------------------------------------------------------------------
-- Section 2.3 & 2.5: Kernel pairs, internal equivalence relations, effectiveness
------------------------------------------------------------------------

-- Kernel pair of f
record KernelPairDeclaration : Set where
  constructor KernelPair_of
  field
    morphism : M.Identifier -- f : A -> B
    objectK  : M.Identifier -- K
    projection1 : M.Identifier -- k1 : K -> A
    projection2 : M.Identifier -- k2 : K -> A
    pullbackSquareWitness : M.Identifier
-- CATEGORY: Pullback(f,f) with projections.

-- Internal equivalence relation on A given (r1,r2)
record InternalEquivalenceRelationDeclaration : Set where
  constructor INTERNAL_EQUIV_RELATION_on
  field
    objectR : M.Identifier
    objectA : M.Identifier
    relLeft : M.Identifier -- r1:R->A
    relRight : M.Identifier -- r2:R->A
    monoIntoProductWitness : M.Identifier -- <r1,r2> mono
    reflexivityWitness  : M.Identifier
    symmetryWitness     : M.Identifier
    transitivityWitness : M.Identifier
-- CATEGORY: Encodes internal reflexive, symmetric, transitive relation.

-- Regular exact sequence K --(k1,k2)--> A --q--> Q
record RegularExactSequenceDeclaration : Set where
  constructor REGULAR_EXACT_SEQUENCE
  field
    kernelPair : KernelPairDeclaration
    quotient   : RegularEpimorphismProperty -- q : A -> Q (regular epi)
    compatibilityWitness : M.Identifier -- kernelPair ≅ KernelPair(q)
-- CATEGORY: Fundamental unit of exactness in regular setting.

-- Theorem: KernelPairIsEquivalenceRelation
record KernelPairIsEquivalenceRelationTheorem : Set where
  constructor THEOREM_KernelPairIsEquivalenceRelation
  field
    category : M.Identifier
    kernelPair : KernelPairDeclaration
    equivalenceRelationWitness : InternalEquivalenceRelationDeclaration
-- CATEGORY: Kernel pair always forms an internal equivalence relation.

-- Theorem: RegularCategoriesHaveEffectiveRelations
record RegularCategoriesHaveEffectiveRelationsTheorem : Set where
  constructor THEOREM_RegularCategoriesHaveEffectiveRelations
  field
    category : M.Identifier
    isRegular : RegularCategoryDeclaration
    effectivenessWitness : M.Identifier -- ∀R, relation effective
    equivalenceStatementWitness : M.Identifier -- (P1 <==> P2)
-- CATEGORY: Every internal equivalence relation is effective.

-- Exact category: Regular + effective equivalence relations
record ExactCategoryDeclaration : Set where
  constructor EXACT_CATEGORY
  field
    category : M.Identifier
    regular : RegularCategoryDeclaration
    effectiveRelationsTheorem : RegularCategoriesHaveEffectiveRelationsTheorem
-- CATEGORY: Regular category where all internal equivalence relations are effective.

------------------------------------------------------------------------
-- Section 2.6: Barr-exact categories
------------------------------------------------------------------------

-- Class closure under composition: E is CLOSED_UNDER_COMPOSITION
record ClosedUnderCompositionProperty : Set where
  constructor _is_CLOSED_UNDER_COMPOSITION
  field
    classId : M.Identifier
    compositionClosureWitness : M.Identifier
-- CATEGORY: Quotients compose.

-- Barr-exact category declaration
record BarrExactCategoryDeclaration : Set where
  constructor BARR_EXACT_CATEGORY
  field
    category : M.Identifier
    regular   : RegularCategoryDeclaration
    regularEpiCompositionClosure : ClosedUnderCompositionProperty
-- CATEGORY: Regular + regular epis closed under composition.

-- Barr-exact functor F is BARR_EXACT_FUNCTOR
record BarrExactFunctorDeclaration : Set where
  constructor _is_BARR_EXACT_FUNCTOR
  field
    functorId : M.Identifier
    sourceCat : M.Identifier
    targetCat : M.Identifier
    preservesFiniteLimitsWitness : M.Identifier
    preservesRegularEpisWitness  : M.Identifier
-- CATEGORY: Preserves finite limits and regular epis.

------------------------------------------------------------------------
-- Section 2.7: Barr's Embedding Theorem
------------------------------------------------------------------------

-- BarrEmbedding theorem statement
record BarrEmbeddingTheoremDeclaration : Set where
  constructor THEOREM_BarrEmbedding
  field
    category : M.Identifier
    smallWitness : M.Identifier
    targetIndexCategory : M.Identifier -- K
    embeddingFunctor : M.Identifier    -- F : C -> Psh(K)
    fullyFaithfulWitness : M.Identifier
    exactFunctorWitness : M.Identifier -- F is Barr-exact functor
-- CATEGORY: Existence of full faithful exact embedding.

-- Element-like reasoning justification axiom
record ElementLikeReasoningJustificationAxiom : Set where
  constructor JUSTIFICATION_AXIOM_GeneralizedElementReasoning_is_SOUND_in_ExactCats
  field
    barrEmbeddingTheoremWitness : BarrEmbeddingTheoremDeclaration
    soundnessPropositionWitness : M.Identifier
-- CATEGORY: Embedding justifies element-based reasoning.

------------------------------------------------------------------------
-- Bridge postulates (placeholders; proof layer extension for regular/exact to follow)
------------------------------------------------------------------------

postulate
  regularCategoryBridge
    : (decl : RegularCategoryDeclaration)
    -> C.Proof (C.RegularCategoryS (RegularCategoryDeclaration.category decl)) C.RegularCategoryName

  barrExactCategoryBridge
    : (decl : BarrExactCategoryDeclaration)
    -> C.Proof (C.BarrExactCategoryS (BarrExactCategoryDeclaration.category decl)) C.BarrExactCategoryName

  regularEpisAreStrongBridge
    : (thm : RegularEpisAreStrongTheorem)
    -> C.Proof (C.RegularEpisAreStrongS (RegularEpisAreStrongTheorem.category thm) (RegularEpimorphismProperty.morphism (RegularEpisAreStrongTheorem.epi thm))) C.RegularEpisAreStrongName

  kernelPairEquivRelBridge
    : (thm : KernelPairIsEquivalenceRelationTheorem)
    -> C.Proof
         (C.KernelPairEquivRelS (KernelPairIsEquivalenceRelationTheorem.category thm)
                                (KernelPairDeclaration.morphism (KernelPairIsEquivalenceRelationTheorem.kernelPair thm))
                                (KernelPairDeclaration.objectK (KernelPairIsEquivalenceRelationTheorem.kernelPair thm))
                                (KernelPairDeclaration.projection1 (KernelPairIsEquivalenceRelationTheorem.kernelPair thm))
                                (KernelPairDeclaration.projection2 (KernelPairIsEquivalenceRelationTheorem.kernelPair thm)))
         C.KernelPairEquivRelName

  effectiveRelationsBridge
    : (thm : RegularCategoriesHaveEffectiveRelationsTheorem)
    -> C.Proof (C.EffectiveRelationsS (RegularCategoriesHaveEffectiveRelationsTheorem.category thm)) C.EffectiveRelationsName

  exactCategoryBridge
    : (decl : ExactCategoryDeclaration)
    -> C.Proof (C.ExactCategoryS (ExactCategoryDeclaration.category decl)) C.ExactCategoryName

  barrExactFunctorPreservesFiniteLimitsBridge
    : (decl : BarrExactFunctorDeclaration)
    -> C.Proof (C.PreservesFiniteLimitsS (BarrExactFunctorDeclaration.functorId decl)
                                         (BarrExactFunctorDeclaration.sourceCat decl)
                                         (BarrExactFunctorDeclaration.targetCat decl))
               C.PreservesFiniteLimitsName

  barrExactFunctorPreservesRegularEpisBridge
    : (decl : BarrExactFunctorDeclaration)
    -> C.Proof (C.PreservesRegularEpisS (BarrExactFunctorDeclaration.functorId decl)
                                        (BarrExactFunctorDeclaration.sourceCat decl)
                                        (BarrExactFunctorDeclaration.targetCat decl))
               C.PreservesRegularEpisName

  barrEmbeddingBridge
    : (thm : BarrEmbeddingTheoremDeclaration)
    -> C.Proof (C.BarrEmbeddingS (BarrEmbeddingTheoremDeclaration.category thm)
                                 (BarrEmbeddingTheoremDeclaration.targetIndexCategory thm)
                                 (BarrEmbeddingTheoremDeclaration.embeddingFunctor thm))
              C.BarrEmbeddingTheoremName

------------------------------------------------------------------------
-- End of structural encoding for 2/2.ebnf (Regular & Barr-exact categories)
------------------------------------------------------------------------
module Level2_3 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C
open import PropertyRegistry as P

-- Lightweight expression placeholder (for textual equations / witnesses)
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Section 3.1: The calculus of relations (in a regular category)
------------------------------------------------------------------------

-- A relation R ⊆ A × B represented by a mono m_R : R_obj → A×B
record RelationDeclaration : Set where
  constructor RELATION_from_to
  field
    category         : M.Identifier
    A                : M.Identifier
    B                : M.Identifier
    relation         : M.Identifier         -- name/id for the relation R
    relationObject   : M.Identifier         -- R_obj
    monoToProduct    : M.Identifier         -- m_R : R_obj → A×B
-- CATEGORY: Subobject of A×B in a regular category.

-- Composition R∘S via pullback then image
record RelationComposition : Set where
  constructor _∘_
  field
    S                  : RelationDeclaration -- S : A ⇸ B
    R                  : RelationDeclaration -- R : B ⇸ C
    pullbackObject     : M.Identifier        -- P_obj
    map_to_A           : M.Identifier        -- P_obj → A
    map_to_C           : M.Identifier        -- P_obj → C
    composite_map      : M.Identifier        -- P_obj → A×C
    imageMono          : M.Identifier        -- mono representing Image(composite_map)
-- CATEGORY: Pullback-then-image construction of relational composition.

-- Opposite (converse) relation R^op : B ⇸ A
record OppositeRelation : Set where
  constructor _^op
  field
    original          : RelationDeclaration
    swapIsomorphism   : M.Identifier   -- τ : A×B → B×A
    oppositeObject    : M.Identifier   -- R^op_obj
    oppositeMono      : M.Identifier   -- mono for Image(τ ∘ m_R)
-- CATEGORY: Swap the components via τ and take image.

-- Identity relation on A from the diagonal Δ : A → A×A
record IdentityRelation : Set where
  constructor Id_Rel
  field
    category : M.Identifier
    A        : M.Identifier
    diagonal : M.Identifier -- Δ : A → A×A (mono)
-- CATEGORY: Identity for relational composition.

-- The category Rel(C): same objects as C; morphisms are relations
record CategoryOfRelations : Set where
  constructor Rel
  field
    baseCategory    : M.Identifier   -- C (assumed regular)
    relCategory     : M.Identifier   -- Rel(C)
    compositionOp   : M.Identifier   -- reference to RelationComposition
    identityFamily  : M.Identifier   -- reference to Id_Rel constructor family
-- CATEGORY: Category whose morphisms are subobjects of products.

------------------------------------------------------------------------
-- Sections 3.2–3.4: Lawvere theories, models, and categories of models
------------------------------------------------------------------------

-- Lawvere theory: category with finite products; every object ≅ X^n
record LawvereTheoryDeclaration : Set where
  constructor LAWVERE_THEORY_with_base_object
  field
    theoryCategory          : M.Identifier -- T
    baseObject              : M.Identifier -- X in T
    finiteProductsWitness   : M.Identifier
    arityDecompositionProof : M.Identifier -- ∀Obj ≅ X^n
-- CATEGORY: Syntactic category encoding operations by morphisms.

-- Operation in a Lawvere theory: X^n → X^m
record OperationInTheory : Set where
  constructor OPERATION_:
  field
    name        : M.Identifier
    theory      : LawvereTheoryDeclaration
    arity_n     : String
    arity_m     : String
    morphismId  : M.Identifier -- the morphism in T
-- CATEGORY: Tuple of n-ary operations (m outputs) as a morphism in T.

-- Axiom in a Lawvere theory: a commuting diagram (f == g)
record AxiomInTheory : Set where
  constructor AXIOM_Diagram_COMMUTES
  field
    theory   : LawvereTheoryDeclaration
    name     : String
    diagram  : M.Identifier  -- identifies the diagram
    lhs      : M.Identifier  -- f
    rhs      : M.Identifier  -- g
-- CATEGORY: Equational law encoded diagrammatically.

-- Model: product-preserving functor T → C
record ModelOfTheory : Set where
  constructor MODEL_of_in
  field
    theory    : LawvereTheoryDeclaration
    targetCat : M.Identifier -- C (with finite products)
    functorId : M.Identifier -- M : T → C
    preservesProductsWitness : M.Identifier
-- CATEGORY: Semantic interpretation of T in C.

-- Category of models Mod(T, C)
record CategoryOfModels : Set where
  constructor Mod_of_in
  field
    theory         : LawvereTheoryDeclaration
    targetCat      : M.Identifier
    modelsCategory : M.Identifier -- Mod(T,C)
-- CATEGORY: Objects are models, morphisms are natural transformations.

------------------------------------------------------------------------
-- Sections 3.5–3.7: Properties of algebraic categories
------------------------------------------------------------------------

-- Declaration that a category is algebraic (equivalent to Mod(T,Set))
record AlgebraicCategoryDeclaration : Set where
  constructor _is_ALGEBRAIC_CATEGORY
  field
    category     : M.Identifier
    witnessTheory : LawvereTheoryDeclaration
    equivalenceWitness : M.Identifier -- category ≅ Mod(T,Set)

-- Theorem: Every algebraic category is complete and cocomplete
record AlgebraicCategoriesAreCompleteAndCocompleteTheorem : Set where
  constructor THEOREM_AlgebraicCategoriesAreCompleteAndCocomplete
  field
    category          : AlgebraicCategoryDeclaration
    completeWitness   : M.Identifier
    cocompleteWitness : M.Identifier

-- Theorem: Every algebraic category is regular
record AlgebraicCategoriesAreRegularTheorem : Set where
  constructor THEOREM_AlgebraicCategoriesAreRegular
  field
    category      : AlgebraicCategoryDeclaration
    regularWitness : M.Identifier

-- Forgetful functor U : C → Set for an algebraic category C
record ForgetfulFunctor_Algebraic : Set where
  constructor U_:
  field
    C          : AlgebraicCategoryDeclaration
    functorId  : M.Identifier -- U_C

-- Free functor F : Set → C for an algebraic category C
record FreeFunctor_Algebraic : Set where
  constructor F_to_
  field
    C          : AlgebraicCategoryDeclaration
    functorId  : M.Identifier -- F

-- Theorem: Free-forgetful adjunction (F ⊣ U)
record ExistenceOfFreeFunctorAdjunctionTheorem : Set where
  constructor THEOREM_ExistenceOfFreeFunctorAdjunction
  field
    C                  : AlgebraicCategoryDeclaration
    freeFunctor        : FreeFunctor_Algebraic
    forgetfulFunctor   : ForgetfulFunctor_Algebraic
    adjunctionWitness  : M.Identifier -- F ⊣ U

-- Lattice-theoretic: element c is compact in a complete lattice L
record CompactElementProperty : Set where
  constructor _is_COMPACT_IN_
  field
    element : M.Identifier
    lattice : M.Identifier
    compactnessWitness : M.Identifier

-- Lattice property: L is an algebraic lattice
record AlgebraicLatticeProperty : Set where
  constructor _is_ALGEBRAIC_LATTICE
  field
    lattice : M.Identifier
    algebraicWitness : M.Identifier

-- Theorem: Sub(X) is algebraic in any algebraic category C
record SubobjectLatticesInAlgebraicCategoriesAreAlgebraicTheorem : Set where
  constructor THEOREM_SubobjectLatticesInAlgebraicCategoriesAreAlgebraic
  field
    C                 : AlgebraicCategoryDeclaration
    objectX           : M.Identifier
    subobjectLattice  : M.Identifier -- Sub(X)
    algebraicWitness  : M.Identifier

------------------------------------------------------------------------
-- Section 3.8: Algebraic functors and characterization
------------------------------------------------------------------------

-- Forgetful functor of an algebraic category (notation U_C)
record ForgetfulFunctorOfAlgebraic : Set where
  constructor U_of_
  field
    C         : AlgebraicCategoryDeclaration
    functorId : M.Identifier -- U_C : C → Set

-- Algebraic functor F : C → D commuting with forgetfuls up to iso
record AlgebraicFunctorDeclaration : Set where
  constructor _is_ALGEBRAIC_FUNCTOR
  field
    F                : M.Identifier
    source           : AlgebraicCategoryDeclaration
    target           : AlgebraicCategoryDeclaration
    commutingIso     : M.Identifier -- α : U_D ∘ F ⇒ U_C

-- Product-preserving morphism of theories φ : T1 → T2
record LawvereTheoryMorphism : Set where
  constructor THEORY_MORPHISM_:
  field
    phiId                  : M.Identifier
    sourceTheory           : LawvereTheoryDeclaration
    targetTheory           : LawvereTheoryDeclaration
    preservesProductsProof : M.Identifier

-- Induced functor on models Mod(φ) : Mod(T2,Set) → Mod(T1,Set)
record InducedFunctorOnModels : Set where
  constructor Mod_of
  field
    phi           : LawvereTheoryMorphism
    inducedFunctor : M.Identifier

-- Characterization theorem: algebraic functors arise from theory morphisms
record CharacterizationOfAlgebraicFunctorsTheorem : Set where
  constructor THEOREM_CharacterizationOfAlgebraicFunctors
  field
    F                      : AlgebraicFunctorDeclaration
    underlyingPhi          : LawvereTheoryMorphism
    naturalIsoWitness      : M.Identifier -- F ≅ Mod(φ)

------------------------------------------------------------------------
-- Section 3.11: Commutative theories (interchange law) and consequences
------------------------------------------------------------------------

-- Interchange axiom for two operations in a theory
record CommutativityAxiom : Set where
  constructor AXIOM_Interchange_for_
  field
    theory : LawvereTheoryDeclaration
    fOp    : M.Identifier -- f : X^n → X
    gOp    : M.Identifier -- g : X^m → X
    interchangeWitness : M.Identifier -- Path1 == Path2

-- Commutative Lawvere theory: every pair of ops satisfies interchange
record CommutativeLawvereTheory : Set where
  constructor COMMUTATIVE_
  field
    theory                 : LawvereTheoryDeclaration
    globalInterchangeProof : M.Identifier

-- Theorem: Mod(T,Set) is symmetric monoidal when T is commutative
record CommutativeTheoriesYieldMonoidalCategoriesTheorem : Set where
  constructor THEOREM_CommutativeTheoriesYieldMonoidalCategories
  field
    T                      : CommutativeLawvereTheory
    modelsCategory         : M.Identifier -- Mod(T,Set)
    monoidalStructureProof : M.Identifier -- Mod(T,Set) symmetric monoidal

-- Instances
record TheoryOfRModulesIsCommutativeInstance : Set where
  constructor INSTANCE_TheoryOfRModulesIsCommutative
  field
    theoryRMod : LawvereTheoryDeclaration
    proof      : M.Identifier

record TheoryOfGroupsIsNotCommutativeInstance : Set where
  constructor INSTANCE_TheoryOfGroupsIsNotCommutative
  field
    theoryGrp : LawvereTheoryDeclaration
    equivalenceWitness : M.Identifier -- (commutative iff models abelian)

------------------------------------------------------------------------
-- Section 3.12: Tensor product of theories and bialgebras
------------------------------------------------------------------------

-- (T₁,T₂)-bialgebra in Set
record BialgebraDeclaration : Set where
  constructor _is_T1_T2_Bialgebra
  field
    T1        : LawvereTheoryDeclaration
    T2        : LawvereTheoryDeclaration
    carrier   : M.Identifier -- set S
    model1    : M.Identifier -- M₁ : T₁ → Set with carrier S
    model2    : M.Identifier -- M₂ : T₂ → Set with carrier S
    compatibilityWitness : M.Identifier -- interchange for all (op1,op2)

-- Category of bialgebras Bialg(T1,T2)
record CategoryOfBialgebras : Set where
  constructor Bialg_of_
  field
    T1        : LawvereTheoryDeclaration
    T2        : LawvereTheoryDeclaration
    category  : M.Identifier -- Bialg(T1,T2)

-- Tensor product of theories T1 ⊗ T2
record TensorProductOfTheories : Set where
  constructor _⊗_
  field
    T1                  : LawvereTheoryDeclaration
    T2                  : LawvereTheoryDeclaration
    tensorTheory        : M.Identifier -- T1 ⊗ T2
    constructionWitness : M.Identifier -- ops/axioms + interchange

-- Theorem: Mod(T1 ⊗ T2, Set) ≅ Bialg(T1,T2)
record TensorProductModelsAreBialgebrasTheorem : Set where
  constructor THEOREM_TensorProductModelsAreBialgebras
  field
    T1        : LawvereTheoryDeclaration
    T2        : LawvereTheoryDeclaration
    equivalenceWitness : M.Identifier -- equivalence of categories

-- Concrete instance: Rings as tensor of Monoids and AbGroups
record TheoryOfRingsAsTensorProductInstance : Set where
  constructor INSTANCE_TheoryOfRingsAsTensorProduct
  field
    T_Mon     : LawvereTheoryDeclaration
    T_Ab      : LawvereTheoryDeclaration
    T_RingIso : M.Identifier            -- TheoryOfRings ≅ T_Mon ⊗ T_Ab
    categoryEquivWitness : M.Identifier -- Mod ≅ Bialg

------------------------------------------------------------------------
-- Section 3.13: Morita equivalence
------------------------------------------------------------------------

-- Morita equivalence of theories (semantic equivalence of model cats)
record MoritaEquivalence : Set where
  constructor _is_MORITA_EQUIVALENT_TO_
  field
    T1 : LawvereTheoryDeclaration
    T2 : LawvereTheoryDeclaration
    equivalenceWitness : M.Identifier -- Mod(T1,Set) ≅ Mod(T2,Set)

-- Progenerator module over a ring R (in R-Mod)
record ProgeneratorModule : Set where
  constructor _is_PROGENERATOR_MODULE_over_
  field
    ringCategory : M.Identifier  -- R-Mod
    moduleP      : M.Identifier
    finitelyGeneratedWitness : M.Identifier
    projectiveWitness        : M.Identifier
    generatorWitness         : M.Identifier

-- Functors built from a bimodule P: - ⊗_R P and Hom_S(P,-)
record MoritaEquivalenceFunctor_Tensor : Set where
  constructor _⊗_R_
  field
    R        : M.Identifier
    P        : M.Identifier -- (S,R)-bimodule identifier
    functor  : M.Identifier -- - ⊗_R P : R-Mod → S-Mod

record MoritaEquivalenceFunctor_Hom : Set where
  constructor Hom__
  field
    S        : M.Identifier
    P        : M.Identifier -- (S,R)-bimodule identifier
    functor  : M.Identifier -- Hom_S(P,-) : S-Mod → R-Mod

-- Morita theorem for rings
record MoritaTheoremForRings : Set where
  constructor THEOREM_MoritaTheoremForRings
  field
    R                : M.Identifier
    S                : M.Identifier
    progenerator     : ProgeneratorModule
    endomorphismRingIso : M.Identifier -- End_R(P) ≅ S
    equivalenceWitness   : M.Identifier -- R-Mod ≃ S-Mod

-- Canonical instance: R ≃ Mₙ(R)
record MoritaEquivalenceOfMatrixRingsInstance : Set where
  constructor INSTANCE_MoritaEquivalenceOfMatrixRings
  field
    R                : M.Identifier
    n                : String
    matrixRing       : M.Identifier -- Mₙ(R)
    progenerator     : ProgeneratorModule
    endoRingIso      : M.Identifier -- End(Rⁿ) ≅ Mₙ(R)
    equivalenceProof : M.Identifier -- module category equivalence

------------------------------------------------------------------------
-- Bridge postulates placeholder (integration with unified proof layer)
------------------------------------------------------------------------

-- Note: This section intentionally refrains from introducing new Level 1
-- subjects/axiom names. When desirable, specific results from this file can
-- be bridged into the generic property scaffolding (e.g., CategoryHasPropertyS)
-- with stable identifiers added to PropertyRegistry, following the established
-- canonicalization pattern.

------------------------------------------------------------------------
-- Section 3.10: Beck's Characterization (internal recognition of algebraic)
------------------------------------------------------------------------

-- Object-level property: an object P is regular projective
record RegularProjectiveObjectProperty : Set where
  constructor _is_REGULAR_PROJECTIVE
  field
    category : M.Identifier
    objectP  : M.Identifier
    liftingSurjectivityWitness : M.Identifier -- surjectivity of Hom(P, -) along reg epis

-- Coproduct_over(I) of G
record CoproductOfGenerator : Set where
  constructor Coproduct_over_of
  field
    category : M.Identifier
    indexSet : M.Identifier
    generator : M.Identifier
    coproductObject : M.Identifier

-- Category property: C is REGULARLY_COVERED_BY G
record RegularlyCoveredByGeneratorProperty : Set where
  constructor _is_REGULARLY_COVERED_BY_
  field
    category  : M.Identifier
    generator : M.Identifier
    coveringWitness : M.Identifier -- every X receives a reg epi from a coproduct of G

-- Beck characterization theorem
record BeckCharacterizationOfAlgebraicCategoriesTheorem : Set where
  constructor THEOREM_BeckCharacterizationOfAlgebraicCategories
  field
    category           : M.Identifier
    cocompleteWitness  : M.Identifier
    generator          : M.Identifier
    generatorIsRegularProjective : RegularProjectiveObjectProperty
    generatorIsGeneratorWitness  : M.Identifier -- G is GENERATOR
    regularlyCoveredByG : RegularlyCoveredByGeneratorProperty
    equivalenceWitness  : M.Identifier -- ALGEBRAIC_CATEGORY <==> (conditions)

postulate
  -- Algebraic category as a generic property
  algebraicCategoryBridge
    : (decl : AlgebraicCategoryDeclaration)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicCategoryDeclaration.category decl)
                                       P.AlgebraicCategoryId)
               C.HasPropertyName

  -- Algebraic categories are complete and cocomplete
  algebraicIsCompleteBridge
    : (thm : AlgebraicCategoriesAreCompleteAndCocompleteTheorem)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicCategoryDeclaration.category
                                         (AlgebraicCategoriesAreCompleteAndCocompleteTheorem.category thm))
                                       P.CompleteCategoryId)
               C.HasPropertyName

  algebraicIsCocompleteBridge
    : (thm : AlgebraicCategoriesAreCompleteAndCocompleteTheorem)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicCategoryDeclaration.category
                                         (AlgebraicCategoriesAreCompleteAndCocompleteTheorem.category thm))
                                       P.CocompleteCategoryId)
               C.HasPropertyName

  -- Algebraic categories are regular
  algebraicIsRegularBridge
    : (thm : AlgebraicCategoriesAreRegularTheorem)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicCategoryDeclaration.category
                                         (AlgebraicCategoriesAreRegularTheorem.category thm))
                                       P.RegularCategoryId)
               C.HasPropertyName

  -- Models of commutative theories are symmetric monoidal
  modelsOfCommutativeTheoryAreSymmetricMonoidalBridge
    : (thm : CommutativeTheoriesYieldMonoidalCategoriesTheorem)
    -> C.Proof (C.CategoryHasPropertyS (CommutativeTheoriesYieldMonoidalCategoriesTheorem.modelsCategory thm)
                                       P.SymmetricMonoidalCategoryId)
               C.HasPropertyName

  -- Existence of free-forgetful adjunction in an algebraic category
  freeForgetfulAdjunctionBridge
    : (thm : ExistenceOfFreeFunctorAdjunctionTheorem)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicCategoryDeclaration.category (ExistenceOfFreeFunctorAdjunctionTheorem.C thm))
                                      P.HasFreeForgetfulAdjunctionId)
               C.HasPropertyName

  -- Algebraic lattice properties (generic, can be applied to Sub(X))
  algebraicLatticeBridge
    : (prop : AlgebraicLatticeProperty)
    -> C.Proof (C.CategoryHasPropertyS (AlgebraicLatticeProperty.lattice prop)
                                      P.AlgebraicLatticeId)
               C.HasPropertyName

  subobjectLatticeAlgebraicBridge
    : (thm : SubobjectLatticesInAlgebraicCategoriesAreAlgebraicTheorem)
    -> C.Proof (C.CategoryHasPropertyS (SubobjectLatticesInAlgebraicCategoriesAreAlgebraicTheorem.subobjectLattice thm)
                                      P.AlgebraicLatticeId)
               C.HasPropertyName

  -- Beck characterization: category-level generic properties
  hasRegularProjectiveGeneratorBridge
    : (thm : BeckCharacterizationOfAlgebraicCategoriesTheorem)
    -> C.Proof (C.CategoryHasPropertyS (BeckCharacterizationOfAlgebraicCategoriesTheorem.category thm)
                                      P.HasRegularProjectiveGeneratorId)
               C.HasPropertyName

  regularlyCoveredByGeneratorBridge
    : (prop : RegularlyCoveredByGeneratorProperty)
    -> C.Proof (C.CategoryHasPropertyS (RegularlyCoveredByGeneratorProperty.category prop)
                                      P.RegularlyCoveredByGeneratorId)
               C.HasPropertyName

  -- Category has a generator (extracted from Beck characterization data)
  hasGeneratorBridge
    : (thm : BeckCharacterizationOfAlgebraicCategoriesTheorem)
    -> C.Proof (C.CategoryHasPropertyS (BeckCharacterizationOfAlgebraicCategoriesTheorem.category thm)
                                      P.HasGeneratorId)
               C.HasPropertyName

  -- Algebraic functor as a generic functor-level property
  algebraicFunctorBridge
    : (decl : AlgebraicFunctorDeclaration)
    -> C.Proof (C.FunctorHasPropertyS (AlgebraicFunctorDeclaration.F decl)
                                      (AlgebraicCategoryDeclaration.category (AlgebraicFunctorDeclaration.source decl))
                                      (AlgebraicCategoryDeclaration.category (AlgebraicFunctorDeclaration.target decl))
                                      P.AlgebraicFunctorId)
               C.HasPropertyName
module Level2_4 where

open import Agda.Builtin.Unit     using (⊤; tt)
open import Agda.Builtin.String   using (String)
open import Agda.Builtin.List     using (List; []; _∷_)
open import Agda.Builtin.Bool     using (Bool)
open import Agda.Builtin.Equality using (_≡_)

open import Metamodel as M
open import Core      as C

-- Expression placeholder
Expr : Set
Expr = String

------------------------------------------------------------------------
-- Section 4.1: Monads and their algebras
------------------------------------------------------------------------

-- Monad data components (functor, unit, multiplication)
record MonadData : Set where
  constructor MONAD_DATA
  field
    category       : M.Identifier  -- C
    endofunctor    : M.Identifier  -- T : C → C
    unit           : M.Identifier  -- η : Id_C ⇒ T
    multiplication : M.Identifier  -- μ : T² ⇒ T
-- CATEGORY: Raw structural components before verification.

-- Monad associativity axiom: μ ∘ T(μ) == μ ∘ μ_T
record MonadAssociativityAxiom : Set where
  constructor AXIOM_MonadAssociativity
  field
    monadData : MonadData
    witness   : M.Identifier
-- CATEGORY: Coherence law for monad multiplication.

-- Monad unitality axiom: μ ∘ T(η) == id_T and μ ∘ η_T == id_T
record MonadUnitalityAxiom : Set where
  constructor AXIOM_MonadUnitality
  field
    monadData : MonadData
    witness   : M.Identifier
-- CATEGORY: Coherence laws ensuring unit acts as two-sided identity.

-- Full monad declaration: data + verification
record MonadDeclaration : Set where
  constructor MONAD_on
  field
    name          : M.Identifier
    data_         : MonadData
    associativity : MonadAssociativityAxiom
    unitality     : MonadUnitalityAxiom
-- CATEGORY: Monad as monoid in endofunctors.

-- T-Algebra data
record TAlgebraData : Set where
  constructor T_ALGEBRA_DATA
  field
    monad        : MonadDeclaration
    carrier      : M.Identifier  -- A
    structureMap : M.Identifier  -- h : T(A) → A
-- CATEGORY: Carrier with structure map from monad application.

-- T-Algebra associativity axiom: h ∘ T(h) == h ∘ μ_A
record TAlgebraAssociativityAxiom : Set where
  constructor AXIOM_TAlgebraAssociativity
  field
    algebraData : TAlgebraData
    witness     : M.Identifier
-- CATEGORY: Structure map coherent with monad multiplication.

-- T-Algebra unitality axiom: h ∘ η_A == id_A
record TAlgebraUnitalityAxiom : Set where
  constructor AXIOM_TAlgebraUnitality
  field
    algebraData : TAlgebraData
    witness     : M.Identifier
-- CATEGORY: Structure map coherent with monad unit.

-- Full T-Algebra declaration
record TAlgebraDeclaration : Set where
  constructor T_ALGEBRA
  field
    algebraData   : TAlgebraData
    associativity : TAlgebraAssociativityAxiom
    unitality     : TAlgebraUnitalityAxiom
-- CATEGORY: Eilenberg-Moore algebra for monad T.

-- Category of T-algebras (Eilenberg-Moore category)
record CategoryOfAlgebras : Set where
  constructor C^T
  field
    monad    : MonadDeclaration
    category : M.Identifier  -- C^T
-- CATEGORY: Objects are T-algebras; morphisms are T-algebra homomorphisms.

-- List monad instance
record ListMonadInstance : Set where
  constructor INSTANCE_ListMonad
  field
    listFunctor      : M.Identifier  -- List : Set → Set
    singletonNT      : M.Identifier  -- η_List : Id ⇒ List
    flattenNT        : M.Identifier  -- μ_List : List² ⇒ List
    monadDeclaration : MonadDeclaration
-- CATEGORY: Canonical monad on Set; algebras are monoids.

-- Theorem: List algebras are monoids
record ListAlgebrasAreMonoidsTheorem : Set where
  constructor THEOREM_ListAlgebrasAreMonoids
  field
    algebraData         : TAlgebraData  -- (A, h : List(A) → A)
    monoidCarrier       : M.Identifier  -- A
    monoidOperation     : M.Identifier  -- binary op from h([a,b])
    monoidUnit          : M.Identifier  -- unit from h([])
    equivalenceWitness  : M.Identifier  -- (A,h) T-algebra ⟺ (A,op,unit) monoid
-- CATEGORY: Fundamental connection: List algebras ≅ Monoids.

-- Category-level consequence
record CategoryOfListAlgebrasIsMonTheorem : Set where
  constructor THEOREM_CategoryOfListAlgebrasIsMon
  field
    algebraCategory  : CategoryOfAlgebras
    monoidCategory   : M.Identifier  -- Mon
    equivalenceProof : M.Identifier  -- C^T_List ≅ Mon
-- CATEGORY: C^T_List ≅ category of monoids and homomorphisms.

------------------------------------------------------------------------
-- Section 4.2: Monads and adjunctions
------------------------------------------------------------------------

-- Theorem: Adjunction induces monad
record AdjunctionInducesMonadTheorem : Set where
  constructor THEOREM_AdjunctionInducesMonad
  field
    adjunction        : M.Identifier  -- F ⊣ G : C ⇄ D
    leftAdjoint       : M.Identifier  -- F
    rightAdjoint      : M.Identifier  -- G
    unitAdj           : M.Identifier  -- η_adj
    counitAdj         : M.Identifier  -- ε_adj
    inducedMonad      : MonadDeclaration  -- T = G∘F with η=η_adj, μ=G(ε_F)
-- CATEGORY: Every adjunction yields a monad on the left category.

-- Eilenberg-Moore adjunction from monad
record EilenbergMooreAdjunction : Set where
  constructor EM_Adjunction_of
  field
    monad            : MonadDeclaration
    algebraCategory  : CategoryOfAlgebras  -- C^T
    forgetfulFunctor : M.Identifier        -- U^T : C^T → C
    freeFunctor      : M.Identifier        -- F^T : C → C^T
    adjunctionWitness : M.Identifier       -- F^T ⊣ U^T
-- CATEGORY: Canonical resolution of monad into free–forgetful adjunction.

-- Monad-adjunction correspondence theorem
record MonadAdjunctionCorrespondenceTheorem : Set where
  constructor THEOREM_MonadAdjunctionCorrespondence
  field
    monad              : MonadDeclaration
    emAdjunction       : EilenbergMooreAdjunction
    inducedMonadFromEM : MonadDeclaration
    isomorphismWitness : M.Identifier  -- monad ≅ inducedMonadFromEM
-- CATEGORY: Monad from EM adjunction is isomorphic to original monad.

------------------------------------------------------------------------
-- Section 4.3: Limits and colimits in categories of algebras
------------------------------------------------------------------------

-- Theorem: Forgetful functor from algebras creates limits
record ForgetfulFunctorFromAlgebrasCreatesLimitsTheorem : Set where
  constructor THEOREM_ForgetfulFunctorFromAlgebrasCreatesLimits
  field
    monad            : MonadDeclaration
    algebraCategory  : CategoryOfAlgebras
    forgetfulFunctor : M.Identifier  -- U^T : C^T → C
    createsWitness   : M.Identifier  -- U^T creates all limits
-- CATEGORY: Limits in algebra category computed via underlying limits.

-- Corollary: Completeness of algebra categories
record CompletenessOfAlgebraCategoriesCorollary : Set where
  constructor COROLLARY_CompletenessOfAlgebraCategories
  field
    baseCategory     : M.Identifier
    baseComplete     : M.Identifier  -- C is complete
    monad            : MonadDeclaration
    algebraCategory  : CategoryOfAlgebras
    conclusionWitness : M.Identifier  -- C^T is complete
-- CATEGORY: Completeness inherited from base category.

-- Reflexive pair
record ReflexivePair : Set where
  constructor REFLEXIVE_PAIR
  field
    category  : M.Identifier
    domain    : M.Identifier  -- A
    codomain  : M.Identifier  -- B
    f         : M.Identifier  -- f : A → B
    g         : M.Identifier  -- g : A → B
    splitting : M.Identifier  -- s : B → A with f∘s = id_B and g∘s = id_B
-- CATEGORY: Parallel pair with common right inverse.

-- Theorem: Forgetful functor preserves coequalizers of reflexive pairs
record ForgetfulFunctorPreservesCertainCoequalizersTheorem : Set where
  constructor THEOREM_ForgetfulFunctorPreservesCertainCoequalizers
  field
    monad            : MonadDeclaration
    algebraCategory  : CategoryOfAlgebras
    forgetfulFunctor : M.Identifier
    reflexivePair    : ReflexivePair
    preservationWitness : M.Identifier
-- CATEGORY: U^T preserves coequalizers of reflexive pairs.

------------------------------------------------------------------------
-- Section 4.4: Characterization of monadic categories (Beck's theorem)
------------------------------------------------------------------------

-- Functor property: reflects isomorphisms
record ReflectsIsomorphismsProperty : Set where
  constructor _reflects_ISOMORPHISMS
  field
    functor  : M.Identifier
    source   : M.Identifier
    target   : M.Identifier
    witness  : M.Identifier  -- ∀f, U(f) iso ⟹ f iso
-- CATEGORY: Conservativity condition for monadicity.

-- U-split pair
record USplitPair : Set where
  constructor U_SPLIT_PAIR
  field
    functor   : M.Identifier  -- U : A → C
    domain    : M.Identifier  -- X
    codomain  : M.Identifier  -- Y
    f         : M.Identifier  -- f : X → Y in A
    g         : M.Identifier  -- g : X → Y in A
    condition : M.Identifier  -- (U(f), U(g)) is reflexive pair in C
-- CATEGORY: Pair whose image under U is reflexive.

-- Functor property: is monadic
record MonadicFunctorProperty : Set where
  constructor _is_MONADIC
  field
    functor            : M.Identifier  -- U : A → C
    source             : M.Identifier  -- A
    target             : M.Identifier  -- C
    comparisonFunctor  : M.Identifier  -- K : A → C^T
    equivalenceWitness : M.Identifier  -- K is equivalence
-- CATEGORY: U equivalent to forgetful functor from algebra category.

-- Beck monadicity theorem
record BeckMonadicityTheorem : Set where
  constructor THEOREM_BeckMonadicityTheorem
  field
    functor                  : M.Identifier  -- U : A → C
    source                   : M.Identifier
    target                   : M.Identifier
    hasLeftAdjoint           : M.Identifier
    reflectsIsomorphisms     : ReflectsIsomorphismsProperty
    hasCoequalizersUSplit    : M.Identifier
    preservesCoequalizersUSplit : M.Identifier
    equivalenceWitness       : M.Identifier  -- conditions ⟺ U is monadic
-- CATEGORY: Precise characterization of monadic functors.

------------------------------------------------------------------------
-- Section 4.5: The adjoint lifting theorem
------------------------------------------------------------------------

-- Distributive law (natural transformation relating two monads)
record DistributiveLaw : Set where
  constructor DISTRIBUTIVE_LAW
  field
    monadT      : MonadDeclaration  -- T on C
    monadT'     : MonadDeclaration  -- T' on D
    functor     : M.Identifier      -- L : D → C
    natTransf   : M.Identifier      -- t : T∘L ⇒ L∘T'
    coherenceWitness : M.Identifier -- satisfies monad morphism conditions
-- CATEGORY: Compatibility data for lifting problem.

-- Adjoint lifting problem setup
record AdjointLiftingProblemSetup : Set where
  constructor LIFTING_PROBLEM_SETUP
  field
    monadT          : MonadDeclaration  -- T on C
    monadT'         : MonadDeclaration  -- T' on D
    functorL        : M.Identifier      -- L : D → C
    distributiveLaw : DistributiveLaw
-- CATEGORY: Data for lifting functor between base categories to algebras.

-- Lifted functor L̄ : D^T' → C^T
record LiftedFunctor : Set where
  constructor LiftedFunctor_of
  field
    problemSetup : AdjointLiftingProblemSetup
    liftedFunctor : M.Identifier  -- L̄ : D^T' → C^T
    constructionWitness : M.Identifier
-- CATEGORY: Functor between algebra categories lifted from base functor.

-- Adjoint lifting theorem
record AdjointLiftingTheorem : Set where
  constructor THEOREM_AdjointLiftingTheorem
  field
    problemSetup     : AdjointLiftingProblemSetup
    lifted           : LiftedFunctor
    uniquenessWitness : M.Identifier
    adjointLiftWitness : M.Identifier  -- if L has left adjoint, so does L̄
-- CATEGORY: Lifts functors and adjunctions to algebra categories.

------------------------------------------------------------------------
-- Section 4.6: Monads with rank
------------------------------------------------------------------------

-- Regular cardinal
record RegularCardinal : Set where
  constructor REGULAR_CARDINAL
  field
    cardinalName : M.Identifier
    regularityWitness : M.Identifier  -- cof(α) = α
-- CATEGORY: Well-behaved infinite cardinal (e.g., ℵ₀).

-- α-filtered colimit
record AlphaFilteredColimit : Set where
  constructor α_FILTERED_COLIMIT
  field
    cardinal       : RegularCardinal
    category       : M.Identifier
    diagram        : M.Identifier
    indexCategory  : M.Identifier
    colimitObject  : M.Identifier
    alphaFilteredWitness : M.Identifier
-- CATEGORY: Colimit over α-filtered diagram.

-- Object property: α-presentable
record AlphaPresentableObjectProperty : Set where
  constructor _is_α_PRESENTABLE
  field
    object   : M.Identifier
    category : M.Identifier
    cardinal : RegularCardinal
    homFunctorPreservesAlphaFilteredColimits : M.Identifier
-- CATEGORY: Categorical notion of α-sized compactness.

-- Monad with rank α
record MonadWithRank : Set where
  constructor MONAD_WITH_RANK
  field
    monad    : MonadDeclaration
    cardinal : RegularCardinal
    preservesAlphaFilteredColimitsWitness : M.Identifier
-- CATEGORY: Monad bounded in size by cardinal α.

-- Locally α-presentable category
record LocallyPresentableCategory : Set where
  constructor LOCALLY_α_PRESENTABLE_CATEGORY
  field
    category      : M.Identifier
    cardinal      : RegularCardinal
    cocomplete    : M.Identifier
    hasAlphaPresentableGenerators : M.Identifier
-- CATEGORY: Category built from objects of size α; very well-behaved.

-- Rank theorem for monadic categories
record RankTheoremForMonadicCategoriesTheorem : Set where
  constructor THEOREM_RankTheoremForMonadicCategories
  field
    baseCategory     : LocallyPresentableCategory
    monadWithRank    : MonadWithRank
    algebraCategory  : CategoryOfAlgebras
    conclusionWitness : M.Identifier  -- C^T is locally α-presentable
-- CATEGORY: Algebra category inherits local presentability.

------------------------------------------------------------------------
-- Section 4.7: A glance at descent theory
------------------------------------------------------------------------

-- Comonad data (dual of monad)
record ComonadData : Set where
  constructor COMONAD_DATA
  field
    category         : M.Identifier  -- C
    endofunctor      : M.Identifier  -- G : C → C
    counit           : M.Identifier  -- ε : G ⇒ Id
    comultiplication : M.Identifier  -- δ : G ⇒ G²
-- CATEGORY: Dual monad structure.

-- Comonad axioms (coassociativity, counitality)
record ComonadAxioms : Set where
  constructor COMONAD_AXIOMS
  field
    coassociativity : M.Identifier
    counitality     : M.Identifier
-- CATEGORY: Dual monad coherence laws.

-- Comonad declaration
record ComonadDeclaration : Set where
  constructor COMONAD_on
  field
    name   : M.Identifier
    data_  : ComonadData
    axioms : ComonadAxioms
-- CATEGORY: Comonad for decomposition and descent data.

-- G-Coalgebra data
record GCoalgebraData : Set where
  constructor G_COALGEBRA_DATA
  field
    comonad      : ComonadDeclaration
    carrier      : M.Identifier  -- A
    structureMap : M.Identifier  -- k : A → G(A)
-- CATEGORY: Object with comonad coalgebra structure.

-- G-Coalgebra axioms
record GCoalgebraAxioms : Set where
  constructor G_COALGEBRA_AXIOMS
  field
    coassociativity : M.Identifier
    counitality     : M.Identifier
-- CATEGORY: Coherence for coalgebra structure map.

-- G-Coalgebra declaration
record GCoalgebraDeclaration : Set where
  constructor G_COALGEBRA
  field
    algebraData : GCoalgebraData
    axioms      : GCoalgebraAxioms
-- CATEGORY: Coalgebra for comonad G.

-- Comonad from adjunction (for cover map)
record ComonadFromAdjunction : Set where
  constructor ComonadFromAdjunction_of
  field
    adjunction       : M.Identifier  -- pullback adjunction p* ⊣ p_*
    coverMap         : M.Identifier  -- p : U → X
    inducedComonad   : ComonadDeclaration  -- G = p_* ∘ p*
-- CATEGORY: Comonad from pullback–pushforward adjunction.

-- Category of descent data
record CategoryOfDescentData : Set where
  constructor Desc_of
  field
    coverMap  : M.Identifier  -- p : U → X
    comonad   : ComonadDeclaration
    category  : M.Identifier  -- Desc(p) ≅ CategoryOfCoalgebras(G)
-- CATEGORY: Gluable objects over cover with cocycle condition.

-- Effective descent morphism
record EffectiveDescentMorphism : Set where
  constructor _is_EFFECTIVE_DESCENT_MORPHISM
  field
    coverMap         : M.Identifier  -- p : U → X
    descentCategory  : CategoryOfDescentData
    baseCategory     : M.Identifier  -- C/X
    equivalenceWitness : M.Identifier  -- pullback functor is equivalence
-- CATEGORY: Cover where objects downstairs ≃ descent data upstairs.

------------------------------------------------------------------------
-- Bridge postulates placeholder
------------------------------------------------------------------------

-- Note: Monad-related structures can be integrated with the proof layer
-- using the generic scaffolding when needed. For now, structural records
-- capture the semantic content from 2/4.ebnf.

------------------------------------------------------------------------
-- End of structural encoding for 2/4.ebnf (Monads)
------------------------------------------------------------------------
-- Level2_5: Accessible Categories (Chapter 2, Section 5)
-- This module encodes the structural content of Section 5 from the EBNF grammar.
-- It covers locally presentable categories, accessible categories, raising degrees,
-- functors with rank, and sketches.

module Level2_5 where

open import Core

-- ============================================================================
-- Section 5.2: Locally Presentable Categories
-- ============================================================================

-- The master definition: a category built from small generators via colimits
record LocallyPresentableCategoryDeclaration : Set where
  field
    category : CategoryDeclaration
    rank : RegularCardinal
    -- Condition 1: C is cocomplete
    isCocompleteCond : Set
    -- Condition 2: There exists a small set S of λ-presentable objects
    -- that generates C under colimits
    generatingSet : Set
    generatingSetIsSmall : Set
    generatorsArePresentable : Set
    generatesUnderColimits : Set

-- Theorem: Every locally presentable category is complete
record LocallyPresentableImpliesCompleteTheorem : Set where
  field
    locallyPresentableCategory : LocallyPresentableCategoryDeclaration
    -- Conclusion: C is also complete
    categoryIsComplete : Set
    -- This is a form of the Adjoint Functor Theorem

-- Theorem: Locally presentable categories are well-behaved
record LocallyPresentableAreWellBehavedTheorem : Set where
  field
    locallyPresentableCategory : LocallyPresentableCategoryDeclaration
    -- Conclusion: C is well-powered, well-copowered, and has
    -- (StrongEpi, Mono) factorization system
    isWellPowered : Set
    isWellCopowered : Set
    hasStrongEpiMonoFactorization : Set

-- ============================================================================
-- Section 5.3: Accessible Categories
-- ============================================================================

-- A weakening of locally presentable: only requires λ-filtered colimits
record AccessibleCategoryDeclaration : Set where
  field
    category : CategoryDeclaration
    rank : RegularCardinal
    -- Condition 1: C has all λ-filtered colimits
    hasFilteredColimits : Set
    -- Condition 2: There exists a small set S of λ-presentable objects
    -- such that every object is a λ-filtered colimit of objects from S
    generatingSet : Set
    generatingSetIsSmall : Set
    generatorsArePresentable : Set
    generatesViaFilteredColimits : Set

-- Theorem: Every locally presentable category is accessible
record LocallyPresentableImpliesAccessibleTheorem : Set where
  field
    locallyPresentableCategory : LocallyPresentableCategoryDeclaration
    -- Conclusion: C is λ-accessible
    categoryIsAccessible : AccessibleCategoryDeclaration
    -- The rank is the same

-- ============================================================================
-- Section 5.4: Raising the Degree of Accessibility
-- ============================================================================

-- Lemma: Presentability is stable upwards
record PresentabilityIsStableUpwardsTheorem : Set where
  field
    smallerRank : RegularCardinal
    largerRank : RegularCardinal
    rankOrdering : Set  -- λ < κ
    -- Premise: Object A is λ-presentable
    objectA : ObjectDeclaration
    isLambdaPresentable : Set
    -- Conclusion: A is also κ-presentable
    isKappaPresentable : Set
    -- Proof sketch: Hom(A,-) preserves λ-filtered colimits,
    -- κ-filtered colimits are also λ-filtered colimits,
    -- therefore Hom(A,-) preserves κ-filtered colimits

-- Theorem: Accessibility is stable upwards
record RaisingTheDegreeOfAccessibilityTheorem : Set where
  field
    category : CategoryDeclaration
    smallerRank : RegularCardinal
    -- Premise: C is λ-accessible
    isLambdaAccessible : AccessibleCategoryDeclaration
    -- Conclusion: For all κ > λ, C is κ-accessible
    stableUpwards : (largerRank : RegularCardinal) → Set

-- Theorem: Local presentability is stable upwards
record RaisingTheDegreeOfPresentabilityTheorem : Set where
  field
    category : CategoryDeclaration
    smallerRank : RegularCardinal
    -- Premise: C is locally λ-presentable
    isLambdaPresentable : LocallyPresentableCategoryDeclaration
    -- Conclusion: For all κ > λ, C is locally κ-presentable
    stableUpwards : (largerRank : RegularCardinal) → Set

-- ============================================================================
-- Section 5.5: Functors with Rank
-- ============================================================================

-- Definition: A functor has rank λ if it preserves λ-filtered colimits
record FunctorHasRankProperty : Set where
  field
    functor : FunctorDeclaration
    rank : RegularCardinal
    -- F has rank λ ⟺ F preserves λ-filtered colimits
    preservesFilteredColimits : Set

-- Theorem: Right adjoints between locally presentable categories have rank
record RightAdjointsBetweenLPCatsHaveRankTheorem : Set where
  field
    sourceCategory : CategoryDeclaration
    targetCategory : CategoryDeclaration
    rank : RegularCardinal
    -- Premise: C and D are locally λ-presentable
    sourceIsLocallyPresentable : LocallyPresentableCategoryDeclaration
    targetIsLocallyPresentable : LocallyPresentableCategoryDeclaration
    -- Premise: F ⊣ G is an adjunction
    leftAdjoint : FunctorDeclaration
    rightAdjoint : FunctorDeclaration
    adjunction : AdjunctionDeclaration
    -- Conclusion: G has rank λ
    rightAdjointHasRank : FunctorHasRankProperty

-- ============================================================================
-- Section 5.6: Sketches
-- ============================================================================

-- A cone in a category (for sketch specification)
record ConeDeclaration : Set where
  field
    indexCategory : CategoryDeclaration
    baseCategory : CategoryDeclaration
    diagram : FunctorDeclaration
    apex : ObjectDeclaration
    legs : Set  -- Collection of morphisms from apex to diagram objects

-- A cocone in a category (for sketch specification)
record CoconeDeclaration : Set where
  field
    indexCategory : CategoryDeclaration
    baseCategory : CategoryDeclaration
    diagram : FunctorDeclaration
    apex : ObjectDeclaration
    legs : Set  -- Collection of morphisms from diagram objects to apex

-- A sketch: syntactic specification of a categorical theory
record SketchDeclaration : Set where
  field
    underlyingCategory : CategoryDeclaration
    -- The underlying category is small
    categoryIsSmall : Set
    -- Designated cones (to become limits in models)
    limitCones : Set  -- Collection of ConeDeclaration
    -- Designated cocones (to become colimits in models)
    colimitCocones : Set  -- Collection of CoconeDeclaration

-- A model of a sketch: a functor that realizes the specification
record ModelOfSketch : Set where
  field
    sketch : SketchDeclaration
    targetCategory : CategoryDeclaration
    -- The functor from sketch's underlying category to target
    interpretationFunctor : FunctorDeclaration
    -- Condition: Every designated cone becomes a limit cone
    preservesLimitCones : Set
    -- Condition: Every designated cocone becomes a colimit cone
    preservesColimitCocones : Set

-- The category of all models of a sketch
record CategoryOfSketchModels : Set where
  field
    sketch : SketchDeclaration
    targetCategory : CategoryDeclaration
    -- Objects: models of S in C
    modelsAsObjects : Set
    -- Morphisms: natural transformations between models
    naturalTransformationsAsMorphisms : Set

-- Gabriel-Ulmer Duality: The fundamental characterization theorem
record GabrielUlmerDualityTheorem : Set where
  field
    category : CategoryDeclaration
    -- The equivalence: C is locally presentable ⟺ C ≅ Mod(S, Set) for some sketch S
    -- Direction 1: Locally presentable implies models of a sketch
    locallyPresentableImpliesSketchModels : 
      LocallyPresentableCategoryDeclaration → 
      (sketch : SketchDeclaration) → 
      Set  -- C ≅ Mod(sketch, Set)
    -- Direction 2: Models of a sketch implies locally presentable
    sketchModelsImpliesLocallyPresentable :
      (sketch : SketchDeclaration) →
      Set  -- Mod(sketch, Set) is locally presentable

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Categories of algebraic models are locally finitely presentable
record AlgebraicModelsAreLocallyFinitelyPresentableInstance : Set where
  field
    theory : LawvereTheoryDeclaration  -- From Level2_3
    modelCategory : CategoryDeclaration
    -- The category of models is locally ℵ₀-presentable
    isLocallyFinitelyPresentable : LocallyPresentableCategoryDeclaration

-- ============================================================================
-- End of Level2_5
-- ============================================================================
-- Level2_6: Enriched Category Theory (Chapter 2, Section 6)
-- This module encodes the structural content of Section 6 from the EBNF grammar.
-- It covers symmetric monoidal closed categories, enriched categories, change of base,
-- enriched functors, natural transformations, adjunctions, the Yoneda lemma,
-- tensors, cotensors, and weighted limits.

module Level2_6 where

open import Core

-- ============================================================================
-- Section 6.1: Symmetric Monoidal Closed Categories
-- ============================================================================

-- Part 1: Monoidal Category

-- Data for a monoidal category
record MonoidalCategoryData : Set where
  field
    underlyingCategory : CategoryDeclaration
    tensorProduct : Set  -- Bifunctor ⊗ : C × C → C
    unitObject : ObjectDeclaration

-- The associator natural isomorphism
record AssociatorDeclaration : Set where
  field
    monoidalCategory : MonoidalCategoryData
    -- α : (A ⊗ B) ⊗ C ≅ A ⊗ (B ⊗ C)
    naturalIsomorphism : Set

-- The left unitor natural isomorphism
record LeftUnitorDeclaration : Set where
  field
    monoidalCategory : MonoidalCategoryData
    -- λ : I ⊗ A ≅ A
    naturalIsomorphism : Set

-- The right unitor natural isomorphism
record RightUnitorDeclaration : Set where
  field
    monoidalCategory : MonoidalCategoryData
    -- ρ : A ⊗ I ≅ A
    naturalIsomorphism : Set

-- Pentagon axiom for associator coherence
record PentagonAxiom : Set where
  field
    monoidalCategory : MonoidalCategoryData
    associator : AssociatorDeclaration
    -- For all A,B,C,D: pentagon diagram commutes
    diagramCommutes : Set

-- Triangle axiom for unitor coherence
record TriangleAxiom : Set where
  field
    monoidalCategory : MonoidalCategoryData
    associator : AssociatorDeclaration
    leftUnitor : LeftUnitorDeclaration
    rightUnitor : RightUnitorDeclaration
    -- For all A,B: triangle diagram commutes
    diagramCommutes : Set

-- Complete monoidal category definition
record MonoidalCategoryDeclaration : Set where
  field
    data : MonoidalCategoryData
    associator : AssociatorDeclaration
    leftUnitor : LeftUnitorDeclaration
    rightUnitor : RightUnitorDeclaration
    pentagonAxiom : PentagonAxiom
    triangleAxiom : TriangleAxiom

-- Part 2: Symmetric Monoidal Category

-- The braiding natural isomorphism
record BraidingDeclaration : Set where
  field
    monoidalCategory : MonoidalCategoryData
    -- γ : A ⊗ B ≅ B ⊗ A
    naturalIsomorphism : Set
    -- Symmetry: γ_{B,A} ∘ γ_{A,B} = id_{A⊗B}
    symmetryCondition : Set

-- Hexagon axiom for braiding coherence
record HexagonAxiom : Set where
  field
    monoidalCategory : MonoidalCategoryData
    associator : AssociatorDeclaration
    braiding : BraidingDeclaration
    -- For all A,B,C: hexagon diagram commutes
    diagramCommutes : Set

-- Symmetric monoidal category
record SymmetricMonoidalCategoryDeclaration : Set where
  field
    monoidalCategory : MonoidalCategoryDeclaration
    braiding : BraidingDeclaration
    hexagonAxiom : HexagonAxiom

-- Part 3: Symmetric Monoidal Closed Category

-- Internal hom-object (exponential object)
record InternalHomObjectDeclaration : Set where
  field
    category : CategoryDeclaration
    sourceObject : ObjectDeclaration
    targetObject : ObjectDeclaration
    -- [B, C] is an object in the category
    internalHomObject : ObjectDeclaration

-- Tensor-Hom adjunction theorem
record TensorHomAdjunctionTheorem : Set where
  field
    category : SymmetricMonoidalCategoryDeclaration
    -- (- ⊗ B) ⊣ [B, -]
    leftAdjoint : FunctorDeclaration
    rightAdjoint : FunctorDeclaration
    adjunction : AdjunctionDeclaration
    -- Hom(A ⊗ B, C) ≅ Hom(A, [B, C])
    adjunctionIsomorphism : Set

-- Symmetric monoidal closed category
record SymmetricMonoidalClosedCategoryDeclaration : Set where
  field
    symmetricMonoidalCategory : SymmetricMonoidalCategoryDeclaration
    internalHom : Set  -- Family of internal hom objects
    tensorHomAdjunction : TensorHomAdjunctionTheorem

-- ============================================================================
-- Section 6.2: Enriched Categories (V-Categories)
-- ============================================================================

-- Part 1: Data of a V-Category

-- Hom-object declaration
record HomObjectDeclaration : Set where
  field
    sourceObject : ObjectDeclaration
    targetObject : ObjectDeclaration
    -- C(A, B) is an object in the enriching category V
    homObjectInV : ObjectDeclaration

-- Composition morphism in the enriching category
record CompositionMorphismDeclaration : Set where
  field
    objectA : ObjectDeclaration
    objectB : ObjectDeclaration
    objectC : ObjectDeclaration
    -- compose : C(B,C) ⊗ C(A,B) → C(A,C) in V
    compositionMorphismInV : MorphismDeclaration

-- Identity morphism in the enriching category
record IdentityMorphismDeclaration_Enriched : Set where
  field
    object : ObjectDeclaration
    -- id_A : I → C(A,A) in V
    identityMorphismInV : MorphismDeclaration

-- Complete data for a V-category
record EnrichedCategoryData : Set where
  field
    enrichingCategory : MonoidalCategoryDeclaration
    objects : Set  -- Collection of objects
    homObjects : Set  -- Family of HomObjectDeclaration
    compositionMorphisms : Set  -- Family of CompositionMorphismDeclaration
    identityMorphisms : Set  -- Family of IdentityMorphismDeclaration_Enriched

-- Part 2: Axioms of a V-Category

-- Enriched associativity axiom
record EnrichedAssociativityAxiom : Set where
  field
    enrichedData : EnrichedCategoryData
    -- Associativity pentagon commutes in V
    diagramCommutesInV : Set

-- Enriched unitality axiom
record EnrichedUnitalityAxiom : Set where
  field
    enrichedData : EnrichedCategoryData
    -- Unit law triangles commute in V
    leftUnitalityDiagram : Set
    rightUnitalityDiagram : Set

-- Complete V-category definition
record EnrichedCategoryDeclaration : Set where
  field
    data : EnrichedCategoryData
    associativityAxiom : EnrichedAssociativityAxiom
    unitalityAxiom : EnrichedUnitalityAxiom

-- ============================================================================
-- Section 6.2 (continued): Change of Base
-- ============================================================================

-- Part 1: Strong Monoidal Functors

-- Strong monoidal functor between monoidal categories
record StrongMonoidalFunctorDeclaration : Set where
  field
    sourceCategory : MonoidalCategoryDeclaration
    targetCategory : MonoidalCategoryDeclaration
    underlyingFunctor : FunctorDeclaration
    -- μ_{A,B} : F(A) ⊗_W F(B) → F(A ⊗_V B)
    monoidalStructure : Set
    -- ε : I_W → F(I_V)
    unitStructure : Set
    -- Coherence conditions for μ and ε
    coherenceConditions : Set

-- Part 2: Change of Base Construction

-- Change of base: transforms a V-category into a W-category
record ChangeOfBaseConstructor : Set where
  field
    sourceCategoryV : MonoidalCategoryDeclaration
    targetCategoryW : MonoidalCategoryDeclaration
    monoidalFunctor : StrongMonoidalFunctorDeclaration
    vCategory : EnrichedCategoryDeclaration
    -- The resulting W-category F_*(C)
    resultWCategory : EnrichedCategoryDeclaration

-- Part 3: Underlying Ordinary Category

-- The underlying Set-enriched category of a V-category
record UnderlyingOrdinaryCategory : Set where
  field
    vCategory : EnrichedCategoryDeclaration
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    -- Hom_V(I, -) : V → Set functor
    homFunctor : FunctorDeclaration
    -- Result is equivalent to change of base along Hom_V(I, -)
    underlyingCategory : CategoryDeclaration
    changeOfBaseEquivalence : Set

-- ============================================================================
-- Section 6.3 & 6.7: Enriched Functors, Natural Transformations, and Adjunctions
-- ============================================================================

-- Part 1: Enriched Functors (V-Functors)

-- Data for a V-functor
record EnrichedFunctorData : Set where
  field
    sourceCategory : EnrichedCategoryDeclaration
    targetCategory : EnrichedCategoryDeclaration
    enrichingCategory : MonoidalCategoryDeclaration
    -- Action on objects
    actionOnObjects : Set
    -- Action on hom-objects: F_{A,B} : C(A,B) → D(F(A),F(B)) in V
    actionOnHomObjects : Set

-- V-functor preserves composition axiom
record EnrichedFunctorAxiom_Composition : Set where
  field
    functorData : EnrichedFunctorData
    -- Composition preservation diagram commutes in V
    diagramCommutes : Set

-- V-functor preserves identity axiom
record EnrichedFunctorAxiom_Identity : Set where
  field
    functorData : EnrichedFunctorData
    -- Identity preservation diagram commutes in V
    diagramCommutes : Set

-- Complete V-functor definition
record EnrichedFunctorDeclaration : Set where
  field
    data : EnrichedFunctorData
    preservesComposition : EnrichedFunctorAxiom_Composition
    preservesIdentity : EnrichedFunctorAxiom_Identity

-- Part 2: Enriched Natural Transformations

-- V-naturality axiom
record V_NaturalityAxiom : Set where
  field
    sourceFunctor : EnrichedFunctorDeclaration
    targetFunctor : EnrichedFunctorDeclaration
    components : Set  -- Family of morphisms α_A : I → D(F(A), G(A)) in V
    -- V-enriched naturality square commutes
    diagramCommutes : Set

-- V-natural transformation
record EnrichedNaturalTransformation : Set where
  field
    sourceFunctor : EnrichedFunctorDeclaration
    targetFunctor : EnrichedFunctorDeclaration
    components : Set
    naturalityAxiom : V_NaturalityAxiom

-- Part 3: Enriched Adjunctions

-- V-adjunction between V-functors
record EnrichedAdjunctionDeclaration : Set where
  field
    leftAdjoint : EnrichedFunctorDeclaration
    rightAdjoint : EnrichedFunctorDeclaration
    -- D(F(A), B) ≅ C(A, G(B)) as V-natural isomorphism
    homObjectIsomorphism : Set
    naturalityInV : Set

-- Part 4: Enriched Yoneda Lemma

-- Category of V-enriched presheaves
record EnrichedPresheafCategory : Set where
  field
    baseCategory : EnrichedCategoryDeclaration
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    -- [C^op, V] is a V-category
    presheafCategoryStructure : EnrichedCategoryDeclaration

-- Enriched Yoneda isomorphism theorem
record EnrichedYonedaIsomorphismTheorem : Set where
  field
    baseCategory : EnrichedCategoryDeclaration
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    yonedaEmbedding : EnrichedFunctorDeclaration
    objectA : ObjectDeclaration
    presheafP : EnrichedFunctorDeclaration
    -- [C^op,V](y(A), P) ≅ P(A) in V
    yonedaIsomorphism : Set

-- Corollary: Yoneda embedding is fully faithful
record EnrichedYonedaEmbeddingIsFullyFaithfulCorollary : Set where
  field
    yonedaTheorem : EnrichedYonedaIsomorphismTheorem
    -- y : C → [C^op, V] is fully faithful
    fullyFaithful : Set

-- ============================================================================
-- Section 6.5 & 6.6: Tensors, Cotensors, and Weighted Limits
-- ============================================================================

-- Part 1: Tensors (Copowers) and Cotensors (Powers)

-- Tensor (copower): v ⊗ X
record TensorDeclaration : Set where
  field
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    vCategory : EnrichedCategoryDeclaration
    objectV : ObjectDeclaration  -- v in V
    objectC : ObjectDeclaration  -- X in C
    -- Universal property: C(v⊗X, Y) ≅ V(v, C(X,Y)) in V
    universalProperty : Set

-- Cotensor (power): [v, X]
record CotensorDeclaration : Set where
  field
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    vCategory : EnrichedCategoryDeclaration
    objectV : ObjectDeclaration  -- v in V
    objectC : ObjectDeclaration  -- X in C
    -- Universal property: C(Y, [v,X]) ≅ V(v, C(Y,X)) in V
    universalProperty : Set

-- Part 2: Weighted Limits and Colimits

-- Weighted limit: {W, D}
record WeightedLimitDeclaration : Set where
  field
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    indexCategory : EnrichedCategoryDeclaration
    targetCategory : EnrichedCategoryDeclaration
    diagram : EnrichedFunctorDeclaration  -- D : J → C
    weight : EnrichedFunctorDeclaration    -- W : J^op → V
    -- Universal property: C(X, {W,D}) ≅ [J^op, V](W, C(X,D(-))) in V
    universalProperty : Set

-- Weighted colimit: {W * D}
record WeightedColimitDeclaration : Set where
  field
    enrichingCategory : SymmetricMonoidalClosedCategoryDeclaration
    indexCategory : EnrichedCategoryDeclaration
    targetCategory : EnrichedCategoryDeclaration
    diagram : EnrichedFunctorDeclaration  -- D : J → C
    weight : EnrichedFunctorDeclaration    -- W : J → V
    -- Universal property: C({W*D}, X) ≅ [J, V](W, C(D(-),X)) in V
    universalProperty : Set

-- Part 3: Unification Theorems

-- Theorem: Tensors are weighted colimits
record TensorsAreWeightedColimitsTheorem : Set where
  field
    tensor : TensorDeclaration
    -- Construction showing v⊗X ≅ {W*D} for specific W and D
    terminalVCategory : EnrichedCategoryDeclaration
    diagramSelectingX : EnrichedFunctorDeclaration
    weightSelectingV : EnrichedFunctorDeclaration
    equivalentColimit : WeightedColimitDeclaration
    isomorphism : Set

-- Dual theorem: Cotensors are weighted limits
record CotensorsAreWeightedLimitsTheorem : Set where
  field
    cotensor : CotensorDeclaration
    -- Construction showing [v,X] ≅ {W,D} for specific W and D
    terminalVCategory : EnrichedCategoryDeclaration
    diagramSelectingX : EnrichedFunctorDeclaration
    weightSelectingV : EnrichedFunctorDeclaration
    equivalentLimit : WeightedLimitDeclaration
    isomorphism : Set

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Set as a symmetric monoidal closed category
record SetAsSymmetricMonoidalClosedInstance : Set where
  field
    -- Set with Cartesian product and singleton set
    underlyingCategory : CategoryDeclaration
    cartesianProduct : Set
    singletonSet : ObjectDeclaration
    isSymmetricMonoidalClosed : SymmetricMonoidalClosedCategoryDeclaration

-- Example: Ordinary categories are Set-categories
record OrdinaryCategoriesAreSetCategoriesInstance : Set where
  field
    ordinaryCategory : CategoryDeclaration
    -- The enrichment over Set
    setEnrichment : EnrichedCategoryDeclaration
    equivalence : Set

-- ============================================================================
-- End of Level2_6
-- ============================================================================
-- Level2_7: Topological Categories (Chapter 2, Section 7)
-- This module encodes the structural content of Section 7 from the EBNF grammar.
-- It covers exponentiable spaces, compactly generated spaces, and topological functors.

module Level2_7 where

open import Core

-- ============================================================================
-- Section 7.1: Exponentiable Spaces
-- ============================================================================

-- Part 1: The Context and Core Property

-- The category of topological spaces
record TopologicalSpacesCategory : Set where
  field
    -- Category of all topological spaces and continuous maps
    underlyingCategory : CategoryDeclaration
    -- Objects are topological spaces
    spaces : Set
    -- Morphisms are continuous maps
    continuousMaps : Set

-- Product functor (- × X) on Top
record ProductFunctor_Top : Set where
  field
    category : TopologicalSpacesCategory
    fixedSpace : ObjectDeclaration
    -- The endofunctor (- × X) : Top → Top
    underlyingFunctor : FunctorDeclaration

-- Exponentiable space property
record ExponentiableSpaceProperty : Set where
  field
    category : TopologicalSpacesCategory
    space : ObjectDeclaration
    -- The product functor (- × X)
    productFunctor : ProductFunctor_Top
    -- X is exponentiable if (- × X) has a right adjoint
    hasRightAdjoint : Set

-- Part 2: The Exponential Object and Adjunction

-- Exponential object Y^X (function space)
record ExponentialObject_Top : Set where
  field
    category : TopologicalSpacesCategory
    baseSpace : ObjectDeclaration  -- X
    targetSpace : ObjectDeclaration  -- Y
    -- Premise: X is exponentiable
    baseIsExponentiable : ExponentiableSpaceProperty
    -- Y^X with compact-open topology
    exponentialSpace : ObjectDeclaration

-- Exponentiation adjunction theorem
record ExponentiationAdjunctionInTopTheorem : Set where
  field
    category : TopologicalSpacesCategory
    space : ObjectDeclaration
    exponentiableProperty : ExponentiableSpaceProperty
    -- (- × X) ⊣ (-)^X
    productFunctor : FunctorDeclaration
    exponentialFunctor : FunctorDeclaration
    adjunction : AdjunctionDeclaration
    -- Hom_Top(A × X, Y) ≅ Hom_Top(A, Y^X)
    homIsomorphism : Set

-- Part 3: Cartesian Closed Categories and the Problem

-- Cartesian closed category property
record CartesianClosedCategoryProperty : Set where
  field
    category : CategoryDeclaration
    -- Has terminal object and all binary products
    hasFiniteProducts : Set
    -- Every object is exponentiable
    allObjectsExponentiable : Set

-- Theorem: Top is not Cartesian closed
record TopIsNotCartesianClosedTheorem : Set where
  field
    topCategory : TopologicalSpacesCategory
    -- Top has finite products
    hasProducts : Set
    -- But there exists a non-exponentiable space (e.g., rationals Q)
    counterexample : ObjectDeclaration
    counterexampleNotExponentiable : Set
    -- Therefore Top is not Cartesian closed
    conclusion : Set

-- ============================================================================
-- Section 7.2: Compactly Generated Spaces
-- ============================================================================

-- Part 1: The Properties and the Subcategory

-- Compactly generated space property (k-space)
record CompactlyGeneratedProperty : Set where
  field
    topCategory : TopologicalSpacesCategory
    space : ObjectDeclaration
    -- A subset A is closed iff f⁻¹(A) is closed in K
    -- for all continuous f : K → X from compact Hausdorff K
    topologyDeterminedByCompacta : Set

-- Weak Hausdorff property
record WeakHausdorffProperty : Set where
  field
    topCategory : TopologicalSpacesCategory
    space : ObjectDeclaration
    -- Image of any continuous map from compact Hausdorff is closed
    compactImagesAreClosed : Set

-- The CGWH category
record CGWH_CategoryDeclaration : Set where
  field
    topCategory : TopologicalSpacesCategory
    -- Full subcategory of Top on CGWH objects
    underlyingCategory : CategoryDeclaration
    -- Objects satisfy both properties
    objectsAreCompactlyGenerated : Set
    objectsAreWeakHausdorff : Set

-- Part 2: The Reflection and Main Theorem

-- k-ification functor
record KificationFunctorDeclaration : Set where
  field
    topCategory : TopologicalSpacesCategory
    cgwhCategory : CGWH_CategoryDeclaration
    -- k : Top → CGWH (the reflector)
    underlyingFunctor : FunctorDeclaration
    -- Gives a space the finest compactly generated topology
    refinesTopology : Set

-- Theorem: CGWH is reflective in Top
record CGWH_isReflectiveInTopTheorem : Set where
  field
    topCategory : TopologicalSpacesCategory
    cgwhCategory : CGWH_CategoryDeclaration
    -- Inclusion functor I : CGWH ↪ Top
    inclusionFunctor : FunctorDeclaration
    -- k-ification functor k : Top → CGWH
    kificationFunctor : KificationFunctorDeclaration
    -- k ⊣ I adjunction
    adjunction : AdjunctionDeclaration

-- Theorem: CGWH is Cartesian closed
record CGWH_isCartesianClosedTheorem : Set where
  field
    cgwhCategory : CGWH_CategoryDeclaration
    -- CGWH has finite products
    hasFiniteProducts : Set
    -- Every object in CGWH is exponentiable (in CGWH)
    allObjectsExponentiable : Set
    -- Therefore CGWH is Cartesian closed
    isCartesianClosed : CartesianClosedCategoryProperty

-- ============================================================================
-- Section 7.3: Topological Functors
-- ============================================================================

-- Part 1: The Lifting Problem and Solutions

-- Structured sink for a functor
record StructuredSink : Set where
  field
    sourceFunctor : FunctorDeclaration  -- U : C → B
    -- Target object in base category B
    targetObject : ObjectDeclaration
    -- Family of morphisms f_i : U(A_i) → B_o
    sourceMaps : Set

-- Initial lift of a structured sink
record InitialLift : Set where
  field
    sink : StructuredSink
    -- The lifted object C_o in source category C
    liftedObject : ObjectDeclaration
    -- Lifted morphisms m_i : A_i → C_o
    liftedMorphisms : Set
    -- U(C_o) = B_o
    preservesTargetObject : Set
    -- U(m_i) = f_i for all i
    preservesSourceMaps : Set
    -- Universal property: initial among all such lifts
    universalProperty : Set

-- Structured source (dual to structured sink)
record StructuredSource : Set where
  field
    sourceFunctor : FunctorDeclaration  -- U : C → B
    -- Source object in base category B
    sourceObject : ObjectDeclaration
    -- Family of morphisms f_i : B_o → U(A_i)
    targetMaps : Set

-- Final lift of a structured source
record FinalLift : Set where
  field
    source : StructuredSource
    -- The lifted object C_o in source category C
    liftedObject : ObjectDeclaration
    -- Lifted morphisms m_i : C_o → A_i
    liftedMorphisms : Set
    -- U(C_o) = B_o
    preservesSourceObject : Set
    -- U(m_i) = f_i for all i
    preservesTargetMaps : Set
    -- Universal property: final among all such lifts
    universalProperty : Set

-- Part 2: The Master Definition and Consequences

-- Topological functor property
record TopologicalFunctorProperty : Set where
  field
    functor : FunctorDeclaration  -- U : C → B
    -- U admits initial lifts for all structured sinks
    admitsInitialLifts : (sink : StructuredSink) → InitialLift
    -- (Dually, admits final lifts for all structured sources)
    admitsFinalLifts : (source : StructuredSource) → FinalLift

-- Theorem: Consequences of being a topological functor
record ConsequencesOfBeingTopologicalTheorem : Set where
  field
    functor : FunctorDeclaration
    topologicalProperty : TopologicalFunctorProperty
    -- 1. Domain category is complete and cocomplete
    domainIsComplete : Set
    domainIsCocomplete : Set
    -- 2. Functor has both left and right adjoints
    hasLeftAdjoint : Set
    hasRightAdjoint : Set
    -- 3. Functor preserves and reflects limits and colimits
    preservesLimits : Set
    preservesColimits : Set
    reflectsLimits : Set
    reflectsColimits : Set

-- Instance: Forgetful functor U : Top → Set is topological
record ForgetfulFunctorForTopIsTopologicalInstance : Set where
  field
    topCategory : TopologicalSpacesCategory
    setCategory : CategoryDeclaration
    -- U : Top → Set forgetful functor
    forgetfulFunctor : FunctorDeclaration
    -- U is topological (admits initial and final lifts)
    isTopological : TopologicalFunctorProperty

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Compact Hausdorff spaces are exponentiable
record CompactHausdorffIsExponentiableInstance : Set where
  field
    topCategory : TopologicalSpacesCategory
    compactHausdorffSpace : ObjectDeclaration
    -- Every compact Hausdorff space is exponentiable
    isExponentiable : ExponentiableSpaceProperty

-- Example: Locally compact Hausdorff spaces are exponentiable
record LocallyCompactHausdorffIsExponentiableInstance : Set where
  field
    topCategory : TopologicalSpacesCategory
    locallyCompactHausdorffSpace : ObjectDeclaration
    -- Every locally compact Hausdorff space is exponentiable
    isExponentiable : ExponentiableSpaceProperty

-- ============================================================================
-- End of Level2_7
-- ============================================================================
-- Level2_8: Fibred Categories (Chapter 2, Section 8)
-- This module encodes the structural content of Section 8 from the EBNF grammar.
-- It covers fibrations, Cartesian arrows, Cartesian functors, Grothendieck construction,
-- fibred adjunctions, completeness criteria, locally small fibrations, and definability.

module Level2_8 where

open import Core

-- ============================================================================
-- Section 8.1: Fibrations
-- ============================================================================

-- Part 1: Cartesian Arrows and the Definition of a Fibration

-- Fibration projection functor
record FibrationProjectionFunctor : Set where
  field
    totalCategory : CategoryDeclaration
    baseCategory : CategoryDeclaration
    -- p : E → B
    projectionFunctor : FunctorDeclaration

-- A morphism lies over another morphism
record MorphismLiesOver : Set where
  field
    projectionFunctor : FibrationProjectionFunctor
    morphismInTotal : MorphismDeclaration
    morphismInBase : MorphismDeclaration
    -- f lies over u iff p(f) = u
    projectionEquals : Set

-- Cartesian arrow (universal lifting property)
record CartesianArrow : Set where
  field
    projectionFunctor : FibrationProjectionFunctor
    arrow : MorphismDeclaration  -- f : Y → X in E
    targetObject : ObjectDeclaration  -- X
    baseMorphism : MorphismDeclaration  -- u : p(Y) → p(X) in B
    -- f lies over u
    liesOver : MorphismLiesOver
    -- Universal property: for all g : Z → X lying over u ∘ w,
    -- there exists unique vertical h : Z → Y such that g = f ∘ h
    universalProperty : Set

-- Fibration declaration
record FibrationDeclaration : Set where
  field
    projectionFunctor : FibrationProjectionFunctor
    -- For every object X in E and morphism u : I → p(X) in B,
    -- there exists a Cartesian arrow f : Y → X lifting u
    cartesianLiftsExist : Set

-- Part 2: Fibres and Reindexing Functors

-- Fibre category over an object in the base
record FibreCategory : Set where
  field
    fibration : FibrationDeclaration
    baseObject : ObjectDeclaration
    -- Subcategory of E consisting of objects lying over I
    -- and vertical morphisms (lying over identity)
    fibreCategoryStructure : CategoryDeclaration

-- Reindexing functor (pullback functor)
record ReindexingFunctor : Set where
  field
    fibration : FibrationDeclaration
    baseMorphism : MorphismDeclaration  -- u : I → J in B
    -- u* : E_J → E_I
    -- Constructed by choosing Cartesian lifts
    underlyingFunctor : FunctorDeclaration
    sourceFibre : FibreCategory
    targetFibre : FibreCategory

-- Part 3: The Dual Theory (Opfibrations)

-- coCartesian arrow (dual to Cartesian arrow)
record CoCartesianArrow : Set where
  field
    projectionFunctor : FibrationProjectionFunctor
    arrow : MorphismDeclaration  -- f : X → Y in E
    sourceObject : ObjectDeclaration  -- X
    baseMorphism : MorphismDeclaration  -- u : p(X) → p(Y) in B
    -- f lies over u
    liesOver : MorphismLiesOver
    -- Universal property (dual to Cartesian)
    universalProperty : Set

-- Opfibration declaration
record OpfibrationDeclaration : Set where
  field
    projectionFunctor : FibrationProjectionFunctor
    -- For every object X in E and morphism u : p(X) → J in B,
    -- there exists a coCartesian arrow f : X → Y lifting u
    coCartesianLiftsExist : Set

-- Pushforward functor (dual to reindexing)
record PushforwardFunctor : Set where
  field
    opfibration : OpfibrationDeclaration
    baseMorphism : MorphismDeclaration  -- u : I → J in B
    -- u_! : E_I → E_J
    underlyingFunctor : FunctorDeclaration
    sourceFibre : FibreCategory
    targetFibre : FibreCategory

-- ============================================================================
-- Section 8.2: Cartesian Functors
-- ============================================================================

-- Part 1: Deconstructing the Definition

-- Axiom: Functor commutes with projections
record CommutesWithProjectionsAxiom : Set where
  field
    functorF : FunctorDeclaration
    sourceFibration : FibrationDeclaration
    targetFibration : FibrationDeclaration
    -- p' ∘ F = p
    diagramCommutes : Set

-- Axiom: Functor preserves Cartesian arrows
record PreservesCartesianArrowsAxiom : Set where
  field
    functorF : FunctorDeclaration
    sourceFibration : FibrationDeclaration
    targetFibration : FibrationDeclaration
    -- If f is Cartesian in E, then F(f) is Cartesian in E'
    preservesCartesian : Set

-- Part 2: The Master Definition and Category of Fibrations

-- Cartesian functor between fibrations
record CartesianFunctorDeclaration : Set where
  field
    sourceFibration : FibrationDeclaration
    targetFibration : FibrationDeclaration
    underlyingFunctor : FunctorDeclaration
    commutesWithProjections : CommutesWithProjectionsAxiom
    preservesCartesianArrows : PreservesCartesianArrowsAxiom

-- Category of all fibrations over a base
record CategoryOfFibrations : Set where
  field
    baseCategory : CategoryDeclaration
    -- Objects: fibrations over B
    fibrations : Set
    -- Morphisms: Cartesian functors
    cartesianFunctors : Set
    -- This is actually a 2-category
    categoryStructure : CategoryDeclaration

-- ============================================================================
-- Section 8.3: Grothendieck Construction
-- ============================================================================

-- Part 1: From Fibration to Pseudofunctor (Unpacking)

-- Pseudofunctor extracted from a fibration
record PseudofunctorFromFibration : Set where
  field
    fibration : FibrationDeclaration
    -- F : B^op → Cat
    -- Objects: I ↦ Fibre(p, I)
    -- Morphisms: u ↦ ReindexingFunctor(u)
    underlyingPseudofunctor : Set  -- PseudoFunctor type
    actionOnObjects : Set
    actionOnMorphisms : Set

-- Part 2: From Pseudofunctor to Fibration (Grothendieck Construction)

-- The Grothendieck construction (category of elements)
record GrothendieckConstruction : Set where
  field
    basePseudofunctor : Set  -- PseudoFunctor(B^op, Cat)
    -- Construct total category E = ∫ F
    -- Objects: pairs (I, x) where I in B, x in F(I)
    -- Morphisms: pairs (u, f) where u : I → J in B, f : x → F(u)(y) in F(I)
    totalCategory : CategoryDeclaration
    -- Projection functor p : E → B
    projectionFunctor : FibrationProjectionFunctor
    -- Result is a fibration
    isFibration : FibrationDeclaration

-- Part 3: The Main Equivalence Theorem

-- Grothendieck equivalence theorem
record GrothendieckEquivalenceTheorem : Set where
  field
    baseCategory : CategoryDeclaration
    -- The 2-category of fibrations over B
    fibrationsOver : CategoryOfFibrations
    -- The 2-category of pseudofunctors B^op → Cat
    pseudofunctors : Set
    -- The two constructions form an equivalence of 2-categories
    equivalence : Set

-- ============================================================================
-- Section 8.4: Fibred Adjunctions
-- ============================================================================

-- Part 1: The Definition (Pointwise Adjunctions)

-- Fibred adjunction (pointwise adjunction on fibres)
record FibredAdjunctionDeclaration : Set where
  field
    leftAdjoint : CartesianFunctorDeclaration
    rightAdjoint : CartesianFunctorDeclaration
    sourceFibration : FibrationDeclaration
    targetFibration : FibrationDeclaration
    -- For each object I in base, F_I ⊣ G_I on fibres
    pointwiseAdjunctions : Set

-- Part 2: The Beck-Chevalley Condition (Coherence Law)

-- Beck-Chevalley condition
record BeckChevalleyCondition : Set where
  field
    fibredAdjunction : FibredAdjunctionDeclaration
    -- For all u : I → J in base,
    -- the comparison u* ∘ G_J → G_I ∘ u* is an isomorphism
    comparisonIsIsomorphism : Set

-- Part 3: The Main Theorem (Connecting Pointwise and Global)

-- Theorem: Fibred adjunction equivalence
record FibredAdjunctionEquivalenceTheorem : Set where
  field
    leftAdjoint : CartesianFunctorDeclaration
    rightAdjoint : CartesianFunctorDeclaration
    -- Global adjunction F ⊣ G between total categories
    globalAdjunction : AdjunctionDeclaration
    -- Pointwise fibred adjunction
    fibredAdjunction : FibredAdjunctionDeclaration
    -- Beck-Chevalley condition
    beckChevalley : BeckChevalleyCondition
    -- Equivalence: global ⟺ (pointwise ∧ Beck-Chevalley)
    equivalence : Set

-- ============================================================================
-- Section 8.5: Completeness and Cocompleteness
-- ============================================================================

-- Part 1: The Main Criterion Theorem

-- Fibration completeness criterion theorem
record FibrationCompletenessCriterionTheorem : Set where
  field
    fibration : FibrationDeclaration
    -- Premise 1: Base is complete
    baseIsComplete : Set
    -- Premise 2: All fibres are complete
    fibresAreComplete : Set
    -- Premise 3: All reindexing functors preserve limits
    reindexingPreservesLimits : Set
    -- Conclusion: Total category is complete
    totalIsComplete : Set

-- Part 2: The Constructive Proof

-- Limit construction in fibration
record LimitConstructor_in_Fibration : Set where
  field
    fibration : FibrationDeclaration
    diagram : Set  -- Diagram in total category
    -- Step 1: Compute limit in base
    baseLimitCone : Set
    baseLimitApex : ObjectDeclaration
    -- Step 2: Construct diagram in fibre by pullback
    fibreDiagram : Set
    -- Step 3: Compute limit in fibre
    fibreLimitCone : Set
    totalLimitApex : ObjectDeclaration

-- Part 3: The Dual Theory for Cocompleteness

-- Opfibration cocompleteness criterion (dual theorem)
record OpfibrationCocompletenessCriterionTheorem : Set where
  field
    opfibration : OpfibrationDeclaration
    -- Premise 1: Base is cocomplete
    baseIsCocomplete : Set
    -- Premise 2: All fibres are cocomplete
    fibresAreCocomplete : Set
    -- Premise 3: All pushforward functors preserve colimits
    pushforwardPreservesColimits : Set
    -- Conclusion: Total category is cocomplete
    totalIsCocomplete : Set

-- ============================================================================
-- Section 8.6 & 8.7: Fibrations, Smallness, and Definability
-- ============================================================================

-- Part 1: Locally Small Fibrations (Section 8.6)

-- Small category property
record SmallCategoryProperty : Set where
  field
    category : CategoryDeclaration
    -- Objects form a set
    objectsAreSet : Set
    -- Morphisms form a set
    morphismsAreSet : Set

-- Locally small fibration
record LocallySmallFibration : Set where
  field
    fibration : FibrationDeclaration
    -- All fibre categories are small
    allFibresAreSmall : Set

-- Refined Grothendieck equivalence theorem
record RefinedGrothendieckEquivalenceTheorem : Set where
  field
    baseCategory : CategoryDeclaration
    -- 2-category of locally small fibrations over B
    locallySmallFibrations : Set
    -- 2-category of pseudofunctors B^op → Cat (small categories)
    pseudofunctorsToSmallCat : Set
    -- Equivalence
    equivalence : Set

-- Codomain fibration
record CodomainFibration : Set where
  field
    baseCategory : CategoryDeclaration
    arrowCategory : CategoryDeclaration
    -- cod : C^→ → C
    codomainFunctor : FunctorDeclaration
    -- This is a fibration (fibre over X is C/X)
    isFibration : FibrationDeclaration

-- Locally small category property
record LocallySmallCategoryProperty : Set where
  field
    category : CategoryDeclaration
    -- For all A, B, Hom_C(A,B) is a set
    homSetsAreSmall : Set

-- Corollary: Codomain fibration smallness
record CodomainFibrationSmallnessCorollary : Set where
  field
    category : CategoryDeclaration
    isLocallySmall : LocallySmallCategoryProperty
    hasPullbacks : Set
    codomainFib : CodomainFibration
    -- Conclusion: codomain fibration is locally small
    codomainFibIsLocallySmall : LocallySmallFibration

-- Part 2: Definability and Connection to Logic (Section 8.7)

-- Logical context (typed variables)
record LogicalContext : Set where
  field
    -- Finite list of typed variables
    variables : Set

-- Substitution morphism
record SubstitutionMorphism : Set where
  field
    sourceContext : LogicalContext
    targetContext : LogicalContext
    -- Map of variable assignments
    substitutionMap : Set

-- Formula in context
record FormulaInContext : Set where
  field
    context : LogicalContext
    formula : Set  -- Well-formed formula

-- First-order theory
record FirstOrderTheory : Set where
  field
    language : Set
    axioms : Set

-- Lindenbaum-Tarski fibration
record LindenbaumTarskiFibration : Set where
  field
    theory : FirstOrderTheory
    -- Base category: contexts and substitutions
    baseCategory : CategoryDeclaration
    -- Total category: formulas in context and proofs
    totalCategory : CategoryDeclaration
    -- Projection functor
    projectionFunctor : FibrationProjectionFunctor
    -- This is a fibration
    isFibration : FibrationDeclaration

-- Definability and generic models theorem
record DefinabilityAndGenericModelsTheorem : Set where
  field
    theory : FirstOrderTheory
    ltFibration : LindenbaumTarskiFibration
    -- LT_Fibration(T) has terminal object (generic model)
    hasTerminalObject : Set
    -- T admits elimination of quantifiers
    quantifierElimination : Set
    -- Equivalence
    equivalence : Set

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Codomain fibration is the canonical example
record CodomainFibrationInstance : Set where
  field
    category : CategoryDeclaration
    hasPullbacks : Set
    codomainFib : CodomainFibration
    -- Cartesian arrows are pullback squares
    cartesianArrowsArePullbacks : Set

-- Example: Families fibration
record FamiliesFibration : Set where
  field
    baseCategory : CategoryDeclaration
    -- Fibration of families of sets indexed by objects of base
    familiesCategory : CategoryDeclaration
    projectionFunctor : FibrationProjectionFunctor
    isFibration : FibrationDeclaration

-- ============================================================================
-- End of Level2_8
-- ============================================================================
module EBNF2.Index where

open import Level2_1 public
open import Level2_2 public
open import Level2_3 public
open import Level2_4 public
open import Level2_5 public
open import Level2_6 public
open import Level2_7 public
open import Level2_8 public

-- Future sections will be re-exported here as they are added.
-- Level3_1: Locales (Chapter 3, Section 1)
-- This module encodes the structural content of Section 1 from the EBNF grammar.
-- It covers intuitionistic propositional calculus, Heyting algebras, locales, frames,
-- nuclei, open and etale morphisms, compactness, and regularity.

module Level3_1 where

open import Core

-- ============================================================================
-- Section 1.1: Intuitionistic Propositional Calculus
-- ============================================================================

-- Intuitionistic propositions (syntax)
record IntuitionisticProposition : Set where
  field
    -- Top, bottom, variables, conjunction, disjunction, implication
    propositionData : Set

-- Deduction sequent (Γ ⊢ p)
record DeductionSequent : Set where
  field
    context : Set  -- Set of assumptions
    conclusion : IntuitionisticProposition
    -- Corresponds to a morphism Product(context) → conclusion

-- Inference rules

record AssumptionRule : Set where
  field
    sequent : DeductionSequent
    assumption : IntuitionisticProposition
    -- Projection morphism from context to assumption

record ConjunctionIntroductionRule : Set where
  field
    sequentLeft : DeductionSequent
    sequentRight : DeductionSequent
    -- Universal morphism into product

record ConjunctionEliminationRule : Set where
  field
    sequentConjunction : DeductionSequent
    -- Projection from product

record ImplicationIntroductionRule : Set where
  field
    sequentWithAssumption : DeductionSequent
    -- Currying morphism into exponential

record ImplicationEliminationRule : Set where
  field
    sequentAntecedent : DeductionSequent
    sequentImplication : DeductionSequent
    -- Modus ponens: evaluation morphism

record TruthIntroductionRule : Set where
  field
    -- Unique morphism to terminal object
    trivialProof : Set

record FalsityEliminationRule : Set where
  field
    sequentFalse : DeductionSequent
    targetProposition : IntuitionisticProposition
    -- Unique morphism from initial object

-- ============================================================================
-- Section 1.2: Heyting Algebras
-- ============================================================================

-- Part 1: Definition and Core Adjunction

-- Heyting algebra declaration
record HeytingAlgebraDeclaration : Set where
  field
    underlyingLattice : Set  -- BoundedLatticeDeclaration
    implicationOperation : Set
    -- Adjointness axiom: (c ∧ a ≤ b) ⟺ (c ≤ (a → b))
    adjointnessAxiom : Set

-- Part 2: Structure-Preserving Maps

-- Heyting algebra homomorphism
record HeytingAlgebraHomomorphism : Set where
  field
    sourceAlgebra : HeytingAlgebraDeclaration
    targetAlgebra : HeytingAlgebraDeclaration
    underlyingMorphism : MorphismDeclaration
    -- Preserves lattice operations and implication
    preservesLatticeStructure : Set
    preservesImplication : Set

-- Part 3: Bridge from Logic to Algebra

-- Lindenbaum-Tarski theorem
record LindenbaumTarskiForIPCTheorem : Set where
  field
    -- Set of propositions under provable equivalence forms initial Heyting algebra
    propositionsQuotient : Set
    isHeytingAlgebra : HeytingAlgebraDeclaration
    isInitial : Set

-- ============================================================================
-- Section 1.3: Locales and Frames
-- ============================================================================

-- Frame declaration (complete Heyting algebra)
record FrameDeclaration : Set where
  field
    underlyingHeytingAlgebra : HeytingAlgebraDeclaration
    -- Complete lattice: has all joins and meets
    isCompleteLattice : Set
    -- Frame homomorphisms preserve finite meets and arbitrary joins
    frameStructure : Set

-- Locale declaration
record LocaleDeclaration : Set where
  field
    -- A locale is defined via its frame
    associatedFrame : FrameDeclaration

-- Part 1: The Two Categories

-- Category of frames
record CategoryOfFrames : Set where
  field
    -- Objects: frames
    frames : Set
    -- Morphisms: frame homomorphisms (preserve finite meets, arbitrary joins)
    frameHomomorphisms : Set
    categoryStructure : CategoryDeclaration

-- Category of locales
record CategoryOfLocales : Set where
  field
    -- Objects: locales
    locales : Set
    -- Morphisms: locale morphisms (dual to frame homomorphisms)
    localeMorphisms : Set
    categoryStructure : CategoryDeclaration

-- Part 2: The Core of the Duality - Locale Morphism

-- Locale morphism (represented by frame homomorphism in opposite direction)
record LocaleMorphismDeclaration : Set where
  field
    sourceLocale : LocaleDeclaration
    targetLocale : LocaleDeclaration
    -- A locale morphism L₁ → L₂ is represented by
    -- a frame homomorphism Frame(L₂) → Frame(L₁)
    representingFrameHomomorphism : Set

-- Part 3: Foundational Duality Theorem

-- Locale-Frame duality theorem
record LocaleFrameDualityTheorem : Set where
  field
    -- Loc ≅ Frm^op
    localeCategory : CategoryOfLocales
    frameCategory : CategoryOfFrames
    isOppositeCategory : Set

-- ============================================================================
-- Section 1.4: Completeness and Cocompleteness
-- ============================================================================

-- Theorem: Frm is complete
record FrmIsCompleteTheorem : Set where
  field
    frameCategory : CategoryOfFrames
    hasAllSmallLimits : Set

-- Dual theorem: Loc is cocomplete (derived via duality)
record LocIsCocompl eteTheorem : Set where
  field
    localeCategory : CategoryOfLocales
    hasAllSmallColimits : Set
    -- Derived from FrmIsComplete via duality

-- Locale coproduct via frame product
record LocaleCoproductViaFrameProductTheorem : Set where
  field
    locale1 : LocaleDeclaration
    locale2 : LocaleDeclaration
    -- Frame(L₁ ∐ L₂) ≅ Frame(L₁) × Frame(L₂)
    coproductFormula : Set

-- ============================================================================
-- Section 1.5: Nuclei
-- ============================================================================

-- Part 1: Formal Definition of a Nucleus

-- Nucleus declaration (closure operator on frame)
record NucleusDeclaration : Set where
  field
    frame : FrameDeclaration
    nucleusMap : Set  -- j : F → F
    -- Axiom 1: Inflationary (a ≤ j(a))
    inflationaryAxiom : Set
    -- Axiom 2: Monotone (a ≤ b ⇒ j(a) ≤ j(b))
    monotoneAxiom : Set
    -- Axiom 3: Idempotent (j(j(a)) = j(a))
    idempotentAxiom : Set
    -- Axiom 4: Preserves meets (j(a ∧ b) = j(a) ∧ j(b))
    preservesMeetsAxiom : Set

-- Part 2: Construction of Sublocale's Frame

-- Frame of fixed points
record FrameOfFixedPoints : Set where
  field
    nucleus : NucleusDeclaration
    -- Fix(j) is the frame of j-closed elements
    fixedPointsCarrier : Set
    -- Operations inherited/modified
    meetInherited : Set
    joinClosed : Set  -- j(Join(S))
    isFrame : FrameDeclaration

-- Part 3: Main Correspondence Theorem

-- Sublocale declaration
record SublocaleDeclaration : Set where
  field
    sublocale : LocaleDeclaration
    parentLocale : LocaleDeclaration
    -- Corresponds to monomorphism in Loc (surjection in Frm)
    isMonomorphism : Set

-- Sublocale-nucleus correspondence theorem
record SublocaleNucleusCorrespondenceTheorem : Set where
  field
    locale : LocaleDeclaration
    -- Bijection between sublocales and nuclei
    sublocales : Set
    nuclei : Set
    bijection : Set

-- ============================================================================
-- Section 1.6 & 1.7: Open and Etale Morphisms
-- ============================================================================

-- Part 1: Open Locale Morphisms

-- Direct image functor (left adjoint to frame homomorphism)
record DirectImageFunctor_of_FrameHom : Set where
  field
    frameHomomorphism : Set
    -- g_! is left adjoint to g
    leftAdjoint : Set

-- Functor preserves finite meets
record FunctorProperty_PreservesMeets : Set where
  field
    functor : FunctorDeclaration
    -- Preserves top and binary meets
    preservesTop : Set
    preservesBinaryMeets : Set

-- Open locale morphism
record OpenLocaleMorphismDeclaration : Set where
  field
    localeMorphism : LocaleMorphismDeclaration
    -- Underlying frame homomorphism has left adjoint
    hasLeftAdjoint : Set
    -- Left adjoint preserves finite meets
    leftAdjointPreservesMeets : FunctorProperty_PreservesMeets

-- Part 2: Etale Locale Morphisms

-- Beck-Chevalley condition
record BeckChevalleyCondition : Set where
  field
    adjunction : AdjunctionDeclaration
    -- For pullback squares, base change map is isomorphism
    baseChangeIsIsomorphism : Set

-- Etale locale morphism
record EtaleLocaleMorphismDeclaration : Set where
  field
    openMorphism : OpenLocaleMorphismDeclaration
    -- Adjunction satisfies Beck-Chevalley condition
    beckChevalley : BeckChevalleyCondition

-- Part 3: Geometric Equivalence Theorem

-- Theorem: Etale ⟺ Local homeomorphism
record EtaleIsLocalHomeomorphismTheorem : Set where
  field
    continuousMap : Set  -- Between sober spaces
    isLocalHomeomorphism : Set
    correspondingLocaleMorphism : LocaleMorphismDeclaration
    isEtale : EtaleLocaleMorphismDeclaration
    equivalence : Set

-- ============================================================================
-- Section 1.8 & 1.9: Topology and Locale Theory Connection
-- ============================================================================

-- Part 1: Functors Bridging the Two Worlds

-- Ω functor: Top → Loc (open sets functor)
record OmegaFunctor : Set where
  field
    -- Takes topological space to its locale of open sets
    actionOnSpaces : Set
    -- Takes continuous map to locale morphism via inverse image
    actionOnMaps : Set
    underlyingFunctor : FunctorDeclaration

-- pt functor: Loc → Top (points functor)
record PointsFunctor : Set where
  field
    -- Takes locale to space of frame homomorphisms to {0,1}
    actionOnLocales : Set
    -- Takes locale morphism to continuous map
    actionOnMorphisms : Set
    underlyingFunctor : FunctorDeclaration

-- Part 2: Main Adjunction and Unit/Counit

-- Theorem: Ω ⊣ pt
record OmegaIsLeftAdjointToPointsTheorem : Set where
  field
    omegaFunctor : OmegaFunctor
    pointsFunctor : PointsFunctor
    adjunction : AdjunctionDeclaration
    -- Hom_Loc(Ω(X), L) ≅ Hom_Top(X, pt(L))
    homIsomorphism : Set

-- Unit of Ω ⊣ pt adjunction
record UnitOfOmegaPtAdjunction : Set where
  field
    -- η : Id_Top ⇒ pt ∘ Ω
    -- Maps point x to frame homomorphism p_x
    naturalTransformation : Set
    componentMaps : Set

-- Counit of Ω ⊣ pt adjunction
record CounitOfOmegaPtAdjunction : Set where
  field
    -- ε : Ω ∘ pt ⇒ Id_Loc
    -- Maps frame element to open set of points satisfying it
    naturalTransformation : Set
    componentMaps : Set

-- Part 3: Sober Spaces, Spatial Locales, Equivalence

-- Sober space (unit is isomorphism)
record SoberSpaceDeclaration : Set where
  field
    space : Set  -- Topological space
    unitComponent : Set  -- η_X
    unitIsIsomorphism : Set

-- Spatial locale (counit is isomorphism)
record SpatialLocaleDeclaration : Set where
  field
    locale : LocaleDeclaration
    counitComponent : Set  -- ε_L
    counitIsIsomorphism : Set

-- Category of sober spaces
record CategoryOfSoberSpaces : Set where
  field
    soberSpaces : Set
    categoryStructure : CategoryDeclaration

-- Category of spatial locales
record CategoryOfSpatialLocales : Set where
  field
    spatialLocales : Set
    categoryStructure : CategoryDeclaration

-- Sober-Spatial equivalence theorem
record SoberSpatialEquivalenceTheorem : Set where
  field
    soberCategory : CategoryOfSoberSpaces
    spatialCategory : CategoryOfSpatialLocales
    restrictedOmega : FunctorDeclaration
    restrictedPt : FunctorDeclaration
    equivalence : Set

-- ============================================================================
-- Section 1.10 & 1.11: Compactness and Regularity
-- ============================================================================

-- Part 1: Compactness (Point-Free)

-- Frame cover
record FrameCover : Set where
  field
    frame : FrameDeclaration
    coveringSet : Set
    -- Join of covering set equals top element
    joinsToTop : Set

-- Finite subcover
record FiniteSubcover : Set where
  field
    originalCover : FrameCover
    finiteSubset : Set
    isFinite : Set
    stillCovers : Set

-- Compact frame
record CompactFrameDeclaration : Set where
  field
    frame : FrameDeclaration
    -- Every cover has a finite subcover
    everyCoversHasFiniteSubcover : Set

-- Compact locale
record CompactLocaleDeclaration : Set where
  field
    locale : LocaleDeclaration
    -- Frame is compact
    frameIsCompact : CompactFrameDeclaration

-- Theorem: Correspondence of compactness
record CorrespondenceOfCompactnessTheorem : Set where
  field
    soberSpace : SoberSpaceDeclaration
    isTopologicallyCompact : Set
    localeOfOpens : LocaleDeclaration
    isLocalicallyCompact : CompactLocaleDeclaration
    equivalence : Set

-- Part 2: Regularity (Point-Free)

-- Way below relation (b ≺ a)
record WayBelowRelation : Set where
  field
    frame : FrameDeclaration
    elementB : Set
    elementA : Set
    -- ∃c such that b ∧ c = 0 and a ∨ c = 1
    separatingElement : Set

-- Regular frame
record RegularFrameDeclaration : Set where
  field
    frame : FrameDeclaration
    -- Every element is join of elements way below it
    regularityCondition : Set

-- Regular locale
record RegularLocaleDeclaration : Set where
  field
    locale : LocaleDeclaration
    -- Frame is regular
    frameIsRegular : RegularFrameDeclaration

-- Theorem: Correspondence of regularity
record CorrespondenceOfRegularityTheorem : Set where
  field
    soberSpace : SoberSpaceDeclaration
    isTopologicallyRegular : Set
    localeOfOpens : LocaleDeclaration
    isLocalicallyRegular : RegularLocaleDeclaration
    equivalence : Set

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Set as a Heyting algebra
record SetAsHeytingAlgebraInstance : Set where
  field
    underlyingSet : Set
    subsetLattice : Set
    implicationViaComplement : Set
    isHeytingAlgebra : HeytingAlgebraDeclaration

-- Example: Frame of open sets of a topological space
record FrameOfOpenSetsInstance : Set where
  field
    topologicalSpace : Set
    openSetsLattice : Set
    isFrame : FrameDeclaration

-- Example: Compact Hausdorff spaces are sober
record CompactHausdorffIsSoberInstance : Set where
  field
    space : Set
    isCompactHausdorff : Set
    isSober : SoberSpaceDeclaration

-- ============================================================================
-- End of Level3_1
-- ============================================================================
-- Level3_2: Sheaves on Locales (Chapter 3, Section 2)
-- This module encodes the structural content of Section 2 from the EBNF grammar.
-- It covers presheaves, sheaves, gluing axioms, Grothendieck toposes, etale spaces,
-- stalks, change of base functors, Ω-sets, and sheaves of rings/modules.

module Level3_2 where

open import Core

-- ============================================================================
-- Section 2.1: Sheaves on a Locale
-- ============================================================================

-- Part 1: Presheaves

-- Presheaf on a locale
record PresheafOnLocale : Set where
  field
    locale : Set  -- LocaleDeclaration
    -- Contravariant functor Frame(L)^op → Set
    underlyingFunctor : Set

-- Part 2: Deconstructing the Gluing Axiom

-- Cover of an open in a frame
record CoverOfOpen : Set where
  field
    frame : Set  -- FrameDeclaration
    coveredElement : Set  -- Element of frame
    coveringSet : Set  -- Set of elements
    -- Join condition: covered element = ⋁ covering set
    joinCondition : Set

-- Matching family for a cover
record MatchingFamily : Set where
  field
    presheaf : PresheafOnLocale
    cover : CoverOfOpen
    -- Family of sections s_i ∈ P(a_i)
    familyOfSections : Set
    -- Compatibility on overlaps
    compatibilityCondition : Set

-- Sheaf gluing axiom
record SheafGluingAxiom : Set where
  field
    presheaf : PresheafOnLocale
    -- ∀ cover, ∀ matching family, ∃! amalgamation
    uniqueAmalgamationProperty : Set

-- Part 3: The Master Definition

-- Sheaf on a locale
record SheafOnLocaleDeclaration : Set where
  field
    underlyingPresheaf : PresheafOnLocale
    satisfiesGluingAxiom : SheafGluingAxiom

-- ============================================================================
-- Section 2.2-2.3: Properties of the Category of Sheaves, Sh(L)
-- ============================================================================

-- Part 1: The Main Theorem - Sh(L) is a Topos

-- Category of sheaves
record CategoryOfSheaves : Set where
  field
    locale : Set  -- LocaleDeclaration
    -- Full subcategory of presheaves
    underlyingCategory : CategoryDeclaration
    sheaves : Set  -- Objects are sheaves
    naturalTransformations : Set  -- Morphisms

-- Grothendieck topos declaration
record GrothendieckToposDeclaration : Set where
  field
    category : CategoryDeclaration
    -- Giraud axioms
    giraudAxiom1_CocompletenessAndGenerators : Set
    giraudAxiom2_DisjointCoproductsStableUnderPullback : Set
    giraudAxiom3_EffectiveEquivalenceRelations : Set

-- Theorem: Sh(L) is a Grothendieck topos
record CategoryOfSheavesIsAToposTheorem : Set where
  field
    locale : Set  -- LocaleDeclaration
    sheafCategory : CategoryOfSheaves
    isGrothendieckTopos : GrothendieckToposDeclaration

-- Part 2: Consequences - Completeness, CCC, and Subobject Classifier

-- Presheaf category
record PresheafCategory : Set where
  field
    locale : Set  -- LocaleDeclaration
    -- [Frame(L)^op, Set]
    underlyingCategory : CategoryDeclaration

-- Limit in sheaf category
record LimitInSheafCategory : Set where
  field
    diagram : Set  -- DiagramDeclaration in Sh(L)
    -- Computed as in Psh(L); automatically a sheaf
    limitObject : Set

-- Colimit in sheaf category
record ColimitInSheafCategory : Set where
  field
    diagram : Set  -- DiagramDeclaration in Sh(L)
    -- Sheafification of colimit in Psh(L)
    colimitInPresheaves : Set
    sheafificationStep : Set

-- Internal hom at presheaf level
record InternalHomPresheaf : Set where
  field
    sourcePresheaf : PresheafOnLocale
    targetPresheaf : PresheafOnLocale
    -- PshHom(F,G)(U) = Hom_{Psh(L/U)}(F|_U, G|_U)
    homPresheaf : PresheafOnLocale

-- Exponential object in Sh(L)
record ExponentialObject_Sheaf : Set where
  field
    baseSheaf : SheafOnLocaleDeclaration
    exponentSheaf : SheafOnLocaleDeclaration
    -- Sheafification of presheaf-level internal hom
    presheafExponential : InternalHomPresheaf
    sheafifiedExponential : SheafOnLocaleDeclaration

-- Characteristic map constructor
record CharacteristicMapConstructor : Set where
  field
    subsheafMono : Set  -- MonomorphismDeclaration S ↪ F
    parentSheaf : SheafOnLocaleDeclaration
    subsheaf : SheafOnLocaleDeclaration
    -- χ_m : F → Ω
    characteristicMap : Set
    -- For s ∈ F(U), returns largest V where s|_V ∈ S
    measurementFunction : Set

-- Subobject classifier axiom
record SubobjectClassifierAxiom : Set where
  field
    monomorphism : Set  -- S ↪ F
    -- Pullback square with true : 1 → Ω
    pullbackProperty : Set
    characteristicMap : CharacteristicMapConstructor

-- ============================================================================
-- Section 2.4-2.5: Etale Spaces and Stalks
-- ============================================================================

-- Part 1: Geometric Perspective

-- Local homeomorphism property
record MorphismPropertyAssertion_LocalHomeomorphism : Set where
  field
    morphism : MorphismDeclaration  -- in Top
    sourceSpace : Set
    targetSpace : Set
    -- ∀ point, ∃ neighborhood mapped homeomorphically
    localHomeomorphismCondition : Set

-- Etale space over a base
record EtaleSpaceOver : Set where
  field
    totalSpace : Set  -- E
    baseSpace : Set  -- X
    projection : MorphismDeclaration  -- p : E → X
    isLocalHomeomorphism : MorphismPropertyAssertion_LocalHomeomorphism

-- Category of etale spaces
record CategoryOfEtaleSpaces : Set where
  field
    baseSpace : Set  -- X
    etaleSpaces : Set  -- Objects
    -- Morphisms respect projection
    baseFibreMorphisms : Set
    categoryStructure : CategoryDeclaration

-- Part 2a: Algebraic-to-Geometric Bridge (Stalks → Total Space)

-- Diagram of neighborhoods
record Diagram_of_Neighborhoods : Set where
  field
    locale : Set  -- LocaleDeclaration
    point : Set  -- PointOf(L)
    presheaf : PresheafOnLocale
    -- Directed system over neighborhoods
    neighborhoodDiagram : Set

-- Germ of a presheaf
record GermOfAPresheaf : Set where
  field
    presheaf : PresheafOnLocale
    point : Set  -- PointDeclaration
    representativeSection : Set  -- ElementDeclaration
    -- Equivalence class of sections
    germEquivalenceClass : Set

-- Stalk constructor
record StalkConstructor : Set where
  field
    presheaf : PresheafOnLocale
    point : Set  -- PointDeclaration
    -- Colimit over neighborhoods
    stalkSet : Set  -- Set of germs

-- Basic open in etale space
record BasicOpen_in_EtaleSpace : Set where
  field
    presheaf : PresheafOnLocale
    section : Set  -- ElementDeclaration
    openSet : Set  -- In base space
    -- {Germ(F, p, s) | p ∈ U}
    basicOpenSubset : Set

-- Total space of stalks
record TotalSpaceOfStalks : Set where
  field
    presheaf : PresheafOnLocale
    baseLocale : Set  -- LocaleDeclaration
    -- Disjoint union of stalks
    underlyingSet : Set
    -- Topology from basic opens
    topologyStructure : Set
    projectionMap : Set

-- Part 2b: Geometric-to-Algebraic Bridge (Sections)

-- Continuous section
record ContinuousSection : Set where
  field
    etaleSpace : EtaleSpaceOver
    openSet : Set  -- In base space
    -- Right-inverse to projection
    sectionMap : Set
    continuityProperty : Set

-- Sheaf of sections functor
record SheafOfSectionsFunctor : Set where
  field
    etaleSpace : EtaleSpaceOver
    -- Presheaf of sections
    underlyingPresheaf : PresheafOnLocale
    -- Always a sheaf
    isSheaf : SheafOnLocaleDeclaration

-- Theorem: Sections of etale space form a sheaf
record SectionsOfEtaleSpaceFormASheafTheorem : Set where
  field
    etaleSpace : EtaleSpaceOver
    sectionsPresheaf : PresheafOnLocale
    satisfiesGluingAxiom : SheafGluingAxiom

-- Part 3: Main Equivalence Theorem

-- Sheaf-Etale equivalence theorem
record SheafEtaleEquivalenceTheorem : Set where
  field
    soberSpace : Set  -- SoberSpaceDeclaration
    sheafCategory : CategoryOfSheaves
    etaleCategory : CategoryOfEtaleSpaces
    -- F_stalks : Sh(X) → Etale(X)
    stalksToEtaleFunctor : FunctorDeclaration
    -- G_sections : Etale(X) → Sh(X)
    sectionsToSheafFunctor : FunctorDeclaration
    equivalenceOfCategories : Set

-- ============================================================================
-- Section 2.6: Associated Sheaves and Etale Morphisms
-- ============================================================================

-- Part 1: Change of Base Functors

-- Direct image functor (locale version)
record DirectImageFunctor_Locale : Set where
  field
    localeMorphism : Set  -- LocaleMorphismDeclaration
    sourceLocale : Set
    targetLocale : Set
    -- f_* : Sh(L) → Sh(M)
    underlyingFunctor : FunctorDeclaration
    -- Pre-composition with frame homomorphism
    actionOnSheaves : Set

-- Inverse image functor (locale version)
record InverseImageFunctor_Locale : Set where
  field
    localeMorphism : Set  -- LocaleMorphismDeclaration
    sourceLocale : Set
    targetLocale : Set
    -- f* : Sh(M) → Sh(L)
    underlyingFunctor : FunctorDeclaration
    -- Involves sheafification
    sheafificationComponent : Set

-- Locale change of base adjunction theorem
record LocaleChangeOfBaseAdjunctionTheorem : Set where
  field
    localeMorphism : Set  -- LocaleMorphismDeclaration
    inverseImageFunctor : InverseImageFunctor_Locale
    directImageFunctor : DirectImageFunctor_Locale
    -- f* ⊣ f_*
    adjunction : AdjunctionDeclaration

-- Part 2: Main Equivalence for Etale Morphisms

-- Etale morphism induces sheaf equivalence theorem
record EtaleMorphismInducesSheafEquivalenceTheorem : Set where
  field
    etaleMorphism : Set  -- ETALE LocaleMorphismDeclaration
    sourceLocale : Set
    targetLocale : Set
    inverseImageFunctor : InverseImageFunctor_Locale
    -- f* is an equivalence of categories
    isEquivalenceOfCategories : Set

-- ============================================================================
-- Section 2.7-2.9: Internal Logic, Ω-sets, and Completeness
-- ============================================================================

-- Part 1: The Internal Set (The Ω-set)

-- Step 1: Data of an Ω-set

-- Ω-set data
record OmegaSetData : Set where
  field
    frame : Set  -- FrameDeclaration (our Ω)
    elementsSet : Set  -- Classical set X
    -- δ : X × X → Ω
    equalityPredicate : Set

-- Step 2: Axioms for the Equality Predicate

-- Reflexivity axiom for Ω-set
record OmegaSet_ReflexivityAxiom : Set where
  field
    omegaSetData : OmegaSetData
    -- ∀x, δ(x,x) = ⊤
    reflexivityCondition : Set

-- Symmetry axiom for Ω-set
record OmegaSet_SymmetryAxiom : Set where
  field
    omegaSetData : OmegaSetData
    -- ∀x,y, δ(x,y) = δ(y,x)
    symmetryCondition : Set

-- Transitivity axiom for Ω-set
record OmegaSet_TransitivityAxiom : Set where
  field
    omegaSetData : OmegaSetData
    -- ∀x,y,z, δ(x,y) ∧ δ(y,z) ≤ δ(x,z)
    transitivityCondition : Set

-- Step 3: Assembled Definition and Morphisms

-- Verified Ω-set declaration
record OmegaSetDeclaration_Verified : Set where
  field
    data_omegaSet : OmegaSetData
    reflexivityProof : OmegaSet_ReflexivityAxiom
    symmetryProof : OmegaSet_SymmetryAxiom
    transitivityProof : OmegaSet_TransitivityAxiom

-- Ω-set homomorphism
record OmegaSetHomomorphism : Set where
  field
    sourceOmegaSet : OmegaSetDeclaration_Verified
    targetOmegaSet : OmegaSetDeclaration_Verified
    underlyingFunction : Set
    -- Respects Ω-valued equality
    respectsEquality : Set

-- Category of Ω-sets
record Category_of_OmegaSets : Set where
  field
    frame : Set  -- FrameDeclaration
    omegaSets : Set  -- Objects
    omegaHomomorphisms : Set  -- Morphisms
    categoryStructure : CategoryDeclaration

-- Part 2: The Main Equivalence Theorem (Sheaves as Complete Ω-Sets)

-- Part 2a: Functor from Sheaves to Ω-Sets

-- Functor A: Sh(L) → Complete Ω-Set(F)
record Functor_SheafToOmegaSet : Set where
  field
    locale : Set  -- LocaleDeclaration
    frame : Set  -- FrameDeclaration
    -- Action on objects
    actionOnSheaves : Set
    -- Global elements X = F(1)
    globalElementsExtraction : Set
    -- Equality predicate from agreement
    equalityFromAgreement : Set
    -- Action on morphisms
    actionOnMorphisms : Set
    underlyingFunctor : FunctorDeclaration

-- Part 2b: Functor from Ω-Sets to Sheaves

-- Functor S: Complete Ω-Set(F) → Sh(L)
record Functor_OmegaSetToSheaf : Set where
  field
    frame : Set  -- FrameDeclaration
    locale : Set  -- LocaleDeclaration
    -- Action on objects
    actionOnOmegaSets : Set
    -- U-elements as sections
    uElementsConstruction : Set
    -- Completeness ensures sheaf property
    completenessImpliesSheaf : Set
    -- Action on morphisms
    actionOnMorphisms : Set
    underlyingFunctor : FunctorDeclaration

-- Part 2c: Refined Equivalence Theorem

-- Sheaves are complete Ω-sets theorem (refined)
record SheavesAreCompleteOmegaSets_RefinedTheorem : Set where
  field
    locale : Set  -- LocaleDeclaration
    frame : Set  -- FrameDeclaration
    sheafCategory : CategoryOfSheaves
    completeOmegaSetCategory : Category_of_OmegaSets
    functorA : Functor_SheafToOmegaSet
    functorS : Functor_OmegaSetToSheaf
    -- S ∘ A ≅ Id and A ∘ S ≅ Id
    quasiInverses : Set

-- ============================================================================
-- Section 2.10: Basic Facts in Ring Theory (Context for Sheaves of Modules)
-- ============================================================================

-- Sheaf of rings
record SheafOfRings : Set where
  field
    locale : Set  -- LocaleDeclaration
    underlyingSheaf : SheafOnLocaleDeclaration
    -- Each section is a ring
    ringStructureOnSections : Set
    -- Restrictions are ring homomorphisms
    restrictionsPreserveRingStructure : Set

-- Sheaf of O-modules
record SheafOfOModules : Set where
  field
    locale : Set  -- LocaleDeclaration
    sheafOfRings : SheafOfRings
    underlyingSheaf : SheafOnLocaleDeclaration
    -- Each section is an O-module
    moduleStructureOnSections : Set
    -- Restrictions are O-linear
    restrictionsAreOLinear : Set

-- Category of O-modules is abelian corollary
record CategoryOfOModulesIsAbelianCorollary : Set where
  field
    sheafOfRings : SheafOfRings
    categoryOfOModules : CategoryDeclaration
    -- Inherits abelian structure pointwise
    isAbelianCategory : Set
    -- Enables homological algebra
    homologicalAlgebraAvailable : Set

-- ============================================================================
-- Instances and Examples
-- ============================================================================

-- Example: Constant sheaf
record ConstantSheafInstance : Set where
  field
    locale : Set  -- LocaleDeclaration
    set : Set
    constantSheaf : SheafOnLocaleDeclaration
    -- All sections are constant maps
    sectionsAreConstant : Set

-- Example: Structure sheaf on a scheme
record StructureSheafInstance : Set where
  field
    scheme : Set
    structureSheaf : SheafOfRings
    -- Fundamental object in algebraic geometry
    geometricInterpretation : Set

-- Example: Sheafification functor
record SheafificationFunctorInstance : Set where
  field
    locale : Set  -- LocaleDeclaration
    presheafCategory : PresheafCategory
    sheafCategory : CategoryOfSheaves
    -- Left adjoint to inclusion
    sheafificationFunctor : FunctorDeclaration
    inclusionFunctor : FunctorDeclaration
    adjunction : AdjunctionDeclaration

-- ============================================================================
-- End of Level3_2
-- ============================================================================
module EBNF3.Index where

-- Aggregator for chapter 3 EBNF-derived modules

open import Level3_1 public
open import Level3_2 public
