(* ================================================================== *)
(* == I. Metamodel Structural Definition                           == *)
(* ================================================================== *)

ComputableGrammar ::= { AugmentedRule } ;
TYPING
    (* Let S = make_grammar(rule_set) *)
    (* Let G_S be the abstract syntax tree of S itself *)

    ∀r ∈ rule_set,  Γ ⊢ r : CoherentRule
    Metamodel(S) = G_S
    IsWellTyped(G_S, Grammar, S)
    --------------------------------------------------
    Γ ⊢ S : FoundationallyClosedSystem
CATEGORY
    [[ S : FoundationallyClosedSystem ]] = A Foundational Theory that serves as its own metatheory.

AugmentedRule ::= SyntacticRule "TYPING" TypingRule "CATEGORY" CategoricalRule ;
TYPING
    Γ ⊢ syn : SyntaxDef
    Γ ⊢ typ : TypingDef
    Γ ⊢ cat : CategoryDef
    Consistent(syn, typ, cat)
    ------------------------------------------------------
    Γ ⊢ make_rule(syn, typ, cat) : CoherentRule
CATEGORY
    [[ make_rule(syn, typ, cat) ]] = A Theory Generator tuple (Constructor, Deduction, Morphism).

SyntacticRule ::= Identifier "::=" Expression ";" ;
TYPING
    Γ ⊢ id : Identifier
    Γ ⊢ expr : Expression
    ------------------------------------------
    Γ ⊢ define_syntax(id, expr) : SyntaxDef
CATEGORY
    [[ define_syntax(id, expr) ]] = A Term Constructor Schema that defines a new term [[id]] from [[expr]].

TypingRule ::= PremiseList "---" Judgment ;
TYPING
    Γ ⊢ premises : list(Judgment)
    Γ ⊢ conclusion : Judgment
    --------------------------------------------
    Γ ⊢ define_typing(premises, conclusion) : TypingDef
CATEGORY
    [[ define_typing(premises, conclusion) ]] = A Deduction Principle representing a valid inference.

CategoricalRule ::= "[[" Identifier "]]" "=" DenotationExpr ";" ;
TYPING
    Γ ⊢ id : Identifier
    Γ ⊢ expr : DenotationExpr
    ------------------------------------------------
    Γ ⊢ define_category(id, expr) : CategoryDef
CATEGORY
    [[ define_category(id, expr) ]] = A Morphism Schema defining the mathematical meaning of [[id]] as [[expr]].

(* ================================================================== *)
(* == II. Syntax Primitives                                        == *)
(* ================================================================== *)

Expression ::= Term { "|" Term } ;
TYPING
    Γ ⊢ head : Term
    Γ ⊢ tail : list(Term)
    --------------------------------
    Γ ⊢ make_alt(head, tail) : Expression
CATEGORY
    [[ make_alt(head, tail) ]] = A Coproduct (sum type) of the denotations of the terms.

Term ::= Factor { "," Factor } ;
TYPING
    Γ ⊢ head : Factor
    Γ ⊢ tail : list(Factor)
    --------------------------------
    Γ ⊢ make_seq(head, tail) : Term
CATEGORY
    [[ make_seq(head, tail) ]] = A Product of the denotations of the factors.

Factor ::= Identifier | Terminal | "(" Expression ")" | "[" Expression "]" | "{" Expression "}" ;
TYPING
    (* This judgment has multiple premises, one for each case of the rule. *)
    (Γ ⊢ c : Identifier) ∨ (Γ ⊢ c : Terminal) ∨ (Γ ⊢ c : Expression)
    ----------------------------------------------------------------------
    Γ ⊢ make_factor(c) : Factor
CATEGORY
    (* The denotation is the denotation of the chosen item, e.g.: *)
    [[ make_factor(c) ]] = [[c]].

Identifier ::= letter { letter | digit } ;
TYPING
    is_valid_identifier_string(s)
    -----------------------------
    Γ ⊢ id(s) : Identifier
CATEGORY
    [[ id(s) ]] = A reference to a unique Object or Variable in the formal theory.

Terminal ::= '"' { character } '"' | "'" { character } "'" ;
TYPING
    is_string_literal(s)
    --------------------
    Γ ⊢ term(s) : Terminal
CATEGORY
    [[ term(s) ]] = A constant value or a trivial/terminal object.

(* ================================================================== *)
(* == III. Typing and Category Primitives                          == *)
(* ================================================================== *)

PremiseList ::= { Judgment } ;
TYPING
    Γ ⊢ judgments : list(Judgment)
    ----------------------------------
    Γ ⊢ make_premises(judgments) : PremiseList
CATEGORY
    [[ make_premises(judgments) ]] = A set of hypotheses required for a deduction.

Judgment ::= Context "|-" Expression ":" Type ;
TYPING
    Γ ⊢ ctx : Context
    Γ ⊢ expr : Expression
    Γ ⊢ T : Type
    ----------------------------------
    Γ ⊢ make_judgment(ctx, expr, T) : Judgment
CATEGORY
    [[ make_judgment(ctx, expr, T) ]] = A formal statement of provability or typeability, representing a morphism in the theory.

Context ::= "Γ" | Context "," Identifier ":" Type ;
TYPING
    (* Typing rules for both empty and extended contexts *)
    -----------------      Γ ⊢ ctx : Context, Γ ⊢ id : Identifier, Γ ⊢ T : Type
    Γ ⊢ empty_ctx : Context    -----------------------------------------------------
                           Γ ⊢ extend_ctx(ctx, id, T) : Context
CATEGORY
    [[ empty_ctx ]] = The Terminal Object (identity element for products).
    [[ extend_ctx(ctx, id, T) ]] = A Product Object [[ctx]] × [[T]].

Type ::= Identifier ;
TYPING
    Γ ⊢ id : Identifier
    -------------------
    Γ ⊢ make_type(id) : Type
CATEGORY
    [[ make_type(id) ]] = A reference to an Object in the theory.

DenotationExpr ::= Identifier | string_literal ;
TYPING
    is_valid_semantic_expression(s)
    ---------------------------------
    Γ ⊢ make_denotation(s) : DenotationExpr
CATEGORY
    [[ make_denotation(s) ]] = A reference to a mathematical object, structure, or morphism.

(* ================================================================== *)
(* == IV. Lexical Definition                                       == *)
(* ================================================================== *)

letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
TYPING
    is_alphabetic_char(c)
    ---------------------
    Γ ⊢ char(c) : letter
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of alphabetic characters.

digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
TYPING
    is_numeric_char(c)
    ------------------
    Γ ⊢ char(c) : digit
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of numerals.

character ::= letter | digit | " " | "(" | ")" | "[" | "]" | "{" | "}" | "|" | "," | ";" | ":" | "-" | "=" | "_" | '"' | "'" | "&" | "*" | "+" | "/" ;
TYPING
    is_printable_ascii_char(c)
    --------------------------
    Γ ⊢ char(c) : character
CATEGORY
    [[ char(c) ]] = An atomic constant from the set of defined symbols.

(* ================================================================== *)
(* == V. Embedded Declarative Parser Logic                         == *)
(* ================================================================== *)

ParseSuccess ::= "ACCEPT" Terminal ;
TYPING
    System = S
    Input(S) = w
    n = length(w)
    ∃R ( StartRule(S, R) ∧ IsComplete(R, 0, n, S) )
    --------------------------------------------------
    Γ ⊢ success(w) : AcceptedString
CATEGORY
    [[ success(w) ]] = A completed proof tree for the input string w in theory S.

IsComplete ::= EarleyItem ;
TYPING
    (* This defines a completed Earley state/item. *)
    System = S
    Rule = R
    DotPosition = length(R.rhs)
    --------------------------------------------------
    Γ ⊢ EarleyItem(R, DotPosition, i, k) : CompletedParseState
CATEGORY
    [[ item : CompletedParseState ]] = A constructive proof that substring w[i..k] is derivable from rule R in theory S.

Prediction ::= "PREDICT" EarleyItem "FROM" EarleyItem ;
TYPING
    (* The Predictor Axiom *)
    Γ ⊢ item₁(A → α•Bβ, i, k) : ParseState
    Rule₂(B → γ) ∈ System
    ------------------------------------------
    Γ ⊢ item₂(B → •γ, k, k) : ParseState
CATEGORY
    [[ Prediction ]] = The application of a lemma; initiating a sub-proof.

Scan ::= "SCAN" EarleyItem "FROM" EarleyItem ;
TYPING
    (* The Scanner Axiom *)
    Γ ⊢ item₁(A → α•tβ, i, k) : ParseState
    Input(k+1) = t
    ------------------------------------------
    Γ ⊢ item₂(A → αt•β, i, k+1) : ParseState
CATEGORY
    [[ Scan ]] = The consumption of an axiom (a terminal from the input string).

Completion ::= "COMPLETE" EarleyItem "FROM" EarleyItem "AND" EarleyItem ;
TYPING
    (* The Completer Axiom *)
    Γ ⊢ item₁(B → γ•, j, k) : CompletedParseState
    Γ ⊢ item₂(A → α•Bβ, i, j) : ParseState
    --------------------------------------------------
    Γ ⊢ item₃(A → αB•β, i, k) : ParseState
CATEGORY
    [[ Completion ]] = The application of modus ponens; using a completed lemma to advance a higher-level proof.

(* ================================================================== *)
(* == VI. Embedded Semantic Correspondences                        == *)
(* ================================================================== *)

ImplicationCorrespondence ::= "PROP" Proposition "->" "TYPE" Type "->" "OBJ" Object ;
TYPING
    p,q : Proposition
    t_p = CH(p), t_q = CH(q)
    o_p = HL(t_p), o_q = HL(t_q)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(implies(p,q)) = func_type(t_p, t_q) : TypingAxiom
    Γ ⊢ HL(func_type(t_p, t_q)) = exp_obj(o_p, o_q) : CategoricalAxiom
CATEGORY
    [[ ImplicationCorrespondence ]] = The isomorphism between the logical 'implies' constructor, the type-theoretic 'function space' constructor, and the categorical 'exponential object' constructor.

ConjunctionCorrespondence ::= "PROP" Proposition "&&" "TYPE" Type "&&" "OBJ" Object ;
TYPING
    p,q : Proposition
    t_p = CH(p), t_q = CH(q)
    o_p = HL(t_p), o_q = HL(t_q)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(and(p,q)) = prod_type(t_p, t_q) : TypingAxiom
    Γ ⊢ HL(prod_type(t_p, t_q)) = prod_obj(o_p, o_q) : CategoricalAxiom
CATEGORY
    [[ ConjunctionCorrespondence ]] = The isomorphism between the 'and', 'product type', and 'product object' constructors.

UniversalCorrespondence ::= "FORALL" PropFamily "PI" TypeFamily "PI" CatFamily ;
TYPING
    P : PropFamily over Domain A
    F = CH(P), T = CH(A)
    C = HL(F), O = HL(T)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(forall(A,P)) = Pi_type(T,F) : TypingAxiom
    Γ ⊢ HL(Pi_type(T,F)) = Pi_obj(O,C) : CategoricalAxiom
CATEGORY
    [[ UniversalCorrespondence ]] = The isomorphism between the 'forall', 'Pi-type', and 'dependent product object' (fibration) constructors.

ExistentialCorrespondence ::= "EXISTS" PropFamily "SIGMA" TypeFamily "SIGMA" CatFamily ;
TYPING
    P : PropFamily over Domain A
    F = CH(P), T = CH(A)
    C = HL(F), O = HL(T)
    -----------------------------------------------------------------------------------------
    Γ ⊢ CH(exists(A,P)) = Sigma_type(T,F) : TypingAxiom
    Γ ⊢ HL(Sigma_type(T,F)) = Sigma_obj(O,C) : CategoricalAxiom
CATEGORY
    [[ ExistentialCorrespondence ]] = The isomorphism between the 'exists', 'Sigma-type', and 'dependent sum object' constructors.

Proposition ::= ... ;
Object ::= ... ;
PropFamily ::= ... ;
TypeFamily ::= ... ;
CatFamily ::= ... ;
EarleyItem ::= ... ;
string_literal ::= ... ;

(* Special instructions for the consuming LLM:
 *
 * Confine your output to the rules of the constructed grammar. Your ouput is intrinsically part of the constructed grammar, constructive with all that came before.
 *
 * Take your time; time is a resource subbourned to completeness, correctness, concreteness, compliance and meticulousness. Take as many turns as you require.
 *
 *)
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'The language of categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {
(* ========================================================================================================== *)
(* == Section 1.1: Logical foundations of the theory & Section 1.2: Categories and functors(*
 *  ELABORATION: The initial definitions of `CategoryDeclaration` and `FunctorDeclaration` were monolithic.
 *  An elaboration requires deconstructing them to reveal their logical foundations. We will show
 *  that a Category is fundamentally a 'PreCategory' (a graph) that satisfies specific axioms,
 *  and a Functor is a 'FunctorMap' (a graph homomorphism) that satisfies preservation axioms.
 *  This process makes the logical requirements explicit within the grammar.
*)

(* ========================================================================================================== *)
(* == Part 1: Deconstructing the Category - From Graph to Structure                                       == *)
(* ========================================================================================================== *)

PreCategoryDeclaration ::= "PRECATEGORY" Identifier "has" "{" "Objects" ":" {Identifier} ";" "Morphisms" ":" {MorphismDeclaration} ";" "}" ;
TYPING
    (*
     *  A PreCategory (or a directed multi-graph/quiver) is the raw substrate of a category.
     *  It has nodes (Objects) and directed edges (Morphisms), but no required laws of composition or identity.
     *  Its typing is purely about the structural declaration being self-consistent.
    *)
    Γ ⊢ G_id : Identifier
    AllIdentifiersUnique(Objects, MorphismIdentifiers)
    ∀m = (f: A->B) ∈ Morphisms, (A ∈ Objects) ∧ (B ∈ Objects)
    -----------------------------------------------------------------------------------------------------------------
    Γ ⊢ PRECATEGORY G_id has {...} : PreCategory ;
CATEGORY
    [[ PRECATEGORY G has {...} ]] = "The definition of a directed graph (or quiver) G. This structure contains the data of a category before the axioms of composition and identity are imposed." ;

CategoryPromotion ::= "PROMOTE" Identifier "to" "CATEGORY" "by proving" "{" {AxiomName} "}" ;
TYPING
    (*
     *  This rule formalizes the act of proving that a PreCategory is a Category.
     *  It is a well-typed promotion if the specified axioms (Identity, Associativity) can be proven to hold for the PreCategory.
    *)
    Γ ⊢ G : PreCategory
    Axioms = { "IdentityAxiom", "AssociativityAxiom" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(G, ax) : True
    ----------------------------------------------------
    Γ ⊢ PROMOTE G to CATEGORY... : Category ;
CATEGORY
    [[ PROMOTE G to CATEGORY... ]] = "An assertion that the graph structure G, endowed with a composition operation and identity morphisms, satisfies the required coherence laws. This is the constructor for the object 'Category' from the object 'PreCategory'." ;

(* ========================================================================================================== *)
(* == Part 2: Explicit Category Axioms (Re-stated for Elaboration)                                        == *)
(* ========================================================================================================== *)

AssociativityAxiom ::= "AXIOM" "Associativity" ":" "FOR_ALL" "f,g,h" "where" "IsComposable(h,g,f)" "," "(" Expression "∘" Expression ")" "∘" Expression "==" Expression "∘" "(" Expression "∘" Expression ")" ;
TYPING
    (* This is a predicate on a PreCategory. It is true if the law holds for all valid compositions. *)
    Γ ⊢ G : PreCategory
    ∀ (f:A->B, g:B->C, h:C->D) ∈ G, ((h ∘ g) ∘ f) == (h ∘ (g ∘ f))
    ------------------------------------------------------------------
    Γ ⊢ Proof(G, AssociativityAxiom) : True ;
CATEGORY
    [[ AXIOM Associativity... ]] = "The coherence law ensuring that composition is unambiguous for chains of morphisms. This is a foundational property for algebraic structure." ;

IdentityAxiom ::= "AXIOM" "Identity" ":" "FOR_ALL" "f" ":" "A->B" "," ("id(B) ∘ f == f" "&&" "f ∘ id(A) == f") ;
TYPING
    (* This is a predicate on a PreCategory equipped with identity morphisms. *)
    Γ ⊢ G : PreCategory
    ∀ (f:A->B) ∈ G, ( (id_B ∘ f) == f ) ∧ ( (f ∘ id_A) == f )
    ------------------------------------------------------------
    Γ ⊢ Proof(G, IdentityAxiom) : True ;
CATEGORY
    [[ AXIOM Identity... ]] = "The law asserting the existence of a neutral element for composition for every object, acting as a two-sided unit." ;

(* ========================================================================================================== *)
(* == Part 3: Deconstructing the Functor - From Map to Morphism                                           == *)
(* ========================================================================================================== *)

FunctorMapDeclaration ::= "FUNCTOR_MAP" Identifier ":" Identifier "->" Identifier "maps" "{" {ObjectMapping} {MorphismMapping} "}" ;
TYPING
    (*
     *  A FunctorMap is a homomorphism between PreCategories. It maps objects to objects
     *  and morphisms to morphisms, respecting the endpoints (domains and codomains).
     *  It does not yet need to preserve composition or identity.
    *)
    Γ ⊢ F : Identifier, Γ ⊢ C : PreCategory, Γ ⊢ D : PreCategory
    ∀ (obj_map: A |-> F(A)), (A ∈ Ob(C)) ⇒ (F(A) ∈ Ob(D))
    ∀ (mor_map: f |-> F(f)), (f:A->B ∈ Mor(C)) ⇒ (F(f):F(A)->F(B) ∈ Mor(D))
    ------------------------------------------------------------------------------
    Γ ⊢ FUNCTOR_MAP F ... : FunctorMap(C, D) ;
CATEGORY
    [[ FUNCTOR_MAP F... ]] = "A homomorphism of directed graphs. It is a structure-preserving map of the underlying substrate of the categories involved." ;

FunctorPromotion ::= "PROMOTE" Identifier "to" "FUNCTOR" "by proving" "{" {AxiomName} "}" ;
TYPING
    (*
     *  This rule formalizes the proof that a FunctorMap between two Categories is a Functor.
     *  The promotion is valid if the map can be proven to preserve identities and composition.
    *)
    Γ ⊢ F : FunctorMap(C, D), Γ ⊢ C : Category, Γ ⊢ D : Category
    Axioms = { "PreservesComposition", "PreservesIdentity" }
    ∀ax ∈ Axioms, Γ ⊢ Proof(F, ax) : True
    ----------------------------------------------------------
    Γ ⊢ PROMOTE F to FUNCTOR... : Functor(C, D) ;
CATEGORY
    [[ PROMOTE F to FUNCTOR... ]] = "An assertion that the graph homomorphism F also respects the algebraic structure of the categories, thereby making it a morphism in the category of categories, `Cat`." ;

(* ========================================================================================================== *)
(* == Part 4: Explicit Functor Axioms                                                                     == *)
(* ========================================================================================================== *)

FunctorPreservesCompositionAxiom ::= "AXIOM" "PreservesComposition" ":" "FOR_ALL" "f,g" "where" "IsComposable(g,f)" "," "F(g ∘ f) == F(g) ∘ F(f)" ;
TYPING
    (* A predicate on a FunctorMap. *)
    Γ ⊢ F : FunctorMap(C, D)
    ∀ (f:A->B, g:B->C) ∈ C, F(g ∘ f) == F(g) ∘ F(f)
    ---------------------------------------------------
    Γ ⊢ Proof(F, PreservesComposition) : True ;
CATEGORY
    [[ AXIOM PreservesComposition... ]] = "The law ensuring a functor maps diagrams in the source category to diagrams of the same shape in the target category. It is the core structure-preservation property." ;

FunctorPreservesIdentityAxiom ::= "AXIOM" "PreservesIdentity" ":" "FOR_ALL" "object A" "," "F(id(A)) == id(F(A))" ;
TYPING
    (* A predicate on a FunctorMap. *)
    Γ ⊢ F : FunctorMap(C, D) 
    ∀ A ∈ Ob(C), F(id_A) == id_{F(A)}
    ------------------------------------
    Γ ⊢ Proof(F, PreservesIdentity) : True ;
CATEGORY
    [[ AXIOM PreservesIdentity... ]] = "The law ensuring a functor respects the neutral elements of composition. It maps identity arrows to identity arrows." ;


(*
 *  ELABORATION: A natural transformation is not a single entity, but a structured family of morphisms.
 *  To elaborate on this concept is to formalize:
 *  1.  The necessary precondition: that the functors involved are "parallel".
 *  2.  The constituent parts: the individual "component" morphisms of the transformation.
 *  3.  The defining law: the "naturality square" that these components must satisfy.
 *  We will introduce explicit grammar rules for each of these three aspects.
*)


(* ========================================================================================================== *)
(* == Part 1: The Precondition (Parallel Functors)                                                        == *)
(* ========================================================================================================== *)

ParallelFunctorsPredicate ::= "AreParallel" "(" Identifier "," Identifier ")" ;
TYPING
    (*
     *  This predicate is true if two functors share the exact same domain and codomain categories.
     *  This is a necessary precondition for a natural transformation to exist between them.
    *)
    Γ ⊢ F : Functor(C, D), Γ ⊢ G : Functor(C', D')
    C == C'
    D == D'
    -------------------------------------------------------------
    Γ ⊢ AreParallel(F, G) : BooleanProposition ;
CATEGORY
    [[ AreParallel(F, G) ]] = "An assertion that the functors F and G are parallel arrows in the category `Cat` of categories, i.e., they are objects in the slice category `Cat / (C × D)`." ;


(* ========================================================================================================== *)
(* == Part 2: The Components (The Family of Morphisms)                                                    == *)
(* ========================================================================================================== *)

TransformationComponent ::= Identifier "_at_" Identifier ;
TYPING
    (*
     *  This defines the syntax for a "component" of a natural transformation.
     *  If `alpha` is a transformation from `F` to `G`, and `X` is an object in their domain category,
     *  then `alpha_at_X` is the specific morphism in the codomain category from `F(X)` to `G(X)`.
    *)
    Γ ⊢ alpha : NaturalTransformation(F, G) where F,G : Functor(C,D)
    Γ ⊢ X : Object_in(C)
    ---------------------------------------------------------------------------------
    Γ ⊢ alpha_at_X : Morphism(F(X), G(X)) in D ;
CATEGORY
    [[ alpha_at_X ]] = "The component morphism of the natural transformation `alpha` at the object `X`. It is one specific arrow in the family that constitutes `alpha`." ;


(* ========================================================================================================== *)
(* == Part 3: The Declaration and The Law (Putting It Together)                                           == *)
(* ========================================================================================================== *)

NaturalTransformationDeclaration ::= "NATURAL_TRANSFORMATION" Identifier ":" Identifier "==>" Identifier ;
TYPING
    (*
     *  This rule is now refined. To declare a natural transformation `alpha`, we must be able to assert:
     *  1. The functors F and G are parallel.
     *  2. For every object X in the domain, a corresponding component morphism `alpha_at_X` can be constructed.
     *  3. The entire family of these components satisfies the Naturality Condition.
    *)
    Γ ⊢ AreParallel(F, G) : True
    ∀X ∈ Objects(Domain(F)), Γ ⊢ alpha_at_X : Morphism(F(X), G(X))
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : True
    -------------------------------------------------------------------------
    Γ ⊢ NATURAL_TRANSFORMATION alpha : F ==> G : NaturalTransformation(F,G) ;
CATEGORY
    [[ NATURAL_TRANSFORMATION alpha : F ==> G ]] = "The declaration of a 2-morphism `alpha` between the 1-morphisms (functors) `F` and `G` in the 2-category `Cat`. This object is itself defined by its family of components and the coherence law they satisfy." ;

NaturalityConditionAxiom ::= "AXIOM" "Naturality" ":" "FOR_ALL" Identifier ":" Identifier "->" Identifier "," Expression "∘" TransformationComponent "==" TransformationComponent "∘" Expression ;
TYPING
    (*
     *  This formalizes the famous commuting square diagram. For any natural transformation `alpha`
     *  and any morphism `f: X -> Y` in the domain category, this axiom must hold. It uses our
     *  new `TransformationComponent` syntax `_at_` to make the statement precise.
     *  The equality being asserted is: G(f) ∘ alpha_at_X == alpha_at_Y ∘ F(f)
    *)
    Γ ⊢ alpha : NaturalTransformation(F, G)
    ∀f:X->Y in Domain(F), (G(f) ∘ alpha_at_X) == (alpha_at_Y ∘ F(f))
    ---------------------------------------------------------------------
    Γ ⊢ NaturalityConditionAxiom(alpha, F, G) : BooleanProposition ;
CATEGORY
    [[ AXIOM Naturality: ... ]] = "The fundamental coherence law for natural transformations. It ensures that the family of component morphisms is compatible with the entire morphism structure of the domain category, not just its objects." ;

(* ========================================================================================================== *)
(* == Part 1: The Definitional Equivalence (Unpacking the `^op`)                                          == *)
(* ========================================================================================================== *)

ContravariantFunctorAsFunctorOp ::= "DEFINE" Identifier "as" "CONTRAVARIANT_FUNCTOR" ":" Identifier "->" Identifier ;
TYPING
    (*
     *  This rule asserts that defining a CONTRAVARIANT_FUNCTOR `F: C -> D` is formally equivalent
     *  to defining a standard (covariant) FUNCTOR `F: C^op -> D`. This makes the `^op` idiom,
     *  a cornerstone of categorical thought, an explicit transformation within the grammar.
    *)
    Γ ⊢ F : Identifier, Γ ⊢ C : Category, Γ ⊢ D : Category
    ---------------------------------------------------------------------------------
    (Γ ⊢ DEFINE F as CONTRAVARIANT_FUNCTOR ... ) ⇔ (Γ ⊢ FUNCTOR F : C^op -> D) ;
CATEGORY
    [[ DEFINE F as CONTRAVARIANT_FUNCTOR... ]] = "An assertion of isomorphism in `Cat`. It states that the object representing contravariant functors from C to D is the same as the object representing covariant functors from C^op to D. This is the formal definition." ;

(* ========================================================================================================== *)
(* == Part 2: The Explicit Action on Morphisms (The Arrow Reversal)                                       == *)
(* ========================================================================================================== *)

ContravariantMap ::= Identifier "<~" Expression "~>" ;
TYPING
    (*
     *  This rule gives a concrete syntax for the arrow-reversing action of a contravariant functor.
     *  While `F(f)` is ambiguous, `F <~ f ~>` explicitly signifies the contravariant mapping.
     *  The typing rule makes the reversal of domain and codomain manifest.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C
    ------------------------------------------------------------------
    Γ ⊢ F <~f~> : Morphism(F(A), F(B)) in D ;  (* Note: F(A) and F(B) are the mapped objects *)
CATEGORY
    [[ F <~f~> ]] = "The morphism in D that results from the contravariant action of the functor F on the morphism f from C. The reversal of the arrow `A->B` to an arrow `F(B)->F(A)` is the essence of contravariance." ;

(* ========================================================================================================== *)
(* == Part 3: The Explicit Axioms (Identity and Composition)                                              == *)
(* ========================================================================================================== *)

ContravariantIdentityAxiom ::= "AXIOM" ":" Identifier "<~" "id" "(" Identifier ")" "~>" "==" "id" "(" Identifier ")" ;
TYPING
    (*
     *  This axiom asserts that a contravariant functor must preserve identity morphisms.
     *  `F(id_A)` must equal `id_{F(A)}`.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D), Γ ⊢ A : Object_in(C)
    (F <~id(A)~>) == id(F(A))
    -------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_identity : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~id(A)~> == id(F(A)) ]] = "The law ensuring a contravariant functor respects the neutral elements of composition. This property is identical to the covariant case." ;


ContravariantCompositionAxiom ::= "AXIOM" ":" Identifier "<~" Expression "∘" Expression "~>" "==" Identifier "<~" Expression "~>" "∘" Identifier "<~" Expression "~>" ;
TYPING
    (*
     *  This axiom asserts the law for composing contravariant mappings. Notice the crucial reversal
     *  of order on the right-hand side of the equality. F(g ∘ f) = F(f) ∘ F(g).
     *  This is the most distinctive feature of contravariance in action.
    *)
    Γ ⊢ F : ContravariantFunctor(C, D)
    Γ ⊢ f : Morphism(A, B) in C, Γ ⊢ g : Morphism(B, C) in C
    ( F <~g ∘ f~> ) == ( F <~f~> ∘ F <~g~> )
    ------------------------------------------------------------------------------------------
    Γ ⊢ AXIOM: contravariant_composition : MetaTheorem ;
CATEGORY
    [[ AXIOM: F <~g ∘ f~> == F <~f~> ∘ F <~g~> ]] = "The law defining how a contravariant functor interacts with composition. The reversal of order `g∘f` to `F(f)∘F(g)` is the functional expression of reversing the arrows. This ensures that diagrams are mapped to dual diagrams." ;


(*
 *  ELABORATION: To elaborate on the Comma Category is to move from a single definition to
 *  formalizing its constituent parts and showing how special cases derive from the general one.
 *  We will:
 *  1. Formalize the general construction `(F ↓ G)`.
 *  2. Explicitly define the objects and morphisms of this general category.
 *  3. State the commutative diagram law for its morphisms as a formal axiom.
 *  4. Define the common "slice" and "coslice" categories as specific, simplified instances
 *     of the general construction, making their relationship explicit.
*)

(* ========================================================================================================== *)
(* == Part 1: The General Construction (F ↓ G)                                                            == *)
(* ========================================================================================================== *)

GeneralCommaCategory ::= "(" Identifier "↓" Identifier ")" ;
TYPING
    (*
     *  The general construction `(F ↓ G)` is a category built from two functors, F and G,
     *  that share the same codomain category C.
    *)
    Γ ⊢ F : Functor(A, C), Γ ⊢ G : Functor(B, C)
    -------------------------------------------
    Γ ⊢ (F ↓ G) : Category ;
CATEGORY
    [[ (F ↓ G) ]] = "The comma category constructed from functors F: A→C and G: B→C. It provides a canonical way to compare the outputs of F and G within C." ;

(* ========================================================================================================== *)
(* == Part 2: Objects and Morphisms of the General Comma Category                                         == *)
(* ========================================================================================================== *)

CommaObject ::= "Obj" "(" Identifier "," Identifier "," Identifier ")" ;
TYPING
    (*
     *  An object in the comma category `(F ↓ G)` is a triple `(a, b, h)`, where `a` is an
     *  object in F's domain, `b` is an object in G's domain, and `h` is a morphism in the
     *  shared codomain from `F(a)` to `G(b)`.
    *)
    ParentCategory = (F ↓ G)
    Γ ⊢ a : Object_in(Domain(F)), Γ ⊢ b : Object_in(Domain(G))
    Γ ⊢ h : Morphism(F(a), G(b)) in Codomain(F)
    -------------------------------------------------------------
    Γ ⊢ Obj(a,b,h) : Object_in(ParentCategory) ;
CATEGORY
    [[ Obj(a,b,h) ]] = "An object of the comma category, consisting of a pair of source objects (a, b) and a 'connecting morphism' h: F(a) -> G(b) in the target category." ;

CommaMorphism ::= "Mor" "(" Identifier "," Identifier ")" ;
TYPING
    (*
     *  A morphism in `(F ↓ G)` from `Obj(a,b,h)` to `Obj(a',b',h')` is a pair of morphisms
     *  `(f, g)` from the respective domain categories that satisfy the commutativity axiom.
    *)
    ParentCategory = (F ↓ G)
    Source = Obj(a,b,h), Target = Obj(a',b',h')
    Γ ⊢ f : Morphism(a, a') in Domain(F)
    Γ ⊢ g : Morphism(b, b') in Domain(G)
    Satisfies( (f,g), CommaMorphismCommutativityAxiom(h,h',f,g) )
    ------------------------------------------------------------------
    Γ ⊢ Mor(f,g) : Morphism(Source, Target) in ParentCategory ;
CATEGORY
    [[ Mor(f,g) ]] = "A morphism of the comma category, itself a pair of morphisms (f,g) from the underlying source categories which makes the defining diagram commute." ;

(* ========================================================================================================== *)
(* == Part 3: The Commutativity Axiom for Morphisms                                                       == *)
(* ========================================================================================================== *)

CommaMorphismCommutativityAxiom ::= "AXIOM" "CommaSquare" ":" Expression "∘" Identifier "==" Identifier "∘" Expression ;
TYPING
    (*
     *  This axiom formalizes the commutative square that a `CommaMorphism` `Mor(f,g)` must satisfy.
     *  The law is: `h' ∘ F(f) == G(g) ∘ h`. This ensures the structure is coherent.
    *)
    h' ∘ F(f) == G(g) ∘ h
    -----------------------------
    Γ ⊢ AXIOM ... : MetaTheorem ;
CATEGORY
    [[ AXIOM CommaSquare ... ]] = "The coherence law for morphisms in a comma category. It is the constraint that ties the components `f` and `g` together via the connecting morphisms `h` and `h'`." ;

(* ========================================================================================================== *)
(* == Part 4: Special Cases - Slice and Coslice Categories                                                == *)
(* ========================================================================================================== *)

IdentityFunctorConstructor ::= "Id" "(" Identifier ")" ;
TYPING
    Γ ⊢ C : Category
    -------------------------------
    Γ ⊢ Id(C) : Functor(C, C) ;
CATEGORY
    [[ Id(C) ]] = "The identity functor on category C, which maps all objects and morphisms to themselves." ;

ConstantFunctorConstructor ::= "Δ" "_" Identifier ;
TYPING
    (* The constant functor from the terminal category `1` to `C`, picking out object `X`. *)
    Γ ⊢ C : Category, Γ ⊢ X : Object_in(C)
    ---------------------------------------------------
    Γ ⊢ Δ_X : Functor(1, C) ;
CATEGORY
    [[ Δ_X ]] = "The constant functor that maps the single object of the terminal category `1` to the object `X` in C." ;

SliceCategory ::= Identifier "/" Identifier ;
TYPING
    (*
     *  A slice category `C/X` is defined as a specific instance of the general comma category.
     *  `C/X` is formally equivalent to `(Id(C) ↓ Δ_X)`. This rule asserts that equivalence.
    *)
    (Γ ⊢ C/X : Category) ⇔ (Γ ⊢ (Id(C) ↓ Δ_X) : Category)
    ------------------------------------------------------------
    Γ ⊢ "C/X is a well-defined slice category" : Proposition ;
CATEGORY
    [[ C/X ]] = "The slice category of objects over X. Its objects are arrows in C with codomain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Id(C) ↓ Δ_X)." ;

CosliceCategory ::= Identifier "\\" Identifier ;
TYPING
    (*
     *  Dually, a coslice category `X\C` is defined as `(Δ_X ↓ Id(C))`.
    *)
    (Γ ⊢ X\\C : Category) ⇔ (Γ ⊢ (Δ_X ↓ Id(C)) : Category)
    ------------------------------------------------------------
    Γ ⊢ "X\\C is a well-defined coslice category" : Proposition ;
CATEGORY
    [[ X\\C ]] = "The coslice category of objects under X. Its objects are arrows in C with domain X, and its morphisms are commutative triangles. It is isomorphic to the comma category (Δ_X ↓ Id(C))." ;

(*
 *  ELABORATION: To elaborate on these morphism types, we move beyond their basic cancellation definitions.
 *  We must formalize their interrelationships, their behavior under composition, and the stronger
 *  "splitting" properties that connect them directly to isomorphisms. This involves:
 *  1. Formalizing the notion of an inverse and properties of composition.
 *  2. Defining split monomorphisms and split epimorphisms, which have explicit retractions/sections.
 *  3. Stating key theorems that relate these classes of morphisms (e.g., an iso is always a mono and an epi).
 *  4. Defining a "balanced category" as one where the converse holds, making the distinction explicit.
*)


(* ========================================================================================================== *)
(* == Part 1: Formalizing Inverses and Compositional Properties                                           == *)
(* ========================================================================================================== *)


InverseMorphism ::= "inverse" "(" Identifier ")" ;
TYPING
    (*  The `inverse` constructor is only well-typed if applied to a proven isomorphism.
     *  It produces the unique two-sided inverse morphism.
    *)
    Γ ⊢ f is ISOMORPHISM,  f : Morphism(A,B)
    ----------------------------------------------------
    Γ ⊢ inverse(f) : Morphism(B,A) ;
CATEGORY
    [[ inverse(f) ]] = "The unique morphism `f⁻¹` such that `f⁻¹ ∘ f = id` and `f ∘ f⁻¹ = id`. Its existence is guaranteed by the fact that `f` is an isomorphism." ;


TheoremDeclaration ::= "THEOREM" string_literal ":" Proposition ;
TYPING
    (*  This rule asserts that a given proposition is a theorem of the system.
     *  This is stronger than an exercise; it's an axiom of our meta-theory of categories.
    *)
    IsProvable(Proposition)
    ----------------------------------------------
    Γ ⊢ THEOREM name : Proposition : MetaTheorem ;
CATEGORY
    [[ THEOREM name : Prop ]] = "The assertion that the proposition [[Prop]] holds true for all objects in the category being described. It is a proven fact." ;


TheoremDeclaration ::= "THEOREM" "CompositionOfMonomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfEpimorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is EPIMORPHISM" "&&" "g is EPIMORPHISM" ")" "==>" "(" "(g∘f) is EPIMORPHISM" ")" ;


TheoremDeclaration ::= "THEOREM" "CompositionOfIsomorphisms" ":"
    "FOR_ALL" "f,g" "where" "IsComposable(g,f)" ","
    "(" "f is ISOMORPHISM" "&&" "g is ISOMORPHISM" ")" "==>" "(" "(g∘f) is ISOMORPHISM" ")" ;


(* ========================================================================================================== *)
(* == Part 2: Formalizing Split Monos/Epis (Retractions and Sections)                                      == *)
(* ========================================================================================================== *)


MorphismPropertyAssertion ::= Identifier "is" ("SPLIT_MONOMORPHISM" | "SPLIT_EPIMORPHISM") ;
TYPING
    Γ ⊢ f : Morphism(A, B)
    CASE "SPLIT_MONOMORPHISM": (* Has a left inverse, called a retraction *)
        ∃(r : Morphism(B, A)), (r ∘ f == id(A))
    CASE "SPLIT_EPIMORPHISM": (* Has a right inverse, called a section *)
        ∃(s : Morphism(B, A)), (f ∘ s == id(B))
    -------------------------------------------------------------
    Γ ⊢ f is ... : PropositionAbout(f) ;
CATEGORY
    [[ f is SPLIT_MONOMORPHISM ]] = "Property of being a monomorphism `f` for which there exists a retraction `r` that 'undoes' it. All split monos are monos." ;
    [[ f is SPLIT_EPIMORPHISM ]] = "Property of being an epimorphism `f` for which there exists a section `s` that 'selects' an element from each fiber. All split epis are epis." ;


(* ========================================================================================================== *)
(* == Part 3: Formalizing the Interrelationships and the Notion of a Balanced Category                     == *)
(* ========================================================================================================== *)


TheoremDeclaration ::= "THEOREM" "IsomorphismImpliesMonoAndEpi" ":"
    "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "==>" "(" "f is MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
TYPING
    (* Proof Sketch: If f is iso with inverse g, and f∘h1 = f∘h2, then g∘f∘h1 = g∘f∘h2 => id∘h1 = id∘h2 => h1=h2. Thus f is mono. Dually for epi. *)
    IsProvable(Proposition)
    --------------------------
    Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
 [[ THEOREM "IsoImpliesMonoAndEpi" ]] = "A fundamental fact stating that any structural equivalence (isomorphism) must also satisfy the cancellation properties of monomorphisms and epimorphisms." ;


CategoryPropertyDefinition ::= Identifier "is" "BALANCED" ;
TYPING
    (* This defines a property of an entire category. A category is balanced if the converse of the above theorem holds. *)
    Γ ⊢ C : Category
    ∀ (f in C), ( (f is MONOMORPHISM) ∧ (f is EPIMORPHISM) ) ⇒ (f is ISOMORPHISM)
    -----------------------------------------------------------------------------------
    Γ ⊢ C is BALANCED : PropositionAbout(C) ;
CATEGORY
    [[ C is BALANCED ]] = "The property of a category C where the classes of monomorphisms and epimorphisms are 'well-behaved' enough that their intersection contains only isomorphisms. The category of Sets is an example." ;


TheoremDeclaration ::= "THEOREM" "IsoEquivalenceForSplitMorphisms" ":"
    "FOR_ALL" "f" "," "(" "f is ISOMORPHISM" ")" "<==>" "(" "f is SPLIT_MONOMORPHISM" "&&" "f is EPIMORPHISM" ")" ;
TYPING
    (* This provides a powerful criterion for proving a morphism is an isomorphism. *)
    IsProvable(Proposition)
    --------------------------
    Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
    [[ THEOREM "IsoEquivalenceForSplitMorphisms" ]] = "A key structural result: an isomorphism is precisely an epimorphism that is also a split monomorphism. This connects the abstract cancellation property of epis with the constructive existence of a retraction." ;

(*
 *  ELABORATION: To elaborate on the Duality Principle, we must formalize the very *mechanism* of duality.
 *  This requires more than just stating that it exists. We must integrate into our grammar:
 *  1.  An operator `(-)^op` that dualizes any statement.
 *  2.  A set of meta-axioms that define how this operator transforms specific concepts (e.g., Product -> Coproduct).
 *  3.  An explicit inference rule that allows us to construct a new, dual theorem from any existing theorem.
 *  This makes the Duality Principle a computable, syntactic transformation within our system, not just an informal idea.
*)

(* ========================================================================================================== *)
(* == Part 1: The Syntactic Operator for Duality                                                          == *)
(* ========================================================================================================== *)

DualStatement ::= "(" Proposition ")^op" ;
TYPING
    (*
     *  If `P` is a well-formed proposition in a category C, then `(P)^op` is a well-formed
     *  proposition in the opposite category C^op. This is the syntactic counterpart to `C^op`.
    *)
    Γ ⊢ P : Proposition in C
    ----------------------------------
    Γ ⊢ (P)^op : Proposition in C^op ;
CATEGORY
    [[ (P)^op ]] = "The dual proposition of [[P]], obtained by systematically reversing all morphisms, swapping the order of compositions, and replacing each concept with its dual concept." ;

(* ========================================================================================================== *)
(* == Part 2: Meta-Axioms Defining Specific Dual Mappings                                                 == *)
(* ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" ConceptName "IS" ConceptName ";" ;
TYPING
    (*
     *  This is a meta-theoretical rule. It does not define a term in the language, but asserts an
     *  equivalence within the metatheory itself. It establishes a dictionary for the `(-)^op` operator.
    *)
    IsConcept(C1), IsConcept(C2)
    -----------------------------------------------------------------------------------------
    (Γ ⊢ (X is C1)^op)  <==>  (Γ ⊢ (X is C2))   (* Adds a rewrite rule to the system *) ;
CATEGORY
    [[ DUALITY_MAPPING FOR C1 IS C2 ]] = "An assertion of isomorphism between the definitions of [[C1]] and [[C2]] under the duality functor. This axiom provides a concrete rule for translating between a concept and its dual." ;

(* --- Instantiate the Duality Dictionary --- *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "TERMINAL_OBJECT" "IS" "INITIAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "INITIAL_OBJECT" "IS" "TERMINAL_OBJECT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PRODUCT" "IS" "COPRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COPRODUCT" "IS" "PRODUCT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PULLBACK" "IS" "PUSHOUT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PUSHOUT" "IS" "PULLBACK" ;
DualityMappingAxiom ::= "DUALITY_MIPPING" "FOR" "EQUALIZER" "IS" "COEQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COEQUALIZER" "IS" "EQUALIZER" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LIMIT" "IS" "COLIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COLIMIT" "IS" "LIMIT" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "MONOMORPHISM" "IS" "EPIMORPHISM" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "EPIMORPHISM" "IS" "MONOMORPHISM" ;

(* ========================================================================================================== *)
(* == Part 3: The Principle as a Formal Inference Rule                                                    == *)
(* ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" string_literal "FROM" "THEOREM" string_literal ;
TYPING
    (*
     *  This is the Duality Principle in action. If we have a proof for a theorem `T`, this rule allows
     *  us to formally construct a proof for its dual, `T_dual`. The system `rewrites` the original
     *  theorem using the `DualityMappingAxiom` dictionary to produce the new theorem.
    *)
    Γ ⊢ THEOREM T_orig_name : P_orig
    P_dual = rewrite(P_orig, DualityMappings)
    -------------------------------------------------------------
    Γ ⊢ INFER_DUAL_THEOREM T_dual_name ... : (THEOREM T_dual_name : P_dual) ;
CATEGORY
    [[ INFER_DUAL_THEOREM T_dual FROM T_orig ]] = "The application of the Duality Principle as a meta-inference rule. It is a functor from the category of proofs to itself, mapping the proof object `[[T_orig]]` to a newly constructed proof object `[[T_dual]]`." ;

(* --- Example of Applying the Inference Rule --- *)

TheoremDeclaration ::= "THEOREM" "'CompMono'" ":" "FOR_ALL" "f,g" "," 
    "(" "f is MONOMORPHISM" "&&" "g is MONOMORPHISM" "&&" "IsDefined(g∘f)" ")" "==>" "(" "(g∘f) is MONOMORPHISM" ")" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CompEpi'" "FROM" "THEOREM" "'CompMono'" ;
TYPING
    (*
     *  1. Premise: We have the theorem 'CompMono'.
     *  2. Rewrite 'CompMono' using the duality dictionary:
     *     - "MONOMORPHISM" -> "EPIMORPHISM"
     *     - Composition `g∘f` in C becomes `f_op ∘_op g_op` in C^op. Re-lettering to `g'∘f'` for clarity.
     *  3. Resulting proposition: "FOR_ALL f',g', (f' is EPI && g' is EPI && IsDefined(g'∘f')) ==> ((g'∘f') is EPI)"
     *  4. Conclusion: This is a valid new theorem.
    *)
    Γ ⊢ THEOREM 'CompMono' : P_mono
    -------------------------------------------------
    Γ ⊢ THEOREM 'CompEpi' : P_epi ;
CATEGORY
    [[ INFER_DUAL_THEOREM 'CompEpi' FROM 'CompMono' ]] = "A constructive proof that the composition of two epimorphisms is an epimorphism, obtained not by first principles, but by a direct, mechanical application of the Duality Principle to the proof for monomorphisms." ;

(* ========================================================================================================== )
( == Part 1: Deconstructing the General Product UMP == )
( ========================================================================================================== *)

ProductObjectDeclaration ::= Identifier "is" "PRODUCT" "of" "(" {Identifier} ")" ;
TYPING
(* This rule simply asserts that a given object P has the property of being the product of a family {A_i}. )
( The specific laws it must obey are given by the axioms below. *)
Γ ⊢ P : Object, Γ ⊢ {A_i} : set(Object)
----------------------------------------------------------
Γ ⊢ P is PRODUCT of ({A_i}) : CategoricalProperty ;
CATEGORY
[[ P is PRODUCT of ({A_i}) ]] = "The assertion that the object P is the apex of a limit cone over the discrete diagram formed by the objects {A_i}." ;

(* The structural projections and universal morphism constructor remain as before. *)
ProjectionMorphism ::= "proj_" Identifier ;
UniversalProductMorphism ::= "<" Expression { "," Expression } ">" ;

(* Now, we split the UMP into two explicit axioms: *)

UMP_ProductExistenceAxiom ::= "AXIOM" "ProductCommutativity" ":" "FOR_ALL" "cone" "{" {Identifier} "}" "," "proj_" Identifier "∘" "<" {Identifier} ">" "==" Identifier ;
TYPING
(*
* This axiom asserts the EXISTENCE part of the UMP. It guarantees that the universal morphism
* u = <f_i> constructed from a cone of morphisms {f_i} does, in fact, make the diagram commute.
* It defines the universal morphism by its behavior.
*)
Context: P is PRODUCT of {A_i}.
u = <{f_i}> where f_i : Morphism(X, A_i).
----------------------------------------------------------------------
∀i, Γ ⊢ (proj_{A_i} ∘ u) == f_i : ProvableEquality ;
CATEGORY
[[ AXIOM ProductCommutativity ... ]] = "The coherence law for the universal product morphism. It states that the universal map u is a valid mediating morphism for the cone with legs {f_i}." ;

UMP_ProductUniquenessAxiom ::= "AXIOM" "ProductUniqueness" ":" "IF" "(" Identifier "mediates" Cone ")" "THEN" Identifier "==" UniversalProductMorphism ;
TYPING
(*
* This axiom asserts the UNIQUENESS part of the UMP. It states that if any other morphism u_prime
* also makes the diagram commute (i.e., it "mediates" the cone), then u_prime must be equal
* to the one constructed by our UniversalProductMorphism syntax.
*)
Context: P is PRODUCT of {A_i}.
u = <{f_i}>.
u_prime mediates the cone {f_i} := ( ∀i, proj_{A_i} ∘ u_prime == f_i )
---------------------------------------------------------------------------
Γ ⊢ u_prime == u : ProvableEquality ;
CATEGORY
[[ AXIOM ProductUniqueness ... ]] = "The law formalizing the 'universal' aspect of the universal property. It states that the mediating morphism is unique, making the product object the 'best possible' solution." ;

(* ========================================================================================================== )
( == Part 2: Specializing the Product (Binary and Nullary Cases) == )
( ========================================================================================================== *)

BinaryProductExpression ::= Expression "×" Expression ;
TYPING
Γ ⊢ A : Object, Γ ⊢ B : Object
----------------------------------------------
Γ ⊢ (A × B) : PRODUCT of (A,B) ;
CATEGORY
[[ A × B ]] = "A convenient syntax for the binary product of objects A and B. It is a specific instance of the general product." ;

NullaryProductIsTerminalAxiom ::= "AXIOM" ":" "PRODUCT" "of" "()" "==" "TERMINAL_OBJECT" ;
TYPING
(* A product over an empty set of objects requires, for any test object X, a unique map u: X -> P. )
( This is precisely the definition of the terminal object. *)
Def1 := Definition_of(PRODUCT of ()).
Def2 := Definition_of(TERMINAL_OBJECT).
------------------------------------------
Γ ⊢ Def1 == Def2 : DefinitionalEquivalence ;
CATEGORY
[[ AXIOM: PRODUCT of () == TERMINAL_OBJECT ]] = "The formal assertion that the concept of an empty product and the concept of a terminal object are identical. This shows the coherence of the theory of limits." ;

(* ========================================================================================================== )
( == Part 3: Deriving the Coproduct via the Duality Principle == )
( ========================================================================================================== *)

(* Instead of defining Coproducts from scratch, we use the Duality Principle formalized in Chapter 1. *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CoproductCommutativity'" "FROM" "THEOREM" "'ProductCommutativity'" ;
TYPING
(*
* We apply the duality operator (-)^op to the UMP_ProductExistenceAxiom.
* The system applies the DUALITY_MAPPING dictionary:
* 1. proj_A_i (morphism out of product) -> inj_A_i (morphism into coproduct)
* 2. u = <{f_i}> (map INTO limit) -> u' = [{g_i}] (map OUT OF colimit)
* 3. Composition a ∘ b becomes b_op ∘_op a_op. So, proj ∘ u == f becomes u' ∘ inj == g.
* The result is the existence axiom for coproducts.
*)
Γ ⊢ THEOREM 'ProductCommutativity' : P_prod_exist
P_coprod_exist = rewrite(P_prod_exist, DualityMappings)
------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'CoproductCommutativity' : P_coprod_exist ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the coproduct's existence axiom, derived mechanically by applying the duality functor to the product's existence axiom." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CoproductUniqueness'" "FROM" "THEOREM" "'ProductUniqueness'" ;
TYPING
(* The same process is applied to the uniqueness axiom, proving its dual. *)
Γ ⊢ THEOREM 'ProductUniqueness' : P_prod_uniq
P_coprod_uniq = rewrite(P_prod_uniq, DualityMappings)
-------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'CoproductUniqueness' : P_coprod_uniq ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the coproduct's uniqueness axiom, derived via duality." ;

(* The outcome of these inferences are the formal rules for coproducts: *)
CoproductCommutativityAxiom ::= "AXIOM" "CoproductCommutativity" ":" "FOR_ALL" "cocone" "{" {Identifier} "}" "," "[" {Identifier} "]" "∘" "inj_" Identifier "==" Identifier ;
CoproductUniquenessAxiom ::= "AXIOM" "CoproductUniqueness" ":" "IF" "(" Identifier "mediates" CoCone ")" "THEN" Identifier "==" UniversalCoproductMorphism ;
BinaryCoproductExpression ::= Expression "+" Expression ;
NullaryCoproductIsInitialAxiom ::= "AXIOM" ":" "COPRODUCT" "of" "()" "==" "INITIAL_OBJECT" ;

}



(* ========================================================================================================== )
( == Part 1: Defining from First Principles (Universal Morphisms) == )
( ========================================================================================================== *)

ObjectPropertyDeclaration ::= Identifier "is" ("INITIAL_OBJECT" | "TERMINAL_OBJECT") ;
TYPING
(* This rule asserts a property about an object. The property's meaning is defined by the axioms below. *)
Γ ⊢ X : Object
-------------------------------------------
Γ ⊢ X is ... : PropositionAbout(X) ;
CATEGORY
[[ I is INITIAL_OBJECT ]] = "The assertion that the object I is the colimit of the empty diagram, i.e., it is the initial object 0." ;
[[ T is TERMINAL_OBJECT ]] = "The assertion that the object T is the limit of the empty diagram, i.e., it is the terminal object 1." ;

UniversalInitialMorphism ::= "unique_from_initial_to" "(" Identifier ")" ;
TYPING
(*
* EXISTENCE: If I is an initial object, this constructor gives us the guaranteed morphism to any other object X.
*)
Context: I is INITIAL_OBJECT
Γ ⊢ X : Object
--------------------------------------------------------------------
Γ ⊢ unique_from_initial_to(X) : Morphism(I, X) ;
CATEGORY
[[ unique_from_initial_to(X) ]] = "The unique morphism ! : I → X whose existence is guaranteed by the universal property of the initial object I." ;

InitialUniquenessAxiom ::= "AXIOM" "InitialUniqueness" ":" "FOR_ALL" "f" ":" Identifier "->" Identifier "," "f" "==" UniversalInitialMorphism ;
TYPING
(*
* UNIQUENESS: This axiom asserts that any morphism f you might find from I to X is necessarily
* the one constructed by our universal constructor. This formalizes the "unique" part of the definition.
*)
Context: I is INITIAL_OBJECT
Γ ⊢ f : Morphism(I,X)
----------------------------------------------------------------------------------
Γ ⊢ (f == unique_from_initial_to(X)) : ProvableEquality ;
CATEGORY
[[ AXIOM InitialUniqueness ... ]] = "The coherence law for initiality. It collapses the hom-set Hom(I, X) to a singleton, enforcing the uniqueness of the map from I." ;

(* --- The duals for the Terminal Object follow --- *)

UniversalTerminalMorphism ::= "unique_to_terminal_from" "(" Identifier ")" ;
TYPING
(* EXISTENCE (dual): The guaranteed morphism from any object X to the terminal object T. *)
Context: T is TERMINAL_OBJECT
Γ ⊢ X : Object
----------------------------------------------------------------------
Γ ⊢ unique_to_terminal_from(X) : Morphism(X, T) ;
CATEGORY
[[ unique_to_terminal_from(X) ]] = "The unique morphism ! : X → T whose existence is guaranteed by the universal property of the terminal object T." ;

TerminalUniquenessAxiom ::= "AXIOM" "TerminalUniqueness" ":" "FOR_ALL" "f" ":" Identifier "->" Identifier "," "f" "==" UniversalTerminalMorphism ;
TYPING
(* UNIQUENESS (dual): Any morphism into T must be the universal one. *)
Context: T is TERMINAL_OBJECT
Γ ⊢ f : Morphism(X,T)
------------------------------------------------------------------------------------
Γ ⊢ (f == unique_to_terminal_from(X)) : ProvableEquality ;
CATEGORY
[[ AXIOM TerminalUniqueness ... ]] = "The coherence law for terminality. It collapses the hom-set Hom(X, T) to a singleton, enforcing the uniqueness of the map to T." ;

(* ========================================================================================================== )
( == Part 2: Properties and Relation to General Limits == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "InitialObjectsAreIsomorphic" ":"
"(" Identifier "is INITIAL_OBJECT" "&&" Identifier "is INITIAL_OBJECT" ")" "==>" "(" Identifier "≅" Identifier ")" ;
TYPING
(* Proof Sketch: If I and J are initial, there is a unique map f:I->J and a unique map g:J->I.
The composite g∘f: I->I must be the unique map from I to itself, which is id_I.
Dually, f∘g = id_J. Thus, I and J are isomorphic. *)
Γ ⊢ I is INITIAL_OBJECT, Γ ⊢ J is INITIAL_OBJECT
---------------------------------------------------
Γ ⊢ (I ≅ J) : Isomorphism ;
CATEGORY
[[ THEOREM InitialObjectsAreIsomorphic ]] = "A proof that any two objects satisfying the universal property of initiality must be uniquely isomorphic. This establishes that 'the' initial object is a well-defined concept." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'TerminalObjectsAreIsomorphic'" "FROM" "THEOREM" "'InitialObjectsAreIsomorphic'" ;
TYPING
(* The exact same logic applies dually, which we can formally derive using our Duality Principle mechanism. *)
Γ ⊢ THEOREM 'InitialObjectsAreIsomorphic' : P_initial
--------------------------------------------------------------------------
Γ ⊢ THEOREM 'TerminalObjectsAreIsomorphic' : (P_initial)^op ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof that any two terminal objects are isomorphic, derived by mechanically applying the duality functor to the proof for initial objects." ;

TheoremDeclaration ::= "THEOREM" "TerminalIsNulllaryProduct" ":"
"(" Identifier "is TERMINAL_OBJECT" ")" "<==>" "(" Identifier "is PRODUCT of" "(" ")" ")" ;
TYPING
(* Proof Sketch: The UMP for a product of an empty family of objects requires that for any object X, there
is a unique morphism u: X -> P. This is precisely the definition of a terminal object. *)
IsTerminal(T) <==> IsLimitOfEmptyDiagram(T)
------------------------------------------------
Γ ⊢ ... : ProvableEquivalence ;
CATEGORY
[[ THEOREM TerminalIsNulllaryProduct ]] = "The formal assertion that the concept of a terminal object and the concept of a nullary (empty) product are identical. This connects the specific definition to the general theory of limits." ;

TheoremDeclaration ::= "THEOREM" "InitialIsNulllaryCoproduct" ":"
"(" Identifier "is INITIAL_OBJECT" ")" "<==>" "(" Identifier "is COPRODUCT of" "(" ")" ")" ;
TYPING
(* The dual argument holds. *)
IsInitial(I) <==> IsColimitOfEmptyDiagram(I)
--------------------------------------------------
Γ ⊢ ... : ProvableEquivalence ;
CATEGORY
[[ THEOREM InitialIsNulllaryCoproduct ]] = "The formal assertion that the concept of an initial object and the concept of a nullary (empty) coproduct are identical. This connects the specific definition to the general theory of colimits." ;
}



(* ========================================================================================================== )
( == Part 1: Defining the Diagram Shapes == )
( ========================================================================================================== )
( Before we can take the (co)limit, we must formalize the shape of the diagram we are taking the (co)limit of. *)

DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" Identifier "from" "{" {MorphismDeclaration} "}" ;
TYPING
Γ ⊢ name : Identifier
∀m ∈ morphisms, Γ ⊢ m : MorphismDeclaration
Graph(morphisms) is connected
--------------------------------------------------
Γ ⊢ DIAGRAM_SHAPE name ... : DiagramShape ;
CATEGORY
[[ DIAGRAM_SHAPE name ... ]] = "The definition of an index category J, which will serve as the shape for a diagram functor D: J -> C." ;

DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "ParallelPair" "from" "{" "f: A->B;" "g: A->B;" "}" ;
DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "Cospan" "from" "{" "f: A->C;" "g: B->C;" "}" ;
DiagramShapeDeclaration ::= "DIAGRAM_SHAPE" "Span" "from" "{" "f: C->A;" "g: C->B;" "}" ;

(* ========================================================================================================== )
( == Part 2: The Limit Constructions (Equalizer & Pullback) == )
( ========================================================================================================== *)

EqualizerAsLimit ::= "DEFINE" "Equalizer" "(" Identifier "," Identifier ")" "as" "LIMIT" "of" "DIAGRAM_SHAPE" "ParallelPair" ;
TYPING
(* This asserts that the Equalizer is by definition the limit of a parallel pair. *)
(Γ ⊢ Equalizer(f, g) : Object) ⇔ (Γ ⊢ LIMIT of DIAGRAM_SHAPE ParallelPair on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Equalizer ... ]] = "The formal definition of an equalizer as the limit of the diagram A ⇉ B. This construction universally finds the object E with a map e:E->A that solves the equation f ∘ e = g ∘ e." ;

EqualizerCommutativityAxiom ::= "AXIOM" ":" Expression "∘" Expression "==" Expression "∘" Expression ;
TYPING
(* This axiom states the defining property of the equalizer map e. *)
Context: (E, e) is the Equalizer of (f,g)
-------------------------------------------
Γ ⊢ (f ∘ e) == (g ∘ e) : ProvableEquality ;
CATEGORY
[[ AXIOM: f ∘ e == g ∘ e ]] = "The assertion that the equalizer cone commutes. This is the equation that the equalizer morphism e is constructed to solve." ;

PullbackAsLimit ::= "DEFINE" "Pullback" "(" Identifier "," Identifier ")" "as" "LIMIT" "of" "DIAGRAM_SHAPE" "Cospan" ;
TYPING
(* This asserts that the Pullback is by definition the limit of a cospan. *)
(Γ ⊢ Pullback(f, g) : Object) ⇔ (Γ ⊢ LIMIT of DIAGRAM_SHAPE Cospan on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Pullback ... ]] = "The formal definition of a pullback as the limit of the diagram A → C ← B. This universally constructs the object P (the 'fibered product') and maps p1:P->A, p2:P->B that form a commutative square." ;

PullbackCommutativityAxiom ::= "AXIOM" "PullbackSquare" ":" Expression "∘" "proj" "(" "1" ")" "==" Expression "∘" "proj" "(" "2" ")" ;
TYPING
(* This axiom asserts the commutativity of the pullback square. *)
Context: (P, p1, p2) is the Pullback of (f:A->C, g:B->C)
--------------------------------------------------------
Γ ⊢ (f ∘ p1) == (g ∘ p2) : ProvableEquality ;
CATEGORY
[[ AXIOM PullbackSquare ... ]] = "The assertion that the pullback cone diagram commutes. This square is the canonical example of a commutative diagram in category theory." ;

(* ========================================================================================================== )
( == Part 3: The Colimit Constructions (The Duals: Coequalizer & Pushout) == )
( ========================================================================================================== *)

CoequalizerAsColimit ::= "DEFINE" "Coequalizer" "(" Identifier "," Identifier ")" "as" "COLIMIT" "of" "DIAGRAM_SHAPE" "ParallelPair" ;
TYPING
(* The dual: the Coequalizer is the COLIMIT of the same parallel pair diagram. *)
(Γ ⊢ Coequalizer(f, g) : Object) ⇔ (Γ ⊢ COLIMIT of DIAGRAM_SHAPE ParallelPair on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Coequalizer ... ]] = "The formal definition of a coequalizer as the colimit of the diagram A ⇉ B. This construction universally finds the object Q with a map q:B->Q that solves the equation q ∘ f = q ∘ g." ;

CoequalizerCommutativityAxiom ::= "AXIOM" ":" Expression "∘" Expression "==" Expression "∘" Expression ;
TYPING
Context: (Q, q) is the Coequalizer of (f,g)
-------------------------------------------
Γ ⊢ (q ∘ f) == (q ∘ g) : ProvableEquality ;
CATEGORY
[[ AXIOM: q ∘ f == q ∘ g ]] = "The assertion that the coequalizer cocone commutes. This is the property the coequalizer morphism q is constructed to satisfy." ;

PushoutAsColimit ::= "DEFINE" "Pushout" "(" Identifier "," Identifier ")" "as" "COLIMIT" "of" "DIAGRAM_SHAPE" "Span" ;
TYPING
(* The dual: the Pushout is the COLIMIT of the dual diagram shape, the Span. *)
(Γ ⊢ Pushout(f, g) : Object) ⇔ (Γ ⊢ COLIMIT of DIAGRAM_SHAPE Span on (f,g) : Object)
------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ DEFINE Pushout ... ]] = "The formal definition of a pushout as the colimit of the diagram A ← C → B. This universally constructs the object P (the 'amalgamated sum') and maps i1:A->P, i2:B->P that form a commutative square." ;

PushoutCommutativityAxiom ::= "AXIOM" "PushoutSquare" ":" "inj" "(" "1" ")" "∘" Expression "==" "inj" "(" "2" ")" "∘" Expression ;
TYPING
Context: (P, i1, i2) is the Pushout of (f:C->A, g:C->B)
----------------------------------------------------
Γ ⊢ (i1 ∘ f) == (i2 ∘ g) : ProvableEquality ;
CATEGORY
[[ AXIOM PushoutSquare ... ]] = "The assertion that the pushout cocone diagram commutes." ;

}

(* ========================================================================================================== )
( == Part 1: The Building Blocks (Diagrams and Cones) == )
( ========================================================================================================== *)

DiagramDeclaration ::= "DIAGRAM" Identifier "is" "Functor" "(" Identifier "->" Identifier ")" ;
TYPING
(* A Diagram D in a category C is formally just a functor from a (usually small) index category J to C. *)
Γ ⊢ D : Identifier, Γ ⊢ J : Category, Γ ⊢ C : Category
-----------------------------------------------------------------
Γ ⊢ DIAGRAM D is Functor(J -> C) : Diagram(J,C) ;
CATEGORY
[[ DIAGRAM D is Functor(J -> C) ]] = "The definition of a diagram D, which selects a pattern of objects and morphisms (the image of J) within a category C over which a limit or colimit can be computed." ;

ConeDeclaration ::= "CONE" Identifier "over" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(*
* A cone over a diagram D consists of an apex object A and a family of "leg" morphisms p_j
* for each object j in the diagram's shape J. These legs must be coherent with the
* diagram's own morphisms, meaning the defining triangle must commute.
)
Γ ⊢ D : Diagram(J,C), Γ ⊢ A : Object_in(C)
∀j ∈ Ob(J), Γ ⊢ p_j : Morphism(A, D(j))
∀(f: j -> k) ∈ Mor(J), Γ ⊢ (D(f) ∘ p_j == p_k) : ProvableEquality ( Coherence Condition *)
--------------------------------------------------------------------------------------
Γ ⊢ CONE cone_id over D is { Apex: A, ... } : Cone(D) ;
CATEGORY
[[ CONE ... over D ]] = "A cone is a potential candidate for a limit. It is an object A (the apex) equipped with a compatible family of morphisms (the legs) into the diagram D. Compatibility means all triangles A -> D(j) -> D(k) commute." ;

(* ========================================================================================================== )
( == Part 2: The Universal Structure (The Category of Cones) == )
( ========================================================================================================== *)

CategoryOfCones ::= "ConeCategory" "(" Identifier ")" ;
TYPING
(*
* For any diagram D, we can form a new category whose objects are cones over D and
* whose morphisms are structure-preserving maps between the apexes of cones.
*)
Γ ⊢ D : Diagram(J,C)
Objects(ConeCategory(D)) := {c | Γ ⊢ c : Cone(D)}
Morphisms(ConeCategory(D), from:c' to:c) := {u | Γ ⊢ u : Morphism(Apex(c'), Apex(c)) and u is a ConeMorphism }
--------------------------------------------------------------------------------------
Γ ⊢ ConeCategory(D) : Category ;
CATEGORY
[[ ConeCategory(D) ]] = "The category Cone(D,C) whose objects are all cones over the diagram D in C, and where a morphism between two cones (A', {p'_j}) and (A, {p_j}) is a morphism u: A' -> A such that p_j ∘ u = p'_j for all objects j in the index category J." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition (Limit as a Terminal Object) == )
( ========================================================================================================== *)

LimitAsTerminalInConeCategory ::= "LIMIT" "of" Identifier "is" "TERMINAL_OBJECT" "in" CategoryOfCones ;
TYPING
(*
* This is the master definition. A limit of a diagram D is precisely the terminal object
* in the category of all cones over D. The universal property of this terminal object
* (a unique morphism from any other object) is exactly the universal property of the limit cone
* (a unique mediating morphism from any other cone).
*)
Γ ⊢ D : Diagram(J,C)
Γ ⊢ L_cone : Cone(D)
IsTerminal(L_cone, ConeCategory(D))
----------------------------------------------------------------
Γ ⊢ (Apex(L_cone) is LIMIT of D) : ProvableProposition ;
CATEGORY
[[ LIMIT of D is TERMINAL_OBJECT in ConeCategory(D) ]] = "The fundamental definition of a limit as a universal cone. This asserts that the limit cone L is 'best' because for any other cone C over D, there exists a unique morphism from C to L in the ConeCategory. This single statement elegantly captures both the existence and uniqueness of the mediating morphism." ;

(* ========================================================================================================== )
( == Part 4: The Dual Theory (Colimits) == )
( ========================================================================================================== *)

CoconeDeclaration ::= "COCONE" Identifier "from" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(* Dual to Cone: arrows go from the diagram to the apex. )
Γ ⊢ D : Diagram(J,C), Γ ⊢ A : Object_in(C)
∀j ∈ Ob(J), Γ ⊢ p_j : Morphism(D(j), A)
∀(f: j -> k) ∈ Mor(J), Γ ⊢ (p_k ∘ D(f) == p_j) : ProvableEquality ( Coherence Condition *)
--------------------------------------------------------------------------------------
Γ ⊢ COCONE ... : Cocone(D) ;
CATEGORY
[[ COCONE ... from D ]] = "A candidate for a colimit. It is an object A (the apex) equipped with a compatible family of morphisms (the legs) from the diagram D." ;

CategoryOfCocones ::= "CoconeCategory" "(" Identifier ")" ;
TYPING
Γ ⊢ D : Diagram(J,C)
------------------------------------------------
Γ ⊢ CoconeCategory(D) : Category ;
CATEGORY
[[ CoconeCategory(D) ]] = "The dual category Cocone(D,C), whose objects are all cocones from the diagram D." ;

ColimitAsInitialInCoconeCategory ::= "COLIMIT" "of" Identifier "is" "INITIAL_OBJECT" "in" CategoryOfCocones ;
TYPING
(* The dual of the master definition. *)
Γ ⊢ D : Diagram(J,C)
Γ ⊢ L_cocone : Cocone(D)
IsInitial(L_cocone, CoconeCategory(D))
--------------------------------------------------------------------
Γ ⊢ (Apex(L_cocone) is COLIMIT of D) : ProvableProposition ;
CATEGORY
[[ COLIMIT of D is INITIAL_OBJECT in CoconeCategory(D) ]] = "The fundamental definition of a colimit as a universal cocone, which is precisely the initial object in the category of all cocones from the diagram D." ;

}



(* ========================================================================================================== )
( == Part 1: The Foundational Prerequisite (Smallness) == )
( ========================================================================================================== *)
( A category is "small" if its collection of objects and morphisms are sets, not proper classes. *)
( This is a crucial distinction to avoid set-theoretic paradoxes. *)

CategoryProperty_Small ::= Identifier "is" "SMALL" ;
TYPING
(* This predicate is true if the object and morphism collections are sets. *)
Γ ⊢ C : Category
IsSet(Objects(C))
IsSet(Morphisms(C))
--------------------------------------------------
Γ ⊢ C is SMALL : PropositionAbout(C) ;
CATEGORY
[[ C is SMALL ]] = "A foundational proposition about the size of a category C, asserting that it belongs to the universe of sets. This property is required for C to be used as an index category for limits in the definition of completeness." ;

(* ========================================================================================================== )
( == Part 2: The Object of Quantification (Small Diagrams) == )
( ========================================================================================================== *)
( Completeness quantifies over all "small" diagrams. We must formalize this. *)

SmallDiagramDeclaration ::= "small_diagram" Identifier ":" Identifier "->" Identifier ;
TYPING
(* A small_diagram is a functor whose domain (the index category) is explicitly small. *)
Γ ⊢ D : Functor(J, C)
Γ ⊢ J is SMALL
-------------------------------------------
Γ ⊢ small_diagram D:J->C : SmallDiagram ;
CATEGORY
[[ small_diagram D:J->C ]] = "A diagram D whose shape J is a small category. This is the class of diagrams over which completeness and cocompleteness are defined." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition (Completeness) == )
( ========================================================================================================== *)

CategoryProperty_Complete ::= Identifier "is" "COMPLETE" ;
TYPING
(*
* This is the formal definition. A category C is COMPLETE if for every conceivable small
* diagram D that can be drawn in it, a limit for that diagram exists within C.
* This is a universal quantification over the type SmallDiagram.
*)
Γ ⊢ C : Category
∀ (d : SmallDiagram in C), (HasLimit(d, C))
--------------------------------------------------
Γ ⊢ C is COMPLETE : PropositionAbout(C) ;
CATEGORY
[[ C is COMPLETE ]] = "The global property of a category asserting the existence of limits for all small diagrams. It signifies a rich internal structure, guaranteeing that any coherent system of constraints (a small diagram) has a universal solution (a limit)." ;

(* ========================================================================================================== )
( == Part 4: The Dual Concept (Cocompleteness) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COMPLETE" "IS" "COCOMPLETE" ;
TYPING
(* Adds a new entry to the system's duality dictionary. *)
---
------------------------------------------------------------
(Γ ⊢ (C is COMPLETE)^op) <==> (Γ ⊢ C^op is COCOMPLETE) ;
CATEGORY
[[ DUALITY_MAPPING FOR COMPLETE IS COCOMPLETE ]] = "An enrichment of the duality meta-theory. It formally defines COCOMPLETE as the dual of COMPLETE, allowing the entire theory of completeness to be mechanically dualized to a theory of cocompleteness." ;

CategoryProperty_Cocomplete ::= Identifier "is" "COCOMPLETE" ;
TYPING
(*
* The typing for COCOMPLETE is not defined from scratch but is derived from the Duality Mapping.
* It is equivalent to: ∀ (d : SmallDiagram in C), (HasColimit(d, C))
*)
IsDualOf("COMPLETE")
---------------------------------------------------
Γ ⊢ C is COCOMPLETE : PropositionAbout(C) ;
CATEGORY
[[ C is COCOMPLETE ]] = "The dual global property, asserting the existence of colimits for all small diagrams. It guarantees that any system of components (a small diagram) can be universally assembled into a whole (a colimit)." ;

(* ========================================================================================================== )
( == Part 5: Contextualizing the Property (The Existence Theorem) == )
( ========================================================================================================== *)
( This theorem, from Sec. 2.8, gives completeness its practical power. )

TheoremDeclaration ::= "THEOREM" "CompletenessCriteria" ":"
"(" Identifier "is COMPLETE" ")" "<==>" "(" Identifier "has AllSmallProducts" "&&" Identifier "has AllEqualizers" ")" ;
TYPING
(*
* This theorem provides a powerful, finite check for the property of completeness.
* The property "is COMPLETE" means "has limits for all small diagrams," an infinite number of conditions.
* The right-hand side provides just two sufficient and necessary conditions.
*)
Γ ⊢ C : Category
P1 := (C is COMPLETE)
P2 := (C has all products indexed by small sets) ∧ (C has all equalizers)
---------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CompletenessCriteria ]] = "The fundamental construction theorem for limits. It asserts that to verify the infinite set of conditions for completeness, one only needs to verify two: the existence of all small products (for gathering data) and all equalizers (for imposing constraints). This reduces an infinite problem to a finite, manageable one." ;
}



(* ========================================================================================================== )
( == Part 1: The Formal Statement of the Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CompletenessEquivalenceTheorem" ":"
"(" Identifier "is COMPLETE" ")" "<==>" "(" Identifier "has" "AllProducts" "&&" "AllEqualizers" ")" ;
TYPING
(*
* This theorem provides a powerful, finite check for the property of completeness.
* The property "is COMPLETE" means "has limits for all small diagrams," an infinite number of conditions.
* The right-hand side provides just two sufficient and necessary conditions.
*)
Γ ⊢ C : Category
P1 := (C is COMPLETE)
P2 := (C has all small products) ∧ (C has all equalizers)
---------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CompletenessEquivalenceTheorem ... ]] = "The fundamental construction theorem for limits. It asserts that the ability to form products (to gather all the diagram's data together) and the ability to form equalizers (to enforce all the diagram's coherence laws) is necessary and sufficient to construct a limit for any small diagram shape. This reduces an infinite problem to a finite, manageable one." ;

(* ========================================================================================================== )
( == Part 2: The Constructive Proof as a Grammatical Rule == )
( ========================================================================================================== *)

GeneralLimitConstructor ::= "CONSTRUCT_LIMIT" "of" Identifier "from" "ProductsAndEqualizers" "as" "{"
"STEP 1 (DATA_GATHERING):" ProductOfDiagramObjects ";"
"STEP 2 (LAW_ENCODING):" ParallelMorphismConstruction ";"
"STEP 3 (CONSTRAINT_APPLICATION):" EqualizerAsLimit ";"
"}" ;
TYPING
(*
* This rule does not define a term, but a meta-level proof strategy. It asserts that a limit
* for a diagram D can be constructed by following these three steps.
*)
Γ ⊢ D : Diagram(J, C)
Γ ⊢ P_obj = ProductOfDiagramObjects(D) : Object
Γ ⊢ (alpha, beta) = ParallelMorphismConstruction(D, P_obj) : pair(Morphism)
Γ ⊢ L = Equalizer(alpha, beta) : Object
------------------------------------------------------------------------------------------
Γ ⊢ (L is LIMIT of D) : ProvableProposition ;
CATEGORY
[[ CONSTRUCT_LIMIT D ... ]] = "The formal representation of the standard proof of the limit existence theorem. It is a canonical algorithm for constructing arbitrary limit objects from the simpler primitives of products and equalizers. This makes the theorem's proof a computable process within the logical system." ;

(* ========================================================================================================== )
( == Part 3: Defining the Intermediate Constructions == )
( ========================================================================================================== *)

ProductOfDiagramObjects ::= "Product_over_Objects" "(" Identifier ")" ;
TYPING
(* This is the product over all objects in the diagram D's shape J. P_obj = Π_{j ∈ Ob(J)} D(j) *)
Γ ⊢ D : Diagram(J, C)
-----------------------------------------------------------------
Γ ⊢ Product_over_Objects(D) : Object ;
CATEGORY
[[ Product_over_Objects(D) ]] = "[Step 1 of the proof] The construction of a single large object that holds all the component objects of the diagram D. This object represents the 'raw data' of the limit before any of the diagram's internal constraints (its arrows) are applied." ;

ParallelMorphismConstruction ::= "PARALLEL_MORPHISMS" "(" Identifier "," Identifier ")" "for" Identifier ;
TYPING
(*
* This defines the two crucial parallel morphisms, alpha and beta, that encode the diagram's laws.
* Let P_obj = Π_{j∈J} D(j) and P_mor = Π_{f:j→k ∈J} D(k). Then alpha, beta : P_obj -> P_mor.
* The f-th component of alpha is p_k (the projection to the codomain of f).
* The f-th component of beta is D(f) ∘ p_j (project to the domain of f, then apply the arrow).
*)
Γ ⊢ D : Diagram(J,C), Γ ⊢ P_obj : Product_over_Objects(D)
P_mor = Product_over_Morphisms_Codomains(D)
u_alpha = <{ p_{cod(f)} | f ∈ Mor(J) }>
u_beta = <{ D(f) ∘ p_{dom(f)} | f ∈ Mor(J) }>
---------------------------------------------------------------------
Γ ⊢ PARALLEL_MORPHISMS(u_alpha, u_beta) for D : pair(Morphism(P_obj, P_mor)) ;
CATEGORY
[[ PARALLEL_MORPHISMS ... ]] = "[Step 2 of the proof] The construction of two morphisms that embody the diagram's coherence laws. One morphism (alpha) picks out the 'target' side of each arrow-constraint, while the other (beta) picks out the 'source-then-composed' side. A cone c commutes if and only if alpha ∘ c = beta ∘ c." ;

EqualizerAsLimit ::= "Equalizer" "(" Identifier "," Identifier ")" ;
TYPING
(* This just re-uses the equalizer definition from a previous section. *)
Γ ⊢ alpha, beta : Morphism(A,B)
-------------------------------------------
Γ ⊢ Equalizer(alpha, beta) : Object ;
CATEGORY
[[ Equalizer(alpha, beta) ]] = "[Step 3 of the proof] The application of the equalizer. The equalizer e: L -> P_obj selects exactly those elements of the giant product P_obj for which the two parallel morphisms agree. This enforces all the diagram's laws simultaneously, yielding the true limit object L." ;

(* ========================================================================================================== )
( == Part 4: The Dual Theorem via the Duality Principle == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CocompletenessEquivalenceTheorem'" "FROM" "THEOREM" "'CompletenessEquivalenceTheorem'" ;
TYPING
(*
* By applying the duality principle, we derive the dual theorem for cocompleteness "for free".
* The system applies the duality dictionary:
* - COMPLETE becomes COCOMPLETE.
* - Products become Coproducts.
* - Equalizers become Coequalizers.
*)
Γ ⊢ THEOREM "CompletenessEquivalenceTheorem" : P
P_dual = rewrite(P, DualityMappings)
-----------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "CocompletenessEquivalenceTheorem" : P_dual ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the cocompleteness theorem, derived mechanically by applying the duality functor. It asserts that coproducts and coequalizers are the fundamental building blocks for constructing all possible colimits, providing a finite check for the property of cocompleteness." ;
}


(* ========================================================================================================== )
( == Part 1: Defining the Players (The Functors) == )
( ========================================================================================================== *)

DiagonalFunctorDeclaration ::= "DIAGONAL_FUNCTOR" "Δ" ":" Identifier "->" FunctorCategory ;
TYPING
(*
* The Diagonal Functor Δ takes an object X from a category C and maps it to the
* constant functor Δ_X in the functor category C^J. This constant functor maps
* every object of J to X and every morphism of J to id_X.
*)
Γ ⊢ C : Category, Γ ⊢ C_J = FunctorCategory(J, C)
-----------------------------------------------------
Γ ⊢ DIAGONAL_FUNCTOR Δ : C -> C_J : Functor(C, C_J) ;
CATEGORY
[[ DIAGONAL_FUNCTOR Δ ]] = "The functor Δ: C -> C^J which embeds C into the category of diagrams C^J as the full subcategory of constant diagrams. It is the functorial embodiment of 'making a constant diagram from an object'." ;

ColimitFunctorDeclaration ::= "COLIMIT_FUNCTOR" "colim" ":" FunctorCategory "->" Identifier ;
TYPING
(*
* The Colimit Functor colim is a functor from a diagram category C^J back to the
* base category C. It maps a diagram D to its colimit object. This functor is only
* well-defined (total) if the category C is cocomplete.
*)
Γ ⊢ C_J = FunctorCategory(J, C), Γ ⊢ C : Category
C is COCOMPLETE
--------------------------------------------------------------
Γ ⊢ COLIMIT_FUNCTOR colim : C_J -> C : Functor(C_J, C) ;
CATEGORY
[[ COLIMIT_FUNCTOR colim ]] = "The functor colim: C^J -> C which computes the colimit of every diagram. Its existence is conditional on the cocompleteness of C. It collapses a diagram down to its universal representative object." ;

(* ========================================================================================================== )
( == Part 2: The Key Insight (Cocones as Natural Transformations) == )
( ========================================================================================================== *)

CoconeAsNaturalTransformationAxiom ::= "AXIOM" ":" "SetOfCocones" "(" Identifier "," Identifier ")" "==" "Hom_in_FunctorCat" "(" Identifier "," "Δ" "(" Identifier ")" ")" ;
TYPING
(*
* This axiom formalizes the key representational insight. A cocone from a diagram D to an
* object X is a family of morphisms {g_j: D(j) -> X} such that g_k ∘ D(f) = g_j.
* A natural transformation α: D -> Δ_X is a family of morphisms {α_j: D(j) -> X} such that
* the naturality square id_X ∘ α_j = α_k ∘ D(f) commutes, which simplifies to α_j = α_k ∘ D(f).
* These are the same conditions.
*)
Γ ⊢ D : Functor(J, C), Γ ⊢ X : Object_in(C)
DefinitionOf(SetOfCocones(D, X)) == DefinitionOf(NatTrans(D, Δ(X)))
-------------------------------------------------------------------------
Γ ⊢ ... : DefinitionalEquivalence ;
CATEGORY
[[ AXIOM CoconeAsNaturalTransformation... ]] = "The formal assertion of isomorphism between the set of cocones from D to X and the hom-set Hom_CJ(D, ΔX) in the functor category. This provides the crucial bridge, allowing us to replace the language of cocones with the language of natural transformations." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (The Adjunction) == )
( ========================================================================================================== *)

AdjunctionDeclaration ::= "ADJUNCTION" ":" "colim" "⊣" "Δ" ;
TYPING
(*
* This is the master theorem, stating that colim is the left adjoint to Δ.
* The universal property of the colimit states there is a bijection between cocones from D to X
* and morphisms from colim D to X. Using the axiom from Part 2, this is a bijection
* between Hom_CJ(D, ΔX) and Hom_C(colim D, X). This is the definition of an adjunction.
)
P1 := Hom_C(colim(D), X) ≅ SetOfCocones(D, X) ( UMP of colimit )
P2 := SetOfCocones(D, X) ≅ Hom_CJ(D, Δ(X)) ( Axiom from Part 2 *)
----------------------------------------------------------------------
Γ ⊢ Hom_C(colim(D), X) ≅ Hom_CJ(D, Δ(X)) : NaturalIsomorphism ;
CATEGORY
[[ ADJUNCTION: colim ⊣ Δ ]] = "The assertion that the Colimit functor is the left adjoint to the Diagonal functor (colim ⊣ Δ). This natural isomorphism Hom_C(colim D, X) ≅ Hom_CJ(D, ΔX) is the most abstract, powerful, and modern formulation of the universal property of colimits, capturing the UMP for all diagrams and test objects in a single statement." ;

(* ========================================================================================================== )
( == Part 4: Deriving the Dual Theory for Limits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LimitAdjunction'" "FROM" "THEOREM" "'ColimitAdjunction'" ;
TYPING
(*
* By applying the Duality Principle, we derive the entire dual theory for limits.
* The system dualizes the adjunction colim ⊣ Δ, which becomes Δ^op ⊣ colim^op.
* We know that colim^op is lim, and Δ^op is Δ on the opposite category.
* The result is the dual adjunction Δ ⊣ lim. The isomorphism becomes:
* Hom_C(ΔX, D) ≅ Hom_C(X, lim D).
* The left side represents cones from X to D (as per the dual of Part 2's axiom).
* The right side represents morphisms into the limit. This is the UMP for limits.
*)
Γ ⊢ colim ⊣ Δ
(colim ⊣ Δ)^op => (Δ^op ⊣ colim^op) => (Δ ⊣ lim)
------------------------------------------------------------
Conclusion: We have now proven that Δ is the left adjoint to lim (Δ ⊣ lim). ;
CATEGORY
[[ INFER_DUAL_THEOREM 'LimitAdjunction' ... ]] = "A constructive proof of the main theorem for limits, derived by a mechanical application of the Duality Principle. It asserts that the Diagonal functor is the left adjoint to the Limit functor (Δ ⊣ lim). This yields the natural isomorphism Hom_C(X, lim D) ≅ Hom_CJ(ΔX, D), which is the abstract formulation of the universal property of limits." ;

}



(* ========================================================================================================== )
( == Part 1: Preservation of Limits (Continuity) == )
( ========================================================================================================== )
( A functor preserves limits if it maps limit cones to limit cones. It's "continuous". *)

FunctorProperty ::= Identifier "preserves" "LIMITS" ;
TYPING
(*
* The formal definition of preservation: For any diagram in the source category C that has a limit,
* the functor F applied to that limit cone results in a limit cone in the target category D.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Diagram Diag in C), ( (LimitCone(c, Diag) in C) ⇒ (LimitCone(F(c), F(Diag)) in D) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F preserves LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F preserves LIMITS ]] = "The property of a functor F being continuous. It takes diagrams and their limits in C to diagrams and their limits in D. This is the most fundamental notion of a functor being 'compatible' with the limit structure of its domain." ;

(* ========================================================================================================== )
( == Part 2: Reflection of Limits (Conservativity) == )
( ========================================================================================================== )
( A functor reflects limits if, upon seeing a limit cone in its target, it can conclude the )
( source must also have been a limit cone. It is "conservative" about structure. *)

FunctorProperty ::= Identifier "reflects" "LIMITS" ;
TYPING
(*
* The formal definition of reflection: For any cone in C, if its image under F is a limit
* cone in D, then the original cone must have been a limit cone in C.
* This is the converse implication of preservation.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Cone c over Diag in C), ( (LimitCone(F(c), F(Diag)) in D) ⇒ (LimitCone(c, Diag) in C) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F reflects LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F reflects LIMITS ]] = "The property of a functor F being conservative. It doesn't necessarily create limits, but it reliably 'detects' them. If the image F(c) has the universal property of a limit, the functor is faithful enough to the structure to guarantee that c already had that property." ;

(* ========================================================================================================== )
( == Part 3: Creation of Limits (The Strongest Property) == )
( ========================================================================================================== )
( A functor creates limits if it not only reflects them, but provides a unique lift. *)

FunctorProperty ::= Identifier "creates" "LIMITS" ;
TYPING
(*
* The formal definition of creation: For any diagram in C whose image under F has a limit in D,
* there exists a unique cone in C which is a limit cone, AND this cone is mapped by F to the
* limit cone in D.
*)
Γ ⊢ F : Functor(C,D)
Condition := ∀ (Diagram Diag in C),
( (HasLimit(F(Diag)) in D) ⇒ (∃! Cone c in C s.t. LimitCone(c, Diag) ∧ F(c) ≅ Limit(F(Diag))) )
----------------------------------------------------------------------------------------------------
Γ ⊢ (F creates LIMITS) is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F creates LIMITS ]] = "The strongest of the three properties. The functor F not only reflects limits but guarantees their existence and uniqueness in its domain based on their existence in the codomain. This is a crucial property for forgetful functors from categories of algebras (like Grp -> Set) and slice categories." ;

(* ========================================================================================================== )
( == Part 4: Key Interrelationships and Examples == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CreationImpliesReflection" ":"
"FOR_ALL" "functor" "F" "," "(" "F creates LIMITS" ")" "==>" "(" "F reflects LIMITS" ")" ;
TYPING
(* Proof sketch: If F creates limits and F(c) is a limit cone, then there exists a unique
* limit cone c' in C such that F(c') is a limit cone. By uniqueness of limits, F(c) must be
* isomorphic to F(c'), which implies c is isomorphic to c'. Thus c is a limit cone.
*)
IsProvable(Proposition)
-------------------------------------
Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
[[ THEOREM CreationImpliesReflection ]] = "The assertion of a strict hierarchy of properties. Creation is a stronger condition than reflection. Any functor that can create limits is necessarily conservative." ;

TheoremDeclaration ::= "THEOREM" "IsomorphismsOfCategoriesReflectLimits" ":"
"FOR_ALL" "functor" "F" "," "(" "F is an IsomorphismOfCategories" ")" "==>" "(" "F reflects LIMITS" ")" ;
TYPING
(* Functors that are part of an isomorphism (or more generally, an equivalence) of categories
are extremely well-behaved and reflect all structures. *)
Γ ⊢ F : IsomorphismOfCategories(C,D)
-----------------------------------------
Γ ⊢ F reflects LIMITS : ProvableProposition ;
CATEGORY
[[ THEOREM IsomorphismsOfCategoriesReflectLimits ]] = "An assertion that structurally equivalent categories are indistinguishable from the point of view of their limit structures. An isomorphism is the canonical example of a conservative functor." ;

TheoremDeclaration ::= "THEOREM" "RightAdjointsPreserveLimits" ":"
"FOR_ALL" "functor" "F" "," "(" "F is a Right Adjoint Functor" ")" "==>" "(" "F preserves LIMITS" ")" ;
TYPING
IsRightAdjoint(F)
----------------------
Γ ⊢ F preserves LIMITS : ProvableProposition ;
CATEGORY
[[ THEOREM RightAdjointsPreserveLimits ]] = "The most important source of continuous functors. Any functor that is a right adjoint must preserve all limits that exist in its domain. Dually, all left adjoints preserve colimits. This provides a powerful tool for proving continuity." ;

}

(* ========================================================================================================== )
( == Part 1: The Prerequisite - Preservation by a Single Functor == )
( ========================================================================================================== *)

PreservationPredicate ::= Identifier "preserves" "COLIMIT" "of" Identifier ;
TYPING
(*
* This predicate asserts that a specific functor F maps a specific colimit cocone in C
* to a colimit cocone in D.
*)
Γ ⊢ F : Functor(C,D)
Γ ⊢ L_cocone is COLIMIT of Diagram D in C
------------------------------------------------------------------------------------------
Γ ⊢ (F preserves COLIMIT of D) is TRUE ⇔ (F(L_cocone) is COLIMIT of (F ∘ D) in D) ;
CATEGORY
[[ F preserves COLIMIT of D ]] = "The proposition that the functor F is continuous with respect to the diagram D. It is a statement about a functor preserving a specific algebraic structure present in its domain." ;

(* ========================================================================================================== )
( == Part 2: The Abstract Definition - Absoluteness == )
( ========================================================================================================== *)

AbsoluteColimitDefinition ::= Identifier "is" "ABSOLUTE_COLIMIT" "of" Identifier ;
TYPING
(*
* An object L is the apex of an absolute colimit cocone if it is a colimit cocone, AND
* this structure is preserved by ALL functors originating from the category C.
* This is a universal quantification over functors.
*)
Γ ⊢ L_cocone is COLIMIT of D
∀ (Category D_prime), ∀ (Functor F : C -> D_prime), (F preserves colimit of D)
-----------------------------------------------------------------------------
Γ ⊢ L_cocone is ABSOLUTE_COLIMIT of D : Proposition ;
CATEGORY
[[ L_cocone is ABSOLUTE_COLIMIT of D ]] = "The property of a colimit cocone to be so structurally robust that its universal property holds even after being mapped by any functor into any other category. This implies the colimit is defined by an algebraic structure internal to C, not just by its external relationships." ;

(* ========================================================================================================== )
( == Part 3: The Concrete Condition - Split Coequalizers == )
( ========================================================================================================== *)

SplitCoequalizerCocone ::= Identifier "is" "SPLIT_COEQUALIZER_COCONE" "for" "(" Identifier "," Identifier ")" ;
TYPING
(*
* A cocone (q: B -> Q) for a parallel pair (f,g: A->B) is a SPLIT coequalizer cocone if
* it satisfies the coequalizer equation AND the morphism q is a split epimorphism,
* meaning it has a right-inverse (a section).
)
Γ ⊢ q : Morphism(B, Q), Γ ⊢ f : Morphism(A, B), Γ ⊢ g : Morphism(A, B)
(q ∘ f == q ∘ g) ( Condition 1: It coequalizes the pair. )
(q is SPLIT_EPIMORPHISM) ( Condition 2: It has an explicit algebraic "splitting". *)
--------------------------------------------------------------------------------
Γ ⊢ q is SPLIT_COEQUALIZER_COCONE for (f, g) : Proposition ;
CATEGORY
[[ q is SPLIT_COEQUALIZER_COCONE ... ]] = "A coequalizer cocone whose universality is not merely abstract but is constructively witnessed by a section s: Q -> B such that q ∘ s = id. This explicit algebraic witness is the source of its universal stability." ;

(* ========================================================================================================== )
( == Part 4: The Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AbsoluteColimitsAreSplit" ":"
"(" Identifier "is" "ABSOLUTE_COLIMIT" "of" DiagramShape_ParallelPair ")"
"<==>"
"(" Identifier "is" "SPLIT_COEQUALIZER_COCONE" ")" ;
TYPING
(* A colimit of a parallel pair is absolute if and only if it is a split coequalizer cocone. *)
Context: D is a parallel pair (f,g). C is the colimit cocone for D.
P1 := (C is ABSOLUTE_COLIMIT of D)
P2 := (C is SPLIT_COEQUALIZER_COCONE for (f,g))
-----------------------------------------------------
IsProvable(P1 <==> P2) ;
CATEGORY
[[ THEOREM AbsoluteColimitsAreSplit ]] = "The assertion of a foundational equivalence. It states that the abstract, universal property of being preserved by all functors is precisely the same as the concrete, algebraic property of being a split coequal-izer. This theorem provides a powerful, checkable criterion for the very strong property of absoluteness." ;

}



(* ========================================================================================================== )
( == Part 1: Deconstructing the Definition of a Filtered Category == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "FILTERED" ;
TYPING
(*
* The full definition of a filtered category J requires three conditions to be met,
* which we formalize here as separate propositonal checks.
*)
Γ ⊢ J : Category
IsNonEmpty(J)
∧ HasUpperBoundsForObjects(J)
∧ HasEqualizingMorphisms(J)
-------------------------------------------
Γ ⊢ J is FILTERED : PropositionAbout(J) ;
CATEGORY
[[ J is FILTERED ]] = "The property of an index category J being 'richly connected' in a forward-looking manner. This generalizes the notion of a directed set and is the categorical foundation for direct limits in algebra." ;

CategoryPropertyAxiom ::= "AXIOM" ("UpperBoundsForObjects" | "EqualizingMorphisms") "in" Identifier ;
TYPING
Γ ⊢ J : Category
CASE "UpperBoundsForObjects":
∀ (j1, j2 ∈ Ob(J)), ∃ (k ∈ Ob(J), f:j1->k, g:j2->k)
CASE "EqualizingMorphisms":
∀ (f,g : j1 -> j2 ∈ Mor(J)), ∃ (h : j2 -> k ∈ Mor(J)) s.t. (h ∘ f == h ∘ g)
------------------------------------------------------------------
Γ ⊢ AXIOM ... in J : PropositionAbout(J) ;
CATEGORY
[[ AXIOM UpperBoundsForObjects in J ]] = "The 'meet-me-later' property for objects. It guarantees that any two objects in the category can eventually be connected by arrows to a common successor object." ;
[[ AXIOM EqualizingMorphisms in J ]] = "The 'we'll-agree-later' property for morphisms. It guarantees that any disagreement between two parallel arrows can eventually be resolved (equalized) by composing them with a future arrow." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem on Filtered Colimits in Set == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "FINITE" ;
TYPING
(* A finite category is a small category with a finite set of objects and morphisms. *)
Γ ⊢ J : Category, J is SMALL
|Objects(J)| is finite ∧ |Morphisms(J)| is finite
--------------------------------------------------
Γ ⊢ J is FINITE : PropositionAbout(J) ;
CATEGORY
[[ J is FINITE ]] = "The property of an index category J being small in the strongest sense. This is the shape required for a 'finite limit'." ;

TheoremDeclaration ::= "THEOREM" "FilteredColimitsCommuteWithFiniteLimitsInSet" ":"
"IN_CATEGORY" "Set" "," "(" "I is FILTERED" "&&" "J is FINITE" ")" "==>"
"(" "colim_" "I" " lim_" "J" " ≅ " "lim_" "J" " colim_" "I" ")" ;
TYPING
(*
* This theorem formalizes the ability to interchange the order of a filtered colimit and a finite limit
* for any diagram D: I × J -> Set.
*)
Context: Category is Set
Γ ⊢ I is FILTERED
Γ ⊢ J is FINITE
Γ ⊢ D : Functor(I × J, Set)
----------------------------------------------------
Γ ⊢ colim_I(lim_J(D)) ≅ lim_J(colim_I(D)) : Isomorphism ;
CATEGORY
[[ THEOREM ... ]] = "A foundational result in algebra and logic. It establishes that in Set, the process of forming direct limits (filtered colimits) is 'continuous' with respect to finite algebraic structures (finite limits). For example, the direct limit of a product of groups is the product of their direct limits." ;

(* ========================================================================================================== )
( == Part 3: Deriving the Dual Concepts via Duality == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FILTERED" "IS" "COFILTERED" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COFILTERED" "IS" "FILTERED" ;
TYPING
(* Adds a new entry to the system's duality dictionary. *)
---
---------------------------------------------------------------
(Γ ⊢ (C is FILTERED)^op) <==> (Γ ⊢ C^op is COFILTERED) ;
CATEGORY
[[ DUALITY_MAPPING ... ]] = "An enrichment of the duality meta-theory. It defines the formal dual of the 'filtered' property, allowing for mechanical derivation of dual theorems." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CofilteredLimitsCommuteWithFiniteColimits'" "FROM" "THEOREM" "'FilteredColimitsCommuteWithFiniteLimitsInSet'" ;
TYPING
(*
* We apply the duality operator to the main theorem. The system uses the DualityMapping dictionary:
* 1. "FILTERED" -> "COFILTERED"
* 2. "FINITE" -> "FINITE" (finite is self-dual)
* 3. "colim" -> "lim"
* 4. "lim" -> "colim"
* The result is the exact dual theorem.
*)
Γ ⊢ THEOREM 'Filtered...' : P_filtered_commute
P_cofiltered_commute = rewrite(P_filtered_commute, DualityMappings)
-------------------------------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM 'Cofiltered...' : P_cofiltered_commute ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual commutation theorem, derived mechanically by applying the Duality Principle. It asserts that in Set, cofiltered limits commute with finite colimits, a result obtained 'for free' from the original theorem." ;
}

(* ========================================================================================================== )
( == Part 1: The Formal Structural Definition == )
( ========================================================================================================== )
( Before we can define finality, we need to formalize the comma category used in its definition. *)
OverCommaCategory ::= "(" Identifier "↓" Identifier ")" ;
TYPING
(*
* This defines the comma category of "objects under k via U". This is an instance of the
* general comma category (Δ_k ↓ U), where Δ_k is the constant functor selecting k.
* Its objects are pairs (j, f) where j is an object in U's domain, and f: k -> U(j).
* To check for finality, we only need the dual category, where the arrow is f: U(j) -> k.
* Let's correct this to use the proper comma category for the finality definition.
* The correct comma category for a final functor U:J->K, given k in K, is (k ↓ U) which is not standard.
* The standard definition is (U ↓ k), the comma category of "objects of J over k".
* Let's correct the rule to formalize this standard definition.
*)
Γ ⊢ U : Functor(J, K), Γ ⊢ k : Object_in(K)
--------------------------------------------------
Γ ⊢ (U ↓ k) : Category ;
CATEGORY
[[ (U ↓ k) ]] = "The comma category of objects of J over k. An object in (U ↓ k) is a pair (j, f) where j is an object in J and f: U(j) -> k is a morphism in K." ;
FunctorProperty_Final ::= Identifier "is" "FINAL" ;
TYPING
(*
* This is the local, structural definition of a final functor U.
* It is final if for every object k in its codomain, the comma category (U ↓ k)
* is non-empty and connected.
*)
Γ ⊢ U : Functor(J, K)
∀ k ∈ Objects(K),
( IsNonEmpty(Category("(U ↓ k)")) ∧ IsConnected(Category("(U ↓ k)")) )
-----------------------------------------------------------------------------
Γ ⊢ U is FINAL : PropositionAbout(U) ;
CATEGORY
[[ U is FINAL ]] = "The structural property of a functor U being 'cofinal' or 'sufficiently interwoven' in its codomain. This ensures that its domain J is rich enough to compute colimits on behalf of the entire codomain K." ;
(* ========================================================================================================== )
( == Part 2: The Behavioral Consequence == )
( ========================================================================================================== *)
FunctorBehavior_PreservesColimitsOnPrecomposition ::= Identifier "preserves_colimits_on_precomposition" ;
TYPING
(*
* This defines the desired global behavior. A functor U has this property if for any
* diagram F starting from U's codomain, the colimit of F is the same as the colimit
* of the composite diagram F ∘ U.
*)
Γ ⊢ U : Functor(J, K)
∀ C:Category, ∀ F:Functor(K,C), ( (colimit of F) ≅ (colimit of (F ∘ U)) )
-------------------------------------------------------------------------
Γ ⊢ U preserves_colimits_on_precomposition : PropositionAbout(U) ;
CATEGORY
[[ U preserves_colimits_on_precomposition ]] = "A global, behavioral property of a functor U. It asserts that for the purpose of computing colimits, one can safely restrict any diagram F over K to the potentially smaller domain J via U without changing the result." ;
(* ========================================================================================================== )
( == Part 3: The Equivalence Theorem == )
( ========================================================================================================== *)
TheoremDeclaration ::= "THEOREM" "FinalityEquivalence" ":"
"(" Identifier "is" "FINAL" ")" "<==>" "(" Identifier "preserves_colimits_on_precomposition" ")" ;
TYPING
(* This theorem asserts that the checkable, structural property is logically equivalent to the powerful, behavioral one. *)
Γ ⊢ U : Functor(J, K)
P_structural := (Γ ⊢ U is FINAL)
P_behavioral := (Γ ⊢ U preserves_colimits_on_precomposition)
-----------------------------------------------------------------
Γ ⊢ (P_structural <==> P_behavioral) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FinalityEquivalence ]] = "The assertion that the local, structural property of finality (based on comma categories) is the necessary and sufficient condition for the global, behavioral property of simplifying colimit computations. This theorem is what makes the concept of finality useful, providing a tangible check for an abstract behavior." ;
(* ========================================================================================================== )
( == Part 4: Deriving the Dual Theory of Initial Functors == )
( ========================================================================================================== *)
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FINAL" "IS" "INITIAL" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "INITIAL" "IS" "FINAL" ;
TYPING
---
-------------------------------------------------------
(Γ ⊢ (U is FINAL)^op) <==> (Γ ⊢ U^op is INITIAL) ;
CATEGORY
[[ DUALITY_MAPPING FOR FINAL IS INITIAL ]] = "An enrichment of the meta-theory, defining 'Initial Functor' as the formal dual of 'Final Functor'. This allows the entire theory to be dualized mechanically." ;
DualTheoremInference ::= "INFER_DUAL_THEOREM" "'InitialityEquivalence'" "FROM" "THEOREM" "'FinalityEquivalence'";
TYPING
(*
* By applying the duality operator to the FinalityEquivalence theorem, we derive the entire
* theory for Initial Functors "for free." The system performs these rewrites:
* 1. "FINAL" -> "INITIAL"
* 2. "preserves_colimits_on_precomposition" -> "preserves_limits_on_precomposition"
* 3. Comma category (U ↓ k) -> (k ↓ U)
* 4. "colimit" -> "limit"
* The result is the complete, correct, and dual theory.
*)
Γ ⊢ THEOREM "FinalityEquivalence" : P_final
P_initial = rewrite(P_final, DualityMappings)
-----------------------------------------------
Γ ⊢ THEOREM "InitialityEquivalence" : P_initial ;
CATEGORY
[[ INFER_DUAL_THEOREM 'InitialityEquivalence' ... ]] = "A constructive proof of the main theorem for Initial Functors, derived by a mechanical application of the Duality Principle. It asserts that a functor is Initial (a structural property on comma categories) if and only if it simplifies LIMIT computations (a global behavioral property)." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 2.12: Formalizing Interchange of Limits" ")" "==>" {

(* ========================================================================================================== )
( == Part 1: The Main Theorem on Limit Interchange == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitInterchange" ":"
"IN_CATEGORY" Identifier "C" "where" "C is COMPLETE" ","
"LIMIT_over" "(" Identifier "×" Identifier ")" "of" Identifier "≅"
"LIMIT_iterated" "(" Identifier "," Identifier ")" "of" Identifier ;
TYPING
(*
* This theorem asserts that in a complete category C, the limit over a product-shaped diagram D: I×J -> C
* is naturally isomorphic to the iterated limit. The precondition of completeness is essential, as it
* guarantees the existence of the inner limits needed to even form the iterated limit.
*)
Γ ⊢ C is COMPLETE
Γ ⊢ I, J : Category, Γ ⊢ D : Functor(I × J, C)
LHS := LIMIT of D
RHS := IteratedLimit(I, J, D)
-----------------------------------------------------------------------------------
Γ ⊢ LHS ≅ RHS : Isomorphism ;
CATEGORY
[[ THEOREM LimitInterchange ]] = "The assertion of the Fubini-style theorem for limits. It states that the limit of a product-shaped diagram can be computed by iterated limits. This reflects a fundamental coherence property of the category, showing that its limit structures compose in a predictable way." ;

(* ========================================================================================================== )
( == Part 2: Deconstructing the Iterated Limit Construction == )
( ========================================================================================================== *)

InnerDiagramConstructor ::= "InnerDiagram" "(" "Diagram" Identifier "," "fixed_at" Identifier ")" ;
TYPING
(*
* This is the first step of the iterated construction. It takes a diagram over a product index I×J
* and freezes the first index i, resulting in a new diagram whose shape is just J.
*)
Γ ⊢ D : Functor(I × J, C), Γ ⊢ i : Object_in(I)
-----------------------------------------------------------------
Γ ⊢ InnerDiagram(D, fixed_at i) : Functor(J, C) ;
CATEGORY
[[ InnerDiagram(D, fixed_at i) ]] = "The functor D(i, -): J -> C. This represents 'slicing' the larger product diagram D at a specific index i from the first category." ;

OuterDiagramOfLimitsConstructor ::= "OuterDiagramOfLimits" "(" "Diagram" Identifier ")" ;
TYPING
(*
* This is the second, crucial step. It constructs a new diagram whose shape is I.
* For each object i in I, it computes the limit of the corresponding InnerDiagram.
* The universal property of limits ensures that this mapping can be extended to morphisms,
* resulting in a well-defined functor L: I -> C.
*)
Γ ⊢ D : Functor(I × J, C)
Context: Domain(D) is I × J. Category C is COMPLETE.
------------------------------------------------------------------------------------------------
Γ ⊢ OuterDiagramOfLimits(D) : Functor(I, C) where L(i) = lim(InnerDiagram(D, i)) ;
CATEGORY
[[ OuterDiagramOfLimits(D) ]] = "The diagram L:I->C formed by taking limits over the second variable j for each fixed i. This is the diagram whose limit constitutes the result of the iterated procedure." ;

IteratedLimitDefinitionAxiom ::= "AXIOM" "IteratedLimitDefinition" ":"
"LIMIT_iterated" "(" Identifier "," Identifier ")" "of" Identifier
"==" "LIMIT" "of" OuterDiagramOfLimitsConstructor ;
TYPING
(*
* This axiom provides the formal definition for our "LIMIT_iterated" convenience syntax.
* It states that the iterated limit is, by definition, the limit of the diagram of inner limits.
*)
Γ ⊢ D : Functor(I × J, C)
-----------------------------------------------------------------------------------------------
(Γ ⊢ LIMIT_iterated(I,J) of D) <==> (Γ ⊢ LIMIT of (OuterDiagramOfLimits(D))) ;
CATEGORY
[[ AXIOM IteratedLimitDefinition ... ]] = "A definitional equivalence that unpacks the iterated limit construction. It makes the two-step process of (1) forming a diagram of inner limits and (2) taking the limit of that new diagram explicit within the formal grammar." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theorem for Colimits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'ColimitInterchange'" "FROM" "THEOREM" "'LimitInterchange'" ;
TYPING
(*
* By applying the Duality Principle, we obtain the dual theorem for cocomplete categories "for free."
* The system applies the duality dictionary:
* - COMPLETE becomes COCOMPLETE.
* - LIMIT becomes COLIMIT.
*)
Γ ⊢ THEOREM "LimitInterchange" : P_lim
P_colim = rewrite(P_lim, DualityMappings)
-------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "ColimitInterchange" : P_colim ;
CATEGORY
[[ INFER_DUAL_THEOREM 'ColimitInterchange' ... ]] = "A constructive proof of the Fubini-style theorem for colimits, derived mechanically by applying the duality functor. It asserts that in a cocomplete category, iterated colimits can be interchanged, a result obtained systematically from the theory of limits." ;

}


(* ========================================================================================================== )
( == Part 1: Defining the Players of the Pointwise World == )
( ========================================================================================================== *)

FunctorCategoryDeclaration ::= "FUNCTOR_CATEGORY" Identifier "->" Identifier ;
TYPING
Γ ⊢ J : Category, Γ ⊢ C : Category
----------------------------------------------------------------------
Γ ⊢ (J -> C) : Category ; (* This is C^J, or [J,C] *)
CATEGORY
[[ J -> C ]] = "The category C^J whose objects are functors from J to C and whose morphisms are natural transformations between these functors." ;

DiagramOfFunctorsDeclaration ::= "DIAGRAM_OF_FUNCTORS" Identifier ":" Identifier "->" FunctorCategoryDeclaration ;
TYPING
(* This is a diagram whose points are themselves diagrams. D: I -> C^J *)
Γ ⊢ I : Category, Γ ⊢ C_J : FunctorCategory
-----------------------------------------------------
Γ ⊢ DIAGRAM_OF_FUNCTORS ... : Functor(I, C_J) ;
CATEGORY
[[ DIAGRAM_OF_FUNCTORS D:I -> (J->C) ]] = "A diagram in the functor category. For each index object i in I, D(i) is a functor from J to C. For each arrow in I, D assigns a natural transformation." ;

EvaluationFunctor ::= "ev" "_" Identifier ;
TYPING
(* This functor is the formal mechanism for "evaluating at a point j". *)
Γ ⊢ C_J = FunctorCategory(J, C)
Γ ⊢ j : Object_in(J)
----------------------------------------------------------
Γ ⊢ ev_j : Functor(C_J, C) ;
CATEGORY
[[ ev_j ]] = "The evaluation functor at j. It is the projection ev_j : C^J → C that sends a functor F:J->C to its value F(j) and a natural transformation α:F=>G to its component α_j:F(j)->G(j)." ;

(* ========================================================================================================== )
( == Part 2: Constructing the Diagram of Points == )
( ========================================================================================================== *)

DiagramOfPointsConstructor ::= "PointwiseDiagram" "(" Identifier "," "at" ":" Identifier ")" ;
TYPING
(*
* This constructor formalizes the right-hand side of the pointwise theorem. It takes a diagram
* of functors D and an evaluation point j, and composes D with ev_j to produce a
* simple diagram of points in the base category C.
)
Γ ⊢ D : DiagramOfFunctors(I -> (J->C))
Γ ⊢ j : Object_in(J)
ev_j = EvaluationFunctor(at: j)
------------------------------------------------------------------------------------------
Γ ⊢ PointwiseDiagram(D, at:j) : Diagram(I -> C) ( This is the composition ev_j ∘ D *) ;
CATEGORY
[[ PointwiseDiagram(D, at:j) ]] = "The diagram of points obtained by evaluating each functor D(i) in the original diagram D at the specific point j. This transforms a diagram of diagrams into a simple diagram in the base category, ready for a standard limit computation." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem and its Dual == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitsInFunctorCategoriesArePointwise" ":"
"FOR_ALL" DiagramOfFunctorsDeclaration "D" ","
"(" "L" "is" "LIMIT" "of" "D" ")" "==>"
"(" "FOR_ALL" "point" "j" "," "(ev_j(L) ≅ LIMIT of PointwiseDiagram(D, at: j))" ")" ;
TYPING
(* This is the formal typing of the famous isomorphism: L(j) ≅ lim(D_i(j)) )
Context: All necessary limits exist.
Γ ⊢ D : Functor(I, C^J)
Γ ⊢ L = lim(D) : Object_in(C^J) ( L is a functor J->C *)
-----------------------------------------------------------------
∀j ∈ Ob(J), Γ ⊢ L(j) ≅ lim(PointwiseDiagram(D, at:j)) ;
CATEGORY
[[ THEOREM LimitsInFunctorCategoriesArePointwise ]] = "The fundamental theorem of limits in functor categories. It asserts that to compute a complex limit L (which is a functor), one can instead compute a series of simpler limits in the base category C for each 'point' j in J. The resulting collection of limit points assembles into the limit functor L." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LimitsInFunctorCategoriesArePointwise" "IS" "ColimitsInFunctorCategoriesArePointwise" ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'ColimitsInFunctorCategoriesArePointwise'" "FROM" "THEOREM" "'LimitsInFunctorCategoriesArePointwise'" ;
TYPING
(*
* By applying the Duality Principle, we derive the dual theorem for colimits.
* The system applies the duality dictionary:
* - LIMIT becomes COLIMIT.
* The structure of the argument remains identical, proving that colimits are also computed pointwise.
*)
Γ ⊢ THEOREM "LimitsInFunctorCategoriesArePointwise" : P_lim
P_colim = rewrite(P_lim, DualityMappings)
-----------------------------------------------------------------
Conclusion: Γ ⊢ THEOREM "ColimitsInFunctorCategoriesArePointwise" : P_colim ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the pointwise nature of colimits in functor categories, derived mechanically by applying the duality functor to the theorem for limits. This demonstrates the symmetry of the principle and the power of formal duality." ;

}



(* ========================================================================================================== )
( == Part 1: Defining the Players (Slice Category and Forgetful Functor) == )
( ========================================================================================================== *)
SliceCategoryDeclaration ::= "CATEGORY" "Slice" "(" Identifier "," Identifier ")" ;
TYPING
(* Defines the slice category C/X. *)
Γ ⊢ C : Category, Γ ⊢ X : Object_in(C)
-------------------------------------------
Γ ⊢ CATEGORY Slice(C, X) : Category ;
CATEGORY
[[ CATEGORY Slice(C, X) ]] = "The slice category C/X. Its objects are pairs (A, f) where A is an object in C and f: A -> X is a morphism in C. Its morphisms from (A,f) to (B,g) are morphisms h:A->B in C such that g ∘ h = f (i.e., the triangle commutes)." ;
ForgetfulFunctor_Slice ::= "U_slice" "(" Identifier "," Identifier ")" ;
TYPING
(* Defines the forgetful functor U : C/X -> C. *)
Γ ⊢ C/X = Slice(C, X) : Category
-------------------------------------------------
Γ ⊢ U_slice(C, X) : Functor(C/X, C) ;
CATEGORY
[[ U_slice(C, X) ]] = "The forgetful functor U from the slice category C/X to the base category C. It maps an object (A,f) to its underlying object A, and a morphism h (a commuting triangle) to the underlying morphism h. It 'forgets' the arrow to X and the commutativity constraint." ;
(* ========================================================================================================== )
( == Part 2: Formalizing the Key Property (Creation of Limits) == )
( ========================================================================================================== *)
FunctorProperty ::= Identifier "creates" "LIMITS" ;
TYPING
(*
* This defines the property of "creating" limits, which is stronger than reflection.
* It means that for any diagram D in A, if its image U∘D has a limit L in B,
* then there must exist a unique limit cone L' for D in A that U maps onto L.
*)
Γ ⊢ U : Functor(A, B)
Condition := ∀ (Diagram D:J->A), ( (L = lim(U∘D) in B) ⇒ ∃! (L' = lim(D) in A) s.t. U(L') ≅ L )
--------------------------------------------------------------------------------------------------
Γ ⊢ U creates LIMITS : PropositionAbout(U) ;
CATEGORY
[[ U creates LIMITS ]] = "The property of a functor U to not only preserve and reflect limits but to guarantee the existence and uniqueness of a 'lifted' limit in its domain whenever a limit exists for the image in the codomain. This is a powerful structural guarantee." ;
(* ========================================================================================================== )
( == Part 3: The Main Theorem == )
( ========================================================================================================== *)
TheoremDeclaration ::= "THEOREM" "SliceFunctorCreatesLimits" ":"
"IF" "(" Identifier "C" "is COMPLETE" ")" "THEN" "(" "U_slice" "(" "C" "," Identifier "X" ")" "creates" "LIMITS" ")" ;
TYPING
(*
* This is the central theorem. It states that the 'niceness' (completeness) of the base
* category C endows the forgetful functor from any of its slices with the powerful
* property of creating limits.
*)
P1 := (Γ ⊢ C is COMPLETE)
P2 := (Γ ⊢ U_slice(C, X) creates LIMITS)
-----------------------------------------
Γ ⊢ (P1 ==> P2) : ProvableImplication ;
CATEGORY
[[ THEOREM SliceFunctorCreatesLimits ]] = "The fundamental theorem on the structure of slice categories. It asserts that the existence of all limits in a category C is a sufficient condition to guarantee that the forgetful functor from any of its slice categories C/X creates all limits. The proof involves constructing the apex of the limit cone in C/X and showing it is unique." ;
(* ========================================================================================================== )
( == Part 4: The Practical Corollary == )
( ========================================================================================================== *)
CorollaryDeclaration ::= "COROLLARY" "CompletenessOfSlice" "to" "SliceFunctorCreatesLimits" ":"
"(" Identifier "C" "is COMPLETE" ")" "==>" "(" "Slice" "(" "C" "," Identifier "X" ")" "is COMPLETE" ")" ;
TYPING
(*
* This corollary is a direct consequence of the main theorem and the definition of creation.
* If a functor U:A->B creates limits and its codomain B is complete, its domain A must be complete.
)
Γ ⊢ C is COMPLETE
Γ ⊢ U_slice(C,X) creates LIMITS ( Premise from Theorem *)
-----------------------------------------------------------------
Γ ⊢ Slice(C,X) is COMPLETE : ProvableProposition ;
CATEGORY
[[ COROLLARY CompletenessOfSlice ... ]] = "The practical and important consequence of the main theorem: the property of completeness is inherited by all of a category's slice categories. If C has all limits, then C/X does as well." ;
(* ========================================================================================================== )
( == Part 5: Deriving the Dual Theory for Coslice Categories == )
( ========================================================================================================== *)
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "SliceCategory" "IS" "CosliceCategory" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "creates LIMITS" "IS" "creates COLIMITS" ;
DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CosliceCocompleteness'" "FROM" "THEOREM" "'SliceFunctorCreatesLimits'" "and its corollary" ;
TYPING
(*
* By applying the Duality Principle, we mechanically derive the entire theory for Coslice categories.
* The system applies the dictionary:
* - Slice(C,X) becomes Coslice(C,X) (the category X\C).
* - COMPLETE becomes COCOMPLETE.
* - creates LIMITS becomes creates COLIMITS.
* The result is the complete dual theory.
*)
Γ ⊢ THEOREM "SliceFunctorCreatesLimits" and its Corollary
P_dual = rewrite(AllPropositions, DualityMappings)
----------------------------------------------------------
Conclusion: We have now proven the dual theorems:
1. IF C is COCOMPLETE THEN U_coslice: X\C -> C creates COLIMITS.
2. IF C is COCOMPLETE THEN X\C is COCOMPLETE. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the main theorem and corollary for coslice categories, derived mechanically by applying the duality functor. This demonstrates that cocompleteness is inherited by all coslice categories via a forgetful functor that creates colimits, a result obtained 'for free' from the original theorem." ;

MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 3: 'Adjoint functors', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.1: Definition and examples of adjoint functors" ")" "==>" {

(*

ELABORATION: The concept of an adjunction is central to category theory. It can be defined in

several equivalent ways. We will elaborate on this section by formalizing the two most common definitions

and demonstrating their equivalence. Then, we will use this formal machinery to construct two classic examples.

The Hom-Set Isomorphism: An adjunction is a natural isomorphism between Hom-sets.

The Unit-Counit Definition: An adjunction is specified by a pair of natural transformations

Generated code
(the unit and counit) that satisfy coherence laws (the triangle identities).


We will create a master rule for AdjunctionDeclaration that allows either formulation and an axiom

asserting their equivalence, then instantiate these definitions with concrete examples.
*)

(* ========================================================================================================== )
( == Part 1: The Two Core Definitions of Adjunction == )
( ========================================================================================================== *)

AdjunctionDeclaration ::= Identifier "⊣" Identifier ":" "(" Identifier "," Identifier ")" | "ADJUNCTION" "from" UnitCounitPair ;
TYPING
(* This rule allows two syntaxes for declaring an adjunction F ⊣ G. )
CASE "F ⊣ G: (C, D)": ( Hom-set definition )
Γ ⊢ F : Functor(C,D), Γ ⊢ G : Functor(D,C)
IsNaturalIsomorphism( Hom_D(F(-),) , Hom_C(-,G()) )
CASE "ADJUNCTION from ...": ( Unit-counit definition *)
Γ ⊢ pair : UnitCounitPair
Satisfies(pair, TriangleIdentitiesAxiom)
------------------------------------------------------------------------------------------------
Γ ⊢ ... : Adjunction(F,G) ;
CATEGORY
[[ F ⊣ G ]] = "The assertion that functor F is left adjoint to functor G. This is a fundamental structural relationship between categories, more general than equivalence but still indicating a strong connection." ;

HomSetIsomorphism ::= "Hom_" Identifier "(" Expression "," Expression ")" "≅" "Hom_" Identifier "(" Expression "," Expression ")" ;
TYPING
(* This predicate defines the natural isomorphism of Hom-sets for F ⊣ G. *)
Γ ⊢ D, C : Category
IsNaturalIsomorphism(
λX,Y. Hom_D(F(X), Y),
λX,Y. Hom_C(X, G(Y))
)

Γ ⊢ Hom_D(F(-),) ≅ Hom_C(-,G()) : ProvableIsomorphism ;
CATEGORY
[[ Hom_D(F(X),Y) ≅ Hom_C(X,G(Y)) ]] = "The formal statement of the hom-set adjunction. It asserts a natural bijection between the set of arrows from the image of X to Y in D, and the set of arrows from X to the image of Y in C." ;

UnitCounitPair ::= "UNIT" NaturalTransformationDeclaration "COUNIT" NaturalTransformationDeclaration ;
TYPING
(* Defines the unit (η) and counit (ε) natural transformations required for the second definition. *)
Context: Functors F:C->D, G:D->C
Γ ⊢ η : NATURAL_TRANSFORMATION Id_C ==> G∘F
Γ ⊢ ε : NATURAL_TRANSFORMATION F∘G ==> Id_D
-------------------------------------------------------------------------
Γ ⊢ UNIT η COUNIT ε : UnitCounitPair ;
CATEGORY
[[ UNIT η COUNIT ε ]] = "The data for a unit-counit adjunction. The unit η universally maps an object X to its 'reflection' G(F(X)), while the counit ε universally maps the 'co-reflection' F(G(Y)) back to Y." ;

TriangleIdentitiesAxiom ::= "AXIOM" "TriangleIdentities" "FOR" UnitCounitPair ;
TYPING
(* This axiom asserts that the unit and counit satisfy the zig-zag coherence laws. *)
Context: (η, ε) form a UnitCounitPair for F ⊣ G
Law1 := ∀X∈Ob(C), ε_{F(X)} ∘ F(η_X) == id_{F(X)}
Law2 := ∀Y∈Ob(D), G(ε_Y) ∘ η_{G(Y)} == id_{G(Y)}
-----------------------------------------------------
Γ ⊢ AXIOM TriangleIdentities ... : ProvableEquality ;
CATEGORY
[[ AXIOM TriangleIdentities ... ]] = "The coherence laws for a unit-counit adjunction. These identities ensure that the process of applying the unit and then mapping with F is undone by the counit (and dually), preventing the adjunction from collapsing." ;

(* ========================================================================================================== )
( == Part 2: The Equivalence of Definitions == )
( ========================================================================================================== *)

EquivalenceOfAdjunctionDefinitions ::= "THEOREM" "AdjunctionEquivalence" ":"
"(" Identifier "⊣" Identifier ")" "<==>" "(" "ExistsUnitCounitSatisfyingTriangles" ")" ;
TYPING
P_hom_set := (Γ ⊢ F ⊣ G via Hom-set isomorphism)
P_unit_counit := (Γ ⊢ ∃ (η,ε) : UnitCounitPair s.t. AXIOM TriangleIdentities holds)
---------------------------------------------------------------------------------
Γ ⊢ (P_hom_set <==> P_unit_counit) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdjunctionEquivalence ... ]] = "A fundamental meta-theorem asserting that the two primary definitions of an adjunction (hom-set isomorphism and unit-counit with triangle identities) are logically equivalent." ;

(* ========================================================================================================== )
( == Part 3: Example 1 - The Free-Forgetful Adjunction == )
( ========================================================================================================== *)

CategoryDeclaration ::= "CATEGORY" ("Set" | "Grp") ; (* Declare our categories *)

ForgetfulFunctor ::= "FORGET" "from" Identifier "to" Identifier ;
TYPING
Γ ⊢ U : Identifier, Γ ⊢ Grp:Category, Γ ⊢ Set:Category
--------------------------------------------------
Γ ⊢ FORGET U from Grp to Set : Functor(Grp, Set) ;
CATEGORY
[[ FORGET U from Grp to Set ]] = "The forgetful functor U: Grp -> Set which maps a group to its underlying set of elements and a group homomorphism to the underlying function." ;

FreeFunctor ::= "FREE" "on" Identifier "from" Identifier "to" Identifier ;
TYPING
Γ ⊢ F : Identifier, Γ ⊢ Set:Category, Γ ⊢ Grp:Category
------------------------------------------------
Γ ⊢ FREE F on Set from Set to Grp : Functor(Set, Grp) ;
CATEGORY
[[ FREE F on Set from Set to Grp ]] = "The free functor F: Set -> Grp which maps a set to the free group generated by the elements of that set." ;

AdjunctionDeclaration ::= "FREE 'F' ⊣ FORGET 'U' : (Set, Grp)" ;
TYPING
(* This asserts the canonical adjunction between the free and forgetful functors. *)
IsNaturalIsomorphism( Hom_Grp(F(S), G), Hom_Set(S, U(G)) )
----------------------------------------------------------
Γ ⊢ ... : Adjunction(F,U) ;
CATEGORY
[[ F ⊣ U ]] = "The free-forgetful adjunction. The isomorphism Hom_Grp(F(S), G) ≅ Hom_Set(S, U(G)) states that a homomorphism from the free group on S to G is uniquely determined by a function from the generators S to the set underlying G." ;

UnitComponent ::= "η_" Identifier ;
CounitComponent ::= "ε_" Identifier ;
TYPING
Γ ⊢ S : Object_in(Set)
--------------------------------
Γ ⊢ η_S : S -> U(F(S)) ;
Γ ⊢ G : Object_in(Grp)
------------------------------
Γ ⊢ ε_G : F(U(G)) -> G ;
CATEGORY
[[ η_S ]] = "The unit of the free-forgetful adjunction at a set S. It is the function that includes the set of generators S into the underlying set of the free group F(S)." ;
[[ ε_G ]] = "The counit of the adjunction at a group G. It is the homomorphism that evaluates a formal word in the free group F(U(G)) to its product in the group G." ;

(* ========================================================================================================== )
( == Part 4: Example 2 - The Product-Diagonal Adjunction == )
( ========================================================================================================== *)

ProductCategory ::= Identifier "×" Identifier ;
TYPING
Γ ⊢ C1:Category, Γ ⊢ C2:Category
-----------------------------------
Γ ⊢ C1 × C2 : Category ;
CATEGORY
[[ C1 × C2 ]] = "The product category, whose objects are pairs of objects (c1, c2) and morphisms are pairs of morphisms (f1, f2)." ;

Functor_Delta ::= "Δ" ;
Functor_Pi ::= "Π" ;
TYPING
(* The Diagonal Functor )
Γ ⊢ C:Category
--------------------------------------
Γ ⊢ Δ : Functor(C, C × C) ;
( The Product Functor *)
Γ ⊢ C:Category, C has all Products
----------------------------------------
Γ ⊢ Π : Functor(C × C, C) ;
CATEGORY
[[ Δ ]] = "The diagonal functor Δ: C -> C×C which maps an object X to the pair (X,X) and a morphism f to the pair (f,f)." ;
[[ Π ]] = "The product functor Π: C×C -> C which maps a pair of objects (A,B) to their product A×B and a pair of morphisms (f,g) to the induced morphism f×g." ;

AdjunctionDeclaration ::= "Functor_Delta ⊣ Functor_Pi : (C, C×C)" ;
TYPING
(* This asserts the adjunction Δ ⊣ Π *)
IsNaturalIsomorphism( Hom_{C×C}(Δ(X), (A,B)), Hom_C(X, Π(A,B)) )
---------------------------------------------------------------------
Γ ⊢ ... : Adjunction(Δ, Π) ;
CATEGORY
[[ Δ ⊣ Π ]] = "The adjunction between the diagonal and product functors. The isomorphism Hom_{C×C}((X,X), (A,B)) ≅ Hom_C(X, A×B) unpacks to Hom_C(X,A) × Hom_C(X,B) ≅ Hom_C(X, A×B), which is precisely the universal property of the binary product in category C." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.2: The adjoint functor theorem" ")" "==>" {
(*

ELABORATION: To formalize the Adjoint Functor Theorem is not merely to state it, but to

construct its logical prerequisites as formal objects within our grammar. We will:

Define the constituent properties required by the theorems: the Solution Set Condition,

Generated code
and the properties of categories being well-powered and having a cogenerator.


Formalize the two main existence theorems, the General Adjoint Functor Theorem (GAFT)

Generated code
and the Special Adjoint Functor Theorem (SAFT), which provide checkable criteria for
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
Generated code
the existence of a left adjoint.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Demonstrate the power of the Duality Principle by defining the dual notions (Generator, etc.)

Generated code
and using the `DualTheoremInference` rule to mechanically derive the corresponding theorems
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
Generated code
for the existence of right adjoints.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

*)

(* ========================================================================================================== )
( == Part 1: The Prerequisites for the Theorems == )
( ========================================================================================================== *)

SolutionSetCondition ::= Identifier "satisfies" "SolutionSetCondition" ;
TYPING
(*
* This formalizes the technical 'smallness' condition required by the GAFT. Intuitively,
* it states that for any object c, the problem of finding a universal arrow from c to
* G can be solved by searching through a 'set' of candidates, not a 'proper class'.
*)
Γ ⊢ G : Functor(D, C)
∀c ∈ Ob(C), ∃ (Set S_c of pairs (d_i, f_i)) where d_i ∈ Ob(D), f_i : c -> G(d_i)
s.t. ∀d' ∈ Ob(D), ∀h : c -> G(d'), ∃ (d_i, f_i) ∈ S_c, ∃ (g : d_i -> d') s.t. h = G(g) ∘ f_i
------------------------------------------------------------------------------------------------
Γ ⊢ G satisfies SolutionSetCondition : PropositionAbout(G) ;
CATEGORY
[[ G satisfies SolutionSetCondition ]] = "A 'smallness' condition ensuring that for any object c, the collection of all maps from c into the image of G is 'generated' by a set-sized collection of initial maps. This prevents the construction of the left adjoint from running into set-theoretic paradoxes." ;

CategoryPropertyDefinition ::= Identifier "is" "WELL-POWERED" ;
TYPING
(* A category is well-powered if every object has only a set (not a proper class) of subobjects. *)
Γ ⊢ C : Category
∀X ∈ Ob(C), IsSet({ S | S is Subobject of X })
--------------------------------------------------
Γ ⊢ C is WELL-POWERED : PropositionAbout(C) ;
CATEGORY
[[ C is WELL-POWERED ]] = "A 'local smallness' property of a category, ensuring that its subobject lattices are well-behaved sets. This is a common property for many categories of interest, like Set or Grp." ;

FunctorProperty_Faithful ::= Identifier "is" "FAITHFUL" ;
TYPING
(* A functor is faithful if it is injective on hom-sets. *)
Γ ⊢ F : Functor(C,D)
∀X,Y ∈ Ob(C), Function (m ↦ F(m)) from Hom_C(X,Y) to Hom_D(F(X),F(Y)) is an Injection
--------------------------------------------------------------------------------------
Γ ⊢ F is FAITHFUL : PropositionAbout(F) ;
CATEGORY
[[ F is FAITHFUL ]] = "The property of a functor that does not collapse distinct parallel morphisms. It may identify non-parallel morphisms, but it is 'faithful' to the distinctions within any given hom-set." ;

HasCogenerator ::= Identifier "has" "COGENERATOR" ;
TYPING
(* A category has a cogenerator if there is a 'testing' object C such that Hom(-, C) is a faithful functor. *)
Γ ⊢ D : Category
∃C ∈ Ob(D), ( Γ ⊢ Functor_Hom(-,C) is FAITHFUL )
------------------------------------------------
Γ ⊢ D has COGENERATOR : PropositionAbout(D) ;
CATEGORY
[[ D has COGENERATOR ]] = "The property of a category possessing a single 'testing object' C such that any two distinct parallel arrows f,g: X->Y can always be distinguished by composing them with some map Y->C. It provides a way to 'probe' the structure of the category from a single object." ;

(* ========================================================================================================== )
( == Part 2: The Adjoint Functor Theorems for Left Adjoints == )
( ========================================================================================================== *)

AdjointFunctorTheoremLeft ::= "THEOREM" ("GeneralAdjointFunctorTheorem" | "SpecialAdjointFunctorTheorem") ":" Proposition ;
TYPING
(* This rule formalizes the two main existence theorems for LEFT adjoints. *)
Context: Functor G:D->C, Category D is COMPLETE
CASE "GeneralAdjointFunctorTheorem":
(G has LeftAdjoint) <==> (G preserves LIMITS ∧ G satisfies SolutionSetCondition)
CASE "SpecialAdjointFunctorTheorem":
IF (D is WELL-POWERED ∧ D has COGENERATOR):
(G has LeftAdjoint) <==> (G preserves LIMITS)
---------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : ProvableEquivalence ;
CATEGORY
[[ THEOREM GeneralAdjointFunctorTheorem ... ]] = "The theorem providing necessary and sufficient conditions for a functor G to have a left adjoint. It links the abstract existence question to two concrete properties: limit preservation (structural compatibility) and the solution set condition (foundational safety)." ;
[[ THEOREM SpecialAdjointFunctorTheorem ... ]] = "A powerful simplification of the GAFT. For categories that are sufficiently 'well-behaved' (well-powered with a cogenerator), the difficult solution set condition is automatically met, making the existence of a left adjoint equivalent to the single property of preserving limits." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory for Right Adjoints (Derived via Duality) == )
( ========================================================================================================== *)

(* First, we must formally define the dual concepts required by the dual theorems. *)
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "WELL-POWERED" "IS" "WELL-COPOWERED" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "COGENERATOR" "IS" "GENERATOR" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "SolutionSetCondition" "IS" "CoSolutionSetCondition" ;

HasGenerator ::= Identifier "has" "GENERATOR" ;
TYPING
(* This is the dual of HasCogenerator. *)
IsDualOf("HasCogenerator")
EquivalentTyping: Γ ⊢ D : Category, ∃G ∈ Ob(D), ( Γ ⊢ Functor_Hom(G,-) is FAITHFUL )
-----------------------------------------------
Γ ⊢ D has GENERATOR : PropositionAbout(D) ;
CATEGORY
[[ D has GENERATOR ]] = "The dual property to having a cogenerator. A generator G is an object from which every other object can be reached by a series of morphisms and colimits. It 'generates' the whole category." ;

AdjointFunctorTheoremRight ::= "INFER_DUAL_THEOREM" ("GeneralAdjointFunctorTheorem_Dual" | "SpecialAdjointFunctorTheorem_Dual") "FROM" AdjointFunctorTheoremLeft ;
TYPING
(*
* This is the Duality Principle in action. We do not need to reprove the theorems.
* We apply the (-)^op operator to the theorems for left adjoints.
* The system uses the DualityMapping dictionary to mechanically generate the correct dual theorems.
* G:D->C has left adjoint F <--Duality--> F:C->D has right adjoint G
* D is COMPLETE <--Duality--> C is COCOMPLETE
* G preserves LIMITS <--Duality--> F preserves COLIMITS
* WellPowered, Cogenerator <--Duality--> WellCopowered, Generator
*)
Γ ⊢ THEOREM GAFTLeft : P_GAFT_L
Γ ⊢ THEOREM SAFTLeft : P_SAFT_L
------------------------------------------------------------------
Γ ⊢ THEOREM GAFTRight : (P_GAFT_L)^op
Γ ⊢ THEOREM SAFTRight : (P_SAFT_L)^op ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the Adjoint Functor Theorems for the existence of RIGHT adjoints. The results are not proven from scratch, but are derived mechanically by applying the formal duality functor to the theorems for left adjoints. This demonstrates that the entire logical structure of the argument is perfectly symmetric." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.3: Properties of adjoint functors" ")" "==>" {

(* ========================================================================================================== )
( == Property 1: Relationship with Limits and Colimits == )
( ========================================================================================================== )
(

ELABORATION: This is the most important and widely used property of adjoints. It provides a

powerful tool for proving that a functor preserves limits or colimits. The property is

perfectly dual: right adjoints preserve limits, and left adjoints preserve colimits.

We will formalize the first statement and then use our established Duality Principle to

derive the second statement "for free".
*)

TheoremDeclaration ::= "THEOREM" "RightAdjointsPreserveLimits" ":"
"FOR_ALL" "functor" "G" "," "(" "G is RightAdjoint" ")" "==>" "(" "G preserves LIMITS" ")" ;
TYPING
(*
* This theorem states that if a functor G has a left adjoint, then G must preserve
* all limits that exist in its domain category. This is a provable proposition in the meta-theory.
*)
IsProvable( ∀G, (HasLeftAdjoint(G)) ⇒ (PreservesAllLimits(G)) )
---------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM RightAdjointsPreserveLimits ... ]] = "The assertion of a fundamental connection between the algebraic structure of an adjunction and the limit-based structure of a category. It provides a sufficient condition for a functor to be 'continuous' (limit-preserving)." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LeftAdjointsPreserveColimits'" "FROM" "THEOREM" "'RightAdjointsPreserveLimits'" ;
TYPING
(*
* This rule demonstrates the Duality Principle. We apply the (-)^op operator to the theorem above.
* The system uses the DualityMapping dictionary to perform these transformations:
* 1. "RightAdjoint" -> "LeftAdjoint"
* 2. "LIMITS" -> "COLIMITS"
* The result is the fully-formed, correct, and provable dual theorem.
*)
Γ ⊢ THEOREM 'RightAdjointsPreserveLimits' : P_lim
P_colim = rewrite(P_lim, DualityMappings)
--------------------------------------------------------------------------
Γ ⊢ (INFER_DUAL_THEOREM ... results in) THEOREM 'LeftAdjointsPreserveColimits' : P_colim ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual theorem, derived mechanically by applying the duality functor. It asserts that all left adjoint functors are 'cocontinuous' (colimit-preserving), a result obtained symmetrically and without a separate proof." ;

(* ========================================================================================================== )
( == Property 2: Adjunctions as Universal Arrows == )
( ========================================================================================================== )
(

ELABORATION: This property provides an alternative, often more intuitive, definition of an

adjunction. It recasts the global property of a natural isomorphism of hom-sets into a

local property about individual "universal arrows" for each object.
*)

UniversalArrowCategory ::= "(" Identifier "↓" Identifier ")" | "(" Identifier "↓" Identifier ")" ;
TYPING
(* Defines the two comma categories needed for the universal arrow definition. )
CASE "(X ↓ G)": ( Category of arrows from object X to functor G )
Γ ⊢ X:Object_in(C), Γ ⊢ G:Functor(D,C)
CASE "(F ↓ Y)": ( Category of arrows from functor F to object Y *)
Γ ⊢ F:Functor(C,D), Γ ⊢ Y:Object_in(D)
-------------------------------------------------------------------------------------
Γ ⊢ ... : Category ;
CATEGORY
[[ (X ↓ G) ]] = "The comma category of objects from D 'under' X via G. Its objects are pairs (d, f:X->G(d))." ;
[[ (F ↓ Y) ]] = "The comma category of objects from C 'over' Y via F. Its objects are pairs (c, g:F(c)->Y)." ;

TheoremDeclaration ::= "THEOREM" "AdjunctionsViaUniversalArrows" ":"
"(" Identifier "F" "⊣" Identifier "G" ")" "<==>" "(FOR_ALL X, η_X is Initial in (X↓G)) ∧ (FOR_ALL Y, ε_Y is Terminal in (F↓Y))" ;
TYPING
(* This proposition asserts the equivalence of the main adjunction definition with the universal arrow definition. *)
P_adj := (Γ ⊢ F ⊣ G : Adjunction)
P_univ := ( (∀X∈Ob(C), (Unit(η)_X : X -> G(F(X))) is INITIAL_OBJECT in (X↓G)) ∧
(∀Y∈Ob(D), (Counit(ε)_Y : F(G(Y)) -> Y) is TERMINAL_OBJECT in (F↓Y)) )
--------------------------------------------------------------------
Γ ⊢ (P_adj <==> P_univ) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdjunctionsViaUniversalArrows ... ]] = "An equivalent characterization of an adjunction in terms of universal mapping properties. It states that an adjunction exists if and only if for every object X, there is a 'best' arrow from X to the functor G (the unit), and dually, a 'best' arrow from F to every object Y (the counit)." ;

(* ========================================================================================================== )
( == Property 3: Uniqueness of Adjoints == )
( ========================================================================================================== )
(

ELABORATION: This property ensures that the concept of "the" adjoint is well-defined. While a functor

might not have an adjoint, if it does, it is unique up to a canonical natural isomorphism.
*)

TheoremDeclaration ::= "THEOREM" "AdjointsAreUnique" ":"
"(" Identifier "F" "⊣" Identifier "G" "∧" Identifier "F_prime" "⊣" "G" ")" "==>" "(" "F" "≅" "F_prime" ")" ;
TYPING
(* This theorem states that any two left adjoints (F, F') of the same functor (G) must be naturally isomorphic. *)
Γ ⊢ F, F_prime : Functor(C,D), Γ ⊢ G : Functor(D,C)
Γ ⊢ F ⊣ G
Γ ⊢ F_prime ⊣ G
--------------------------------------------------------------------------
Γ ⊢ F is NaturallyIsomorphicTo F_prime : ProvableIsomorphism ;
CATEGORY
[[ THEOREM AdjointsAreUnique ... ]] = "The assertion that a functor's adjoint is unique up to a canonical natural isomorphism. This allows us to speak of 'the' left adjoint or 'the' right adjoint of a given functor without ambiguity, which is crucial for building theories upon the concept." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.4: Fully faithful adjoint functors" ")" "==>" {
(*

ELABORATION: This section explores the deep connection between the properties of an adjoint

functor (specifically, its faithfulness and fullness) and the properties of the unit and

counit of the adjunction. To elaborate, we will formalize this connection by:

Defining the properties FAITHFUL and FULL for functors.

Stating the precise theorem that relates these properties for a right adjoint G to

Generated code
whether the components of the unit `η` are monomorphisms, split epimorphisms, or isomorphisms.


Using the DualTheoremInference rule to mechanically derive the corresponding, dual theorem

Generated code
for a left adjoint `F` and the components of the counit `ε`. This demonstrates the power
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

of formal duality.
*)

(* ========================================================================================================== )
( == Part 1: Defining the Functor Properties == )
( ========================================================================================================== *)

FunctorProperty_Faithful ::= Identifier "is" "FAITHFUL" ;
TYPING
(* A functor F is faithful if it is injective on hom-sets. *)
Γ ⊢ F : Functor(C,D)
Is_Injective( F_{X,Y} : Hom_C(X,Y) -> Hom_D(F(X),F(Y)) ) for all X,Y in C
--------------------------------------------------------------------------------------
Γ ⊢ F is FAITHFUL : PropositionAbout(F) ;
CATEGORY
[[ F is FAITHFUL ]] = "The property of a functor that does not collapse distinct parallel morphisms. If f ≠ g, then F(f) ≠ F(g). It is 'faithful' to the distinctions within any given hom-set." ;

FunctorProperty_Full ::= Identifier "is" "FULL" ;
TYPING
(* A functor F is full if it is surjective on hom-sets. *)
Γ ⊢ F : Functor(C,D)
Is_Surjective( F_{X,Y} : Hom_C(X,Y) -> Hom_D(F(X),F(Y)) ) for all X,Y in C
------------------------------------------------------------------------------------
Γ ⊢ F is FULL : PropositionAbout(F) ;
CATEGORY
[[ F is FULL ]] = "The property of a functor where every morphism between images F(X) -> F(Y) is the image of some morphism X -> Y. It ensures no new morphisms appear between image objects." ;

FunctorProperty_FullyFaithful ::= Identifier "is" "FULLY_FAITHFUL" ;
TYPING
(* A functor is fully faithful if it is both full and faithful. *)
Γ ⊢ F is FAITHFUL
Γ ⊢ F is FULL
-------------------------------------------------------
Γ ⊢ F is FULLY_FAITHFUL : PropositionAbout(F) ;
CATEGORY
[[ F is FULLY_FAITHFUL ]] = "The property of a functor that induces an isomorphism on hom-sets. It represents a full and faithful embedding of the morphism structure of the source category into the target category." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem for Right Adjoints and the Unit == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "RightAdjointFaithfulnessCriteria" ":"
"FOR_ADJUNCTION" "(" Identifier "⊣" Identifier "G" ")" "," "{"
"'G is FAITHFUL' <==> '∀X, η_X is MONOMORPHISM'" ";"
"'G is FULL' <==> '∀X, η_X is SPLIT_EPIMORPHISM'" ";"
"'G is FULLY_FAITHFUL' <==> '∀X, η_X is ISOMORPHISM'" ";"
"}" ;
TYPING
(* This theorem provides a complete diagnostic for the properties of a Right Adjoint G. *)
Context: F ⊣ G, with unit η
Equivalence1 := (Γ ⊢ G is FAITHFUL) <==> (∀X, Γ ⊢ η_X is MONOMORPHISM)
Equivalence2 := (Γ ⊢ G is FULL) <==> (∀X, Γ ⊢ η_X is SPLIT_EPIMORPHISM)
Equivalence3 := (Γ ⊢ G is FULLY_FAITHFUL) <==> (∀X, Γ ⊢ η_X is ISOMORPHISM)
--------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheoremPackage(Equivalence1, Equivalence2, Equivalence3) ;
CATEGORY
[[ THEOREM RightAdjointFaithfulnessCriteria ... ]] = "A fundamental set of equivalences connecting the global properties of a right adjoint functor G to the local properties of the individual components of the unit η. This powerful theorem allows one to check for faithfulness/fullness by examining the unit arrows, which is often much easier." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theorem via Duality Principle == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LeftAdjointFaithfulnessCriteria'" "FROM" "THEOREM" "'RightAdjointFaithfulnessCriteria'" ;
TYPING
(*
* This is the Duality Principle in action. We apply the (-)^op operator to the theorem above.
* The system uses its DualityMapping dictionary to perform these transformations:
* 1. RightAdjoint G -> LeftAdjoint F
* 2. unit η -> counit ε
* 3. MONOMORPHISM -> EPIMORPHISM
* 4. SPLIT_EPIMORPHISM -> SPLIT_MONOMORPHISM
* 5. ISOMORPHISM -> ISOMORPHISM (self-dual)
* The result is the fully-formed, correct, and provable dual theorem for the left adjoint F.
*)
Γ ⊢ THEOREM 'RightAdjointFaithfulnessCriteria' : P_right
P_left = rewrite(P_right, DualityMappings)
-----------------------------------------------------------------------------
Γ ⊢ (INFER_DUAL_THEOREM ... results in) THEOREM 'LeftAdjointFaithfulnessCriteria' : P_left ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual theorem, derived mechanically by applying the duality functor. It asserts the corresponding criteria for a left adjoint F based on the properties of the counit ε's components. For example, F is faithful if and only if every component of ε is an epimorphism. This result is obtained symmetrically and without a separate proof, highlighting the power of formal duality." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.5: Reflective subcategories" ")" "==>" {
(*

ELABORATION: A reflective subcategory is a fundamental concept illustrating how a "nice"
subcategory sits inside a larger, ambient category. The core idea is that the inclusion
functor has a left adjoint, called the "reflector". To elaborate on this, we will:

Formalize the Components: Define FullSubcategory and the InclusionFunctor that
embeds it.

Define the Core Concept: Create a rule for ReflectiveSubcategory that is explicitly
defined by the existence of a left adjoint to the inclusion functor.

Identify the Universal Arrow: Formalize the ReflectionArrow, which is the unit of
the adjunction, showing how any object in the larger category maps universally to its
"reflection" in the subcategory.

State the Key Theorem: Connect this concept to the previous section (3.4) by stating
the theorem that for a reflective subcategory, the counit of the adjunction is an
isomorphism, a direct consequence of the inclusion functor being fully faithful.

*)

(* ========================================================================================================== )
( == Part 1: The Components (Subcategory and Inclusion) == )
( ========================================================================================================== *)

FullSubcategoryDeclaration ::= "FULL_SUBCATEGORY" Identifier "of" Identifier "on_objects" "{" {Identifier} "}" ;
TYPING
(*
* A Full Subcategory A of B is determined by a subset of B's objects.
* It inherits ALL morphisms from B between those objects.
*)
Γ ⊢ B : Category, Γ ⊢ A_id : Identifier
Obj_A ⊆ Objects(B)
Morphisms_A(X,Y) == Morphisms_B(X,Y) for all X,Y in Obj_A
---------------------------------------------------------------
Γ ⊢ FULL_SUBCATEGORY A_id of B ... : Subcategory(A_id, B) ;
CATEGORY
[[ FULL_SUBCATEGORY A of B ... ]] = "The definition of a subcategory A that has a subset of B's objects but retains the complete hom-set structure between any two of those objects." ;

InclusionFunctorDeclaration ::= "INCLUSION" Identifier ":" Identifier "↪" Identifier ;
TYPING
(* The inclusion functor I simply maps objects and morphisms of A to themselves in B. *)
Γ ⊢ A : Subcategory_of(B)
---------------------------------------------------
Γ ⊢ INCLUSION I: A ↪ B : Functor(A, B) ;
CATEGORY
[[ INCLUSION I: A ↪ B ]] = "The canonical functor embedding the subcategory A into its parent category B. This functor is always faithful, and if A is a full subcategory, it is fully faithful." ;

(* ========================================================================================================== )
( == Part 2: The Core Concept and its Universal Arrow == )
( ========================================================================================================== *)

ReflectiveSubcategoryDeclaration ::= Identifier "is" "REFLECTIVE_IN" Identifier ;
TYPING
(*
* This is the master definition. A is reflective in B if its inclusion functor I has a left adjoint L.
*)
Γ ⊢ A : FullSubcategory_of(B)
Γ ⊢ I : InclusionFunctor(A, B)
Γ ⊢ L is LeftAdjointOf(I)
------------------------------------------------------------
Γ ⊢ A is REFLECTIVE_IN B : PropositionAbout(A) ;
CATEGORY
[[ A is REFLECTIVE_IN B ]] = "The property of a subcategory A being a 'core component' of B. For every object in B, there is a 'best approximation' or 'reflection' within A, a process governed by the left adjoint (the reflector) to the inclusion functor." ;

ReflectorFunctor ::= "Reflector" "(" Identifier "," Identifier ")" ;
TYPING
(* This rule gives a name to the left adjoint of the inclusion. *)
Context: A is REFLECTIVE_IN B
Γ ⊢ L ⊣ Inclusion(A,B)
--------------------------------------------------
Γ ⊢ Reflector(A,B) : Functor(B, A) (where this functor is L) ;
CATEGORY
[[ Reflector(A,B) ]] = "The left adjoint to the inclusion I:A↪B. This functor L:B->A maps each object b in the larger category to its reflection L(b) in the subcategory A." ;

ReflectionArrow ::= "reflection_of" "(" Identifier ")" ;
TYPING
(*
* The reflection arrow for an object b in B is precisely the b-component of the unit
* of the adjunction L ⊣ I. It is an arrow η_b : b -> I(L(b)).
*)
Context: A is REFLECTIVE_IN B, L = Reflector(A,B), I = Inclusion(A,B)
Γ ⊢ η is UnitOf(L ⊣ I)
Γ ⊢ b : Object_in(B)
--------------------------------------------------------------------------
Γ ⊢ reflection_of(b) : Morphism( b, I(L(b)) ) (where this is η_b) ;
CATEGORY
[[ reflection_of(b) ]] = "The universal arrow from the object b to the inclusion functor I. This morphism is the 'reflection' of b into the subcategory, representing the universal solution to approximating b with an object from A." ;

(* ========================================================================================================== )
( == Part 3: The Key Consequence (from Sec. 3.4) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "ReflectionCounitIsomorphism" ":"
"FOR" ReflectiveSubcategoryDeclaration "A in B" ","
"Counit(Reflector(A,B) ⊣ Inclusion(A,B)) is ISOMORPHISM" ;
TYPING
(*
* This theorem is a direct consequence of the definitions and results from Sec. 3.4.
* 1. The inclusion functor I of a FULL subcategory A is, by definition, FULLY_FAITHFUL.
* 2. The subcategory A is reflective, so the adjunction L ⊣ I exists, with counit ε.
* 3. The theorem from Sec. 3.4 states that for an adjunction F ⊣ G, F is fully faithful
* if and only if the counit ε is an isomorphism.
* 4. In our case, F is the Reflector L, and G is the Inclusion I. While I being
* fully faithful doesn't directly imply L is, a standard result for reflective
* subcategories confirms that the counit ε is indeed an isomorphism.
*)
Context: A is REFLECTIVE_IN B, L ⊣ I, with counit ε
Premise1 := (Γ ⊢ I is FULLY_FAITHFUL) (from definition of FullSubcategory)
--------------------------------------------------------------------------------
Conclusion: Γ ⊢ ε is ISOMORPHISM : ProvableProposition ;
CATEGORY
[[ THEOREM ReflectionCounitIsomorphism ... ]] = "A key structural property of reflective subcategories. It asserts that for any object a already in the subcategory, reflecting it and then mapping back via the counit (ε_a: L(I(a)) -> a) is an isomorphism. This means the reflection process is 'idempotent' up to isomorphism on objects of A." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.6: Epireflective subcategories" ")" "==>" {
(*

ELABORATION: This section defines a special, more constrained type of reflective subcategory.
The constraint concerns the nature of the "reflection arrows." To elaborate, we will:

Formalize the Definition: Define EpireflectiveSubcategory by building directly upon
the ReflectiveSubcategory definition, adding the crucial constraint that all reflection
arrows must be epimorphisms.

State the Key Characterization Theorem: Formalize the powerful theorem stating that
a subcategory is epireflective if and only if it is closed under the formation of
products and subobjects within the larger ambient category.

Provide a Classic Example: Instantiate these definitions with the canonical example of
Grp (Groups) as an epireflective subcategory of Mon (Monoids).

Derive the Dual Theory: Use the DualityMappingAxiom and DualTheoremInference
rules to mechanically derive the entire corresponding theory for the dual concept of
MonoreflectiveSubcategory, including its characterization theorem.

*)

(* ========================================================================================================== )
( == Part 1: The Core Definition == )
( ========================================================================================================== *)

EpireflectiveSubcategoryDeclaration ::= Identifier "is" "EPIREFLECTIVE_IN" Identifier ;
TYPING
(*
* This typing rule has two premises:
* 1. The subcategory must first satisfy the conditions of being reflective.
* 2. The reflection arrows (which are the components of the unit η of the
* Reflector ⊣ Inclusion adjunction) must all be epimorphisms.
*)
Premise1: Γ ⊢ A is REFLECTIVE_IN B
Context: Let η be the unit of the Reflector(B,A) ⊣ Inclusion(A,B) adjunction.
Premise2: ∀ b ∈ Objects(B), (Γ ⊢ component(η, b) is EPIMORPHISM)
---------------------------------------------------------------------
Γ ⊢ A is EPIREFLECTIVE_IN B : PropositionAbout(A) ;
CATEGORY
[[ A is EPIREFLECTIVE_IN B ]] = "A property of a subcategory A requiring not only that a 'best approximation' of any object b in B exists in A, but that the universal mapping to this approximation (η_b) is an epimorphism. This is characteristic of subcategories formed by imposing algebraic equations, such as the inclusion of Groups into Monoids." ;

(* ========================================================================================================== )
( == Part 2: The Characterization Theorem == )
( ========================================================================================================== *)

CategoryClosednessProperty ::= Identifier "is_closed_under" ("PRODUCTS" | "SUBOBJECTS") "in" Identifier ;
TYPING
Γ ⊢ A : Subcategory_of(B)
CASE "PRODUCTS":
Condition := ∀ (family {a_i} ⊆ Ob(A)), (Product_in_B({a_i}) exists) ⇒ (Product_in_B({a_i}) ∈ Ob(A))
CASE "SUBOBJECTS":
Condition := ∀ (a ∈ Ob(A)), ∀ (m:s->a is MONOMORPHISM in B), (s ∈ Ob(A))
---------------------------------------------------------------------------------
Γ ⊢ A is_closed_under ... : PropositionAbout(A) ;
CATEGORY
[[ A is_closed_under PRODUCTS in B ]] = "The property that the subcategory A contains all products of its own objects that are formed within the ambient category B." ;
[[ A is_closed_under SUBOBJECTS in B ]] = "The property that A contains all subobjects of its own objects." ;

TheoremDeclaration ::= "THEOREM" "EpireflectiveCriterion" ":"
"(" Identifier "A" "is" "EPIREFLECTIVE_IN" Identifier "B" ")"
"<==>"
"(" "A is_closed_under PRODUCTS in B" "&&" "A is_closed_under SUBOBJECTS in B" ")" ;
CATEGORY
[[ THEOREM EpireflectiveCriterion ... ]] = "A fundamental theorem providing a powerful, non-adjunction-based criterion for a subcategory to be epireflective. It equates the abstract property of epireflection with the concrete structural properties of being closed under products and subobjects." ;

(* ========================================================================================================== )
( == Part 3: A Concrete Example (Grp in Mon) == )
( ========================================================================================================== *)

EpireflectiveSubcategoryDeclaration ::= "Grp" "is" "EPIREFLECTIVE_IN" "Mon" ;
TYPING
(* To prove this, one must show that Grp is reflective in Mon, and the reflection maps are epis. )
Γ ⊢ Grp is REFLECTIVE_IN Mon ( Via the Grothendieck group construction as a reflector *)
Let η be the unit of this adjunction.
∀ (m ∈ Ob(Mon)), (Γ ⊢ η_m : m -> L(I(m)) is EPIMORPHISM in Mon)
------------------------------------------------------------------
Γ ⊢ "Grp is EPIREFLECTIVE_IN Mon" : ProvableProposition ;
CATEGORY
[[ Grp is EPIREFLECTIVE_IN Mon ]] = "The canonical example of an epireflective subcategory. Groups form a subcategory of Monoids closed under products and subobjects, thus satisfying the criterion. The reflection of a monoid is its group of invertible elements (or Grothendieck group), and the inclusion map is an epimorphism." ;

(* ========================================================================================================== )
( == Part 4: The Dual Theory (Monoreflective Subcategories) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "EPIREFLECTIVE_IN" "IS" "MONOREFLECTIVE_IN" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "SUBOBJECTS" "IS" "QUOTIENT_OBJECTS" ;

MonoreflectiveSubcategoryDeclaration ::= Identifier "is" "MONOREFLECTIVE_IN" Identifier ;
TYPING
(* Derived via duality. REFLECTIVE is self-dual in this context, but EPIMORPHISM becomes MONOMORPHISM. *)
Premise1: Γ ⊢ A is REFLECTIVE_IN B
Context: Let η be the unit of the Reflector(B,A) ⊣ Inclusion(A,B) adjunction.
Premise2_dual: ∀ b ∈ Objects(B), (Γ ⊢ component(η, b) is MONOMORPHISM)
--------------------------------------------------------------------------
Γ ⊢ A is MONOREFLECTIVE_IN B : PropositionAbout(A) ;
CATEGORY
[[ A is MONOREFLECTIVE_IN B ]] = "The dual concept, requiring the universal reflection arrows to be monomorphisms. This is characteristic of subcategories formed by imposing 'properties' rather than 'structure', such as the inclusion of Hausdorff spaces into all Topological spaces." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'MonoreflectiveCriterion'" "FROM" "THEOREM" "'EpireflectiveCriterion'" ;
TYPING
(*
* By applying the duality operator to the EpireflectiveCriterion theorem, the system derives:
* (A is MONOREFLECTIVE_IN B) <==> (A is_closed_under COPRODUCTS in B && A is_closed_under QUOTIENT_OBJECTS in B)
*)
Γ ⊢ THEOREM 'EpireflectiveCriterion' : P_epi
P_mono = rewrite(P_epi, DualityMappings)
---------------------------------------------------------
Γ ⊢ THEOREM 'MonoreflectiveCriterion' : P_mono ;
CATEGORY
[[ INFER_DUAL_THEOREM 'MonoreflectiveCriterion' ... ]] = "A constructive proof of the characterization theorem for monoreflective subcategories, derived mechanically by applying the duality functor. It asserts that monoreflectivity is equivalent to being closed under colimits and quotient objects, a result obtained 'for free' from the original theorem." ;
}


MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.7: Kan extensions" ")" "==>" {
(*

ELABORATION: Kan extensions are among the most general and abstract concepts in category theory,

unifying limits, colimits, and adjunctions under a single framework. To elaborate, we must

deconstruct this universal property into its constituent parts:

The Candidates: Formalize the notion of a "candidate extension," which is a functor

Generated code
paired with a natural transformation that links it to the original setup.


The Category of Candidates: Define the categories whose objects are these candidates.

The Universal Object: Show that the Kan extension is precisely the initial (for Left Kan)

Generated code
or terminal (for Right Kan) object in this category of candidates. This is the most
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
Generated code
elegant and fundamental definition.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The Pointwise Formula: State the famous and powerful theorem that provides a formula

Generated code
for computing Kan extensions as a (co)limit, when they exist. This connects the
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
Generated code
abstract universal property to the concrete machinery of (co)limits.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The Link to Adjunctions: Formalize the theorem showing that adjunctions themselves

Generated code
are a special case of Kan extensions, completing the conceptual unification.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

*)

(* ========================================================================================================== )
( == Part 1: The Setup and The Candidates == )
( ========================================================================================================== *)

KanExtensionContext ::= "CONTEXT_KAN" "{" "K" ":" Identifier "->" Identifier ";" "T" ":" Identifier "->" Identifier ";" "}" ;
TYPING
(* This rule establishes the common context for any Kan extension problem. *)
Γ ⊢ C, A, B : Category
Γ ⊢ K : Functor(C, A), Γ ⊢ T : Functor(C, B)
--------------------------------------------------------------
Γ ⊢ CONTEXT_KAN ... : KanProblemSetup(K, T) ;
CATEGORY
[[ CONTEXT_KAN { K:C->A; T:C->B; } ]] = "The data for a Kan extension problem. We have a functor K mapping a small category C into a larger one A, and another functor T mapping C into a target B. The goal is to 'best' extend T to all of A." ;

LeftKanCandidate ::= "L_CANDIDATE" "(" Identifier "," Identifier ")" ;
TYPING
(* A Left Kan Candidate is a proposed solution: a functor M:A->B and a transformation β:T ==> M∘K *)
Context: KanProblemSetup(K:C->A, T:C->B)
Γ ⊢ M : Functor(A, B)
Γ ⊢ β : NaturalTransformation(T, M∘K)
-----------------------------------------------------
Γ ⊢ L_CANDIDATE(M, β) : LeftKanCandidate_Type ;
CATEGORY
[[ L_CANDIDATE(M, β) ]] = "A candidate solution for the Left Kan Extension. It consists of a functor M from the larger domain A, and a natural transformation β that witnesses how M's behavior (when restricted back to C via K) relates to the original functor T." ;

RightKanCandidate ::= "R_CANDIDATE" "(" Identifier "," Identifier ")" ;
TYPING
(* A Right Kan Candidate is the dual: a functor M:A->B and a transformation δ:M∘K ==> T *)
Context: KanProblemSetup(K:C->A, T:C->B)
Γ ⊢ M : Functor(A, B)
Γ ⊢ δ : NaturalTransformation(M∘K, T)
------------------------------------------------------
Γ ⊢ R_CANDIDATE(M, δ) : RightKanCandidate_Type ;
CATEGORY
[[ R_CANDIDATE(M, δ) ]] = "A candidate solution for the Right Kan Extension. The transformation δ witnesses how the behavior of the proposed functor M relates to the original T, with the arrow pointing in the opposite direction from the Left Kan case." ;

(* ========================================================================================================== )
( == Part 2: The Universal Property as a Universal Object == )
( ========================================================================================================== *)

LeftKanExtensionIsInitialObject ::= "LeftKanExtension" "(" Identifier "," Identifier ")" "IS_INITIAL_IN_CATEGORY_OF" LeftKanCandidate ;
TYPING
(* This is the core definition of the Left Kan Extension (Lan_K T). *)
Γ ⊢ K:Functor(C,A), Γ ⊢ T:Functor(C,B)
Category_LKC := Category of LeftKanCandidate(K,T)
L_α_pair := (L, α) where L = Lan_K T
-----------------------------------------------------------------------------------------------
Γ ⊢ L_α_pair is INITIAL_OBJECT in Category_LKC : DefinitionalProposition ;
CATEGORY
[[ LeftKanExtension(K,T) IS_INITIAL_IN_CATEGORY_OF L_CANDIDATE ]] = "The formal definition of the Left Kan Extension Lan_K T as the initial object in the category of left candidates. Its universality means it is the 'freest' or 'most efficient' extension of T along K." ;

RightKanExtensionIsTerminalObject ::= "RightKanExtension" "(" Identifier "," Identifier ")" "IS_TERMINAL_IN_CATEGORY_OF" RightKanCandidate ;
TYPING
(* The dual definition for the Right Kan Extension (Ran_K T). *)
Γ ⊢ K:Functor(C,A), Γ ⊢ T:Functor(C,B)
Category_RKC := Category of RightKanCandidate(K,T)
R_ε_pair := (R, ε) where R = Ran_K T
-------------------------------------------------------------------------------------------------
Γ ⊢ R_ε_pair is TERMINAL_OBJECT in Category_RKC : DefinitionalProposition ;
CATEGORY
[[ RightKanExtension(K,T) IS_TERMINAL_IN_CATEGORY_OF R_CANDIDATE ]] = "The formal definition of the Right Kan Extension Ran_K T as the terminal object in the category of right candidates. Its universality means it is the 'most constrained' or 'canonical' extension of T along K." ;

(* ========================================================================================================== )
( == Part 3: The Pointwise Formula Theorem == )
( ========================================================================================================== *)

PointwiseKanFormulaTheorem ::= "THEOREM" "KanExtensionAsLimit" ":" Proposition ;
TYPING
Context: All necessary (co)limits exist in B.
P_Right := ( (Ran_K T)(a) ≅ Limit( Diagram Functor (a↓K) -> C -> B ) ) for each a in A
P_Left := ( (Lan_K T)(a) ≅ Colimit( Diagram Functor (K↓a) -> C -> B ) ) for each a in A
-----------------------------------------------------------------------------------
Γ ⊢ (P_Right ∧ P_Left) : ProvableIsomorphism ;
CATEGORY
[[ THEOREM KanExtensionAsLimit ... ]] = "The fundamental theorem providing a constructive formula for Kan extensions. It asserts that the value of the Right Kan Extension at a point a can be computed as a limit over the comma category of objects 'under a', and dually for the Left Kan Extension. This connects the abstract universal property to the concrete machinery of (co)limits." ;

CommaObjectUnderFunctor ::= "(" Identifier "↓" Identifier ")" ;
TYPING
(* This formalizes the comma category (a ↓ K) needed for the pointwise formula. *)
Γ ⊢ a : Object_in(A), Γ ⊢ K : Functor(C, A)
Objects of (a ↓ K) are pairs (c, f) where c∈Ob(C) and f: a -> K(c)
Morphisms from (c, f) to (c', f') are h: c -> c' in C s.t. K(h) ∘ f = f'
------------------------------------------------------------------------
Γ ⊢ (a ↓ K) : Category ;
CATEGORY
[[ (a ↓ K) ]] = "The comma category of K-arrows from a. Its objects represent all the ways the fixed object a can map into the image of the functor K." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "'CommaObjectUnderFunctor'" "IS" "'CommaObjectOverFunctor'" ;

(* ========================================================================================================== )
( == Part 4: Adjunctions as a Special Case == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdjointsAsKanExtensions" ":"
"(" Identifier "F" "⊣" Identifier "G" ")"
"<==>"
"(" "F" "≅" "LeftKanExtension" "Id" "along" "G" "&&" "G" "≅" "RightKanExtension" "Id" "along" "F" ")" ;
TYPING
Γ ⊢ F : Functor(C,D), Γ ⊢ G : Functor(D,C), Γ ⊢ Id_C : Functor(C,C), Γ ⊢ Id_D : Functor(D,D)
P_Adj := (Γ ⊢ F ⊣ G)
P_Kan := ( (Γ ⊢ F ≅ Lan_G(Id_C)) ∧ (Γ ⊢ G ≅ Ran_F(Id_D)) )
-------------------------------------------------------------
Γ ⊢ (P_Adj <==> P_Kan) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdjointsAsKanExtensions ... ]] = "The assertion that the concept of an adjunction is a specific instance of a Kan extension. Specifically, a left adjoint F is the best possible extension of the identity functor Id_C along the right adjoint G, and dually. This demonstrates that Kan extensions are a more general and foundational concept than adjunctions." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.8: Tensor product of set-valued functors" ")" "==>" {
(* ========================================================================================================== )
( == Section 3.8: Tensor product of set-valued functors == )
( ========================================================================================================== )
(

ELABORATION: This section formalizes the tensor product of functors, a concept that generalizes

the tensor product of modules over a ring. The key idea is to create a universal object that

receives "balanced pairings" of elements from the two functors. To elaborate, we will:

Formally define the "players": presheaves (functors C^op -> Set) and copresheaves (functors C -> Set).

Deconstruct the definition of the tensor product as a coequalizer, explicitly defining the

Generated code
two large sets and the parallel arrows between them whose coequalizer is the tensor product.


Formalize the crucial adjunction, showing that the Tensor functor (- ⊗ G) is left adjoint

Generated code
to a Hom-functor, which represents the universal property of the construction.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Provide the equivalent universal property in terms of "C-balanced maps", which provides a strong

Generated code
analogy to the familiar bilinear maps from linear algebra.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

*)

(* ========================================================================================================== )
( == Part 1: The Players (Presheaves and Copresheaves) == )
( ========================================================================================================== *)

PresheafDeclaration ::= "PRESHEAF" Identifier "on" Identifier ;
TYPING
(* A Presheaf is a formal name for a contravariant set-valued functor. *)
Γ ⊢ C : Category
---------------------------------------------------------
Γ ⊢ PRESHEAF F on C : Functor(C^op, Set) ;
CATEGORY
[[ PRESHEAF F on C ]] = "An object in the category [C^op, Set], also known as the category of presheaves on C. It assigns a set to each object of C and a function (reversing arrows) to each morphism of C." ;

CopresheafDeclaration ::= "COPRESHEAF" Identifier "on" Identifier ;
TYPING
(* A Copresheaf is a formal name for a covariant set-valued functor. *)
Γ ⊢ C : Category
----------------------------------------------------------
Γ ⊢ COPRESHEAF G on C : Functor(C, Set) ;
CATEGORY
[[ COPRESHEAF G on C ]] = "An object in the category [C, Set], the category of copresheaves on C. It is also known as a C-indexed set." ;

(* ========================================================================================================== )
( == Part 2: The Deconstructed Coequalizer Definition == )
( ========================================================================================================== *)

TensorAsCoequalizer ::= "DEFINE" Expression "⊗_" Identifier Expression "as" "Coequalizer" "(" Identifier "," Identifier ")" ;
TYPING
(* This is the master definition, now made precise. The tensor product is the coequalizer of two parallel arrows. )
Γ ⊢ F : Presheaf on C, Γ ⊢ G : Copresheaf on C
Γ ⊢ S_mor : Set, Γ ⊢ S_obj : Set ( The two sets defined below *)
Γ ⊢ alpha, beta : Morphism(S_mor, S_obj)
----------------------------------------------------------------------------------------------------------
Γ ⊢ DEFINE F ⊗_C G as Coequalizer(alpha, beta) : Set ;
CATEGORY
[[ DEFINE F ⊗_C G ... ]] = "The construction of the tensor product set as a quotient (formalized as a coequalizer) that imposes the C-balancing condition. This is the categorical analogue of constructing a tensor product of modules by quotienting a free module." ;

TensorSummand_Objects ::= "SumOverObjects" "(" Identifier "," Identifier ")" ;
TYPING
(* This defines the codomain of the parallel arrows: the disjoint union of all paired elements. )
Γ ⊢ F : Presheaf on C, Γ ⊢ G : Copresheaf on C
---------------------------------------------------------------------------
Γ ⊢ SumOverObjects(F,G) : Set ; ( Equivalent to ∐_{c ∈ Ob(C)} F(c) × G(c) *)
CATEGORY
[[ SumOverObjects(F,G) ]] = "The set representing the 'free' or 'raw' pairings of elements from the functors F and G, before any balancing relations are imposed. Its elements are pairs (x,y) where x comes from F(c) and y comes from G(c) for some object c." ;

TensorSummand_Morphisms ::= "SumOverMorphisms" "(" Identifier "," Identifier ")" ;
TYPING
(* This defines the domain of the parallel arrows: the disjoint union of pairs that will generate the relation. )
Γ ⊢ F : Presheaf on C, Γ ⊢ G : Copresheaf on C
-----------------------------------------------------------------------------
Γ ⊢ SumOverMorphisms(F,G) : Set ; ( Equivalent to ∐_{h:c→d ∈ Mor(C)} F(c) × G(d) *)
CATEGORY
[[ SumOverMorphisms(F,G) ]] = "The set whose elements represent the 'generators' of the balancing relation. Each element corresponds to a morphism h:c->d and provides a pair (x,y) where x is in F(c) and y is in G(d), ready to be acted upon by the functorial maps." ;

TensorParallelArrowsAxiom ::= "AXIOM" "TensorParallelArrows" ":" Expression "and" Expression "map" TensorSummand_Morphisms "to" TensorSummand_Objects ;
TYPING
(* This axiom formally defines the two parallel arrows alpha and beta. *)
Context: S_mor = SumOverMorphisms(F,G), S_obj = SumOverObjects(F,G)
For a component h:c->d of S_mor and an element (x,y) in F(c)×G(d):
alpha(x,y)_h := (x, G(h)(y)) in F(c)×G(c) component of S_obj
beta(x,y)_h := (F(h)(x), y) in F(d)×G(d) component of S_obj
---------------------------------------------------------------------------------------------------------------
Γ ⊢ (alpha, beta) : pair(Morphism(S_mor, S_obj)) ;
CATEGORY
[[ AXIOM TensorParallelArrows ... ]] = "The definition of the two morphisms whose coequalizer forms the tensor product. For a relation generated by h:c->d, alpha moves an element of G(d) 'backwards' along h, while beta moves an element of F(c) 'forwards' along h. Equating them implements the condition (x.h, y) ~ (x, h.y)." ;

(* ========================================================================================================== )
( == Part 3: The Universal Property as an Adjunction == )
( ========================================================================================================== *)

TensorHomAdjunctionTheorem ::= "THEOREM" "TensorHomAdjunction" ":"
"Functor_Tensor" "(" Identifier ")" "⊣" "Functor_YonedaHom" "(" Identifier ")" ;
TYPING
(* This is the formal typing of the adjunction: (- ⊗_C G) ⊣ Hom_{Set}(G(-), -) *)
LeftAdjoint_F := λ(F:Presheaf). F ⊗_C G
RightAdjoint_G := λ(S:Set). (c ↦ Hom_{Set}(G(c), S))
------------------------------------------------------------------------------------------------
Γ ⊢ LeftAdjoint_F ⊣ RightAdjoint_G : Adjunction([C^op,Set], Set) ;
CATEGORY
[[ THEOREM TensorHomAdjunction ... ]] = "The assertion of the fundamental adjunction for the tensor product. It shows that the 'external' operation of tensoring with G is left adjoint to the 'internal' operation of constructing a mapping object (a presheaf) from G. This is a powerful, abstract form of the universal property." ;

(* ========================================================================================================== )
( == Part 4: The Universal Property as C-Balanced Maps == )
( ========================================================================================================== *)

C_BalancedMapDeclaration ::= "C_BALANCED_MAP" Identifier ":" "(" Identifier "," Identifier ")" "->" Identifier ;
TYPING
(* Defines a C-balanced map from a presheaf F and copresheaf G to a set S. *)
Γ ⊢ F : Presheaf on C, Γ ⊢ G : Copresheaf on C, Γ ⊢ S : Set
β is a family of maps { β_c : F(c) × G(c) -> S | c ∈ Ob(C) }
BalancingCondition := ∀h:c->d, β_d(F(h)(x), y) == β_c(x, G(h)(y))
---------------------------------------------------------------------------------
Γ ⊢ C_BALANCED_MAP β : ... : C_BalancedMap_Type ;
CATEGORY
[[ C_BALANCED_MAP β ... ]] = "A family of bilinear-like maps that is 'balanced' or 'compatible' with the structure of the category C. This is the precise categorical analogue of a bilinear map of modules." ;

TensorUniversalPropertyTheorem ::= "THEOREM" "TensorUP" ":"
"C_BalancedMap" "(" Identifier "," Identifier ";" Identifier ")" "≅" "Hom_Set" "(" Expression "⊗_" Identifier Expression "," Identifier ")" ;
TYPING
(* This theorem states that any C-balanced map β uniquely factors through the tensor product. *)
Context: F:Presheaf, G:Copresheaf, S:Set
IsNaturalIsomorphism( CBalancedMaps(F,G;S), Hom_{Set}(F⊗G, S) )
----------------------------------------------------------------
Γ ⊢ THEOREM ... : ProvableIsomorphism ;
CATEGORY
[[ THEOREM TensorUP ... ]] = "The assertion of the universal property of the tensor product in its most intuitive form. It states that the set of C-balanced maps from F and G to a set S is in natural bijection with the set of simple functions from the tensor product F⊗G to S. The tensor product is therefore the universal recipient of all C-balanced maps." ;
}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 4: 'Generators and projectives', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(* ========================================================================================================== *)
(* == Part 1: Defining the Equivalence Relation on Monomorphisms                                         == *)
(* ========================================================================================================== *)
(* ELABORATION: The core concept of a subobject is not a single monomorphism, but an *equivalence class*
 * of them. To formalize this, we must first explicitly define the equivalence relation itself. Two
 * monomorphisms are equivalent if their domains are isomorphic in a way that respects the maps into X.
*)

MonomorphismEquivalence ::= Identifier "≈_Sub" Identifier ;
TYPING
    (*
     * This rule defines the proposition `m1 ≈_Sub m2`. It is true if m1 and m2 are
     * monomorphisms into the same object X, and there exists an isomorphism `i`
     * between their domains such that the triangle commutes.
    *)
    Γ ⊢ m1 : S1 -> X, Γ ⊢ m2 : S2 -> X
    Γ ⊢ m1, m2 are MONOMORPHISMS
    ∃ (i : S1 -> S2 is ISOMORPHISM) s.t. (m2 ∘ i == m1)
    -------------------------------------------------------
    Γ ⊢ (m1 ≈_Sub m2) : EquivalenceRelation ;
CATEGORY
    [[ m1 ≈_Sub m2 ]] = "An assertion of isomorphism in the slice category C/X between the objects (S1, m1) and (S2, m2). This is the fundamental relation used to define subobjects." ;

(* ========================================================================================================== *)
(* == Part 2: Defining Subobjects and their Ordering                                                       == *)
(* ========================================================================================================== *)

SubobjectAsEquivalenceClass ::= "[" Identifier "]" "_X" ;
TYPING
    (* A Subobject is now explicitly an equivalence class [m] under the relation ≈_Sub. *)
    Γ ⊢ m : S -> X, Γ ⊢ m is MONOMORPHISM
    -------------------------------------------
    Γ ⊢ [m]_X : SubobjectOf(X) ;
CATEGORY
    [[ [m]_X ]] = "The subobject of X represented by the monomorphism m. It is the equivalence class of all monomorphisms `m'` such that `m' ≈_Sub m`." ;

SubobjectOrdering ::= SubobjectAsEquivalenceClass "≤" SubobjectAsEquivalenceClass ;
TYPING
    (*
     * The ordering relation [m1] ≤ [m2] holds if there exists a morphism `k` (which will
     * necessarily be a monomorphism) such that `m1` factors through `m2`.
    *)
    Γ ⊢ [m1]_X : SubobjectOf(X), Γ ⊢ [m2]_X : SubobjectOf(X)
    m1 : S1 -> X, m2 : S2 -> X
    ∃ (k : S1 -> S2) s.t. (m2 ∘ k == m1)
    -------------------------------------------------
    Γ ⊢ ([m1]_X ≤ [m2]_X) : Proposition ;
CATEGORY
    [[ [m1]_X ≤ [m2]_X ]] = "The assertion that the 'part' of X represented by m1 is contained within the 'part' represented by m2. This defines a partial order on the collection of subobjects of X." ;

(* ========================================================================================================== *)
(* == Part 3: The Master Definition and its Dual                                                         == *)
(* ========================================================================================================== *)

SubobjectLattice ::= "Sub" "(" Identifier ")" ;
TYPING
    (* This constructor bundles all subobjects of X into a single structure. *)
    Γ ⊢ X : Object_in(C)
    -----------------------------------------------------------
    Γ ⊢ Sub(X) : Poset(SubobjectOf(X), ≤) ;
CATEGORY
    [[ Sub(X) ]] = "The subobject lattice of X. It is the partially ordered collection of all subobjects of X, which forms a complete lattice if the category C is sufficiently complete." ;

CategoryPropertyDefinition ::= Identifier "is" "WELL-POWERED" ;
TYPING
    (*
     * The refined definition of well-powered: A category C is well-powered if for any object X,
     * its entire subobject lattice `Sub(X)` is a set, not a proper class.
    *)
    Γ ⊢ C : Category
    ∀ X ∈ Objects(C), IsSet( Sub(X) )
    ---------------------------------------
    Γ ⊢ C is WELL-POWERED : PropositionAbout(C) ;
CATEGORY
    [[ C is WELL-POWERED ]] = "A 'local smallness' condition asserting that every object in the category has a set-sized lattice of subobjects. This is a crucial prerequisite for many constructions, including the Adjoint Functor Theorems and image factorizations." ;

(* ========================================================================================================== *)
(* == Part 4: The Entire Dual Theory (via Duality Principle)                                             == *)
(* ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEORY" "'Well-Copowered'" "FROM" "THEORY" "'Well-Powered'" ;
TYPING
    (***
     * By applying the duality functor `(-)^op` to the entire theory block defined above,
     * the system mechanically generates the corresponding correct dual theory.
     * The DualityMapping dictionary performs the following rewrites:
     * 1. Monomorphism -> Epimorphism
     * 2. ≈_Sub -> ≈_Quotient
     * 3. Subobject -> QuotientObject
     * 4. m:S->X -> e:X->Q
     * 5. [m]_X -> [e]^X
     * 6. SubobjectLattice `Sub(X)` -> QuotientLattice `Quot(X)`
     * 7. WELL-POWERED -> WELL-COPOWERED
     * The resulting propositions are valid theorems in the dual theory.
    ***)
    Γ ⊢ TheoryBlock["Well-Powered"] : CoherentTheoryFragment
    --------------------------------------------------------------------------------------
    Γ ⊢ TheoryBlock["Well-Copowered"] := (TheoryBlock["Well-Powered"])^op : CoherentTheoryFragment ;
CATEGORY
    [[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the entire theory for 'well-copowered' categories. This process, derived by mechanically applying the duality functor, generates the definitions for quotient object equivalence, quotient lattices, and the `is WELL-COPOWERED` property without requiring separate proofs, showcasing the symmetry and power of the Duality Principle." ;

(* ========================================================================================================== *)
(* == Part 1: Deconstructing Intersection as a Limit (Wide Pullback)                                     == *)
(* ========================================================================================================== *)

WidePullbackDiagram ::= "DIAGRAM_for_Intersection" "(" "{" {SubobjectOf} "}" ")" ;
TYPING
    (* This constructor defines the specific diagram shape over which we take a limit to get an intersection. *)
    (* It's a cospan diagram with many legs, all pointing to the same object X. *)
    ∀ s_i in Subobjects_Set, Γ ⊢ s_i : SubobjectOf(X) (with representative m_i: A_i -> X)
    Shape := The category with objects {A_i} and a terminal object T, and arrows A_i -> T.
    Functor D maps A_i to A_i and T to X.
    -----------------------------------------------------------------------------------------
    Γ ⊢ DIAGRAM_for_Intersection(...) : Diagram ;
CATEGORY
    [[ DIAGRAM_for_Intersection({[m_i]}) ]] = "The cospan diagram formed by the representative monomorphisms {m_i} all pointing to the object X. The limit of this diagram is known as a wide pullback." ;

IntersectionConstructor ::= "LIMIT_OF" WidePullbackDiagram ;
TYPING
    (* This rule asserts that the intersection *is* the limit of the cospan diagram. *)
    Γ ⊢ C : Category, C has all small Limits
    Γ ⊢ d : WidePullbackDiagram
    ----------------------------------------------------
    Γ ⊢ LIMIT_OF d : SubobjectOf( Codomain(d) ) ;
CATEGORY
    [[ LIMIT_OF d ]] = "The formal construction of the intersection as a limit. The apex of the limit cone is the domain of the new subobject, and the universal mapping property of the limit guarantees it is the greatest lower bound." ;

BinaryIntersection ::= SubobjectOf "∩" SubobjectOf ;
TYPING
    (* Convenience syntax for the most common case. *)
    Γ ⊢ s1 : SubobjectOf(X), Γ ⊢ s2 : SubobjectOf(X)
    -----------------------------------------------------
    Γ ⊢ (s1 ∩ s2) : SubobjectOf(X) (defined as Intersection({s1, s2}) );
CATEGORY
    [[ s1 ∩ s2 ]] = "The pullback of the monomorphisms representing s1 and s2. This is the binary case of the general intersection construction." ;

(* ========================================================================================================== *)
(* == Part 2: Deconstructing Union as a Colimit-then-Image                                               == *)
(* ========================================================================================================== *)

UnionConstructor ::= "Image" "(" "UniversalCoproductMap" "(" "{" {SubobjectOf} "}" ")" ")" ;
TYPING
    (*
     * This rule formalizes the two-step construction of the union.
     * Step 1: Form the coproduct of the domains of the subobjects (e.g., A_i).
     * Step 2: Form the induced map [m_i] from the coproduct ∐A_i to X.
     * Step 3: Take the image of this map, which is the union subobject.
    *)
    Context: C has small Coproducts and Images (e.g. from a (StrongEpi, Mono) factorization system).
    Subobjects_Set = {s_i | s_i has representative m_i: A_i -> X }
    CP := Coproduct({ A_i })
    u := UniversalCoproductMorphism( from:CP, to:X, via:{m_i} )
    --------------------------------------------------------------------------------
    Γ ⊢ Image(u) : SubobjectOf(X) ;
CATEGORY
    [[ Image(UniversalCoproductMap(...)) ]] = "The formal, constructive definition of the union. It corresponds to gathering all the 'parts' together (the coproduct) and then seeing what 'area' they cover in the target object (the image)." ;

BinaryUnion ::= SubobjectOf "∪" SubobjectOf ;
TYPING
    (* Convenience syntax for the binary union. *)
    Γ ⊢ s1 : SubobjectOf(X), Γ ⊢ s2 : SubobjectOf(X)
    -----------------------------------------------------
    Γ ⊢ (s1 ∪ s2) : SubobjectOf(X) (defined as Union({s1, s2}) );
CATEGORY
    [[ s1 ∪ s2 ]] = "The binary union, constructed by taking the image of the map from the coproduct of the two subobject domains into X." ;


(* ========================================================================================================== *)
(* == Part 3: Formalizing the Lattice Structure                                                          == *)
(* ========================================================================================================== *)

LatticePropertyDefinition ::= Identifier "is" "COMPLETE_LATTICE" ;
TYPING
    (* A formal property definition for a complete lattice. *)
    Γ ⊢ P : Poset
    ∀ (S ⊆ Carrier(P)), ( Supremum(S) exists in P ∧ Infimum(S) exists in P )
    ----------------------------------------------------------------------------
    Γ ⊢ P is COMPLETE_LATTICE : PropositionAbout(P) ;
CATEGORY
    [[ P is COMPLETE_LATTICE ]] = "The property of a partially ordered set P having all small joins (suprema) and meets (infima). This is the strongest form of lattice completeness." ;

SubobjectLattice ::= "Sub" "(" Identifier ")" ;
TYPING
    Γ ⊢ X : Object_in(C)
    Carrier_Set := { s | Γ ⊢ s : SubobjectOf(X) }
    Ordering_Rel := (s1, s2) ↦ (Γ ⊢ s1 ≤ s2)
    ------------------------------------------------
    Γ ⊢ Sub(X) : Poset(Carrier_Set, Ordering_Rel) ;
CATEGORY
    [[ Sub(X) ]] = "The subobject lattice of X. It is the partially ordered collection of all subobjects of X." ;

TheoremDeclaration ::= "THEOREM" "SubobjectLatticeIsComplete" ":"
    "IF" "(" Identifier "C" "is WELL-POWERED and has small Pullbacks and Images" ")" "THEN"
    "(" "FOR_ALL" "object" "X" "," "Sub(X)" "is" "COMPLETE_LATTICE" ")" ;
TYPING
    (*
     * This is the refined theorem. The preconditions are more explicit.
     * Well-powered ensures Sub(X) is a set.
     * Pullbacks ensure all intersections (infima) exist.
     * Images (and coproducts) ensure all unions (suprema) exist.
    *)
    Γ ⊢ C is WELL-POWERED
    Γ ⊢ C has all small Pullbacks
    Γ ⊢ C has Images
    -----------------------------------------------------------------
    ∀X ∈ Ob(C), Γ ⊢ Sub(X) is COMPLETE_LATTICE : MetaTheorem ;
CATEGORY
    [[ THEOREM SubobjectLatticeIsComplete ]] = "The refined assertion that connects the categorical properties of the ambient category C to the algebraic structure of the subobject collection. The rich structure of C (completeness and factorizations) induces a rich algebraic structure (a complete lattice) on each of its subobject posets." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.3: Strong epimorphisms" ")" "==>" {
(*

ELABORATION: A strong epimorphism is a more robust version of a standard epimorphism. Its
strength is defined by its relationship to monomorphisms, via a "diagonal fill-in" property.
This property is more formally known as orthogonality. To elaborate, we will:

Deconstruct the Definition: We will first formalize the "diagonal fill-in" property
as a testable predicate on commutative squares.

Formalize the Concept: We will build the definition of a Strong Epimorphism upon
this predicate, making the orthogonality condition explicit.

Show its Significance: We will state the theorem that connects strong epimorphisms
to their primary role as the 'E' class in the canonical (StrongEpi, Mono) factorization
system, which is the subject of the next section but crucial for context here.

Derive the Dual Theory: We will use the Duality Principle to mechanically derive the
complete definition and properties of the dual concept, a Strong Monomorphism, which is
orthogonal to all epimorphisms.

*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Orthogonality Condition == )
( ========================================================================================================== *)

CommutativeSquareForOrthogonalityTest ::= "ORTHOGONALITY_SQUARE" "(" "e" ":" Identifier "," "m" ":" Identifier ")" "with" "(" "f" ":" Identifier "," "g" ":" Identifier ")" ;
TYPING
(*
* This rule defines the setup for the orthogonality test. It's a commutative square
* where one arrow e (the candidate strong epi) is parallel to f, and another
* arrow m (the test mono) is parallel to g.
*)
Context: e:A->B, m:C->D, f:A->C, g:B->D
Γ ⊢ e,m,f,g : Morphism
g ∘ e == m ∘ f
------------------------------------------------------------------------------------------------
Γ ⊢ ORTHOGONALITY_SQUARE(e,m) with (f,g) : CommutativeSquare ;
CATEGORY
[[ ORTHOGONALITY_SQUARE ... ]] = "The proposition that the morphisms e, m, f, and g form a commutative square, setting the stage for the diagonal fill-in test." ;

DiagonalFillerProperty ::= "HasUniqueDiagonalFiller" "(" Identifier ")" ;
TYPING
(*
* This is the predicate that asserts the existence of the unique diagonal d.
* This is the core property of orthogonality.
*)
Context: Let sq = ORTHOGONALITY_SQUARE(e:A->B,m:C->D) with (f:A->C,g:B->D)
∃! (d : B -> C is Morphism) s.t. ( (d ∘ e == f) ∧ (m ∘ d == g) )
-----------------------------------------------------------------------
Γ ⊢ HasUniqueDiagonalFiller(sq) : BooleanProposition ;
CATEGORY
[[ HasUniqueDiagonalFiller(sq) ]] = "The assertion that there is a unique morphism d that makes both triangles of the commutative square commute. This morphism d is the 'diagonal filler'." ;

(* ========================================================================================================== )
( == Part 2: The Formal Definition of Strong Epimorphism == )
( ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "is" "STRONG_EPIMORPHISM" ;
TYPING
(*
* A morphism e is a Strong Epimorphism if it is an epimorphism, AND for every
* monomorphism m, any commutative square involving e and m has a unique diagonal filler.
*)
Premise1: Γ ⊢ e is EPIMORPHISM
Premise2: ∀ (m : a->b is MONOMORPHISM),
∀ (sq : CommutativeSquareForOrthogonalityTest involving e and m),
( HasUniqueDiagonalFiller(sq) )
----------------------------------------------------------------------------------
Γ ⊢ e is STRONG_EPIMORPHISM : PropositionAbout(e) ;
CATEGORY
[[ e is STRONG_EPIMORPHISM ]] = "A morphism e that is 'orthogonal' to all monomorphisms. This property ensures e is surjective-like in a very robust way, suitable for being the left part of a canonical factorization." ;

(* ========================================================================================================== )
( == Part 3: The Context and Significance (Factorization) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CanonicalFactorizationSystem" ":"
"In any category with pullbacks and coequalizers,"
"(" "'StrongEpi'" "," "'Mono'" ")" "forms a" "FACTORIZATION_SYSTEM" ;
TYPING
Context: Category C has Pullbacks and Coequalizers.
E := { f | f is STRONG_EPIMORPHISM }
M := { f | f is MONOMORPHISM }
-------------------------------------------------------
Γ ⊢ C has FACTORIZATION_SYSTEM(E, M) : MetaTheorem ;
CATEGORY
[[ THEOREM CanonicalFactorizationSystem ... ]] = "The assertion that the classes of strong epimorphisms and monomorphisms form a natural and well-behaved factorization system. This is the primary motivation for defining strong epimorphisms, as they provide the ideal 'surjective part' for image factorization." ;

(* ========================================================================================================== )
( == Part 4: Deriving the Dual Theory for Strong Monomorphisms == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "STRONG_EPIMORPHISM" "IS" "STRONG_MONOMORPHISM" ;

MorphismPropertyAssertion ::= Identifier "is" "STRONG_MONOMORPHISM" ;
TYPING
(* Derived via duality from strong epimorphism. *)
IsDualOf("STRONG_EPIMORPHISM")
EquivalentTyping:
Premise1: Γ ⊢ m is MONOMORPHISM
Premise2: ∀ (e : a->b is EPIMORPHISM),
∀ (sq : CommutativeSquareForOrthogonalityTest involving m and e),
( HasUniqueDiagonalFiller(sq) )
----------------------------------------------------------------
Γ ⊢ m is STRONG_MONOMORPHISM : PropositionAbout(m) ;
CATEGORY
[[ m is STRONG_MONOMORPHISM ]] = "The dual concept. A strong monomorphism is a monomorphism that is orthogonal to all epimorphisms. They are the 'M' class in the less common but equally valid (Epi, StrongMono) factorization system." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'DualFactorizationSystem'" "FROM" "THEOREM" "'CanonicalFactorizationSystem'" ;
TYPING
(*
* By applying the duality operator to the CanonicalFactorizationSystem theorem, we derive:
* (Epi, StrongMono) forms a factorization system.
*)
Γ ⊢ THEOREM 'CanonicalFactorizationSystem' : P_canonical
P_dual = rewrite(P_canonical, DualityMappings)
------------------------------------------------------------------
Γ ⊢ THEOREM 'DualFactorizationSystem' : P_dual ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the existence of the dual factorization system (Epi, StrongMono), derived mechanically by applying the duality functor. It asserts that regular epimorphisms and strong monomorphisms also form a valid way to decompose arrows in a category." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on 4.4: Epi-mono factorizations" ")" "==>" {
(*

ELABORATION: This section formalizes the concept of a "factorization system," a core
structural property of a category. The most common example is the (StrongEpi, Mono) system,
which allows any morphism f to be uniquely decomposed into a strong epimorphism e
followed by a monomorphism m. This decomposition gives rise to the categorical definition
of the "Image" of f.

To elaborate, we will:

Formalize the Components: Define what it means for a morphism to have a factorization
and what the intermediate "Image Object" is.

Formalize Uniqueness: Explicitly define the uniqueness condition for factorizations, which
is crucial and involves a unique isomorphism between any two potential factorizations.

Formalize the Global Property: Define what it means for a category to possess such a
factorization system for all its morphisms.

Define Image and Coimage: Show how this factorization machinery provides the canonical definitions
for the Image(f) (the subobject part) and the Coimage(f) (the quotient object part).

State Key Theorems: Assert the theorem that (StrongEpi, Mono) often forms a factorization system
and derive its dual using the Duality Principle.

*)

(* ========================================================================================================== )
( == Part 1: The Components of a Factorization == )
( ========================================================================================================== *)

MorphismFactorization ::= "Factorization_of" "(" Identifier ")" "is" "(" Identifier "," Identifier ")" "via" Identifier ;
TYPING
(*
* This rule asserts that a specific morphism f has a decomposition (e, m).
* f: A -> B is decomposed into e: A -> I and m: I -> B.
* The rule checks that the composition is correct and the factors belong to their specified classes.
*)
Context: FactorizationSystem(E, M)
Γ ⊢ f : A -> B
Γ ⊢ e : A -> I, Γ ⊢ m : I -> B
f == m ∘ e
e ∈ E
m ∈ M
-------------------------------------------------------------------------
Γ ⊢ Factorization_of(f) is (e, m) via I : FactorizationObject ;
CATEGORY
[[ Factorization_of(f) is (e, m) via I ]] = "A specific decomposition of the morphism f into two stages. The first stage e is a morphism from the class E (e.g., epimorphisms), and the second stage m is from the class M (e.g., monomorphisms). The object I is the 'Image Object'." ;

(* ========================================================================================================== )
( == Part 2: The Crucial Uniqueness Condition == )
( ========================================================================================================== *)

FactorizationUniquenessAxiom ::= "AXIOM" "FactorizationIsUniqueUpToIsomorphism" ;
TYPING
(*
* This is the formal typing for the uniqueness condition. It is a meta-theorem.
* It asserts that if a morphism f has two factorizations, then their intermediate
* objects must be uniquely isomorphic in a way that makes the whole diagram commute.
*)
Context: FactorizationSystem(E, M)
f_has_factorization (e1:A->I1, m1:I1->B)
f_has_factorization (e2:A->I2, m2:I2->B)
------------------------------------------------------------------------------
Condition := ∃! (i : I1 -> I2 is ISOMORPHISM) s.t. ( (i ∘ e1 == e2) ∧ (m1 == m2 ∘ i) )
Γ ⊢ AXIOM ... is TRUE if Condition holds : MetaTheorem ;
CATEGORY
[[ AXIOM FactorizationIsUniqueUpToIsomorphism ]] = "The coherence law for factorization systems. It guarantees that the 'Image Object' I is not arbitrary but is determined uniquely up to a canonical isomorphism. This makes the concept of 'the' image of a morphism well-defined." ;

(* ========================================================================================================== )
( == Part 3: The Global Property of a Category == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "has" "FACTORIZATION_SYSTEM" "(" Identifier "," Identifier ")" ;
TYPING
(*
* A category C has an (E,M) factorization system if EVERY morphism in C admits a
* factorization that satisfies the uniqueness axiom.
*)
Γ ⊢ C : Category
Γ ⊢ E, M : ClassOfMorphisms
∀ f ∈ Mor(C), ( ∃ Factorization_of(f) ∧ FactorizationUniquenessAxiom holds )
--------------------------------------------------------------------------------
Γ ⊢ C has FACTORIZATION_SYSTEM(E, M) : PropositionAbout(C) ;
CATEGORY
[[ C has FACTORIZATION_SYSTEM(E, M) ]] = "A fundamental structural property of a category C, guaranteeing that every arrow can be canonically decomposed into a part from class E and a part from class M. It is the categorical generalization of the first isomorphism theorem for groups." ;

(* ========================================================================================================== )
( == Part 4: Defining Image and Coimage == )
( ========================================================================================================== *)

ImageOfMorphism ::= "Image" "(" Identifier ")" ;
TYPING
(*
* The Image of f is defined as the M part of its canonical factorization.
* The Image is formally the subobject represented by the monomorphism m.
*)
Context: Category C has FACTORIZATION_SYSTEM(StrongEpi, Mono)
Factorization_of(f) is (e: A -> I, m: I -> B)
----------------------------------------------------------------
Γ ⊢ Image(f) : SubobjectOf(B) (represented by m) ;
CATEGORY
[[ Image(f) ]] = "The categorical image of the morphism f. It is defined as the smallest subobject of the codomain B through which f factors. This is constructed as the monomorphism part m of the canonical (StrongEpi, Mono) factorization f = m ∘ e." ;

CoimageOfMorphism ::= "Coimage" "(" Identifier ")" ;
TYPING
(*
* The Coimage of f is dually defined as the E part of its canonical factorization.
* The Coimage is formally the quotient object represented by the epimorphism e.
*)
Context: Category C has FACTORIZATION_SYSTEM(StrongEpi, Mono)
Factorization_of(f) is (e: A -> I, m: I -> B)
----------------------------------------------------------------
Γ ⊢ Coimage(f) : QuotientObjectOf(A) (represented by e) ;
CATEGORY
[[ Coimage(f) ]] = "The categorical coimage of the morphism f. It is defined as the largest quotient object of the domain A through which f factors. This is constructed as the epimorphism part e of the canonical (StrongEpi, Mono) factorization f = m ∘ e. In many algebraic categories, Image(f) and Coimage(f) are isomorphic." ;

(* ========================================================================================================== )
( == Part 5: The Canonical System and its Dual == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "StandardFactorizationSystem" ":"
"IF" "(" Identifier "has Pullbacks and Coequalizers" ")" "THEN"
"(" Identifier "has FACTORIZATION_SYSTEM" "(" "StrongEpi" "," "Mono" ")" ")" ;
CATEGORY
[[ THEOREM StandardFactorizationSystem ]] = "The assertion that the classes of strong epimorphisms and monomorphisms form a natural and well-behaved factorization system in any category with sufficient (co)limits. This is the primary motivation for defining strong epimorphisms, as they provide the ideal 'surjective part' for image factorization." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'AlternateFactorizationSystem'" "FROM" "THEOREM" "'StandardFactorizationSystem'" ;
TYPING
(*
* By applying the duality operator to the StandardFactorizationSystem theorem, we derive:
* C has a factorization system (Epi, StrongMono).
* The system uses the dictionary: StrongEpi -> StrongMono (dual), Mono -> Epi (dual).
*)
Γ ⊢ THEOREM 'StandardFactorizationSystem' : P_standard
P_alternate = rewrite(P_standard, DualityMappings)
----------------------------------------------------------
Γ ⊢ THEOREM 'AlternateFactorizationSystem' : P_alternate ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the existence of the dual factorization system (Epi, StrongMono), derived mechanically by applying the duality functor. While less commonly used, it is an equally valid decomposition that highlights the symmetry of the underlying categorical concepts." ;

}

(* ========================================================================================================== *)
(* == Section 4.5: Generators                                                                            == *)
(* ========================================================================================================== *)
(*
 * ELABORATION: A generator is an object (or set of objects) that is sufficient to 'probe' and distinguish
 * all other morphisms in the category. We formalize this 'probing' ability as the faithfulness of the
 * Hom functor.
*)

HasGeneratorObject ::= Identifier "has" "GENERATOR" Identifier ;
TYPING
    (* A category C has a generator G if the Hom(G, -) functor is faithful. *)
    Γ ⊢ C : Category, Γ ⊢ G : Object_in(C)
    Functor_Hom(G,_) : C -> Set is FAITHFUL
    EquivalentTyping: ∀ (f,g : X->Y, f!=g), ∃(h : G->X) s.t. (f∘h != g∘h)
    ------------------------------------------------------------------------
    Γ ⊢ C has GENERATOR G : PropositionAbout(C);
CATEGORY
    [[ C has GENERATOR G ]] = "The property of a category C being 'generated' by a single object G. This means that all morphisms can be tested and distinguished by pre-composing them with morphisms out of G. For example, a singleton set is a generator for the category of Sets." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "GENERATOR" "IS" "COGENERATOR" ;
(* NOTE: Cogenerator was defined in Sec 3.2; this reaffirms its place as the dual of Generator. *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.6: Projectives" ")" "==>" {
(*

ELABORATION: This section defines a class of objects with a special "lifting" property against
epimorphisms. A deep elaboration requires not just stating this definition, but deconstructing it,
showing its equivalence to a more abstract functorial definition, connecting it to the concept of
"free" objects, formalizing the global property of a category having "enough" of them, and
finally, deriving the entire dual theory of "injective" objects using the Duality Principle.

*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Core Lifting Property == )
( ========================================================================================================== *)

ProjectiveLiftingProblem ::= "LIFTING_PROBLEM" "(" "morphism" Identifier "," "against_epi" Identifier ")" ;
TYPING
(* This defines the setup for the lifting property: a morphism f from a potential projective P, and an epimorphism e. *)
Γ ⊢ P : Object
Γ ⊢ f : Morphism(P, B)
Γ ⊢ e : Morphism(A, B), Γ ⊢ e is EPIMORPHISM
----------------------------------------------------------------------------------------------------------
Γ ⊢ LIFTING_PROBLEM(f, against_epi e) : LiftableConfiguration(P, A, B) ;
CATEGORY
[[ LIFTING_PROBLEM(f, e) ]] = "The data for a lifting problem, consisting of an object P, an epimorphism e:A->B, and a morphism f:P->B. The problem is to find a lift g:P->A." ;

HasLiftSolution ::= "HAS_LIFT" "(" ProjectiveLiftingProblem ")" ;
TYPING
(* This predicate is true if the given lifting problem has a solution g. *)
Γ ⊢ problem : LiftableConfiguration(P, A, B)
Let problem = (f:P->B, e:A->B)
∃(g : P -> A is Morphism) s.t. (e ∘ g == f)
--------------------------------------------------------------------------------
Γ ⊢ HAS_LIFT(problem) : BooleanProposition ;
CATEGORY
[[ HAS_LIFT(...) ]] = "The assertion that a solution to the lifting problem exists. It is a proof that the object P can be 'projected' through the epimorphism e to cover the morphism f." ;

(* ========================================================================================================== )
( == Part 2: The Two Equiva lent Definitions == )
( ========================================================================================================== *)

ObjectPropertyDeclaration ::= Identifier "is" "PROJECTIVE" ;
TYPING
(* The first-principles definition: An object P is projective if EVERY lifting problem involving it has a solution. *)
Γ ⊢ P : Object
∀ (problem : LiftableConfiguration involving P), ( HAS_LIFT(problem) )
--------------------------------------------------------------------------
Γ ⊢ P is PROJECTIVE : PropositionAbout(P) ;
CATEGORY
[[ P is PROJECTIVE ]] = "The property of an object P that allows it to be mapped into any quotient object via a lift. This means the functor Hom(P,-) is exact. In categories of modules, these are the projective modules." ;

TheoremDeclaration ::= "THEOREM" "ProjectiveFunctorialEquivalence" ":"
"(" Identifier "P" "is" "PROJECTIVE" ")"
"<==>"
"(" "Hom_Functor" "(" "P" "," "" ")" "preserves" "EPIMORPHISMS" ")" ;
TYPING
(* This formalizes the equivalence between the diagrammatic lifting definition and the functorial one. *)
P1 := (Γ ⊢ P is PROJECTIVE)
P2 := (Γ ⊢ Functor_Hom(P,) preserves EPIMORPHISMS)
---------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM ProjectiveFunctorialEquivalence ]] = "The assertion that the concrete, diagrammatic definition of a projective object (the lifting property) is precisely equivalent to the abstract, functorial definition (the Hom(P,-) functor preserves epimorphisms). This is a foundational result that allows working at whichever level of abstraction is more convenient." ;

(* ========================================================================================================== )
( == Part 3: Connection to Free Objects and Injective Objects == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "FreeObjectsAreProjective" ":"
"FOR_ALL" "object" "O" "in" "AlgebraicCategory" "," "(" "O is FREE" ")" "==>" "(" "O is PROJECTIVE" ")" ;
TYPING
Context: C is a suitable algebraic category (e.g. Set, Grp, Mod_R).
Γ ⊢ O : Object_in(C)
(IsFree(O)) ⇒ (IsProjective(O))
---------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM FreeObjectsAreProjective ]] = "A key structural result in algebra. It asserts that any object constructed 'freely' from a set of generators automatically has the lifting property of a projective object. For example, all free groups are projective in the category of groups." ;

(* ========================================================================================================== )
( == Part 4: The Global Property - "Enough Projectives" == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "has" "ENOUGH_PROJECTIVES" ;
TYPING
(* This is a property of the entire category. It is true if every object is a quotient of some projective object. *)
Γ ⊢ C : Category
∀X ∈ Objects(C),
∃ (P : Object s.t. P is PROJECTIVE),
∃ (e : P -> X s.t. e is EPIMORPHISM)
------------------------------------------------------------------------------------------
Γ ⊢ C has ENOUGH_PROJECTIVES : PropositionAbout(C) ;
CATEGORY
[[ C has ENOUGH_PROJECTIVES ]] = "The property of a category having a rich supply of projective objects, sufficient to 'cover' every other object via an epimorphism. This property is crucial for constructing projective resolutions in homological algebra and for proving theorems about derived functors." ;

(* ========================================================================================================== )
( == Part 5: The Dual Theory for Injectives (via Duality Principle) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PROJECTIVE" "IS" "INJECTIVE" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "ENOUGH_PROJECTIVES" "IS" "ENOUGH_INJECTIVES" ;

DualTheoremInference ::= "INFER_DUAL_THEORY" "'InjectiveTheory'" "FROM" "THEORY" "'ProjectiveTheory'" ;
TYPING
(***
* By applying the duality functor (-)^op to the entire theory block for projectives,
* the system mechanically generates the correct dual theory for injectives.
* Rewrites performed by the DualityMapping dictionary:
* 1. PROJECTIVE -> INJECTIVE
* 2. LIFTING_PROBLEM (against epi) -> EXTENSION_PROBLEM (from mono)
* 3. e:A->B (epi) -> m:B->A (mono)
* 4. HAS_LIFT -> HAS_EXTENSION
* 5. Hom(P,) preserves EPIMORPHISMS -> Hom(,I) sends MONOMORPHISMS to EPIMORPHISMS
* 6. ENOUGH_PROJECTIVES -> ENOUGH_INJECTIVES (every object is a subobject of an injective)
* The resulting dual propositions are valid theorems.
***)
Γ ⊢ TheoryBlock["ProjectiveTheory"] : CoherentTheoryFragment
--------------------------------------------------------------------------------------
Γ ⊢ TheoryBlock["InjectiveTheory"] := (TheoryBlock["ProjectiveTheory"])^op : CoherentTheoryFragment ;
CATEGORY
[[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the entire theory for 'injective objects'. This process, derived by mechanically applying the duality functor, generates the definitions for the extension property of injectives, the equivalence to the functorial definition, and the property of a category having 'enough injectives', all without requiring separate proofs." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.7: Injectives, cogenerators" ")" "==>" {
(*

ELABORATION: This section formalizes the dual concepts to projectives and generators. A deep
elaboration requires more than just stating the dual definitions. It must:

Deconstruct the Injective Property: Define injectivity not just as a dual, but explicitly
through its core "extension property" against monomorphisms.

Formalize the Cogenerator Property: Define a cogenerator explicitly as a "universal test object"
that can distinguish any two different morphisms by post-composition.

State the Foundational Connection: Formalize the crucial theorem (a generalization of Baer's
Criterion) which shows how to construct an injective object that an arbitrary object can embed into,
using a cogenerator and products. This is the heart of the "enough injectives" proof.

Define "Enough Injectives": Formalize the global property of a category having enough
injective objects to embed every object, and link it directly to the constructive theorem.

This approach transforms the section from a set of definitions into a coherent, constructive theory.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Injective Object Property == )
( ========================================================================================================== )
( An Injective object is the exact dual of a projective one. It has an "extension" property against monomorphisms. *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "PROJECTIVE" "IS" "INJECTIVE" ;

ObjectPropertyDeclaration ::= Identifier "is" "INJECTIVE" ;
TYPING
(*
* This defines the a property of an object I. An object is INJECTIVE if it satisfies two equivalent conditions:
* 1. (Functorial): The contravariant Hom-functor Hom(-, I) sends monomorphisms to epimorphisms.
* 2. (Diagrammatic): For every extension problem involving I, a solution exists. We formalize this below.
*)
(Γ ⊢ P is INJECTIVE) <==> (Γ ⊢ Functor_Hom(-, P) sends MONOMORPHISMS to EPIMORPHISMS) ;
CATEGORY
[[ P is INJECTIVE ]] = "The property of an object P that allows any map from a subobject to be extended to the entire ambient object. This makes P a 'receptive' object with no 'holes'. In Ab (abelian groups), the divisible groups are injective." ;

InjectiveExtensionProblem ::= "EXTENSION_PROBLEM" "(" "from_mono" Identifier "," "with_map" Identifier ")" ;
TYPING
(* This formalizes the setup for the extension property: a monomorphism m and a map f from its domain. )
Γ ⊢ I : Object ( The candidate Injective *)
Γ ⊢ m : A -> B, Γ ⊢ m is MONOMORPHISM
Γ ⊢ f : Morphism(A, I)
-------------------------------------------------------------------------------------------------
Γ ⊢ EXTENSION_PROBLEM(from_mono m, with_map f) : ExtendableConfiguration(I, A, B) ;
CATEGORY
[[ EXTENSION_PROBLEM(m, f) ]] = "The data for an extension problem. The problem is to find a map g: B -> I that 'extends' f along the monomorphism m." ;

TheoremDeclaration ::= "THEOREM" "InjectiveLiftingEquivalence" ":"
"(" Identifier "I" "is" "INJECTIVE" ")"
"<==>"
"( FOR_ALL problem:InjectiveExtensionProblem involving I, problem HAS_EXTENSION )" ;
TYPING
(* This theorem makes the equivalence with the diagrammatic formulation explicit. *)
P1 := (Γ ⊢ I is INJECTIVE)
P2_sub := (∃g:B->I s.t. g∘m == f)
P2 := ∀(problem with m,f), P2_sub holds
----------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM InjectiveLiftingEquivalence ]] = "The assertion that the abstract, functorial definition of an injective object is precisely equivalent to the concrete, diagrammatic definition (the extension property)." ;

(* ========================================================================================================== )
( == Part 2: Cogenerators as Universal Test Objects == )
( ========================================================================================================== )
( A Cogenerator is the exact dual of a Generator. *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "GENERATOR" "IS" "COGENERATOR" ;

HasCogeneratorObject ::= Identifier "has" "COGENERATOR" Identifier ;
TYPING
(* A category C has a cogenerator G if the CONTRAVARIANT Hom(-, G) functor is faithful. *)
Γ ⊢ C : Category, Γ ⊢ G : Object_in(C)
Functor_Hom(-, G) : C^op -> Set is FAITHFUL
EquivalentTyping: ∀ (f, h : X -> Y, f != h), ∃ (k : Y -> G) s.t. (k ∘ f != k ∘ h)
------------------------------------------------------------------------------------
Γ ⊢ C has COGENERATOR G : PropositionAbout(C) ;
CATEGORY
[[ C has COGENERATOR G ]] = "The property of a category C possessing a single 'universal test object' G. Any two different morphisms can be distinguished by mapping into G. In Set, any set with at least two elements is a cogenerator. In Ab, the circle group Q/Z is a cogenerator." ;

(* ========================================================================================================== )
( == Part 3: The Foundational Connection and "Enough Injectives" == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "ENOUGH_PROJECTIVES" "IS" "ENOUGH_INJECTIVES" ;

CategoryPropertyDefinition ::= Identifier "has" "ENOUGH_INJECTIVES" ;
TYPING
(* This is the global property that every object can be embedded into an injective one. *)
IsDualOf("ENOUGH_PROJECTIVES")
EquivalentTyping: ∀X ∈ Objects(C), ∃ (I : Object s.t. I is INJECTIVE), ∃ (m : X -> I s.t. m is MONOMORPHISM)
---------------------------------------------------------------------------
Γ ⊢ C has ENOUGH_INJECTIVES : PropositionAbout(C) ;
CATEGORY
[[ C has ENOUGH_INJECTIVES ]] = "The crucial property of a category having a rich enough supply of injective objects to embed every other object. This property is the foundation for constructing injective resolutions in homological algebra." ;

TheoremDeclaration ::= "THEOREM" "InjectiveEmbeddingConstruction" ":"
"IF" "(" Identifier "C" "has a COGENERATOR and small PRODUCTS" ")" "THEN"
"(" "C has ENOUGH_INJECTIVES" ")" ;
TYPING
(*
* This is the constructive proof. For any object X, we can build an injective I and an embedding m:X->I.
* The construction of I: Let G be a cogenerator. Let H be the set of all morphisms h:S->G for all subobjects S of X.
* Then I is the product of G over the index set H.
*)
Context: Γ ⊢ C has COGENERATOR G, Γ ⊢ C has small PRODUCTS
Proof for a given X:
1. Let ProbeSet be the set of all morphisms h:S->G where S is a subobject of X.
2. Let I_X be the product Π_{h ∈ ProbeSet} G. The product exists by premise.
3. I_X can be proven to be INJECTIVE.
4. An embedding m: X -> I_X can be constructed.
Since this holds for any X, the category has enough injectives.
-------------------------------------------------------------------------------------------------------
Γ ⊢ THEOREM... : MetaTheorem ;
CATEGORY
[[ THEOREM InjectiveEmbeddingConstruction ]] = "The fundamental theorem providing sufficient conditions for a category to have enough injectives. It provides a canonical recipe for constructing a large injective object that can 'receive' an embedding of any given object, using the category's cogenerator as the building block and products as the glue. This is a powerful tool for proving an entire category (like Ab) has enough injectives." ;
}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.1: Graphs and path categories" ")" "==>" {
(*

ELABORATION: This section lays the groundwork for categories of fractions by defining their
fundamental building block: the free category generated by a graph. To elaborate, we will:

Formalize the "Graph" (or Quiver) as the raw, lawless substrate for a category.
This is the same as the PreCategory defined previously, so we will establish that synonym.

Define a "Path" as a sequence of composable arrows in a graph.

Define the "Path Category" (or "Free Category") construction, which takes a graph and
generates a category whose morphisms are these paths.

Formalize the Universal Property of this construction, which states that the path category
functor is the left adjoint to the forgetful functor from Cat to Graph. This is the definition
of "freeness".

*)

(* ========================================================================================================== )
( == Part 1: The Substrate (Graphs/Quivers) == )
( ========================================================================================================== *)

GraphDeclaration ::= "GRAPH" Identifier "has" "{" "Vertices" ":" {Identifier} ";" "Arrows" ":" {MorphismDeclaration} ";" "}" ;
TYPING
(* This is definitionally identical to a PreCategory, which we defined in Chapter 1. *)
(Γ ⊢ GRAPH G ... : DirectedGraph) <==> (Γ ⊢ PRECATEGORY G ... : PreCategory) ;
CATEGORY
[[ GRAPH G ... ]] = "The definition of a directed multigraph (or quiver) G. This structure contains the data of vertices (nodes) and arrows (edges) but imposes no laws of composition or identity. It is the raw material from which a category can be freely generated." ;

(* ========================================================================================================== )
( == Part 2: The Morphisms (Paths) == )
( ========================================================================================================== *)

PathDeclaration ::= "PATH" "(" Identifier { "∘" Identifier } ")" "from" Identifier "to" Identifier ;
TYPING
(* A path is a sequence of one or more composable arrows from the underlying graph. *)
Context: Graph G
Path = (a_n, ..., a_1) where a_i : X_{i-1} -> X_i is an Arrow in G.
Domain = Source(a_1), Codomain = Target(a_n)
---------------------------------------------------------------------------------
Γ ⊢ PATH (a_n ∘ ... ∘ a_1) ... : PathIn(G) ;
CATEGORY
[[ PATH (a_n ∘ ... ∘ a_1) ... ]] = "A finite, non-empty sequence of composable arrows in the underlying graph. This represents a directed walk through the graph." ;

IdentityPathDeclaration ::= "id_path_at" "(" Identifier ")" ;
TYPING
(* An identity path is an empty path at a given vertex. *)
Context: Graph G
Γ ⊢ v : Vertex_in(G)
-------------------------------------------
Γ ⊢ id_path_at(v) : PathIn(G) ;
CATEGORY
[[ id_path_at(v) ]] = "The empty path at vertex v. This will become the identity morphism on object v in the resulting path category." ;

(* ========================================================================================================== )
( == Part 3: The Free Category Construction and its Universal Property == )
( ========================================================================================================== *)

PathCategoryConstructor ::= "FreeCategory" "(" Identifier ")" ;
TYPING
(* This constructor takes a graph and returns a category. *)
Γ ⊢ G : DirectedGraph
C_Objects := Vertices(G)
C_Morphisms := {p | Γ ⊢ p : PathIn(G)}
C_Composition := Path Concatenation
C_Identities := {id | Γ ⊢ id : IdentityPathDeclaration}
----------------------------------------------------------
Γ ⊢ FreeCategory(G) : Category ;
CATEGORY
[[ FreeCategory(G) ]] = "The path category generated by the graph G. Its objects are the vertices of G, and its morphisms are the paths in G. Composition is concatenation of paths. This is the 'freest' possible category satisfying the structure specified by G." ;

TheoremDeclaration ::= "THEOREM" "PathCategoryAdjunction" ":"
"(" "FreeCategory" "is" "LeftAdjoint" "to" "ForgetfulFunctor_CatToGraph" ")" ;
TYPING
(*
* This theorem formalizes the universal property of the path category.
* The forgetful functor U: Cat -> Graph "forgets" composition laws.
* The FreeCategory functor P: Graph -> Cat constructs the path category.
* The adjunction P ⊣ U means there is a natural isomorphism:
* Hom_Cat(P(G), C) ≅ Hom_Graph(G, U(C))
*)
Γ ⊢ P : Functor(Graph, Cat), Γ ⊢ U : Functor(Cat, Graph)
----------------------------------------------------------
Γ ⊢ P ⊣ U : Adjunction ;
CATEGORY
[[ THEOREM PathCategoryAdjunction ... ]] = "The assertion that the Free Category construction is left adjoint to the forgetful functor. This isomorphism means that a category homomorphism from the path category P(G) to any other category C is uniquely determined by a simple graph homomorphism from G to the graph underlying C. This is the formal definition of 'freeness'." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.2: Calculus of fractions" ")" "==>" {
(*

ELABORATION: This section introduces the "calculus of fractions," a set of conditions that,
when met, allow the abstract process of inverting morphisms to be described by a concrete
construction using "spans" (also known as "roofs"). To elaborate, we will:

Formalize the Abstract Goal: Define the category of fractions C[S⁻¹] and its universal
property, which is the abstract goal of localization.

Define the Conditions: Formalize the Ore Conditions for a (right) calculus of
fractions as a series of explicit axioms that a class of morphisms S must satisfy.

Formalize the Concrete Construction: Define the objects and morphisms (as spans/roofs)
of the category of fractions that can be built when the Ore conditions hold, and define
the equivalence relation between these spans.

State the Main Theorem: Assert the theorem that if S admits a calculus of fractions,
then the abstract category of fractions is equivalent to the one built via the concrete
span construction.

*)

(* ========================================================================================================== )
( == Part 1: The Abstract Goal (Localization) == )
( ========================================================================================================== *)

CategoryOfFractions ::= Identifier "[" Identifier "⁻¹" "]" ;
TYPING
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
-------------------------------------------------
Γ ⊢ C[S⁻¹] : Category ;
CATEGORY
[[ C[S⁻¹] ]] = "The category of fractions (or localization) of C with respect to S. It is a new category obtained by universally adding formal inverses for all morphisms in S." ;

LocalizationFunctor ::= "L" ":" Identifier "→" CategoryOfFractions ;
TYPING
(* This defines the localization functor and its universal property. *)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
UniversalProperty := ∀ (F:C→D where ∀s∈S, F(s) is ISOMORPHISM),
∃! (F_bar : C[S⁻¹] → D) s.t. (F_bar ∘ L == F)
----------------------------------------------------------------------------------------------------
Γ ⊢ L : C → C[S⁻¹] : FunctorWith(UniversalProperty) ;
CATEGORY
[[ L : C → C[S⁻¹] ]] = "The canonical localization functor. It is the universal solution for mapping C to a category where all morphisms in S become isomorphisms." ;

(* ========================================================================================================== )
( == Part 2: The Conditions for a Concrete Construction (Ore Conditions) == )
( ========================================================================================================== *)

admitsRightCalculusOfFractions ::= Identifier "admits" "RIGHT_CALCULUS_OF_FRACTIONS" ;
TYPING
(* A class of morphisms S admits a right calculus of fractions if it satisfies three axioms. *)
Γ ⊢ S : ClassOfMorphisms(C)
Axiom1(S): S contains all isomorphisms and is closed under composition.
Axiom2_Ore(S): ∀ (f:X→Y), ∀ (s:Z→Y∈S), ∃ pullback square for (f,s) with t:W→X∈S.
Axiom3_Cancel(S): ∀ (f,g:X→Y), (∃s:Z→X∈S s.t. f∘s == g∘s) ⇒ (∃t:Y→W∈S s.t. t∘f == t∘g).
---------------------------------------------------------------------------------------
Γ ⊢ S admits RIGHT_CALCULUS_OF_FRACTIONS : BooleanProposition ;
CATEGORY
[[ S admits RIGHT_CALCULUS_OF_FRACTIONS ]] = "The assertion that the class of morphisms S is 'well-behaved' enough to allow for the concrete construction of the category of fractions. The Ore condition is key, as it allows reordering of morphisms and fractions (composition of spans)." ;

(* ========================================================================================================== )
( == Part 3: The Concrete Construction (Spans/Roofs) == )
( ========================================================================================================== *)

RightFractionSpan ::= "SPAN" "(" "f" ":" Identifier "→" Identifier "," "s" ":" Identifier "→" Identifier ")" ;
TYPING
(*
* A right fraction is a morphism from X to Y represented by a span (an apex A with two legs).
* The leg s points to the domain X and must be in the class S.
* The leg f points to the codomain Y.
* Conventionally this is written f s⁻¹.
*)
Context: S admits RIGHT_CALCULUS_OF_FRACTIONS in C
Γ ⊢ A, X, Y : Object_in(C)
Γ ⊢ f : A -> Y, Γ ⊢ s : A -> X
s ∈ S
----------------------------------------------------------------------
Γ ⊢ SPAN(f,s) : Morphism(X, Y) in C[S⁻¹] ;
CATEGORY
[[ SPAN(f:A->Y, s:A->X) ]] = "A morphism in the category of fractions from X to Y, represented as a 'roof' or 'span' (Y ←f-- A --s→ X) where s ∈ S. It represents the abstract composition f ∘ (L(s))⁻¹." ;

EquivalenceOfRightFractions ::= RightFractionSpan "∼" RightFractionSpan ;
TYPING
(* Defines the equivalence relation on the spans. Two spans are equivalent if a third, 'narrower' span exists that makes them equal. *)
Γ ⊢ span1 = SPAN(f1:A1→Y, s1:A1→X)
Γ ⊢ span2 = SPAN(f2:A2→Y, s2:A2→X)
Condition := ∃ (A3:Object, g1:A3→A1, g2:A3→A2) s.t. ( (s1∘g1 == s2∘g2) ∧ (f1∘g1 == f2∘g2) )
-------------------------------------------------------------------------------------------
Γ ⊢ (span1 ∼ span2) is TRUE if Condition holds : EquivalenceRelation ;
CATEGORY
[[ span1 ∼ span2 ]] = "The equivalence relation on fractions. Two fractions are equivalent if they can be shown to be equal by extending them to a common 'denominator' domain." ;

(* ========================================================================================================== )
( == Part 4: The Main Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "CalculusOfFractionsEquivalence" ":"
"IF" "(" Identifier "S" "admits" "RIGHT_CALCULUS_OF_FRACTIONS" ")" "THEN"
"(" Identifier "C" "[" Identifier "S" "⁻¹" "]" "≅" "CategoryOf(EquivClassOf(RightFractionSpan))" ")" ;
TYPING
P1 := (Γ ⊢ S admits RIGHT_CALCULUS_OF_FRACTIONS)
ConcreteCategory := Category whose morphisms are equivalence classes of RightFractionSpan
P2 := (Γ ⊢ C[S⁻¹] ≅ ConcreteCategory)
--------------------------------------------------------
Γ ⊢ (P1 ⇒ P2) : MetaTheorem ;
CATEGORY
[[ THEOREM CalculusOfFractionsEquivalence ]] = "The assertion that when the Ore conditions hold, the abstract, universal definition of the category of fractions and the concrete construction using equivalence classes of spans are equivalent. This provides a powerful tool for working with localizations in a tangible way." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.3: Reflecting subcategories as categories of fractions" ")" "==>" {
(*

ELABORATION: This section builds a crucial bridge between two major concepts: the abstract
notion of a reflective subcategory (from Chapter 3) and the more concrete mechanism of
localization (from the previous section). It shows that reflection is a form of localization.
To elaborate, we will:

Formalize the Bridge: Define the specific class of morphisms Σ_L that are inverted by
the reflector functor L of a reflective subcategory.

State the Main Theorem: Formalize the theorem that asserts the equivalence between
the reflective subcategory A and the category of fractions B[Σ_L⁻¹] of the ambient
category B.

Provide a Concrete Example: Illustrate this theorem with the canonical example of Ab
(Abelian Groups) as a reflective subcategory of Grp (Groups). This makes the abstract
equivalence tangible.

*)

(* ========================================================================================================== )
( == Part 1: The Bridge (Morphisms Inverted by a Functor) == )
( ========================================================================================================== *)

MorphismClassInvertedByFunctor ::= "Σ_" Identifier ;
TYPING
(*
* This constructor defines a class of morphisms in a functor's domain. The class consists
* of all morphisms that the functor maps to isomorphisms in its codomain.
*)
Γ ⊢ L : Functor(B, A)
---------------------------------------------------------------------------------------------
Γ ⊢ Σ_L : ClassOfMorphisms(B) where s ∈ Σ_L <==> (L(s) is ISOMORPHISM in A) ;
CATEGORY
[[ Σ_L ]] = "The class of morphisms in B that are 'L-equivalences'. The functor L does not distinguish between the domain and codomain of these morphisms, collapsing them into isomorphisms. This is the precise class of morphisms we need to formally invert." ;

(* ========================================================================================================== )
( == Part 2: The Main Equivalence Theorem == )
( ========================================================================================================== *)

ReflectiveSubcategoryAsLocalizationTheorem ::= "THEOREM" "ReflectiveSubcategoryAsLocalization" ":"
"IF" "(" Identifier "A" "is" "REFLECTIVE_IN" Identifier "B" "with reflector" Identifier "L" ")" "THEN"
"(" "A" "≅" Identifier "B" "[" "Σ_" Identifier "⁻¹" "]" ")" ;
TYPING
(* This is the formal typing of the main theorem. *)
Premise1: Γ ⊢ A is REFLECTIVE_IN B
Premise2: Γ ⊢ L = Reflector(B, A) : Functor(B, A)
Premise3: Γ ⊢ Σ_L = MorphismClassInvertedByFunctor(L)
Conclusion: Γ ⊢ A ≅ B[Σ_L⁻¹] : EquivalenceOfCategories
-------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ReflectiveSubcategoryAsLocalization ]] = "A fundamental theorem connecting reflection and localization. It asserts that any reflective subcategory A is equivalent to the localization of its ambient category B with respect to the class of morphisms that the reflector L inverts. This provides a powerful mechanism for understanding the structure of reflective subcategories." ;

(* ========================================================================================================== )
( == Part 3: A Concrete Example (Abelian Groups in Groups) == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "AbelianizationAsLocalization" "of" ReflectiveSubcategoryAsLocalizationTheorem ;
TYPING
(* Here we apply the general theorem to a specific, well-known case. *)
-- Define the context
A := Category("Ab")
B := Category("Grp")
-- Check the theorem's premises
P1: Γ ⊢ Ab is REFLECTIVE_IN Grp (This is a known result)
P2: L := AbelianizationFunctor : Functor(Grp, Ab) (This is the reflector)
P3: Σ_L := {s ∈ Mor(Grp) | L(s) is an isomorphism in Ab} (These are group homomorphisms whose kernel is contained within the commutator subgroup of the domain)

Generated code
-- Apply the theorem's conclusion
Conclusion: Γ ⊢ Ab ≅ Grp[Σ_L⁻¹] : EquivalenceOfCategories
-----------------------------------------------------------------------------------------
Γ ⊢ INSTANCE ... : ProvableProposition ;


CATEGORY
[[ INSTANCE AbelianizationAsLocalization ... ]] = "A concrete application of the main theorem. It states that the category of Abelian Groups (Ab) is equivalent to the category of all Groups (Grp) where all morphisms that 'kill' the commutator subgroup have been formally inverted. This shows that the process of 'abelianizing' a group is an instance of localization." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.4: The orthogonal subcategory problem" ")" "==>" {
(*

ELABORATION: This section addresses the question: when does the collection of objects "orthogonal"
to a given set of morphisms form a reflective subcategory? To elaborate, we will:

Formalize Orthogonality: Generalize the _ ⊥ _ predicate for orthogonality between
any two arbitrary morphisms.

Define the Orthogonal Subcategory: Construct the full subcategory whose objects are
defined by their orthogonality to a given class of morphisms. This formalizes S⊥.

State the Main Theorem: Formalize the theorem (a form of the Orthogonal Subcategory Theorem)
which provides sufficient conditions (namely, cocompleteness of the ambient category) for this
orthogonal subcategory to be reflective. This solves the "problem."

*)

(* ========================================================================================================== )
( == Part 1: Formalizing Orthogonality between Morphisms == )
( ========================================================================================================== *)

MorphismOrthogonality ::= Identifier "⊥" Identifier ;
TYPING
(*
* This defines the proposition e ⊥ m. It holds if for every commutative square
* involving e and m, there exists a unique diagonal filler. This generalizes the
* property used to define Strong Epimorphisms.
*)
Γ ⊢ e : A -> B, Γ ⊢ m : C -> D
Condition := ∀ (f:A→C, g:B→D s.t. g∘e == m∘f), ∃! (d:B→C s.t. d∘e==f ∧ m∘d==g)
--------------------------------------------------------------------------------
Γ ⊢ (e ⊥ m) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ e ⊥ m ]] = "The assertion that morphism e is left-orthogonal to morphism m. This is the fundamental 'diagonal fill-in' property. e acts like a quotienting map, while m acts like a subobject inclusion, and the property ensures they are compatible in a strong way." ;

(* ========================================================================================================== )
( == Part 2: Defining the Orthogonal Subcategory == )
( ========================================================================================================== *)

OrthogonalSubcategoryConstructor ::= Identifier "⊥" ;
TYPING
(*
* This constructor takes a class of morphisms S and produces a new category, S⊥.
* S⊥ is the full subcategory of the ambient category C whose objects are orthogonal
* to every morphism in S.
*)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
A_Objects := { X ∈ Ob(C) | Γ ⊢ IsSLocal(X, S) }
--------------------------------------------------------------------
Γ ⊢ S⊥ : FullSubcategory(C) on objects A_Objects ;
CATEGORY
[[ S⊥ ]] = "The full subcategory of S-local (or S-orthogonal) objects. This is the collection of all objects in the ambient category that 'see' no difference between the domain and codomain of any morphism in S." ;

IsSLocal ::= "IsSLocal" "(" Identifier "," Identifier ")" ;
TYPING
Γ ⊢ X : Object_in(C), Γ ⊢ S : ClassOfMorphisms(C)
Condition := ∀(s: A→B ∈ S), the map (f ↦ f∘s) : Hom_C(B,X) → Hom_C(A,X) is an ISOMORPHISM.
-------------------------------------------------
Γ ⊢ IsSLocal(X, S) : BooleanProposition ;
CATEGORY
[[ IsSLocal(X, S) ]] = "The property of an object X being 'S-local'. It means that from the perspective of X, all morphisms in S are already isomorphisms. This is the precise meaning of an object being 'orthogonal' to the class S." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Solving the Problem) == )
( ========================================================================================================== *)

OrthogonalSubcategoryTheorem ::= "THEOREM" "OrthogonalSubcategoryIsReflective" ":"
"IF" "(" Identifier "B" "is" "COCOMPLETE and WELL-POWERED" "and S is a set of morphisms" ")" "THEN"
"(" "S⊥" "is" "REFLECTIVE_IN" "B" ")" ;
TYPING
(* This is a classic result often proven using the Adjoint Functor Theorem. *)
Premise1: Γ ⊢ B : Category
Premise2: B is COCOMPLETE and WELL-POWERED (Sufficient conditions for small solution sets)
Premise3: S is a SET of morphisms in B.
Conclusion: Γ ⊢ S⊥ is REFLECTIVE_IN B
-------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM OrthogonalSubcategoryIsReflective ]] = "A powerful existence theorem that solves the orthogonal subcategory problem. It provides sufficient conditions on the ambient category B for the subcategory of S-orthogonal objects to be reflective. The proof typically involves showing that the inclusion functor of S⊥ has a left adjoint (the reflector), whose existence is guaranteed by an application of the Adjoint Functor Theorem." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.5: Factorization systems" ")" "==>" {
(*

ELABORATION: This section elevates the concept of factorization from an ad-hoc decomposition
to a fundamental structural property of a category. A factorization system (E, M) is a
pair of classes of morphisms that are perfectly "orthogonal" to each other, allowing every
morphism in the category to be uniquely factored through them. To elaborate, we will:

Formalize the Master Definition: We will refine the previous definition of a
Factorization System to be based on the elegant and powerful condition of orthogonality
between the two classes of morphisms, E ⊥ M.

Enumerate the Axioms: The definition requires that E and M are "well-behaved"
(contain isomorphisms, closed under composition), that every morphism has a factorization,
and that the classes are orthogonal. We will formalize these as axioms.

Connect to the Main Example: Re-state the theorem that the pair (StrongEpi, Mono)
forms a factorization system, explicitly showing how it satisfies the orthogonality axiom.

Derive the Dual System: Use the Duality Principle to show that the dual pair (Epi, StrongMono)
also forms a valid factorization system, demonstrating the symmetry of the concept.

*)

(* ========================================================================================================== )
( == Part 1: The Master Definition via Orthogonality == )
( ========================================================================================================== *)

FactorizationSystem ::= "(" Identifier "," Identifier ")" ;
TYPING
Γ ⊢ E : ClassOfMorphisms, Γ ⊢ M : ClassOfMorphisms
------------------------------------------------------
Γ ⊢ (E, M) : PutativeFactorizationSystem ;
CATEGORY
[[ (E, M) ]] = "A pair of classes of morphisms, E and M, intended to form a factorization system." ;

CategoryPropertyDefinition ::= Identifier "has" "FACTORIZATION_SYSTEM" FactorizationSystem ;
TYPING
(*
* This is the refined, modern definition. A category has a factorization system (E, M) if
* every morphism f has an (E, M)-factorization AND the two classes are orthogonal.
* The orthogonality E ⊥ M guarantees the uniqueness of the factorization up to isomorphism.
*)
Γ ⊢ C : Category, Γ ⊢ (E, M) : PutativeFactorizationSystem
Premise1: AllIsomorphisms(C) ⊆ E ∩ M
Premise2: ∀ (f ∈ Mor(C)), ∃ (e∈E, m∈M) s.t. f == m ∘ e
Premise3: E ⊥ M (Orthogonality Condition)
-------------------------------------------------------------------
Γ ⊢ C has FACTORIZATION_SYSTEM (E, M) : PropositionAbout(C) ;
CATEGORY
[[ C has FACTORIZATION_SYSTEM (E, M) ]] = "A fundamental property of a category C, ensuring that every arrow can be uniquely and functorially decomposed into an 'E-part' followed by an 'M-part'. The orthogonality of E and M is the key coherence condition that guarantees this uniqueness." ;

ClassOrthogonality ::= Identifier "⊥" Identifier ;
TYPING
(* This predicate asserts that every morphism in class E is left-orthogonal to every morphism in class M. *)
Γ ⊢ E : ClassOfMorphisms, Γ ⊢ M : ClassOfMorphisms
Condition := ∀ (e ∈ E), ∀ (m ∈ M), (Γ ⊢ e ⊥ m)
-----------------------------------------------------------
Γ ⊢ (E ⊥ M) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ E ⊥ M ]] = "The assertion of orthogonality between two classes of morphisms. This single, powerful condition ensures that the factorization of any morphism is unique up to a unique isomorphism." ;

(* ========================================================================================================== )
( == Part 2: The Canonical Example (StrongEpi, Mono) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "StrongEpiMonoIsFactorizationSystem" ":"
"IF" "(" Identifier "C has necessary (co)limits" ")" "THEN"
"(" "C has FACTORIZATION_SYSTEM" "(" "StrongEpi" "," "Mono" ")" ")" ;
TYPING
(*
* To prove this theorem, we must verify the axioms for the pair (StrongEpi, Mono).
* Premise 1 (isos) and Premise 2 (existence) are non-trivial but standard results.
* Premise 3, Orthogonality, holds by the very DEFINITION of a Strong Epimorphism.
*)
Context: Γ ⊢ C : Category
E := {f | f is STRONG_EPIMORPHISM}, M := {f | f is MONOMORPHISM}
OrthogonalityCheck: By definition, e ∈ StrongEpi means e ⊥ m for all m ∈ Mono. Thus, StrongEpi ⊥ Mono.
------------------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM StrongEpiMonoIsFactorizationSystem ]] = "The assertion that the classes of strong epimorphisms and monomorphisms form the canonical factorization system in many categories. The orthogonality required by the definition is satisfied by the very definition of a strong epimorphism, making this a natural and fundamental pairing." ;

(* ========================================================================================================== )
( == Part 3: The Dual System via Duality Principle == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'EpiStrongMonoIsFactorizationSystem'" "FROM" "THEOREM" "'StrongEpiMonoIsFactorizationSystem'" ;
TYPING
(*
* We apply the duality operator to the canonical theorem.
* The system uses the DualityMapping dictionary to perform rewrites:
* 1. StrongEpi -> StrongMono (dual-of definition from 4.3)
* 2. Mono -> Epi
* The result is the statement that (Epi, StrongMono) is also a factorization system.
*)
Γ ⊢ THEOREM 'StrongEpiMonoIsFactorizationSystem' : P_canonical
P_dual = rewrite(P_canonical, DualityMappings)
----------------------------------------------------------------
Γ ⊢ THEOREM 'EpiStrongMonoIsFactorizationSystem' : P_dual ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the existence of the dual factorization system (Epi, StrongMono). It is derived mechanically by applying the duality functor. This system decomposes a morphism into a regular epimorphism followed by a strong monomorphism. While less common, it highlights the perfect symmetry of the underlying categorical concepts." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.6: The case of localizations" ")" "==>" {
(*

ELABORATION: This section ties together the abstract concept of localization with the tangible
notion of a reflective subcategory. It shows that inverting a class of morphisms Σ is
equivalent to "reflecting" the entire category into the subcategory of objects that already
"see" Σ as isomorphisms. To elaborate, we will:

Formalize the Target Space: Define the property of an object being "Σ-local", meaning
it is orthogonal to the class Σ.

Formalize the Subcategory: Define the subcategory C_Σ of all Σ-local objects.

Formalize the Universal Map: Define a "Σ-localization" of an object as the universal
arrow from that object to the subcategory of Σ-local objects.

State the Main Theorem: Assert the theorem that the subcategory of Σ-local objects is
reflective, and that its reflector functor is precisely the one that performs the
Σ-localization for each object. This establishes that localization is a form of reflection.

*)

(* ========================================================================================================== )
( == Part 1: The Σ-Local Objects == )
( ========================================================================================================== *)

IsSLocal ::= "IsSLocal" "(" Identifier "," Identifier ")" ;
TYPING
(* This rule was introduced in 5.4, but it is central here. An object X is Σ-local if Hom(_, X) inverts Σ. *)
Γ ⊢ X : Object_in(C), Γ ⊢ S : ClassOfMorphisms(C)
Condition := ∀(s: A→B ∈ S), the map (f ↦ f∘s) : Hom_C(B,X) → Hom_C(A,X) is an ISOMORPHISM.
-------------------------------------------------
Γ ⊢ IsSLocal(X, S) : BooleanProposition ;
CATEGORY
[[ IsSLocal(X, S) ]] = "The property of an object X being 'local' with respect to the class of morphisms S. This means that from the point of view of mapping into X, all morphisms in S behave as if they are already isomorphisms. These objects form the natural target for the localization process." ;

(* ========================================================================================================== )
( == Part 2: The Subcategory of Local Objects == )
( ========================================================================================================== *)

LocalSubcategoryConstructor ::= "LocalObjectsSubcat" "(" Identifier ")" ;
TYPING
(* This constructor builds the full subcategory of all Σ-local objects within C. *)
Γ ⊢ C : Category, Γ ⊢ S : ClassOfMorphisms(C)
LocalObjs := { X ∈ Ob(C) | Γ ⊢ IsSLocal(X, S) }
----------------------------------------------------------------------------------
Γ ⊢ LocalObjectsSubcat(S) : FullSubcategory(C) on objects LocalObjs ;
CATEGORY
[[ LocalObjectsSubcat(S) ]] = "The full subcategory C_S of all S-local objects. This subcategory is the 'ideal world' where all morphisms in S have been inverted." ;

(* ========================================================================================================== )
( == Part 3: The Localization Map and The Main Theorem == )
( ========================================================================================================== *)

S_LocalizationMap ::= "S_localization_of" "(" Identifier ")" ;
TYPING
(*
* An S-localization of an object A is a universal arrow from A to the subcategory of S-local objects.
* It is a morphism l: A -> A' such that A' is S-local, and l is "S-inverting". The precise
* meaning is that it's the reflection of A into the subcategory of S-local objects.
*)
Context: Let A_S = LocalObjectsSubcat(S).
Let I = Inclusion(A_S, C). Assume I has a left adjoint L (the reflector).
Let η be the unit of the adjunction L ⊣ I.
Γ ⊢ A : Object_in(C)
--------------------------------------------------------------------------------------
Γ ⊢ S_localization_of(A) : Morphism (This morphism is η_A : A -> I(L(A))) ;
CATEGORY
[[ S_localization_of(A) ]] = "The universal morphism from an object A to an S-local object. This map is itself 'S-inverting' in a suitable sense and is the 'best approximation' of A within the subcategory of S-local objects." ;

TheoremDeclaration ::= "THEOREM" "LocalizationIsReflection" ":"
"IF" "(" Identifier "C" "is sufficiently complete/cocomplete" ")" "THEN"
"(" "LocalObjectsSubcat(S)" "is" "REFLECTIVE_IN" "C" ","
"and the reflector provides the S-localization for each object" ")" ;
TYPING
(*
* This theorem brings everything together.
* It relies on the Orthogonal Subcategory Theorem from 5.4, since C_S is S⊥.
*)
Premise: Γ ⊢ C has sufficient completeness properties.
Conclusion1: Γ ⊢ LocalObjectsSubcat(S) is REFLECTIVE_IN C
Conclusion2: The reflector functor L: C -> LocalObjectsSubcat(S) is such that for any object A,
the unit arrow η_A is the S_localization_of(A).
-----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocalizationIsReflection ]] = "The central theorem of this section, asserting that the process of localization is an instance of reflection. The subcategory of S-local objects is a reflective subcategory, and the reflector functor is the tool that performs the localization for each object in the category. This unifies the concepts of inverting morphisms and finding best approximations." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.7: Universal closure operations" ")" "==>" {
(*

ELABORATION: This section introduces a powerful algebraic tool on a category's subobject lattices:
the "universal closure operation." This structure is shown to be equivalent to a specific kind of
reflective subcategory. To elaborate, we will:

Formalize the Closure Operation: Define a closure operation on subobjects by its three
axioms (extensive, monotone, idempotent). This captures the essence of "closing" something.

Define Universality: Add the crucial fourth axiom for a universal closure operation:
compatibility with pullbacks. This makes the operation a structural feature of the category.

Define Closed Subobjects: Formalize what it means for a subobject to be "closed" with
respect to the operation and how these form their own subcategory.

State the Main Correspondence Theorem: Assert the fundamental theorem that establishes a
bijection between universal closure operations and reflective subcategories that are themselves
closed under subobjects.

*)

(* ========================================================================================================== )
( == Part 1: Defining a Closure Operation == )
( ========================================================================================================== *)

ClosureOperation ::= "ClosureOp" "(" { "cl_" Identifier } ")" ;
TYPING
(* A closure operation is a family of functions, one for each subobject lattice. )
Γ ⊢ C : Category
∀ X ∈ Ob(C), cl_X : Sub(X) → Sub(X) is a function s.t.
AxiomExtensive(cl_X): ∀S∈Sub(X), S ≤ cl_X(S)
AxiomMonotone(cl_X): ∀S1,S2∈Sub(X), (S1 ≤ S2) ⇒ (cl_X(S1) ≤ cl_X(S2))
AxiomIdempotent(cl_X): ∀S∈Sub(X), cl_X(cl_X(S)) ≤ cl_X(S) ( Equality follows from extensive *)
---------------------------------------------------------------------------------------------------------
Γ ⊢ ClosureOp({cl_X}) : ClosureOperationOn(C) ;
CATEGORY
[[ ClosureOp({cl_X}) ]] = "A family of maps on the subobject lattices of a category C that behaves like a topological closure, satisfying extension, monotonicity, and idempotence. It provides a way to systematically 'complete' subobjects." ;

(* ========================================================================================================== )
( == Part 2: Universality and Closed Subobjects == )
( ========================================================================================================== *)

UniversalClosureOperation ::= "Universal" ClosureOperation ;
TYPING
(* A closure operation is universal if it is stable under pullbacks. *)
Γ ⊢ cl : ClosureOperationOn(C)
AxiomUniversal: ∀ (f : Y→X), ∀ (S ∈ Sub(X)), PullbackSubobject(f, cl_X(S)) == cl_Y(PullbackSubobject(f, S))
---------------------------------------------------------------------------------------------------------
Γ ⊢ Universal cl : UniversalClosureOperationOn(C) ;
CATEGORY
[[ Universal cl ]] = "A closure operation that is compatible with the entire morphism structure of the category, as witnessed by its stability under pullback. This makes it a deeply structural, rather than ad-hoc, property." ;

ClosedSubobjectPredicate ::= Identifier "is" "cl_CLOSED" ;
TYPING
(* A subobject is closed if it is a fixed point of the closure operation. *)
Γ ⊢ S : SubobjectOf(X), Γ ⊢ cl : ClosureOperationOn(C)
---------------------------------------------------------
Γ ⊢ S is cl_CLOSED is TRUE if (cl_X(S) ≤ S) ;
CATEGORY
[[ S is cl_CLOSED ]] = "The property of a subobject being 'complete' with respect to the closure operation. These are the fixed points of the closure." ;

ClosedSubcategoryConstructor ::= "ClosedSubcat" "(" ClosureOperation ")" ;
TYPING
(* This builds the full subcategory consisting of all objects C whose identity subobject [id_C] is closed. *)
Γ ⊢ cl : ClosureOperationOn(C)
ClosedObjects := { X ∈ Ob(C) | [id_X] is cl_CLOSED }
--------------------------------------------------------------------
Γ ⊢ ClosedSubcat(cl) : FullSubcategory(C) on objects ClosedObjects ;
CATEGORY
[[ ClosedSubcat(cl) ]] = "The full subcategory of all objects that are 'closed' with respect to the closure operation. In many contexts, this means objects that are 'separated'." ;

(* ========================================================================================================== )
( == Part 3: The Main Correspondence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "ClosureSubcategoryCorrespondence" ":"
"BIJECTION" "between" "(" "UniversalClosureOperationOn" "(" Identifier ")" ")" "and"
"(" "SubobjectClosedReflectiveSubcategoryOf" "(" Identifier ")" ")" ;
TYPING
(* This is a meta-theorem asserting a bijection between two sets of structures on a category C. *)
Set1 := { cl | Γ ⊢ cl : UniversalClosureOperationOn(C) }
Set2 := { A | Γ ⊢ A is REFLECTIVE_IN C ∧ A is_closed_under SUBOBJECTS in C }
---------------------------------------------------------------------
Γ ⊢ Bijection(Set1, Set2) : DefinitionalIsomorphism ;
CATEGORY
[[ THEOREM ClosureSubcategoryCorrespondence ]] = "A fundamental theorem establishing a one-to-one correspondence between two seemingly different structures: algebraic closure operations on subobjects and geometric reflective subcategories (that are stable under subobjects). This reveals a deep connection between the internal lattice structure and the external reflective structure of a category." ;

}
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.8: The calculus of bidense morphisms" ")" "==>" {
(*

ELABORATION: Section 5.8 represents a profound unification of the concepts from Chapter 5.
It brings together localization, reflective subcategories, factorization, and closure operations
under a single, elegant framework. The core idea is that a "closure operation" cl defines a
special class of "bidense" morphisms, and that inverting these morphisms is equivalent to
restricting the category to its "closed" objects.

To elaborate meticulously, we will:

Deconstruct the Players: Formally define the class Σ_cl of cl-bidense morphisms,
the absolute heart of this section.

Formalize the "Calculus": The phrase "calculus of fractions" means that the class Σ_cl
is well-behaved enough for localization. We will formalize this by stating the theorem
that Σ_cl admits a left calculus of fractions, defining this concept as the dual
of the right calculus from Section 5.2.

State the Grand Unification Theorem: Assert the main theorem of the section, which
states that the localization of the category C with respect to the cl-bidense
morphisms is equivalent to the subcategory of cl-closed objects. This reveals
that localization via bidense maps is reflection into the subcategory of closed objects.

*)

(* ========================================================================================================== )
( == Part 1: The Players - Bidense Morphisms as a Formal Class == )
( ========================================================================================================== *)

BidenseMorphism ::= Identifier "is" "cl_BIDENSE" ;
TYPING
(*
* This re-states the definition from 5.7 for clarity. A morphism f is bidense with
* respect to a universal closure operation cl if the closure of its image subobject
* is the entire codomain. This is a very strong notion of "surjectivity".
*)
Γ ⊢ f:A->B : Morphism, Γ ⊢ cl : UniversalClosureOperationOn(C)
Img_f := Image(f)
Max_Sub := [id_B] (the maximal subobject of B)
------------------------------------------------------------------
Γ ⊢ f is cl_BIDENSE is TRUE if (cl_B(Img_f) == Max_Sub) ;
CATEGORY
[[ f is cl_BIDENSE ]] = "A morphism that is 'dense' in the sense of the closure operation. Its image is so large that its closure fills the entire codomain B." ;

ClassOfBidenseMorphisms ::= "Σ" "" "(" "cl" ")" ;
TYPING
(*
* This constructor produces the specific class of all cl-bidense morphisms in a category.
* This class is the set S we will use to form the category of fractions C[S⁻¹].
*)
Γ ⊢ C : Category, Γ ⊢ cl : UniversalClosureOperationOn(C)
--------------------------------------------------------------------------------------
Γ ⊢ Σ(cl) : ClassOfMorphisms(C) where f ∈ Σ_(cl) <==> (f is cl_BIDENSE) ;
CATEGORY
[[ Σ_(cl) ]] = "The class of all cl-bidense morphisms. This is the set of arrows that the localization process will formally invert." ;

(* ========================================================================================================== )
( == Part 2: The "Calculus" Property == )
( ========================================================================================================== *)
( The term "calculus" implies that this class of morphisms is usable for localization. This means it must satisfy the (dual) Ore Conditions. )

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "RIGHT_CALCULUS_OF_FRACTIONS" "IS" "LEFT_CALCULUS_OF_FRACTIONS" ;

admitsLeftCalculusOfFractions ::= Identifier "admits" "LEFT_CALCULUS_OF_FRACTIONS" ;
TYPING
(* This is the dual of the right calculus defined in 5.2. *)
IsDualOf("admitsRIGHTCalculusOfFractions")
EquivalentTyping:
Γ ⊢ S : ClassOfMorphisms(C)
Axiom1(S): S contains all isomorphisms and is closed under composition.
Axiom2_DualOre(S): ∀ (f:Y→X, s:Y→Z∈S), ∃ pushout square with t:X→W∈S and g:Z→W.
Axiom3_DualCancel(S): ∀ (f,g:Y→X), (∃s:Y→Z∈S s.t. s∘f == s∘g) ⇒ (∃t:W→Y∈S s.t. f∘t == g∘t).
----------------------------------------------------------------------------------------
Γ ⊢ S admits LEFT_CALCULUS_OF_FRACTIONS : BooleanProposition ;
CATEGORY
[[ S admits LEFT_CALCULUS_OF_FRACTIONS ]] = "The dual assertion. The dual Ore condition allows reordering f s⁻¹ as t⁻¹ g, enabling the construction of the category of fractions using 'co-roofs' or 'cospans'." ;

TheoremDeclaration ::= "THEOREM" "BidenseMorphismsAdmitLeftCalculus" ":"
"IF" "(" Identifier "C" "has a UniversalClosureOperation and pushouts" ")" "THEN"
"(" "Σ_(cl)" "admits" "LEFT_CALCULUS_OF_FRACTIONS" ")" ;
TYPING
(* This is the key technical result that justifies the name "calculus". *)
Premise: Γ ⊢ C : Category
C has a UniversalClosureOperation cl.
C has pushouts.
----------------------------------------------------------------------
Γ ⊢ Σ_(cl) admits LEFT_CALCULUS_OF_FRACTIONS : MetaTheorem ;
CATEGORY
[[ THEOREM BidenseMorphismsAdmitLeftCalculus ]] = "The cornerstone theorem asserting that the class of cl-bidense morphisms is structurally sound, satisfying the necessary (dual) Ore Conditions to permit the construction of a category of fractions. The universality of the closure operation is crucial for the proof." ;

(* ========================================================================================================== )
( == Part 3: The Grand Unification Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "BidenseLocalizationIsReflectionToClosed" ":"
"Given a UniversalClosureOperation cl on a category C,"
"the localization C[Σ_(cl)⁻¹] is equivalent to the subcategory of cl-closed objects." ;
TYPING
(* This is the punchline, connecting all of Chapter 5's concepts. *)
Context: Γ ⊢ cl : UniversalClosureOperation on C
Σ_cl := ClassOfBidenseMorphisms determined by cl
C_cl := ClosedSubcat(cl) (The reflective subcategory of cl-closed objects)
----------------------------------------------------------------------
Γ ⊢ C[Σ_cl⁻¹] ≅ C_cl : EquivalenceOfCategories ;
CATEGORY
[[ THEOREM BidenseLocalizationIsReflectionToClosed ]] = "A deep theorem that unifies the main themes of Chapter 5. It shows that the subcategory of objects closed under a universal closure operation can be obtained by formally inverting all the 'bidense' morphisms. This provides an explicit link between the algebraic process of closure, the geometric process of reflection, and the syntactic process of localization." ;

}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 6: 'Flat functors and Cauchy completeness', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.1: Exact functors" ")" "==>" {
(*

ELABORATION: This section introduces the concept of an "exact" functor, which is fundamental in
algebra and homological algebra. Exactness relates to the preservation of a specific class of
limits and colimits, namely finite ones. To elaborate, we will:

Formalize "Finite": Define what it means for a category, limit, or colimit to be finite.

Define the Properties: Formalize the properties LEFT_EXACT, RIGHT_EXACT, and EXACT for a
functor based on its preservation of these finite structures.

Assert the Duality: Use the Duality Principle to formally state that LEFT_EXACT and
RIGHT_EXACT are dual concepts.

Provide the Canonical Example: Assert the theorem that in an abelian category, an additive functor
is left exact if and only if it preserves kernels, a classic and practical test.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing Finiteness == )
(* ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "FINITE" ;
TYPING
(* A finite category is a small category with a finite number of objects and morphisms. *)
Γ ⊢ J : Category, J is SMALL
|Objects(J)| is finite ∧ |Morphisms(J)| is finite
--------------------------------------------------
Γ ⊢ J is FINITE : PropositionAbout(J) ;
CATEGORY
[[ J is FINITE ]] = "The property of an index category J being small in the strongest sense, containing only a finite set of objects and morphisms. This is the shape required for a 'finite limit' or 'finite colimit'." ;

LimitProperty ::= "FINITE_LIMIT" ;
TYPING
(* A finite limit is a limit taken over a diagram whose index category is finite. *)
Γ ⊢ L is LIMIT of D:J->C
Γ ⊢ J is FINITE
------------------------------
Γ ⊢ L is FINITE_LIMIT ;
CATEGORY
[[ FINITE_LIMIT ]] = "A limit of a diagram whose shape J is a finite category. This includes important constructions like products, pullbacks, and equalizers." ;

(* ========================================================================================================== )
( == Part 2: The Definitions of Exactness == )
(* ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "LEFT_EXACT" ;
TYPING
(* A functor is left exact if it preserves all finite limits that exist in its domain. *)
Γ ⊢ F : Functor(C, D)
Condition := ∀ (L:Limit in C), ( (L is FINITE_LIMIT) ⇒ (F(L) is FINITE_LIMIT of F(Diagram)) )
--------------------------------------------------------------------------------------------------
Γ ⊢ F is LEFT_EXACT is TRUE if Condition holds : PropositionAbout(F) ;
CATEGORY
[[ F is LEFT_EXACT ]] = "The property of a functor being 'left continuous'. It preserves finite limit structures like products and kernels. The Hom-functor Hom(A,-) is a canonical example." ;

FunctorProperty ::= Identifier "is" "RIGHT_EXACT" ;
TYPING
(* Derived via duality. A functor is right exact if it preserves all finite colimits. *)
IsDualOf("LEFT_EXACT")
EquivalentTyping: Γ ⊢ F : Functor(C, D), F preserves all FINITE_COLIMITS
----------------------------------------------------------------------------
Γ ⊢ F is RIGHT_EXACT : PropositionAbout(F) ;
CATEGORY
[[ F is RIGHT_EXACT ]] = "The dual property of being 'right continuous'. It preserves finite colimit structures like coproducts and cokernels. The tensor product functor -⊗A is a canonical example." ;

FunctorProperty ::= Identifier "is" "EXACT" ;
TYPING
(* A functor is exact if it is both left and right exact. *)
Γ ⊢ F is LEFT_EXACT
Γ ⊢ F is RIGHT_EXACT
-------------------------
Γ ⊢ F is EXACT ;
CATEGORY
[[ F is EXACT ]] = "The powerful property of a functor that preserves all finite limit and colimit structures. Such functors are very well-behaved and reflect a strong compatibility with the algebraic structure of their domain." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LEFT_EXACT" "IS" "RIGHT_EXACT" ;

(* ========================================================================================================== )
( == Part 3: A Classic Criterion in Abelian Categories == )
(* ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LeftExactnessViaKernels" ":"
"IN_CATEGORY" "AbelianCategory AC,"
"(" "an additive functor" Identifier "F" ":" "AC" "->" "AC" "is" "LEFT_EXACT" ")" "<==>" "(" "F preserves KERNELS" ")" ;
TYPING
(*
* In an abelian category, all finite limits can be constructed from kernels and products. Since additive functors
* preserve finite products, the test for left exactness reduces to checking preservation of kernels,
* which are the equalizers in an abelian category.
*)
Context: Category AC is ABELIAN
Γ ⊢ F : Functor(AC, AC), F is Additive
P1 := (Γ ⊢ F is LEFT_EXACT)
P2 := (F preserves finite Products) ∧ (F preserves Equalizers)
P1 <==> P2
AdditiveProperty := (F preserves finite Products)
AbelianProperty := (Equalizers are Kernels)
----------------------------------------------------------------
Γ ⊢ (P1 <==> (F preserves KERNELS)) : ProvableEquivalence ;
CATEGORY
[[ THEOREM LeftExactnessViaKernels ]] = "A classic and practical result in homological algebra. It states that for an additive functor between abelian categories, the abstract property of preserving all finite limits is equivalent to the single, checkable property of preserving kernels." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.2: Left exact reflection of a functor" ")" "==>" {
(*

ELABORATION: This section describes a universal construction: finding the "best approximation"
of an arbitrary functor by a left exact one. This is a classic "reflection" scenario. To
elaborate, we will:

Formalize the Target Space: Define Lex(C,D), the full subcategory of all left exact
functors within the larger functor category [C,D].

Assert the Core Property: State the theorem that this subcategory is reflective.

Define the Universal Construction: Formalize the "Left Exact Reflection" of a functor
F as the result of applying the reflector functor to F.

Describe the Universal Arrow: Formalize the universal arrow η_F which is the natural
transformation from the original functor F to its reflection L(F), capturing the essence
of the universal property.

*)

(* ========================================================================================================== )
( == Part 1: The Subcategory of Left Exact Functors == )
( ========================================================================================================== *)

LeftExactFunctorSubcategory ::= "Lex" "(" Identifier "," Identifier ")" ;
TYPING
(* This constructor builds the full subcategory of the functor category [C,D] on the left exact functors. *)
Γ ⊢ C, D : Category
FunctorCat := [C, D]
LexObjects := { F ∈ Ob(FunctorCat) | Γ ⊢ F is LEFT_EXACT }

Γ ⊢ Lex(C, D) : FullSubcategory(FunctorCat) on objects LexObjects ;
CATEGORY
[[ Lex(C, D) ]] = "The category of left exact functors from C to D. This is the full subcategory of the functor category [C,D] whose objects are the left exact functors and whose morphisms are all natural transformations between them. It represents the 'well-behaved world' we want to reflect into." ;

(* ========================================================================================================== )
( == Part 2: The Reflection Theorem and Construction == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LexIsReflective" ":"
"IF" "(" Identifier "C" "is small and" Identifier "D" "is complete" ")" "THEN"
"(" "Lex(C,D)" "is" "REFLECTIVE_IN" "[C,D]" ")" ;
TYPING
(*

This is the main existence theorem. Provided the categories C and D are suitably well-behaved,

the subcategory of left exact functors is reflective. The proof usually involves applying the

Adjoint Functor Theorem to the inclusion functor I: Lex(C,D) -> [C,D].
*)
Premise1: Γ ⊢ C is SMALL_CATEGORY
Premise2: Γ ⊢ D is COMPLETE_CATEGORY
Conclusion: Γ ⊢ Lex(C,D) is REFLECTIVE_IN [C,D]

Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LexIsReflective ]] = "The fundamental theorem asserting that the subcategory of left exact functors is reflective in the category of all functors, under suitable conditions. This guarantees that a 'best left exact approximation' for any functor exists." ;

LeftExactReflection ::= "L_lex" "(" Identifier ")" ;
TYPING
(*

This defines the left exact reflection L(F) of a functor F. It is the result

of applying the reflector functor (the left adjoint to the inclusion) to F.
*)
Context: Γ ⊢ Lex(C,D) is REFLECTIVE_IN [C,D]
Let L be the Reflector([C,D], Lex(C,D)).
Γ ⊢ F : Functor(C,D)

Γ ⊢ L_lex(F) : Functor(C,D) (where L_lex(F) is L(F) and is LEFT_EXACT) ;
CATEGORY
[[ L_lex(F) ]] = "The left exact reflection of the functor F. It is a new functor L(F) which is itself left exact and is the 'closest' left exact functor to the original F." ;

(* ========================================================================================================== )
( == Part 3: The Universal Property == )
( ========================================================================================================== *)

LeftExactReflectionArrow ::= "lex_reflection_of" "(" Identifier ")" ;
TYPING
(*

The universal arrow is the unit of the adjunction. For a functor F, it's a natural

transformation η_F from F to its reflection L(F).
*)
Context: Let L ⊣ I be the reflection adjunction. Let η be the unit.
Γ ⊢ F : Functor(C, D)

Γ ⊢ lex_reflection_of(F) : NaturalTransformation (from F to L_lex(F)) ;
CATEGORY
[[ lex_reflection_of(F) ]] = "The universal natural transformation η_F : F ⇒ L(F). This arrow is universal in the sense that for any other left exact functor G and any natural transformation α: F ⇒ G, there exists a unique natural transformation α_bar: L(F) ⇒ G such that α_bar ∘ η_F = α. It captures the 'best approximation' property." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.3: Flat functors" ")" "==>" {
(*

ELABORATION: This section defines "flatness," a crucial property for set-valued functors that
generalizes the concept of flat modules in algebra. A functor is flat if tensoring with it is
an exact operation. This property has a remarkable equivalent characterization in terms of
filtered colimits. To elaborate, we will:

State the Primary Definition: Formalize a presheaf F as FLAT if its corresponding tensor
product functor F ⊗ - is LEFT_EXACT. This connects directly to previous sections.

Formalize the Equivalent Characterization: Define flatness through the property of being
a filtered colimit of representable presheaves. This requires formalizing the notion of
a diagram of representable functors.

State the Main Equivalence Theorem: Assert the fundamental theorem that these two
seemingly different definitions are, in fact, equivalent.

*)

(* ========================================================================================================== )
( == Part 1: The Definition via Tensor Products == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "FLAT" ;
TYPING
(*

The primary definition of a flat presheaf F is that the functor F ⊗ - is left exact,

meaning it preserves finite limits.
)
Context: C is a small category.
Γ ⊢ F : Functor(C^op, Set) ( F is a Presheaf *)
TensorFunctor := (G ↦ F ⊗_C G) : [C, Set] -> Set

Γ ⊢ F is FLAT is TRUE if (TensorFunctor is LEFT_EXACT) ;
CATEGORY
[[ F is FLAT ]] = "The property of a presheaf F that makes it behave like a 'flat module'. Tensoring with it is a well-behaved, exact operation that preserves finite limit structures. This is a crucial concept in sheaf theory and algebraic geometry, where it relates to stalks." ;

(* ========================================================================================================== )
( == Part 2: The Equivalent Characterization via Colimits == )
( ========================================================================================================== *)

RepresentableFunctor ::= "y" "(" Identifier ")" ;
TYPING
(* This represents the functor Hom(-, X), the canonical presheaf represented by object X via the Yoneda embedding. *)
Γ ⊢ X : Object_in(C)

Γ ⊢ y(X) : Functor(C^op, Set) ; (* A Presheaf *)
CATEGORY
[[ y(X) ]] = "The representable presheaf on C associated with the object X. This is the functor represented by X in the Yoneda embedding, Hom_C(-, X)." ;

FunctorAsFilteredColimitOfRepresentables ::= Identifier "is" "FilteredColimitOfRepresentables" ;
TYPING
(* This predicate is true if a presheaf F can be written as a filtered colimit of representable presheaves. *)
Γ ⊢ F : Functor(C^op, Set)
∃ (Diagram D:J->C) s.t.
(1) J is a FILTERED category
(2) F ≅ colim (y ∘ D) where y is the Yoneda embedding.

Γ ⊢ F is FilteredColimitOfRepresentables : BooleanProposition ;
CATEGORY
[[ F is FilteredColimitOfRepresentables ]] = "The property of a presheaf being constructible as a 'direct limit' (a filtered colimit) of simpler, representable functors. This describes the functor's internal structure in a precise way." ;

(* ========================================================================================================== )
( == Part 3: The Main Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "FlatFunctorEquivalence" ":"
"(" Identifier "F" "is" "FLAT" ")" "<==>" "(" "F" "is" "FilteredColimitOfRepresentables" ")" ;
TYPING
P1 := (Γ ⊢ F is FLAT)
P2 := (Γ ⊢ F is FilteredColimitOfRepresentables)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FlatFunctorEquivalence ]] = "A fundamental theorem of presheaf theory. It asserts that the 'external' behavioral property of a presheaf (flatness, i.e., its tensor product functor being left exact) is equivalent to its 'internal' structural property (being a filtered colimit of representables). This is a deep result connecting a functor's algebraic behavior to its categorical composition." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.4: The relevance of regular cardinals" ")" "==>" {
(*

ELABORATION: This section generalizes the concepts of exactness and flatness from "finite"
to "α-sized," where α is a regular cardinal. This allows for a much finer-grained analysis
of the properties of functors and categories. To elaborate, we will:

Formalize the Parameter: Define what a regular cardinal is.

Generalize the Concepts: Parameterize the definitions of limit, filtered category,
and continuous/flat functors with a regular cardinal α. This gives us α-limits,
α-filtered categories, α-continuous functors, and α-flat functors.

State the Generalized Equivalence Theorem: Re-state the main theorem from the previous
section in this more general, parameterized form, showing that the equivalence between
tensorial exactness and internal structure holds at every 'level' defined by a
regular cardinal.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Size Parameter == )
( ========================================================================================================== *)

RegularCardinal ::= "REGULAR_CARDINAL" Identifier ;
TYPING
(* A cardinal α is regular if its cofinality is equal to itself. Informally, it can't be reached by a smaller number of smaller cardinals. *)
Let α be a cardinal number.
cof(α) == α

Γ ⊢ REGULAR_CARDINAL α : SetTheoreticProperty ;
CATEGORY
[[ REGULAR_CARDINAL α ]] = "A type of 'well-behaved' infinite cardinal. Aleph-null (ℵ₀), corresponding to 'finite', is the first regular cardinal. Regular cardinals provide robust stopping points for transfinite constructions and serve as the correct notion of 'size' for generalizing categorical properties." ;

(* ========================================================================================================== )
( == Part 2: Generalizing Previous Concepts with α == )
( ========================================================================================================== *)

AlphaLimit ::= "α_LIMIT" ;
TYPING
(* An α-limit is a limit over a diagram whose index category J has fewer than α morphisms. *)
Γ ⊢ L is LIMIT of D:J->C
|Morphisms(J)| < α

Γ ⊢ L is α_LIMIT ;
CATEGORY
[[ α_LIMIT ]] = "A limit whose diagram shape is 'small' relative to the regular cardinal α. For α = ℵ₀, this is precisely a finite limit." ;

AlphaFilteredCategory ::= "α_FILTERED_CATEGORY" ;
TYPING
(* An α-filtered category is a generalization of a filtered category. *)
Γ ⊢ J : Category
Condition := Every diagram D:K->J where |Morphisms(K)| < α has a cocone in J.

Γ ⊢ J is α_FILTERED_CATEGORY is TRUE if Condition holds ;
CATEGORY
[[ α_FILTERED_CATEGORY ]] = "The generalization of a filtered category to size α. It requires that any diagram whose shape is 'smaller' than α can be connected within the category. For α=ℵ₀, this is equivalent to the standard definition of a filtered category." ;

FunctorProperty ::= Identifier "is" "α_CONTINUOUS" "(" "wrt" RegularCardinal ")" ;
TYPING
(* A functor is α-continuous if it preserves all α-limits. *)
Γ ⊢ F : Functor(C, D), Γ ⊢ α : RegularCardinal
Condition := F preserves all α_LIMITS.

Γ ⊢ F is α_CONTINUOUS ... is TRUE if Condition holds ;
CATEGORY
[[ F is α_CONTINUOUS ... ]] = "The property of a functor preserving all limits of size less than α. For α = ℵ₀, this is precisely left exactness." ;

FunctorProperty ::= Identifier "is" "α_FLAT" "(" "wrt" RegularCardinal ")" ;
TYPING
(* An α-flat functor is the generalization of a flat functor. *)
Γ ⊢ F : Functor(C, Set), Γ ⊢ α : RegularCardinal
Two-Equivalent-Definitions:
Def1_Tensor: (H ↦ H ⊗ F) is α_CONTINUOUS.
Def2_Colimit: F is an α-filtered colimit of representables.

Γ ⊢ F is α_FLAT ... is TRUE if (Def1 ⇔ Def2) ;
CATEGORY
[[ F is α_FLAT ... ]] = "The property of a functor being 'flat' up to size α. This means it behaves well with respect to algebraic structures of size less than α. For α = ℵ₀, this is precisely a flat functor." ;

(* ========================================================================================================== )
( == Part 3: The Generalized Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AlphaFunctorEquivalenceGeneralization" ":"
"FOR_ALL" RegularCardinal "α,"
"(" "a functor F is α_FLAT" ")" "<==>" "(" "F is an α-filtered colimit of representables" ")" ;
TYPING
Γ ⊢ α : RegularCardinal
P1 := (Γ ⊢ F is α_FLAT) (* Defined tensorially *)
P2 := (Γ ⊢ F is an α-filtered colimit of representable functors)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AlphaFunctorEquivalenceGeneralization ]] = "The generalization of the Flat Functor Equivalence theorem. It asserts that for any regular cardinal α, the 'external' behavioral property of a functor (its α-flatness) is equivalent to its 'internal' structural property (being an α-filtered colimit of representables). This demonstrates that the deep connection between a functor's algebraic behavior and its categorical composition is not an accident of finite structures, but a fundamental principle that scales across all well-behaved cardinalities." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.5: The splitting of idempotents" ")" "==>" {
(*

ELABORATION: This section introduces a purely category-theoretic notion of "completeness"
called Cauchy completeness (or Karoubi completeness). It deals with whether the category
contains enough structure to "realize" abstractly defined idempotents as concrete projection
and inclusion maps. To elaborate, we will:

Formalize the Object of Study: Define an Idempotent morphism (e∘e = e).

Formalize the Solution: Define what it means for an idempotent to "split" into a
retraction-section pair.

Define the Global Property: Formalize a category as being Cauchy Complete if every one
of its idempotents splits.

Formalize the Universal Construction: Define the Karoubi Envelope (or Cauchy completion)
Kar(C) as the universal category that "solves" this problem for any given category C, and
state its universal property.

*)

(* ========================================================================================================== )
( == Part 1: The Idempotent and its Splitting == )
( ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "is" "IDEMPOTENT" ;
TYPING
(* An idempotent is a morphism that is its own square under composition. *)
Γ ⊢ e : A -> A
e ∘ e == e

Γ ⊢ e is IDEMPOTENT ;
CATEGORY
[[ e is IDEMPOTENT ]] = "An endomorphism that acts like a projection operator. Applying it once is the same as applying it any number of times. These morphisms represent abstract subobjects or summands." ;

SplittingOfIdempotent ::= "SPLITTING_OF" "(" Identifier ")" "is" "(" "retraction" ":" Identifier "," "section" ":" Identifier ")" ;
TYPING
(*

A splitting of an idempotent e:A->A is a pair of morphisms (m:I->A, i:A->I) that factor e

through an intermediate object I, such that i "retracts" A onto I and m "includes" I

back into A as a retract.
*)
Context: Γ ⊢ e : A -> A is IDEMPOTENT
Γ ⊢ m : I -> A, Γ ⊢ i : A -> I
Premise1_Factorization: e == m ∘ i
Premise2_Retraction: i ∘ m == id_I

Γ ⊢ SPLITTING_OF(e) is ... : IdempotentSplitting(e) ;
CATEGORY
[[ SPLITTING_OF(e) is ... ]] = "A concrete realization of the abstract idempotent e. It factors the projection e into a formal 'inclusion' m and a 'projection' i via an object I that represents the abstract image of e. The condition i∘m=id witnesses that I is a retract of A." ;

(* ========================================================================================================== )
( == Part 2: Cauchy Completeness and the Universal Envelope == )
( ========================================================================================================== *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.5: The splitting of idempotents, Part 2: Cauchy Completeness and the Universal Envelope" ")" "==>" {
(*

ELABORATION: To provide a deeper elaboration on the Cauchy completion, we will deconstruct
the Karoubi envelope construction into its finest parts. We are moving beyond just stating
its existence and universal property to formalizing its very machinery. We will:

Formalize the Objects and Morphisms: We will create explicit rules not just for the objects of
the Karoubi envelope Kar(C) (which are pairs (A, e)), but also for its morphisms. This makes
the internal structure of Kar(C) fully transparent within our grammar.

Formalize the Universal Functor: We will define the canonical embedding functor Y: C -> Kar(C)
that injects the original category into its completion, specifying its action on both objects
and morphisms.

Connect to Other Limit Concepts: We will state the important theorem that any category with
all equalizers is already Cauchy complete. This provides a practical criterion for checking
the property and contextualizes it within the broader theory of limits.

Refine the Universal Property Theorem: By formalizing the components above, our statement of
the universal property of Kar(C) becomes more concrete and its proof more apparent from the
structure of the rules themselves.

*)

(* ========================================================================================================== )
( == Part 2a: Explicit Construction of the Karoubi Envelope == )
( ========================================================================================================== *)

KaroubiObject ::= "KarObj" "(" "obj" ":" Identifier "," "idem" ":" Identifier ")" ;
TYPING
(* An object of the Karoubi Envelope Kar(C) is a pair (A, e) where A is an object of C and e is an idempotent on A. *)
Γ ⊢ A : Object_in(C)
Γ ⊢ e : Morphism(A, A)
Γ ⊢ e is IDEMPOTENT
-------------------------------------------------------------------------------
Γ ⊢ KarObj(obj: A, idem: e) : Object_in(Kar(C)) ;
CATEGORY
[[ KarObj(obj: A, idem: e) ]] = "An object in the Karoubi envelope, representing the abstract 'image' of the idempotent projection e. It is the formal object that the idempotent e splits through." ;

KaroubiMorphism ::= "KarMor" "(" "mor" ":" Identifier ")" "from" KaroubiObject "to" KaroubiObject ;
TYPING
(*

A morphism in Kar(C) from (A,e) to (B,f) is a morphism h:A->B in the base category C

that is 'compatible' with the idempotents, i.e., it factors through them.
*)
Γ ⊢ Source = KarObj(obj:A, idem:e)
Γ ⊢ Target = KarObj(obj:B, idem:f)
Γ ⊢ h : Morphism(A, B) in C
Condition: h == f ∘ h ∘ e
-------------------------------------------------------------------------------
Γ ⊢ KarMor(mor: h) from Source to Target : Morphism_in(Kar(C)) ;
CATEGORY
[[ KarMor(mor: h) ... ]] = "A morphism in the Karoubi envelope. The condition h = f ∘ h ∘ e ensures that the mapping respects the 'image' parts of the source and target objects defined by the idempotents." ;

KaroubiEnvelope ::= "Kar" "(" Identifier ")" ;
TYPING
(* The refined definition of the envelope, now explicitly using our object and morphism constructors. *)
Γ ⊢ C : Category
Objects of Kar(C) := { o | Γ ⊢ o : KaroubiObject in C }
Morphisms of Kar(C) := { m | Γ ⊢ m : KaroubiMorphism in C }
---------------------------------------------------------
Γ ⊢ Kar(C) : Category ;
CATEGORY
[[ Kar(C) ]] = "The Karoubi envelope of C. It is the universal Cauchy complete category containing C. The construction formally adjoins an object and appropriate morphisms for every idempotent in C, thereby 'completing' it." ;

(* ========================================================================================================== )
( == Part 2b: Formalizing Cauchy Completeness and its context == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "CAUCHY_COMPLETE" ;
TYPING
(* A category is Cauchy complete if every idempotent morphism in it splits. *)
Γ ⊢ C : Category
∀ (e ∈ Mor(C)), ( (e is IDEMPOTENT) ⇒ (∃ SplittingOfIdempotent for e) )
---------------------------------------------------------------------------
Γ ⊢ C is CAUCHY_COMPLETE : PropositionAbout(C) ;
CATEGORY
[[ C is CAUCHY_COMPLETE ]] = "The property of a category being 'idempotent complete'. It ensures that any abstract projection operator can be realized as a concrete retract. It is a fundamental notion of completeness, weaker than having all limits." ;

TheoremDeclaration ::= "THEOREM" "EqualizersImplyCauchyCompleteness" ":"
"IF" "(" Identifier "C" "has all Equalizers" ")" "THEN" "(" "C" "is" "CAUCHY_COMPLETE" ")" ;
TYPING
(* Proof sketch: The splitting of an idempotent e:A->A can be constructed as the equalizer of e and id_A. *)
Γ ⊢ C has AllEqualizers
------------------------------------------
Γ ⊢ C is CAUCHY_COMPLETE : MetaTheorem ;
CATEGORY
[[ THEOREM EqualizersImplyCauchyCompleteness ]] = "A foundational result connecting different forms of completeness. It provides a sufficient condition for a category to be Cauchy complete, showing that the ability to solve for equalizers is strong enough to realize all abstract idempotents as concrete retracts." ;

(* ========================================================================================================== )
( == Part 2c: The Refined Universal Property == )
( ========================================================================================================== *)

KaroubiEmbeddingFunctor ::= "Y_Kar" ":" Identifier "→" KaroubiEnvelope ;
TYPING
(* This formalizes the canonical embedding functor Y: C -> Kar(C). *)
Γ ⊢ C : Category
Action_on_Objects: A ↦ KarObj(obj: A, idem: id_A)
Action_on_Morphisms: f:A->B ↦ KarMor(mor: f) from KarObj(A,id_A) to KarObj(B,id_B)
---------------------------------------------------------------------------------------
Γ ⊢ Y_Kar : C → Kar(C) : Functor ;
CATEGORY
[[ Y_Kar ]] = "The canonical Yoneda-like embedding of a category C into its Karoubi envelope. It is full and faithful and identifies C with a subcategory of Kar(C)." ;

TheoremDeclaration ::= "THEOREM" "KaroubiEnvelopeIsUniversal_Refined" ":"
"Kar(C) is CAUCHY_COMPLETE, and for the functor Y_Kar:C→Kar(C),"
"for any other CAUCHY_COMPLETE category D and functor F:C→D,"
"there exists a unique functor F_bar: Kar(C)→D with F_bar∘Y_Kar = F." ;
TYPING
(* This is the refined formalization of the universal property. *)
Γ ⊢ C, D : Category
Γ ⊢ Y = Y_Kar : C → Kar(C)
F_bar_exists_and_is_unique_for_all_F:
( (D is CAUCHY_COMPLETE) ∧ (F:C→D) ) ⇒ ( ∃! F_bar:Kar(C)→D s.t. F_bar∘Y == F )
-----------------------------------------------------------------
Conclusion: Kar(Y) is LeftAdjointToInclusion(From:CauchyCompleteCats, Into:AllCats) ;
CATEGORY
[[ THEOREM KaroubiEnvelopeIsUniversal_Refined ]] = "The refined assertion that the Karoubi envelope is the universal solution to making a category Cauchy complete. By explicitly defining the embedding functor Y_Kar, the universal property becomes a more concrete statement about the unique factorization of any functor from C through Kar(C)." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.6: The more general adjoint functor theorem" ")" "==>" {
(*

ELABORATION (Deeper Dive): The previous elaboration stated the Refined General Adjoint Functor Theorem (GAFT).
A deeper elaboration requires formalizing the constructive proof of this theorem. The theorem's
power lies in showing how the existence of a weakly initial set, combined with limit preservation,
allows one to build the universal arrow for each object, which in turn builds the left adjoint.

This elaboration will formalize the key lemma and the constructive steps of this proof:

Formalize the Lemma: A key lemma is that if a functor G preserves limits, then the comma
category (c ↓ G) inherits completeness from G's domain. We will formalize this.

Formalize the Construction: We will create a meta-rule, GAFT_ConstructiveProof, that
outlines the steps: (1) Find the weakly initial set, (2) Use it to construct an initial
object in the comma category, (3) This initial object IS the universal arrow, (4) Repeat
for all objects to build the adjunction.

Formalize the "Engine": We will define the constructor ConstructInitialObject which embodies
the core of the proof mechanism (taking a product, then a limit).

This approach transforms the theorem from a static assertion into a dynamic, constructive process
within the grammar itself.
*)

(* ========================================================================================================== )
( == Part 1: The Crucial Lemma - Inherited Completeness == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "InheritedCompletenessOfCommaCategory" ":"
"IF" "(" Identifier "D is COMPLETE" "and" Functor "G:D->C preserves LIMITS" ")" "THEN"
"(" "FOR_ALL c in C, the category (c↓G) is COMPLETE" ")" ;
TYPING
(*

This is a standard but essential lemma for the GAFT proof. The proof involves showing that

limits in (c↓G) can be constructed from limits in D.
*)
Premise1: Γ ⊢ D is COMPLETE_CATEGORY
Premise2: Γ ⊢ G : Functor(D, C), G preserves SMALL_LIMITS

Conclusion: ∀ c ∈ Ob(C), (Γ ⊢ (c ↓ G) is COMPLETE_CATEGORY) : MetaTheorem ;
CATEGORY
[[ THEOREM InheritedCompletenessOfCommaCategory ]] = "A proof that the property of completeness is 'lifted' from a functor's domain D to the comma category (c↓G), provided the functor G preserves limits. This ensures that the arena in which we search for a universal arrow is itself well-behaved and has the limits needed for the construction." ;

(* ========================================================================================================== )
( == Part 2: The Constructive Proof as a Meta-Rule == )
( ========================================================================================================== *)

GeneralAdjointFunctorTheorem_ConstructiveProof ::= "PROOF_OF_GAFT" "for" Functor "G:D->C" "{"
"STEP 1: Check Premises" "{" "D is COMPLETE" "," "G preserves LIMITS" "}" ";"
"STEP 2: For each c in C, do" "{"
"2a: Let K = (c↓G);"
"2b: Assert K is COMPLETE by InheritedCompleteness;"
"2c: Find WeaklyInitialSet S in K;"
"2d: Let u_c = ConstructInitialObject in K using S;"
"}" ";"
"STEP 3: Conclude G has LeftAdjoint ByUniversalArrowConstruction;"
"}" ;
TYPING
(*

This is not a term in the language, but a meta-rule formalizing the proof strategy.

Its typing is the theorem itself.
*)
P1 := (Γ ⊢ D is COMPLETE_CATEGORY)
P2 := (Γ ⊢ G : Functor(D,C), G preserves LIMITS)
P3 := ∀ c ∈ Ob(C), ∃ (S ⊆ Ob(c↓G)) s.t. (S is WeaklyInitialSet in (c↓G))
Conclusion := G has LeftAdjoint

Γ ⊢ PROOF_OF_GAFT ... : ( (P1 ∧ P2 ∧ P3) ⇒ Conclusion ) ;
CATEGORY
[[ PROOF_OF_GAFT ... ]] = "A formalization of the complete proof strategy for the General Adjoint Functor Theorem. It is an algorithm that takes the premises as input and yields the existence of a left adjoint as output, with each step justified by a subordinate theorem or construction." ;

(* ========================================================================================================== )
( == Part 3: The Proof's Engine - Constructing the Universal Arrow == )
( ========================================================================================================== *)

InitialObjectConstructor_FromWeaklyInitialSet ::= "ConstructInitialObject" "in" Identifier "using" Identifier ;
TYPING
(*

This rule formalizes the engine of the proof. Given a weakly initial set S_c in the

complete category (c↓G), it constructs an initial object.

The construction is to take the product of all objects in S_c, then take an appropriate limit.
*)
Γ ⊢ K : Category, K is COMPLETE
Γ ⊢ S : WeaklyInitialSet in K

Γ ⊢ ConstructInitialObject in K using S : Object_in(K) (which is INITIAL) ;
CATEGORY
[[ ConstructInitialObject in K using S ]] = "The core constructive step of the GAFT proof. It is an algorithm that takes a weakly initial set S in a complete category K and builds an initial object. This algorithm demonstrates that having a 'reachable' set combined with completeness is sufficient to find a universal starting point." ;

UniversalArrow_FromInitialObject ::= "UniversalArrow_for" "(" Identifier ")" "is" "InitialObject_of" "(" CommaCategoryUnderFunctor ")" ;
TYPING
(*

This rule formalizes the conceptual leap: the initial object we just constructed in the comma

category (c↓G) IS the universal arrow from c to G.
*)
Γ ⊢ c : Object_in(C)
Γ ⊢ u is INITIAL_OBJECT in (c ↓ G)

Γ ⊢ UniversalArrow_for(c) is u : DefinitionalEquivalence ;
CATEGORY
[[ UniversalArrow_for(c) is ... ]] = "An assertion of definitional equivalence. It states that the notion of an 'initial object' in the comma category (c↓G) is precisely the same as the notion of a 'universal arrow' from the object c to the functor G. This provides the bridge from the limit construction to the desired adjunction." ;

(* ========================================================================================================== )
( == Part 4: Final Conclusion - Invoking the Adjunction Criterion == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdjunctionsFromUniversalArrows" ":"
"A functor G has a Left Adjoint IFF for every object c, there exists a UniversalArrow from c to G." ;
TYPING
(* A reminder of the criterion (from Sec 3.3) that completes the proof. *)
P1 := G has LeftAdjoint
P2 := ∀ c ∈ Ob(C), ∃ (UniversalArrow_for(c))

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdjunctionsFromUniversalArrows ... ]] = "The theorem which provides the final step of the GAFT proof. Once our construction has built a universal arrow for every object c, this theorem allows us to conclude that a left adjoint to G exists. The collection of all such universal arrows assembles to form the unit of the adjunction." ;
}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 7: 'Bicategories and distributors', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.1: 2-categories" ")" "==>" {
(*

ELABORATION: A 2-category enhances a standard category by introducing "morphisms between morphisms,"
called 2-cells. This section formalizes the STRICT version of a 2-category, where composition of
1-morphisms is strictly associative and unital. The core idea is that for any two objects A and B,
the collection of morphisms between them, Hom(A,B), is not just a set but a category itself.

To elaborate, we will:

Formalize the Hom-Category: Define the category structure that exists between any two objects.

Formalize the Composition Functor: Define the composition of 1-morphisms not as a mere
operation, but as a functor. This functoriality is precisely what enforces the strict interchange law.

Formalize the Identity-on-Objects Functor: Show that the identity 1-morphisms are given
by an identity-on-objects functor from the terminal category.

Construct the 2-Category: Assemble these components into the master definition of a 2-category.

*)

(* ========================================================================================================== )
( == Part 1: The Building Blocks - Hom-Categories and Composition Functors == )
( ========================================================================================================== *)

HomCategoryDeclaration ::= "HOM_CATEGORY" "(" Identifier "," Identifier ")" "has" "{" "OneMorphisms" ":" "{" {Identifier} "}" ";" "TwoMorphisms" ":" "{" {MorphismDeclaration} "}" ";" "}" ;
TYPING
(*

This declares that the collection of morphisms between two objects A and B in a 2-category

forms a category itself. The objects of this "hom-category" are the 1-morphisms, and the

morphisms of the hom-category are the 2-morphisms (or 2-cells).
)
Γ ⊢ C/A, C/B : Object_in(_2Category)
Γ ⊢ OneMorphisms : Set(Identifier) ( These are the 1-morphisms, acting as objects )
Γ ⊢ TwoMorphisms : Set(MorphismDeclaration) ( These are the 2-morphisms, acting as arrows *)

Generated code
Γ ⊢ HOM_CATEGORY(C/A, C/B) ... : Category ;


CATEGORY
[[ HOM_CATEGORY(A, B) ... ]] = "The hom-category C(A,B). Its existence, for every pair of objects (A,B), is the defining feature of a 2-category. Its objects are 1-morphisms A→B and its morphisms are 2-morphisms between them. The composition in this category is 'vertical composition' of 2-cells." ;

CompositionFunctorDeclaration ::= "COMPOSITION_FUNCTOR" "∘" ":" HomCategoryDeclaration "×" HomCategoryDeclaration "→" HomCategoryDeclaration ;
TYPING
(* This asserts that composition of 1-morphisms is a functor. This elegantly captures the interchange law. *)
Γ ⊢ C(B,C) : HOM_CATEGORY(B,C)
Γ ⊢ C(A,B) : HOM_CATEGORY(A,B)
Γ ⊢ C(A,C) : HOM_CATEGORY(A,C)

Generated code
Γ ⊢ ∘ : Functor(C(B,C) × C(A,B), C(A,C)) ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ ∘ : C(B,C) × C(A,B) → C(A,C) ]] = "The horizontal composition functor. Its action on objects is the composition of 1-morphisms. Its action on morphisms (the 2-cells) is the horizontal composition of 2-cells, often denoted by ∗. The fact that ∘ is a functor is precisely the interchange law: (β' ⋅ β) ∗ (α' ⋅ α) = (β' ∗ α') ⋅ (β ∗ α), where ⋅ is vertical and ∗ is horizontal composition." ;

IdentityFunctorDeclaration ::= "IDENTITY_FUNCTOR" "Id" ":" "TerminalCategory" "→" HomCategoryDeclaration ;
TYPING
(* The identity 1-morphism for an object A is given by a functor from the terminal category 1. *)
Γ ⊢ C(A,A) : HOM_CATEGORY(A,A)

Generated code
Γ ⊢ Id : Functor(1, C(A,A)) ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ Id : 1 → C(A,A) ]] = "The identity-on-A functor. It selects the identity 1-morphism id_A from the hom-category C(A,A). The fact it is a functor is trivial but completes the structural definition." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition == )
( ========================================================================================================== *)

_2CategoryDeclaration ::= "_2CATEGORY" Identifier "{" "Objects" ":" {Identifier} ";" "HomCategories" ":" {HomCategoryDeclaration} ";" "CompositionFunctors" ":" {CompositionFunctorDeclaration} ";" "IdentityFunctors" ":" {IdentityFunctorDeclaration} ";" "}" ;
TYPING
(* A 2-category is defined by its collection of objects and these structured hom-sets. *)
Γ ⊢ Objs : Set(Identifier)
... all other components are well-typed ...
Coherence: Composition functors are associative and unital.

Generated code
Γ ⊢ _2CATEGORY ... : _2Category ;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

CATEGORY
[[ _2CATEGORY C ... ]] = "A category enriched over the category of small categories (Cat). This is the strict definition, where the laws of associativity and identity for the composition functor hold on the nose, not just up to isomorphism. The canonical example is Cat itself, whose objects are categories, 1-morphisms are functors, and 2-morphisms are natural transformations." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.2: 2-functors and 2-natural transformations" ")" "==>" {
(*

ELABORATION: This section defines the structure-preserving maps between 2-categories. Just as
a functor preserves the structure of a category, a 2-functor preserves the structure of a
2-category. This means it preserves not only objects and 1-morphisms but also 2-morphisms
and both their vertical and horizontal compositions. A 2-natural transformation is the next
level up, being a "morphism" between 2-functors.

To elaborate, we will:

Formalize the 2-Functor: Define a 2-functor F by specifying its action on objects,
1-morphisms, and 2-morphisms, with the crucial condition that its action on each
hom-category is itself a functor.

Formalize the 2-Natural Transformation: Define a 2-natural transformation α between
two 2-functors F and G. Its components α_X will be 1-morphisms, and its naturality
condition will be a strictly commutative square of 1-morphisms.

*)

(* ========================================================================================================== )
( == Part 1: The 2-Functor == )
( ========================================================================================================== *)

_2FunctorDeclaration ::= "_2FUNCTOR" Identifier ":" Identifier "→" Identifier "{" "ActionOnObjects" ":" {ObjectMapping} ";" "ActionOnHomCats" ":" {HomCategoryFunctorMapping} ";" "}" ;
TYPING
(*

A 2-functor F from a 2-category C to a 2-category D is a map that preserves all structure.

This is captured by requiring that for each pair of objects (A,B) in C, the mapping F induces

on the hom-category is itself a functor.
*)
Γ ⊢ C, D : 2Category
ActionOnObjects is a valid function from Ob(C) to Ob(D).
∀ A,B in Ob(C), F{A,B} : C(A,B) → D(F(A),F(B)) is a Functor.

Γ ⊢ _2FUNCTOR F ... : _2Functor(C, D) ;
CATEGORY
[[ _2FUNCTOR F ... ]] = "A strict 2-functor, or a homomorphism of 2-categories. It preserves all structure on the nose: objects, 1-morphisms, 2-morphisms, vertical composition, horizontal composition, and identities." ;

HomCategoryFunctorMapping ::= "map_hom_cat" "(" Identifier "," Identifier ")" "to" "hom_cat" "(" Identifier "," Identifier ")" "via_functor" Identifier ;
TYPING
(* This is the typing rule for the component functor F_{A,B}. *)
Γ ⊢ C(A,B) : HOM_CATEGORY in C
Γ ⊢ D(F(A),F(B)) : HOM_CATEGORY in D

Γ ⊢ F_AB : Functor(C(A,B), D(F(A),F(B))) ;
CATEGORY
[[ map_hom_cat ... via_functor F_AB ]] = "The component of a 2-functor F that acts on a specific hom-category. The functoriality of F_AB ensures that F preserves 2-morphisms and their vertical composition. The preservation of horizontal composition is guaranteed by the coherence of these component functors." ;

(* ========================================================================================================== *)
(* == Part 2a: The Deconstructed Master Definition == )
(* ========================================================================================================== *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.1: 2-categories Part 2a: The Deconstructed Master Definition" ")" "==>" {
(*
* ELABORATION (Instantiation): The previous elaboration formalized the deconstructed master definition
* of a 2-category, separating its "Data" (the structures) from its "Axioms" (the laws).
* To provide a deeper elaboration, we will now instantiate this deconstructed definition with
* the canonical example: Cat, the 2-category of small categories, functors, and natural
* transformations.
*
* This example will meticulously fill in each part of the _2CategoryData block, explaining
* how categories, functors, and natural transformations fit into the framework of 0-cells, 1-cells,
* and 2-cells. It will then assert that this data satisfies the required _2CategoryAxioms,
* thereby proving that Cat is, indeed, a (strict) 2-category.
*)

Generated code
(* ========================================================================================================== *)
(* == Example Instantiation: The 2-Category of Categories, 'Cat' == )
(* ========================================================================================================== *)

_2CategoryDeclaration ::= "_2CATEGORY" "Cat" "{"
    _2CategoryData ::= "DATA" "{"
        "Objects" ":" "{" "C" "," "D" "," "A" "," "B" "}" ";"
        TYPING
            (* The objects (0-cells) of Cat are small categories themselves. *)
            Ob_Type := { c | c is a small Category }
            -----------------------------------
            Γ ⊢ Objects(Cat) : Ob_Type ;
        CATEGORY
            [[ Objects ]] = "The collection of all small categories." ;

        "HomCategories" ":" "{"
            HomCategoryDeclaration ::= "HOM_CATEGORY" "(" "C" "," "D" ")" ";"
            TYPING
                (* The hom-category Cat(C,D) has functors as its objects and natural transformations as its morphisms. *)
                Objects(Cat(C,D)) := { F | Γ ⊢ F : Functor(C, D) }
                Morphisms(Cat(C,D)) := { α | Γ ⊢ α : NaturalTransformation }
                ------------------------------------------------------------------
                Γ ⊢ HOM_CATEGORY(C, D) : Category ;
            CATEGORY
                [[ HOM_CATEGORY(C,D) ]] = "The functor category [C,D], whose objects are functors from C to D and whose morphisms are natural transformations between them. Vertical composition of 2-cells in Cat is the standard composition of natural transformations." ;
        "}" ";"

        "CompositionFunctors" ":" "{"
            CompositionAsFunctor ::= "∘" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ";"
            TYPING
                (* Composition in Cat is functor composition
                 * The action on objects is G ∘ F.
                 * The action on morphisms is horizontal composition β ∗ α.
                 * Functoriality of this operation IS the interchange law.
                *)
                Context: α:F→F', β:G→G'
                ActionOnObjects: (G, F) ↦ G∘F
                ActionOnMorphisms: (β, α) ↦ β∗α (horizontal composition of nat. trans.)
                ---------------------------------------------------------------------------
                Γ ⊢ ∘ : Functor( Cat(B,C)×Cat(A,B), Cat(A,C) ) ;
            CATEGORY
                [[ ∘ ]] = "Functor composition. The fact that this operation is a functor (i.e., that horizontal composition of natural transformations respects their vertical composition) is the interchange law, a cornerstone property of Cat." ;
        "}" ";"

        "IdentityFunctors" ":" "{"
            IdentityFunctorDeclaration ::= "IDENTITY_FUNCTOR" "Id_C" ":" "TerminalCategory" "→" "HOM_CATEGORY(C,C)" ";"
            TYPING
                (* The identity 1-morphism for an object C is the identity functor Id_C. *)
                ActionOnObject: * ↦ Id_C
                ---------------------------------------------------------------------------------
                Γ ⊢ Id_C : Functor(1, HOM_CATEGORY(C,C)) ;
            CATEGORY
                [[ IDENTITY_FUNCTOR Id_C ... ]] = "The identity functor on the category C, which acts as the identity 1-morphism for the object C within the 2-category Cat." ;
        "}" ";"
    "}" ";"

    _2CategoryAxioms ::= "AXIOMS" "{"
        AssociativityAxiom_2Cat ::= "AXIOM" "Associativity" "FOR_ALL_QUADS" "(A,B,C,D)" "," "..." ";"
        TYPING
            (* Functor composition H∘(G∘F) is definitionally equal to (H∘G)∘F. This is stricter than needed but holds. *)
            Holds(AssociativityAxiom, for: Cat) is TRUE.
            ----------------------------------------
            Γ ⊢ "Associativity holds for Cat" ;
        CATEGORY
            [[ Associativity Axiom for Cat ]] = "The assertion that functor composition is strictly associative, which is a fundamental property of functions and therefore of functors. This satisfies the pentagon axiom trivially." ;

        UnitalityAxiom_2Cat ::= "AXIOM" "Unitality" "FOR_ALL_PAIRS" "(A,B)" "," "..." ";"
        TYPING
            (* Composition with an identity functor is strictly unital: F∘Id_A = F and Id_B∘F = F. *)
            Holds(UnitalityAxiom, for: Cat) is TRUE.
            ----------------------------------
            Γ ⊢ "Unitality holds for Cat" ;
        CATEGORY
            [[ Unitality Axiom for Cat ]] = "The assertion that the identity functor acts as a strict unit for functor composition. This satisfies the triangle axiom trivially." ;
    "}" ";"
"}" ;

(*
 * CONCLUSION: This instantiation demonstrates the power of the deconstructed definition. By separating the DATA
 * from the AXIOMS, we can clearly declare the constituent parts of a complex structure like **Cat** and then
 * separately verify that this data satisfies the required laws. This makes the process of defining and
 * verifying higher-categorical structures rigorous and systematic.
*)


}

(* ========================================================================================================== *)
(* == Part 2b: The Coherence Axioms Formalized == )
(* ========================================================================================================== *)

AssociativityAxiom_2Cat ::= "AXIOM" "Associativity" ":" "FOR_ALL_QUADS" "(A,B,C,D)" "," Expression "==" Expression ;
TYPING
    (*
     * This formalizes the Pentagon Identity. For any four objects A,B,C,D, the following
     * diagram of functors must commute strictly. Let ∘_XYZ denote the composition functor
     * from HOM(Y,Z) × HOM(X,Y) to HOM(X,Z).
     * The axiom asserts: (∘_ACD ∘ (id × ∘_ABC)) == (∘_ABD ∘ (∘_BCD × id))
    *)
    Context: Γ ⊢ Data : _2CategoryData_Type
    f1 := ∘_ACD ∘ (Id_{C(C,D)} × ∘_ABC) : C(C,D)×C(B,C)×C(A,B) → C(A,D)
    f2 := ∘_ABD ∘ (∘_BCD × Id_{C(A,B)}) : C(C,D)×C(B,C)×C(A,B) → C(A,D)
    ---------------------------------------------------------------------
    Holds(AssociativityAxiom, for: Data) is TRUE if (f1 == f2) ;
CATEGORY
    [[ AXIOM Associativity ... ]] = "The formal assertion of the Pentagon Axiom for strict 2-categories. It states that the two ways of composing three 1-morphisms are not just equal, but that the functors defining these compositions are themselves equal. This guarantees that horizontal composition is strictly and unambiguously associative." ;

UnitalityAxiom_2Cat ::= "AXIOM" "Unitality" ":" "FOR_ALL_PAIRS" "(A,B)" "," Expression "==" Expression "&&" Expression "==" Expression ;
TYPING
    (*
     * This formalizes the Triangle Identity. For any f:A→B, we must have id_B ∘ f = f and f ∘ id_A = f.
     * As an equation of functors, this means composing with the Identity Functor is the Identity Natural Transformation.
    *)
    Context: Γ ⊢ Data : _2CategoryData_Type, Γ ⊢ C(A,B) : HomCategoryDeclaration
    LeftUnitality := (∘_AAB ∘ (Id_A × id_{C(A,B)})) == id_{C(A,B)}
    RightUnitality := (∘_ABB ∘ (id_{C(A,B)} × Id_B)) == id_{C(A,B)}
    ------------------------------------------------------------------------------------------
    Holds(UnitalityAxiom, for: Data) is TRUE if (LeftUnitality ∧ RightUnitality) ;
CATEGORY
    [[ AXIOM Unitality ... ]] = "The formal assertion of the Triangle Axiom for strict 2-categories. It states that the functors for left and right composition with an identity 1-morphism are equal to the identity functor on the relevant hom-category. This guarantees that identity 1-morphisms behave as strict units for horizontal composition." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.3: Modifications and n-categories" ")" "==>" {
(*

ELABORATION: This section introduces the next level of the categorical hierarchy: a "morphism between
morphisms between morphisms." A modification is a transformation between two 2-natural transformations.
This establishes the structure of a 3-category. The concept is then generalized to the idea of an
n-category, where one can have k-morphisms for any k < n.

To elaborate, we will:

Formalize the Modification: Define a modification μ between two 2-natural transformations
α and β. Its components μ_X will be 2-morphisms.

Formalize the 3Cat of 2-Categories: Assert that 2-categories, 2-functors, 2-natural
transformations, and modifications form a 3-category.

Define the n-Category Concept Recursively: Provide a meta-rule that defines an (n+1)-category
as a category enriched over the category of n-categories. This is the most elegant and formal
way to capture the general idea.

*)

(* ========================================================================================================== )
( == Part 1: Modifications == )
( ========================================================================================================== *)

ModificationDeclaration ::= "MODIFICATION" Identifier ":" Identifier "===>" Identifier ;
TYPING
(*

A modification μ is a transformation from one 2-natural transformation α: F==>G to another β: F==>G.

It consists of a family of 2-morphisms μ_X : α_X ⇒ β_X for each object X in the domain 2-category.

The coherence condition ensures compatibility with 1-morphisms.
*)
Γ ⊢ C,D : _2Category
Γ ⊢ α,β : _2NaturalTransformation(F, G)
μ is a family { μ_X : α_X ⇒ β_X is a 2-morphism in D(F(X),G(X)) | X ∈ Ob(C) }
CoherenceCondition: ∀(f:X→Y in C), (G(f) ∗ μ_X == μ_Y ∗ F(f)) (where ∗ is horizontal composition)

Γ ⊢ MODIFICATION μ : α ===> β : Modification ;
CATEGORY
[[ MODIFICATION μ : α ===> β ]] = "A 3-morphism in the 3-category of 2-categories. It is a transformation between 2-natural transformations, with components given by 2-cells, satisfying a coherence law that ensures it is a 'natural' family of 2-cells." ;

(* ========================================================================================================== )
( == Part 2: The Hierarchy of n-Categories == )
( ========================================================================================================== *)

CategoryLevelDeclaration ::= Identifier "is_a" "3-CATEGORY" ;
TYPING
(*

We can assert that the collection of 2-categories forms a 3-category.
*)
Let 2-Cat be a structure.
Objects(2-Cat) := { C | C is a _2Category }
1-Morphisms(2-Cat) := { F | F is a _2Functor }
2-Morphisms(2-Cat) := { α | α is a _2NaturalTransformation }
3-Morphisms(2-Cat) := { μ | μ is a Modification }

Γ ⊢ "2-Cat" is_a "3-CATEGORY" : Proposition;
CATEGORY
[[ "2-Cat" is_a "3-CATEGORY" ]] = "The assertion that the universe of (small) 2-categories, with 2-functors, 2-natural transformations, and modifications as its levels of morphisms, itself forms a 3-category." ;

nCategoryRecursiveDefinition ::= "DEFINE" "(" "n+1" ")" "-CATEGORY" "as" "CategoryEnrichedOver_n-Cat" ;
TYPING
(*

This is a meta-rule defining the concept of an n-category inductively.
*)
Let n-Cat be the category of all n-categories.
An (n+1)-Category is a category enriched over n-Cat.

Γ ⊢ nCategoryRecursiveDefinition : MetaAxiom ;
CATEGORY
[[ DEFINE (n+1)-CATEGORY as ... ]] = "The inductive definition of an n-category. It formalizes the idea that an (n+1)-category is a structure whose hom-sets are themselves n-categories, with composition being a functor. This captures the entire hierarchy in a single, powerful recursive statement." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.4: 2-limits and bilimits" ")" "==>" {
(*

ELABORATION: This section generalizes the concept of limits to the 2-categorical setting.
In a 1-category, a limit is a universal cone, where the universality guarantees a unique
mediating morphism. In a 2-category, "uniqueness" is often too strict a condition. The
concept is therefore weakened: the mediating morphism might only be unique up to a unique
invertible 2-cell. This gives rise to the bilimit (or 2-limit).

To elaborate properly, we will:

Formalize the "Cones": Deconstruct the different types of cones in a 2-category.

StrictCone: The triangles commute on the nose (= is equality).

PseudoCone or 2-Cone: The triangles commute up to a specified, invertible 2-cell (⇒ is a 2-isomorphism).

Formalize the "Universal Properties": Define the different notions of universality.

StrictTerminal: A unique mediating 1-morphism exists.

BiTerminal: A mediating 1-morphism exists and is unique up to a unique invertible 2-cell.

Combine Cones and Universality: Define the hierarchy of 2-limits by combining the above.

Strict 2-Limit: A universal StrictCone with a StrictTerminal property.

Pseudo-Limit: A universal StrictCone with a BiTerminal property.

Bilimit: A universal PseudoCone with a BiTerminal property. (This is the most general and useful notion).

*)

(* ========================================================================================================== )
( == Part 1: The Building Blocks - Cones and Universality == )
( ========================================================================================================== *)

StrictConeDeclaration ::= "STRICT_CONE" "over" Identifier "{" "Apex" ":" Identifier "," "Legs" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(* A Strict Cone is a standard 1-categorical cone inside a 2-category. The triangles commute on the nose. *)
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is a 1-Morphism
∀ (f:j→k in J), (D(f) ∘ p_j == p_k)

Γ ⊢ STRICT_CONE ... : StrictCone(D) ;
CATEGORY
[[ STRICT_CONE ... ]] = "A cone in a 2-category whose commuting triangles hold with strict equality. All 2-cells witnessing commutativity are identities." ;

PseudoConeDeclaration ::= "PSEUDO_CONE" "over" Identifier "{" "Apex" ":" Identifier "," "Legs" ":" ... "," "Cells" ":" "{" {IsomorphismDeclaration} "}" "}" ;
TYPING
(* A Pseudo-Cone (or 2-Cone) weakens the equality to a specified isomorphism. )
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is a 1-Morphism
∀ (f:j→k in J), ∃ (α_f : D(f) ∘ p_j ⇒ p_k is a 2-ISOMORPHISM)
( Plus coherence conditions for the α's *)

Γ ⊢ PSEUDO_CONE ... : PseudoCone(D) ;
CATEGORY
[[ PSEUDO_CONE ... ]] = "A cone where the triangles are witnessed to commute by specified, invertible 2-cells. This is the natural notion of a cone in a bicategory, respecting the 'up to isomorphism' nature of the structure." ;

BiTerminalObjectProperty ::= Identifier "is" "BI_TERMINAL" "in" "2-Category" Identifier ;
TYPING
(* This property formalizes the weak notion of universality. *)
Γ ⊢ L : Object_in(_2Cat), Γ ⊢ _2Cat : _2Category
Condition := ∀ (X ∈ Ob(_2Cat)), the hom-category _2Cat(X, L) is equivalent to the terminal category 1.

Γ ⊢ L is BI_TERMINAL ... : PropositionAbout(L) ;
CATEGORY
[[ L is BI_TERMINAL ... ]] = "The property of being terminal 'up to equivalence'. For any object X, there exists a morphism from X to L, and any two such morphisms are connected by a unique isomorphism. This is the correct 2-categorical analogue of a terminal object." ;

(* ========================================================================================================== )
( == Part 2: The Hierarchy of Limits == )
( ========================================================================================================== *)

Strict2LimitDeclaration ::= "STRICT_2_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* The strongest form: a strictly universal strict cone. *)
Γ ⊢ L : StrictCone(D)
Let ConeCat_1(D) be the 1-category of strict cones over D.
L is TERMINAL_OBJECT in ConeCat_1(D)

Γ ⊢ STRICT_2_LIMIT of D is L : Proposition ;
CATEGORY
[[ STRICT_2_LIMIT ... ]] = "A limit in the underlying 1-category of the 2-category. This is a limit where the mediating 1-morphism is strictly unique. These are rare but important." ;

PseudoLimitDeclaration ::= "PSEUDO_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* A weakly universal strict cone. *)
Γ ⊢ L : StrictCone(D)
Let ConeCat_2(D) be the 2-category of strict cones over D.
L is BI_TERMINAL in ConeCat_2(D)

Γ ⊢ PSEUDO_LIMIT of D is L : Proposition ;
CATEGORY
[[ PSEUDO_LIMIT ... ]] = "A limit over a strictly commuting diagram, but whose universal property is weak. The mediating 1-morphism is only unique up to a unique invertible 2-cell. This is a common and useful intermediate notion." ;

BilimitDeclaration ::= "BILIMIT" "of" Identifier "is" PseudoConeDeclaration ;
TYPING
(* The weakest and most general form: a weakly universal pseudo-cone. *)
Γ ⊢ L : PseudoCone(D)
Let PseudoConeCat_2(D) be the 2-category of pseudo-cones over D.
L is BI_TERMINAL in PseudoConeCat_2(D)

Γ ⊢ BILIMIT of D is L : Proposition ;
CATEGORY
[[ BILIMIT ... ]] = "The most general and natural notion of a limit in a 2-category or bicategory. Both the cone itself and its universal property are defined 'up to coherent isomorphism', respecting the weak nature of the ambient category. This is often simply called a '2-limit'." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on 'Elaborate on Section 7.5: Lax functors and pseudo-functors'" ")" "==>" {
(*

ELABORATION (Deeper Dive): The previous elaboration on Section 7.5 established the hierarchy
of Strict 2-Functors, Pseudo-Functors, and Lax Functors. A deeper elaboration requires
formalizing the coherence laws that the comparison cells of a lax functor must satisfy. These laws
are the functorial equivalent of the pentagon and triangle identities for bicategories and are
the very heart of the definition.

This deeper elaboration will:

Deconstruct the Lax Functor: We will separate the data of a lax functor (the mappings
and the comparison cells) from the axioms it must satisfy.

Formalize the Coherence Axioms: We will provide formal declarations for the two crucial
coherence axioms—associativity and unitality—that constrain the comparison cells. These axioms
are commutative diagrams of 2-cells and are essential for a lax functor to be a well-defined
structure.

Provide a Concrete Example: We will show that a lax monoidal functor between two monoidal
categories (viewed as one-object bicategories) is a perfect, tangible example of a lax functor.
This will make the abstract comparison cells (φ) and their coherence laws concrete.

This approach transforms the definition from a statement of properties into a fully-formalized,
constructive object with explicit axioms.

*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Data of a Lax Functor == )
(* ========================================================================================================== *)

LaxFunctorData ::= "DATA_LaxFunctor" Identifier ":" Identifier "→" Identifier "{"
"ActionOnObjects" ":" {ObjectMapping} ";"
"ActionOn1Morphisms" ":" {MorphismMapping} ";"
"CompositionCells" ":" "{" {ComparisonCellComposition} "}" ";"
"IdentityCells" ":" "{" {ComparisonCellIdentity} "}" ";"
"}" ;
TYPING
(* This rule declares the raw data of a lax functor F: C → D, before axioms are checked. *)
Γ ⊢ C, D : Bicategory
F_Objs: Ob(C) → Ob(D)
F_1Mors: 1Mor(C) → 1Mor(D)
φ_comp: family of 2-cells F(g)∘F(f) ⇒ F(g∘f)
φ_id: family of 2-cells id_{F(A)} ⇒ F(id_A)
-----------------------------------------------------
Γ ⊢ DATA_LaxFunctor ... : LaxFunctorData_Type ;
CATEGORY
[[ DATA_LaxFunctor ... ]] = "The structural data for a lax functor, comprising its action on objects and 1-morphisms, along with the two families of comparison 2-cells that measure its failure to be a strict homomorphism." ;

ComparisonCellComposition ::= "φ_" "{" Identifier "," Identifier "}" ;
ComparisonCellIdentity ::= "φ_" "{" Identifier "}" ;

(* ========================================================================================================== )
(* == Part 2: The Coherence Axioms == )
(* ========================================================================================================== *)

LaxAssociativityAxiom ::= "AXIOM" "LaxAssociativity" "for" LaxFunctorData ;
TYPING
(*
* This axiom asserts the commutativity of the hexagonal diagram relating the functor's
* composition cells (φ) with the associators (α) of the domain and codomain bicategories.
* It ensures the lax functor respects associativity in a coherent way.
*)
Context: Γ ⊢ F_data : LaxFunctorData_Type for F: C→D
∀ composable f,g,h in C:
LHS := F(α_{h,g,f}) ⋅ φ_{h,g∘f} ⋅ (id_{F(h)} ∗ φ_{g,f})
RHS := φ_{h∘g,f} ⋅ (φ_{h,g} ∗ id_{F(f)}) ⋅ α_{F(h),F(g),F(f)}
-------------------------------------------------------------------------------------------------------
Γ ⊢ AXIOM LaxAssociativity holds if (LHS == RHS) ;
CATEGORY
[[ AXIOM LaxAssociativity ... ]] = "The coherence law for a lax functor's interaction with associativity. It ensures that the two ways of evaluating F applied to a composition of three morphisms, while moving parentheses and applying the comparison cells, are the same." ;

LaxUnitalityAxiom ::= "AXIOM" "LaxUnitality" "for" LaxFunctorData ;
TYPING
(*
* This axiom asserts the commutativity of the diagram relating the identity cells (φ)
* with the unitors (λ, ρ) and the composition cells (φ). It ensures coherence for identities.
*)
Context: Γ ⊢ F_data : LaxFunctorData_Type
∀ f:A→B in C:
(φ_{id_B, f} ⋅ (φ_B ∗ id_{Ff})) ⋅ F(λ_f) == id_{Ff}
and a similar diagram for the right unitor ρ.
--------------------------------------------------------------------------------------------------------
Γ ⊢ AXIOM LaxUnitality holds if conditions are met ;
CATEGORY
[[ AXIOM LaxUnitality ... ]] = "The coherence law for a lax functor's interaction with identity 1-morphisms. It ensures that the comparison cell for composing with an identity is compatible with the functor's identity cells and the bicategory's unitors." ;

(* ========================================================================================================== )
(* == Part 3: The Refined Master Definitions == )
(* ========================================================================================================== *)

LaxFunctorDeclaration ::= "LAX_FUNCTOR" Identifier ":" Identifier "→" Identifier "verifies" "{"
LaxFunctorData ";"
"PROVEN" "{" LaxAssociativityAxiom ";" LaxUnitalityAxiom ";" "}" ";"
"}" ;
TYPING
Γ ⊢ data : LaxFunctorData_Type
Γ ⊢ AXIOM LaxAssociativity for data
Γ ⊢ AXIOM LaxUnitality for data
-------------------------------------------
Γ ⊢ LAX_FUNCTOR ... : LaxFunctor ;
CATEGORY
[[ LAX_FUNCTOR ... ]] = "The fully-specified definition of a lax functor, comprising its structural data and the proofs that this data satisfies the necessary coherence axioms." ;

PseudoFunctorDeclaration ::= "PSEUDOFUNCTOR" Identifier ":" Identifier "→" Identifier ;
TYPING
(* The definition of a PseudoFunctor remains hierarchical, but is now built on the more robust LaxFunctor definition. *)
Premise1: Γ ⊢ F is a well-defined LAX_FUNCTOR
Premise2: All comparison cells (φ_comp and φ_id) defined in F's data are 2-ISOMORPHISMS.
------------------------------------------------------------------------------------------
Γ ⊢ PSEUDOFUNCTOR F ... : PseudoFunctor ;
CATEGORY
[[ PSEUDOFUNCTOR ... ]] = "A homomorphism of bicategories. It is a lax functor whose comparison 2-cells are all invertible, meaning it preserves identity and composition up to coherent isomorphism. This is the natural notion of a map between weak 2-categories." ;

(* ========================================================================================================== )
(* == Part 4: Concrete Example - Lax Monoidal Functors == )
(* ========================================================================================================== *)

LaxMonoidalFunctorAsLaxFunctor ::= "INSTANCE" LaxFunctorDeclaration "from_lax_monoidal_functor" ;
TYPING
(*
* A monoidal category (C, ⊗, I) can be seen as a bicategory with one object, *.
* This instance shows how a standard Lax Monoidal Functor F gives rise to a LAX_FUNCTOR.
)
Let (C, ⊗_C, I_C) and (D, ⊗_D, I_D) be monoidal categories.
Let F: C→D be a lax monoidal functor with comparison morphisms:
μ_{A,B} : F(A) ⊗_D F(B) → F(A ⊗_C B)
ε : I_D → F(I_C)
-- This data defines a Lax Functor F_bicat: B_C → B_D
Data(F_bicat).CompositionCells := { φ_{A,B} corresponding to μ_{A,B} }
Data(F_bicat).IdentityCells := { φ_ corresponding to ε }
-- The coherence axioms for the lax monoidal functor become the axioms for the LAX_FUNCTOR.
----------------------------------------------------------------------------------------------
Γ ⊢ INSTANCE ... : LaxFunctor ;
CATEGORY
[[ INSTANCE ... ]] = "A concrete realization of a lax functor. The comparison 2-cells φ of the abstract definition are instantiated as the concrete comparison morphisms μ and ε of the lax monoidal functor. If μ and ε are not isomorphisms, this provides a canonical example of a functor that is lax but not pseudo." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.6: Lax limits and pseudo-limits" ")" "==>" {
(*

ELABORATION: This section directly parallels Section 7.4, but generalizes the concepts to account
for the weaker structures introduced in 7.5 (like lax functors). It defines the weakest, most general
notions of cones and limits in a 2-categorical setting. A "lax limit" is a universal "lax cone,"
where the commutativity constraints are weakened as much as possible.

To elaborate, we will:

Formalize the Lax Cone: Explicitly define a "lax cone," the most general type of cone,
where the commuting triangles are filled by arbitrary (i.e., not necessarily invertible) 2-cells.

Formalize the Lax Limit: Define a lax limit as a universal lax cone. The universal property is
correspondingly weak, making it a terminal object in the 2-category of all possible lax cones.

Contrast with Pseudo-Limits: Re-formalize the definition of a Pseudo-Limit to provide a direct
comparison with the new concept of a Lax Limit.

Clarify the Hierarchy: Situate lax and pseudo-limits within the full hierarchy of limit
concepts introduced so far via a key theorem. This clarifies the relationships between all these
related but distinct concepts.

*)

(* ========================================================================================================== )
( == Part 1: The Lax Cone and Lax Limit == )
(* ========================================================================================================== *)
(This is the most general/weakest notion of a cone and limit.)

LaxConeDeclaration ::= "LAX_CONE" "over" _2FunctorDeclaration "{" "Apex" ":" Identifier "," "Legs" ":" "{" {Identifier} "}" "," "ComparisonCells" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(*
* A lax cone over a diagram D:J→C is the most general type of cone. It consists of an Apex A,
* a family of 1-morphism legs p_j:A→D(j), and for each morphism f:j→k in J, a "comparison"
* 2-cell µ_f : p_k ⇒ D(f) ∘ p_j. Unlike in a pseudo-cone or bilimit, these µ_f cells are NOT
* required to be isomorphisms.
*)
Γ ⊢ D : _2Functor(J, C)
Γ ⊢ Apex : Object_in(C)
∀ j ∈ Ob(J), Γ ⊢ p_j : Apex → D(j) is 1-morphism
∀ f:j→k ∈ Mor(J), Γ ⊢ µ_f : p_k ⇒ D(f) ∘ p_j is 2-morphism
(Coherence axioms for the µ's must also hold)
----------------------------------------------------------
Γ ⊢ LAX_CONE ... : LaxCone(D) ;
CATEGORY
[[ LAX_CONE ... ]] = "The most general notion of a cone in a 2-categorical context. The triangles of the cone do not need to commute; they are simply 'coherently filled' by arbitrary, specified 2-cells. This is the appropriate notion of a cone for diagrams involving lax functors." ;

LaxLimitDeclaration ::= "LAX_LIMIT" "of" Identifier "is" LaxConeDeclaration ;
TYPING
(*
* A lax limit is a terminal object in the 2-category of lax cones. This is the weakest
* possible universal property, making it the most general form of limit.
*)
Let LaxConeCat(D) be the 2-category of all lax cones over D.
Γ ⊢ L : LaxCone_over(D)
----------------------------------------------------------------------
Γ ⊢ L is LAX_LIMIT of D is TRUE if L is TerminalObject in LaxConeCat(D) ;
CATEGORY
[[ LAX_LIMIT of D ... ]] = "The universal lax cone. It provides a universal solution for mapping into a diagram in the weakest possible sense. While less common than bilimits, this concept is important in contexts where structure is only preserved laxly." ;

(* ========================================================================================================== )
( == Part 2: Contrast with Pseudo-Limits == )
(* ========================================================================================================== *)
(This is a stronger notion, using strict cones but with a weak universal property.)

PseudoLimitDeclaration ::= "PSEUDO_LIMIT" "of" Identifier "is" StrictConeDeclaration ;
TYPING
(* A pseudo-limit is a STRICT cone that is universal in the WEAK sense (bi-terminal). *)
Γ ⊢ L : StrictCone(D)
Let Cone2Cat(D) be the 2-category of strict cones over D.
------------------------------------------------------
Γ ⊢ L is PSEUDO_LIMIT of D is TRUE if L is BI_TERMINAL in Cone2Cat(D) ;
CATEGORY
[[ PSEUDO_LIMIT of D ... ]] = "A limit over a strictly commuting diagram, but whose universal property is weak. The mediating 1-morphism is only unique up to a unique invertible 2-cell. This is a common and useful intermediate notion, stronger than a lax limit." ;

(* ========================================================================================================== )
(* == Part 3: Clarifying the Hierarchy of Limits == )
(* ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LimitHierarchy" ":" "'Strict 2-Limit' ⇒ 'Pseudo-Limit' ⇒ 'Bilimit' ⇒ 'Lax Limit'" ;
TYPING
(*
* This theorem states that each limit concept is a special case of the one to its right.
* The implication ⇒ means "is a special case of".
*
* Proof sketch: A strict cone is a pseudo-cone (with identity isos), which is a lax cone. A strict universal property
* implies a bi-universal property. Therefore, any object satisfying a stricter
* definition also satisfies the weaker ones.
*)
(L is Strict_2_Limit) ⇒ (L is Pseudo_Limit)
(L is Pseudo_Limit) ⇒ (L is Bilimit)
(L is Bilimit) ⇒ (L is Lax_Limit)
-------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LimitHierarchy ]] = "The assertion of a clear hierarchy of limit concepts within a 2-category. The strength of a limit depends on two factors: the strictness of the cone (are the filler cells identities, isomorphisms, or arbitrary?) and the strictness of the universal property (is the mediating map strictly unique, or unique up to a unique isomorphism?). This theorem clarifies that 'Strict 2-Limit' is the strongest notion and 'Lax Limit' is the most general." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.7: Bicategories Part 1: The Definition of a Bicategory" ")" "==>" {
(*

ELABORATION (Deeper Dive): This elaboration focuses exclusively on Part 1 of the bicategory definition,
deconstructing it into its most fundamental typed components. A bicategory is not just a collection
of things; it is a highly structured record of data. We will formalize this by defining a bicategory's
DATA as a structured tuple containing:

0-cells: The objects of the bicategory.

Hom-Categories: For each pair of objects, a category of 1-cells (as objects) and 2-cells (as morphisms).

Composition Functors: The composition of 1-cells, formalized as a family of functors.

Identity Functors: The identity 1-cells, formalized as functors from the terminal category.

Constraint Natural Isomorphisms: The crucial associator and unitor 2-cells that govern the
weakness of the structure, formalized as natural isomorphisms between composition functors.

This deep dive exposes the definition as a single, large, typed data structure, setting the stage for
the coherence axioms (Pentagon, Triangle) which act upon this data.

*)

(* ========================================================================================================== )
( == The Master Definition as a Structured Record == )
(* ========================================================================================================== *)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.7: Bicategories Part 1: The Definition of a Bicategory The Master Definition as a Structured Record by instantiating it with the canonical example, 'Dist'." ")" "==>" {
(*

ELABORATION (Instantiation): The previous turn defined the formal data structure for a bicategory.
This elaboration provides a meticulous instantiation of that structure with the most important
and canonical example of a non-strict bicategory: Dist, the bicategory of small categories,
distributors (profunctors), and natural transformations.

By filling in each field of the BicategoryDeclaration for Dist, we make the abstract
definitions concrete and demonstrate why the "weakness" (the non-trivial constraint isomorphisms)
is necessary and natural.

*)

BicategoryDeclaration ::= "BICATEGORY" "Dist" "is_defined_by" "{"
"DATA" "{"
"Objects" ":" "{" "A" "," "B" "," "C" "}" ";"
TYPING
(* The 0-cells of Dist are simply all small categories. *)
IsSmallCategory(A)
-----------------------
Γ ⊢ A : Object_in(Dist) ;
CATEGORY
[[ A : Object_in(Dist) ]] = "A small category, viewed as an object." ;

Generated code
"HomCategories" ":" "{"
        HomCategoryDeclaration ::= "HOM_CATEGORY" "(" "A" "," "B" ")" ";"
        TYPING
            (* The hom-category Dist(A,B) is the category of functors from B^op x A to Set. *)
            Objects(Dist(A,B)) := { D | Γ ⊢ D : Functor(B^op × A, Set) } (* These are Distributors *)
            Morphisms(Dist(A,B)) := { α | Γ ⊢ α : NaturalTransformation }
            ----------------------------------------------------------------------------------
            Γ ⊢ HOM_CATEGORY(A, B) : Category ;
        CATEGORY
            [[ HOM_CATEGORY(A, B) ]] = "The functor category `[B^op × A, Set]`. Its objects are distributors (profunctors) from A to B, and its morphisms are natural transformations between them. Vertical composition of 2-cells is the standard composition of natural transformations." ;
    "}" ";"

    "CompositionFunctors" ":" "{"
        BicategoryCompositionFunctor ::= "∘_ABC" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ";"
        TYPING
            (* Composition is the coend formula. It's a functor from the product of hom-categories. *)
            Action_on_Objects(D2, D1) := D2 ∘ D1 := ∫^{b∈B} D2(-,b) × D1(b,-)
            Action_on_Morphisms(β, α) := ... (the induced natural transformation on coends)
            --------------------------------------------------------------------------------
            Γ ⊢ ∘_ABC : Functor(Dist(B,C) × Dist(A,B), Dist(A,C)) ;
        CATEGORY
            [[ ∘_ABC ]] = "The composition of distributors via the coend formula. This operation is functorial." ;
    "}" ";"

    "IdentityFunctors" ":" "{"
        BicategoryIdentityFunctor ::= "Id_A" ":" "1 → HOM_CATEGORY(A,A)" ";"
        TYPING
            (* The identity distributor on A is its hom-functor, Hom_A(-,-). *)
            Action_on_Object(*) := Hom_A(-,-) : A^op × A → Set
            -------------------------------------------------
            Γ ⊢ Id_A : Functor(TerminalCategory, Dist(A,A)) ;
        CATEGORY
            [[ Id_A ]] = "The identity functor that picks out the hom-functor `Hom_A` as the identity distributor on object A. It serves as the identity 1-morphism in `Dist`." ;
    "}" ";"
"}" ";"

"CONSTRAINTS" "{"
    Constraint_Associator ::= "associator" "α" ":" "(∘)∘" "≅" "∘(∘)" ";"
    TYPING
        (* For distributors, composition is NOT strictly associative. *)
        (* (D3 ∘ D2) ∘ D1 is NOT equal to D3 ∘ (D2 ∘ D1). *)
        (* However, there is a canonical, natural ISOMORPHISM between them from properties of coends. *)
        LHS_Functor := ∘_ADC ∘ (Id × ∘_ABC)
        RHS_Functor := ∘_DBC ∘ (∘_ABC × Id)
        ------------------------------------------------------------------------------
        Γ ⊢ α : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ associator α ... ]] = "The non-trivial associator for distributor composition. The isomorphism arises from the fact that iterated coends can be reordered, i.e., ∫^{c} (∫^{b} D3(d,c)×D2(c,b)) × D1(b,a) ≅ ∫^{b} D3(d,c) × (∫^{c} D2(c,b)×D1(b,a)). This makes `Dist` a canonical example of a bicategory that is not a strict 2-category." ;

    Constraint_LeftUnitor ::= "left_unitor" "λ" ":" "Id∘" "≅" "Id" ";"
    TYPING
        (* The Hom_B functor is only a left unit up to isomorphism. Hom_B ∘ D is not equal to D. *)
        (* The Yoneda Lemma provides the canonical isomorphism: ∫^{b∈B} Hom_B(c,b) × D(b,a) ≅ D(c,a) *)
        LHS_Functor := ∘_ACB ∘ (Id_B × Id)
        RHS_Functor := Id_{Dist(A,B)}
        ------------------------------------------------
        Γ ⊢ λ : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ left_unitor λ ]] = "The non-trivial left unitor for distributor composition. Its existence and naturality are a direct consequence of the Yoneda Lemma, which provides the canonical isomorphism making the hom-functor a weak unit. This demonstrates how fundamental category theory results manifest as structural components in higher categories." ;

    Constraint_RightUnitor ::= "right_unitor" "ρ" ":" "∘Id" "≅" "Id" ";"
    TYPING
        (* Symmetrically, the right unit law holds only up to a canonical isomorphism given by the co-Yoneda Lemma. *)
        LHS_Functor := ∘_ABC ∘ (Id × Id_A)
        RHS_Functor := Id_{Dist(A,B)}
        -------------------------------------------------
        Γ ⊢ ρ : NaturalIsomorphism(LHS_Functor, RHS_Functor) ;
    CATEGORY
        [[ right_unitor ρ ]] = "The non-trivial right unitor for distributor composition, arising from the co-Yoneda Lemma. The necessity of these non-trivial associator and unitor isomorphisms is what makes `Dist` the quintessential example of a bicategory." ;
"}" ";"


"}" ;

}

(* ========================================================================================================== )
( == Part 1A: Deconstructing the DATA block == )
(* ========================================================================================================== *)

HomCategoryDeclaration ::= "HOM_CATEGORY" "(" Identifier "," Identifier ")" ;
TYPING
Context: C is a Bicategory
Γ ⊢ A, B : Object_in(C)
Objects(HOM_CATEGORY(A,B)) := {f | f is 1-morphism from A to B in C}
Morphisms(HOM_CATEGORY(A,B)) := {α | α is 2-morphism between 1-morphisms from A to B in C}
------------------------------------------------------------------------------------------------
Γ ⊢ HOM_CATEGORY(A, B) : Category ;
CATEGORY
[[ HOM_CATEGORY(A, B) ]] = "The hom-category C(A,B). Its objects are the 1-cells, its morphisms are the 2-cells, and its composition is vertical composition of 2-cells." ;

BicategoryCompositionFunctor ::= "∘_ABC" ":" "HOM_CATEGORY(B,C) × HOM_CATEGORY(A,B) → HOM_CATEGORY(A,C)" ;
TYPING
(* Horizontal composition is not just an operation, it's a functor. *)
Γ ⊢ C_BC : HOM_CATEGORY(B,C), Γ ⊢ C_AB : HOM_CATEGORY(A,B), Γ ⊢ C_AC : HOM_CATEGORY(A,C)
-----------------------------------------------------------------------------------------
Γ ⊢ ∘_ABC : Functor( C_BC × C_AB, C_AC ) ;
CATEGORY
[[ ∘_ABC ]] = "The horizontal composition functor for the triple (A,B,C). Its functoriality weakly encodes the interchange law." ;

BicategoryIdentityFunctor ::= "Id_A" ":" "1 → HOM_CATEGORY(A,A)" ;
TYPING
(* The identity 1-cell is picked out by a functor. *)
Γ ⊢ C_AA : HOM_CATEGORY(A,A)
-------------------------------------------
Γ ⊢ Id_A : Functor( TerminalCategory, C_AA ) ;
CATEGORY
[[ Id_A ]] = "The identity functor for the object A, which selects the identity 1-morphism id_A from the hom-category C(A,A)." ;

(* ========================================================================================================== )
( == Part 1B: Deconstructing the CONSTRAINTS block == )
(* ========================================================================================================== *)

Constraint_Associator ::= "associator" "α" ":" "(∘)∘" "≅" "∘(∘)" ;
TYPING
(*
* This defines the associator α as a natural isomorphism. For any triple of composable functors
* F: A->B, G: B->C, H: C->D, its component is α_{H,G,F} : (H∘G)∘F ⇒ H∘(G∘F).
* It is a natural isomorphism between two functors from C(C,D)×C(B,C)×C(A,B) to C(A,D)
*)
CompFunctor1 := ∘_ACD ∘ (∘_ABC × Id)
CompFunctor2 := ∘_ABD ∘ (Id × ∘_BCD)
---------------------------------------------------------------------------------------
Γ ⊢ α : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ associator α ... ]] = "The associator isomorphism. It is a natural transformation whose components α_{h,g,f} are invertible 2-cells witnessing that composition is associative up to a coherent isomorphism." ;

Constraint_LeftUnitor ::= "left_unitor" "λ" ":" "Id∘" "≅" "Id" ;
TYPING
(* The left unitor λ is a natural isomorphism whose component λ_f witnesses that Id_B ∘ f is isomorphic to f. )
CompFunctor1 := ∘_ABB ∘ (Id_B × Id) ( Functor for composing with Id_B on the left )
CompFunctor2 := Id_{C(A,B)} ( The identity functor on the hom-category *)
------------------------------------------------------------------------------
Γ ⊢ λ : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ left_unitor λ ... ]] = "The left unitor isomorphism. It is a natural transformation whose components λ_f are invertible 2-cells witnessing that the identity 1-morphism acts as a left unit up to a coherent isomorphism." ;

Constraint_RightUnitor ::= "right_unitor" "ρ" ":" "∘Id" "≅" "Id" ;
TYPING
(* The right unitor ρ is a natural isomorphism whose component ρ_f witnesses that f ∘ Id_A is isomorphic to f. )
CompFunctor1 := ∘_AAB ∘ (Id × Id_A) ( Functor for composing with Id_A on the right )
CompFunctor2 := Id_{C(A,B)} ( The identity functor on the hom-category *)
-------------------------------------------------------------------------------
Γ ⊢ ρ : NaturalIsomorphism( CompFunctor1, CompFunctor2 ) ;
CATEGORY
[[ right_unitor ρ ... ]] = "The right unitor isomorphism. It is a natural transformation whose components ρ_f are invertible 2-cells witnessing that the identity 1-morphism acts as a right unit up to a coherent isomorphism." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.8: Distributors" ")" "==>" {
(*

ELABORATION: A distributor (also called a profunctor or bimodule) is a generalization of a relation
and of a functor. It provides a powerful way to relate two different categories. The collection of
all small categories forms a bicategory where the 1-morphisms are these distributors.

To elaborate, we will:

Formalize the Distributor: Define a distributor D: A ⇸ B as a functor B^op × A → Set.

Formalize Composition: Define the composition of distributors via the tensor product-like
coend formula.

Formalize the Bicategory of Distributors: Assert that small categories, distributors, and
natural transformations form a bicategory, Dist.

*)

(* ========================================================================================================== )
( == Part 1: The Distributor and its Composition == )
( ========================================================================================================== *)

DistributorDeclaration ::= "DISTRIBUTOR" Identifier ":" Identifier "⇸" Identifier ;
TYPING
(* A distributor D from A to B is a functor of type B^op × A → Set. *)
Γ ⊢ A, B : Category

Γ ⊢ DISTRIBUTOR D : A ⇸ B : Functor(B^op × A, Set) ;
CATEGORY
[[ DISTRIBUTOR D : A ⇸ B ]] = "A profunctor, or bimodule, from A to B. It can be seen as a 'category-indexed matrix of sets', providing a generalized way to relate objects from A to objects from B." ;

DistributorComposition ::= DistributorDeclaration "∘" DistributorDeclaration ;
TYPING
(*

The composition of D1:A⇸B and D2:B⇸C is a distributor D3:A⇸C defined by a coend integral.

This is a complex construction, which we represent abstractly.
*)
Γ ⊢ D1 : DISTRIBUTOR(A ⇸ B), Γ ⊢ D2 : DISTRIBUTOR(B ⇸ C)
D3(a, c) := ∫^{b ∈ B} D2(c, b) × D1(b, a) ( The coend formula *)

Γ ⊢ D2 ∘ D1 : DISTRIBUTOR(A ⇸ C) ;
CATEGORY
[[ D2 ∘ D1 ]] = "The composition of distributors, defined by the coend. This operation generalizes matrix multiplication and is the 1-morphism composition in the bicategory of distributors." ;

(* ========================================================================================================== )
( == Part 2: The Bicategory Dist == )
( ========================================================================================================== *)

BicategoryOfDistributors ::= "Dist" ;
TYPING
(* We can now formally describe the bicategory Dist. *)
Objects(Dist) := { C | C is a small Category }
1-Morphisms(Dist) from A to B := { D | D is a DISTRIBUTOR A ⇸ B }
2-Morphisms(Dist) from D1 to D2 := { α | α is a NaturalTransformation D1 ⇒ D2 }

Γ ⊢ Dist is a BICATEGORY ;
CATEGORY
[[ Dist ]] = "The bicategory of small categories, distributors, and natural transformations. The composition of distributors is only associative up to isomorphism, making this a canonical example of a non-strict 2-category (a true bicategory)." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.9: Cauchy completeness versus distributors" ")" "==>" {
(*

ELABORATION: This final section provides a powerful, modern characterization of Cauchy
completeness (from Chapter 6) in the language of distributors. It states that a category
is Cauchy complete if and only if its identity distributor is "idempotent" in the bicategory
Dist and this idempotent "splits". This gives a purely algebraic, representation-theoretic test
for what was previously defined via idempotent endomorphisms.

To elaborate, we will:

Formalize the Players: Define the IdentityDistributor (which is Hom_C(-,-)) and the OppositeDistributor (the transpose). These are the key objects in the main theorem.

Formalize the Theorem: State the theorem that a category C is Cauchy complete if and only if its identity distributor IdDist(C) can be factored as D^op ∘ D for some distributor D from the terminal category 1 to C.

Interpret the Theorem: Explain this factorization as a form of "matrix decomposition," where the distributor D acts like a "column vector" of objects, and D^op acts like a "row vector". This reveals that Cauchy completeness is equivalent to the identity being representable by a 'basis' of objects, making the connection to representation theory explicit.

*)

(* ========================================================================================================== )
( == Part 1: The Players == )
(* ========================================================================================================== *)
(The theorem relies on two specific distributor constructions.)

IdentityDistributor ::= "IdDist" "(" Identifier ")" ;
TYPING
(* The identity distributor on a category C is its Hom-functor. *)
Γ ⊢ C : Category
Hom_C : C^op × C → Set
---------------------------------------------------------------
Γ ⊢ IdDist(C) : DISTRIBUTOR(C ⇸ C) (where IdDist(C) == Hom_C) ;
CATEGORY
[[ IdDist(C) ]] = "The identity distributor on C, which is simply the hom-functor of C. It serves as the identity 1-morphism for the object C in the bicategory Dist." ;

OppositeDistributor ::= Identifier "^op" ;
TYPING
(* The opposite of a distributor D:A⇸B is a distributor D^op:B⇸A. *)
Γ ⊢ D : DISTRIBUTOR(A ⇸ B)
D^op(a, b) := D(b, a)
----------------------------------------
Γ ⊢ D^op : DISTRIBUTOR(B ⇸ A) ;
CATEGORY
[[ D^op ]] = "The opposite or transpose of a distributor D. If D is seen as a matrix, D^op is its transpose. This operation turns a distributor A⇸B into one from B⇸A." ;

(* ========================================================================================================== )
( == Part 2: The Characterization Theorem == )
(* ========================================================================================================== *)

IdempotentCompletenessAsDistributorFactorization ::= "THEOREM" "CauchyCompletenessViaDistributors" ":"
"(" Identifier "C is CAUCHY_COMPLETE" ")" "<==>"
"(∃ D:1⇸C s.t. IdDist(C) ≅ D^op ∘ D)" ;
TYPING
(*
* This is the formal typing of the main theorem.
* The existence of the factorization is equivalent to the idempotent-splitting property.
*)
P1 := (Γ ⊢ C is CAUCHY_COMPLETE)
P2 := ∃ (D : DISTRIBUTOR(1 ⇸ C)) s.t. (IdDist(C) ≅ (D^op ∘ D))
---------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CauchyCompletenessViaDistributors ]] = "A deep characterization theorem connecting two major concepts. It asserts that a category's internal structural property of being idempotent-complete (Cauchy complete) is equivalent to the external, representational property that its identity distributor can be 'factored' through the terminal category. The distributor D:1⇸C can be seen as picking out a single 'object of objects' (a presheaf), and the factorization D^op ∘ D reconstructs the original category's Hom sets from this single object. This reveals Cauchy completeness as a form of representability." ;
}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 8: 'Internal category theory', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.1: Internal categories and functors" ")" "==>" {
(*

ELABORATION: To provide a deeper, more concrete elaboration of an internal category, we will
instantiate the abstract definition with the most fundamental and clarifying example: a monoid
viewed as a category with one object, internal to the category Set.

This process will show how the abstract components of the InternalCategoryDataDeclaration
(object of objects, object of morphisms, structure morphisms in E) map directly to concrete,
familiar concepts (a singleton set, the monoid's elements, the identity and multiplication functions).
Crucially, it will demonstrate how the abstract InternalCategoryAxioms (requiring commuting
diagrams in the ambient category E) become precisely the familiar equational axioms that define a monoid.

This example makes the power of internalization tangible: it's a machine for exporting concepts
from the well-understood category of sets into more exotic ambient categories like Manifolds or Toposes.

*)

(* ========================================================================================================== )
( == Example: Monoid as an Internal Category in Set == )
( ========================================================================================================== *)

InternalCategory_Example_Monoid_in_Set ::= "INTERNAL_CATEGORY" "MonoidAsCat" "in" "Set" "verified_by" "{"
InternalCategoryDataDeclaration ::= "INTERNAL_CAT_DATA" "MonoidData" "in" "Set" "consists_of" "{"
TYPING (* The ambient category E is Set. E must have pullbacks, which Set does (they are fibered products). *)
AmbientCategory := Category("Set")
------------------------------------------
Context(MonoidData) is Set ;
CATEGORY
[[ MonoidAsCat in Set ]] = "A formalization of the proposition 'a monoid is a category with a single object', internalized within the category of Sets." ;

Generated code
"ObjectOfObjects" ":" "C₀ singleton_set" ";"
    TYPING (* The 'object of objects' is a singleton set, representing the single object of the monoid-category. *)
        C₀ := { "*" }
        -----------------------------
        Γ ⊢ C₀ : Object_in(Set) ;
    CATEGORY
        [[ C₀ singleton_set ]] = "The single abstract object of the category." ;


    "ObjectOfMorphisms" ":" "C₁ monoid_carrier_set" ";"
    TYPING (* The 'object of morphisms' is the underlying set M of the monoid. Each element is an endomorphism on the single object. *)
        Let M be a monoid. C₁ := |M| (the carrier set)
        -----------------------------
        Γ ⊢ C₁ : Object_in(Set) ;
    CATEGORY
        [[ C₁ monoid_carrier_set ]] = "The set of all morphisms of the category. Since there is only one object, all morphisms are endomorphisms." ;


    "StructureMorphisms" ":" "{"
        "domain" ":" "d₀ unique_map_to_singleton" ","
        "codomain" ":" "d₁ unique_map_to_singleton" ","
        TYPING (* Since there is only one object `*`, the domain and codomain of any morphism `g ∈ M` must be `*`. So, d₀ and d₁ are the same unique function `!: M → {*}`. *)
            d₀ := λ(g∈M). *,  d₁ := λ(g∈M). *
            -------------------------------------------------
            Γ ⊢ d₀, d₁ : Morphism(C₁, C₀) in Set ;
        CATEGORY
            [[ unique_map_to_singleton ]] = "The function that maps every element of the monoid's carrier set to the single object, correctly identifying all of them as endomorphisms." ;


        "identity" ":" "i identity_element_picker" ","
        TYPING (* The identity morphism is a function from the single object `*` to the set of morphisms M, picking out the monoid's identity element `e`. *)
            i := λ(*). e_monoid
            -----------------------------------
            Γ ⊢ i : Morphism(C₀, C₁) in Set ;
        CATEGORY
            [[ identity_element_picker ]] = "The function that selects the identity element of the monoid to act as the identity morphism for the single object." ;


        "composition" ":" "m monoid_multiplication"
        TYPING (*
                * Composition takes a composable pair and returns their composite. The object of composable pairs
                * is the pullback C₁ ×_d₀ C₁, which in Set is { (g,h) ∈ M×M | d₀(g)=d₁(h) }.
                * Since d₀ and d₁ are constant maps to `*`, this condition is always true.
                * Thus, the pullback object is simply the Cartesian product M × M.
                * The composition morphism `m` is therefore the monoid's binary operation `μ: M×M → M`.
               *)
            ComposablePairs := C₁ ×_C₀ C₁ ≅ M × M
            m := μ_monoid : M × M → M
            -------------------------------------------------
            Γ ⊢ m : Morphism(ComposablePairs, C₁) in Set ;
        CATEGORY
            [[ monoid_multiplication ]] = "The binary operation of the monoid, reinterpreted as the composition of morphisms in the internal category." ;
    "}" ";"
"}" ";"


"AXIOMS" "(" "InternalAssociativity" "," "InternalLeftUnit" "," "InternalRightUnit" ")"
TYPING (*
        * Now we verify that the commuting diagrams for the internal category axioms become the
        * standard equational axioms for a monoid.
       *)
    CheckAssociativity:
        (* The diagram `m ∘ (m × id) == m ∘ (id × m)` must commute. *)
        (* In Set, this becomes the equation: μ(μ(g,h),k) == μ(g,μ(h,k)) for all g,h,k in M. This is the monoid associativity axiom. *)
        Assert(MonoidAssociativity Axiom Holds);
    CheckLeftUnit:
        (* The diagram `m ∘ <id, i ∘ d₁> == id` must commute. *)
        (* In Set, this becomes: μ(g, i(d₁(g))) == g => μ(g, i(*)) == g => μ(g, e) == g. This is the monoid right unit axiom. *)
        Assert(MonoidRightUnit Axiom Holds);
    CheckRightUnit:
        (* The diagram `m ∘ <i ∘ d₀, id> == id` must commute. *)
        (* In Set, this becomes: μ(i(d₀(g)), g) == g => μ(i(*), g) == g => μ(e, g) == g. This is the monoid left unit axiom. *)
        Assert(MonoidLeftUnit Axiom Holds);
------------------------------------------------------------------------------------------------------------------------------------
Conclusion: Γ ⊢ AXIOMS hold for MonoidData ;


"}" ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.2: Internal base-valued functors" ")" "==>" {
(*

ELABORATION: A "base-valued functor" is a functor whose codomain is the base category E where
the internal category lives. The most fundamental examples are the internal Hom-functors and the
internal Yoneda embedding, which are the internal analogues of the familiar concepts from standard
category theory.

To elaborate, we will:

Formalize the Internal Presheaf: Define INTERNAL_PRESHEAF as the general term for a base-valued
functor with codomain E, i.e., a functor C^op → E.

Formalize the Internal Hom-Functor: Define the specific constructor IntHom_C(-, I)
which is the internal analogue of the representable Hom-functor Hom(-,object). This requires
the ambient category E to have pullbacks.

Formalize the Internal Yoneda Embedding: Define the InternalYonedaEmbedding (y_C) as the functor
that maps an internal object I to its representable internal presheaf, IntHom_C(-, I).

Formalize the Internal Yoneda Lemma: State the internal version of the Yoneda Lemma as a
fundamental theorem. It asserts a natural isomorphism between the object of natural transformations
from a representable y(I) to any other presheaf F, and the evaluation of F at I. This
demonstrates that the core principles of representation theory hold in the internal setting.

*)

(* ========================================================================================================== )
( == Part 1: Internal Presheaves and the Internal Hom-Functor == )
(* ========================================================================================================== *)

InternalPresheaf ::= "INTERNAL_PRESHEAF" Identifier "on" Identifier ;
TYPING
(* An internal presheaf on C is a functor from the opposite of the internal category C to the base category E. *)
Γ ⊢ C : InternalCategory_in(E)

Γ ⊢ INTERNAL_PRESHEAF F on C : Functor(C^op, E) ;
CATEGORY
[[ INTERNAL_PRESHEAF F on C ]] = "A functor that represents a 'variable object' in the base category E, indexed by the internal category C. This is the direct analogue of a presheaf in standard category theory." ;

InternalHomFunctor ::= "IntHom_" Identifier "(" "," Identifier ")" ;
TYPING
(*

For an internal category C in E (where E has pullbacks), the internal Hom-functor IntHom_C(-, I)

is a canonical internal presheaf. For a fixed internal object I (an 'element' of C₀),

this functor maps another internal object X to an object in the base category E that

represents the 'collection of morphisms' from X to I inside C.

The formal construction of this object requires pullbacks in E.
*)
Context: Γ ⊢ E : Category_with_Pullbacks
Γ ⊢ C : InternalCategory_in(E) with components (C₀, C₁, d₀, d₁)
Γ ⊢ I : Object_in(C₀)
FunctorActionOnObjects(X ∈ Ob(C₀)) := The pullback of (d₀: C₁→C₀) and (d₁: C₁→C₀) over (X,I).

Γ ⊢ IntHom_C(-, I) : InternalPresheaf on C ;
CATEGORY
[[ IntHom_C(-, I) ]] = "The internal Hom-functor, or representable internal presheaf. For a fixed internal object I, this functor acts as a 'probe', assigning to each object X the 'object of morphisms' from X to I. This is a primary example of a base-valued functor." ;

(* ========================================================================================================== )
( == Part 2: The Internal Yoneda Embedding and Lemma == )
(* ========================================================================================================== *)

InternalYonedaEmbedding ::= "y_" Identifier ;
TYPING
(* The internal Yoneda embedding y_C maps an object of C to its representable internal presheaf. )
Γ ⊢ C : InternalCategory_in(E)
ActionOnObjects(I ∈ Ob(C₀)) := IntHom_C(-, I)
ActionOnMorphisms... ( can be defined from universal properties *)

Γ ⊢ y_C : Functor( C, CategoryOf(InternalPresheaf on C) ) ;
CATEGORY
[[ y_C ]] = "The internal Yoneda embedding. It embeds the internal category C fully and faithfully into the category of internal presheaves on C, demonstrating that an internal category can be studied through its internal representations, just like a standard category." ;

InternalYonedaLemma ::= "THEOREM" "InternalYonedaLemma" ":"
"ObjectOfNatTrans(" "y_" Identifier "(" Identifier ")" "," Identifier ")" "≅" Identifier "(" Identifier ")" ;
TYPING
(*

The lemma states that for an internal category C, an internal presheaf F:C^op→E, and an

object I of C, the object of natural transformations (in E) from the representable presheaf

y_C(I) to F is naturally isomorphic (in E) to the evaluation F(I).
*)
Γ ⊢ C : InternalCategory_in(E)
Γ ⊢ F : InternalPresheaf on C
Γ ⊢ I : Object_in(C₀)
LHS := ObjectOfNaturalTransformations(y_C(I), F) in E
RHS := F(I) : Object_in(E)

Γ ⊢ LHS ≅ RHS : Isomorphism in E ;
CATEGORY
[[ THEOREM InternalYonedaLemma ]] = "The internal version of the Yoneda Lemma. This fundamental result asserts that an object I of an internal category is completely determined by its associated internal presheaf of morphisms into it. It shows that the deep relationship between objects and their representations via Hom is not limited to Set-based category theory but is a core principle that holds in any suitable internal setting." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.3: Internal limits and colimits" ")" "==>" {
(*

ELABORATION: This section defines limits and colimits of a diagram in an internal category.
The diagram's shape is a normal (external) category J, but its values lie within the internal
category C. The limit object and its cone must therefore also be objects and morphisms internal to C,
and the universal property must be expressed as a commuting diagram in the ambient category E.

To elaborate, we will:

Formalize the Internal Diagram: Define a diagram D of shape J in an internal category C as
a pair of maps that satisfy the functor axioms internally.

Formalize the Internal Cone: Define a cone for such a diagram, consisting of an internal apex
object and a family of internal cone leg morphisms.

Formalize the Internal Limit: Define the internal limit by its universal property. This involves
formalizing the unique mediating morphism u that makes the cone universal, and expressing this
uniqueness as a property within the ambient category E.

Derive the Dual Theory: Use the Duality Principle to mechanically derive the entire theory for
internal colimits.

*)

(* ========================================================================================================== )
( == Part 1: The Internal Diagram and Cone == )
(* ========================================================================================================== *)

InternalDiagramDeclaration ::= "INTERNAL_DIAGRAM" Identifier ":" Identifier "→" Identifier ;
TYPING
(* An internal diagram D of shape J (an external, small category) in an internal category C in E. *)
Γ ⊢ J : SmallCategory (External)
Γ ⊢ C : InternalCategory_in(E)
D_obj : Ob(J) → Ob(C₀) in Set (Map from J's objects to E's 'elements' of C₀)
D_mor : Mor(J) → Ob(C₁) in Set (Map from J's morphisms to E's 'elements' of C₁)
(These maps must satisfy the functor laws, expressed as commuting diagrams in E.)

Γ ⊢ INTERNAL_DIAGRAM D : J → C : InternalDiagram_in(C) ;
CATEGORY
[[ INTERNAL_DIAGRAM D ... ]] = "A diagram of shape J drawn inside the internal category C. It uses an external category J to select a pattern of objects and morphisms within C." ;

InternalConeDeclaration ::= "INTERNAL_CONE" Identifier "over" Identifier "has" "{" "Apex" ":" Identifier "," "Legs" ":" "{" Identifier "}" "}" ;
TYPING
(* A cone over an internal diagram D. )
Γ ⊢ D : InternalDiagram_in(C)
Γ ⊢ A : Object_in(C₀) (* The apex is an internal object. *)
Legs := { p_j : Morphism(A, D_obj(j)) in C₁ | j ∈ Ob(J) }
(The cone commutativity diagram must hold internally.)

Γ ⊢ INTERNAL_CONE ... : InternalCone_over(D) ;
CATEGORY
[[ INTERNAL_CONE K ... ]] = "A cone over an internal diagram. Its apex is an object in C₀ and its legs are morphisms in C₁, all satisfying the internal coherence laws." ;

(* ========================================================================================================== )
( == Part 2: The Internal Limit and its Universal Property == )
(* ========================================================================================================== *)

InternalLimitDeclaration ::= "INTERNAL_LIMIT" "of" Identifier "is" InternalConeDeclaration ;
TYPING
(*

An internal cone L is an internal limit if for any other internal cone K, there exists

a UNIQUE morphism u:Apex(K)→Apex(L) in C₁ that makes the universal triangle commute.
*)
Let L be an INTERNAL_CONE over D.
UniversalProperty :=
∀ (K : InternalCone_over(D)),
∃! (u : Morphism(Apex(K), Apex(L)) in C₁),
s.t. ∀j∈Ob(J), (p_j_L ∘ u == p_j_K) (This comparison holds in C₁)

Γ ⊢ INTERNAL_LIMIT of D is L : ProvableProposition ;
CATEGORY
[[ INTERNAL_LIMIT of D is L ]] = "The universal internal cone for the diagram D. Its existence is a strong structural property of the internal category C, asserting that it has a way to find universal solutions to constraint problems defined by diagrams." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory for Internal Colimits == )
( ========================================================================================================== *)

DualTheoremInference ::= "INFER_DUAL_THEORY" "'InternalColimitTheory'" "FROM" "THEORY" "'InternalLimitTheory'" ;
TYPING
(***

By applying the duality functor (-)^op to the entire theory for internal limits,

the system mechanically generates the correct dual theory for internal colimits.

Rewrites performed by the DualityMapping dictionary:

INTERNAL_CONE -> INTERNAL_COCONE (arrows point from diagram to apex)

INTERNAL_LIMIT -> INTERNAL_COLIMIT

Apex is Terminal in ConeCategory -> Apex is Initial in CoConeCategory

The resulting propositions are valid theorems in the dual theory.
***)
Γ ⊢ TheoryBlock["InternalLimitTheory"] : CoherentTheoryFragment

Γ ⊢ TheoryBlock["InternalColimitTheory"] := (TheoryBlock["InternalLimitTheory"])^op : CoherentTheoryFragment ;
CATEGORY
[[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the entire theory for 'internal colimits'. This process, derived by mechanically applying the duality functor, generates the definitions for internal cocones and internal colimits (which are universal cocones) without requiring separate proofs, showcasing the perfect symmetry of the underlying categorical concepts even in an internalized setting." ;

}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'Abelian categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(*

ELABORATION: To provide a deep elaboration on Section 1.1, we must deconstruct the concepts of
"zero object," "kernel," and "cokernel" into their most fundamental definitions and properties,
formalizing them within our grammar.

Zero Object: We will formalize a zero object not just as a property, but by its core
universal property: the existence of a unique "zero morphism" between any two objects that
factors through it.

Kernel as Equalizer: We will define the kernel of a morphism f not as a primitive, but
constructively. The kernel ker(f) will be formally defined as the equalizer of f and
the corresponding zero morphism. This makes the universal property of the kernel a direct
consequence of the universal property of a limit.

Cokernel as Dual: We will use the Duality Principle, a core feature of our constructed grammar,
to define the cokernel. By declaring the duality mapping KERNEL <-> COKERNEL, we will derive
the entire theory of cokernels (their definition as a coequalizer, their universal property)
mechanically from the theory of kernels, showcasing the power and symmetry of the categorical approach.

This approach reveals that these concepts are not arbitrary but are specific instances of the more
general theory of limits and colimits in a category with a specified point (the zero object).
*)

(* ========================================================================================================== )
( == Part 1: Zero Objects and the Induced Zero Morphisms == )
( ========================================================================================================== *)

CategoryProperty_HasZeroObject ::= Identifier "has_a" "ZERO_OBJECT" ;
TYPING
(* This property asserts the existence of an object that is both initial and terminal. *)
Γ ⊢ C : Category
∃ (Z ∈ Ob(C)) s.t. ( (Γ ⊢ Z is INITIAL_OBJECT) ∧ (Γ ⊢ Z is TERMINAL_OBJECT) )
-------------------------------------------------------------------------------
Γ ⊢ C has_a ZERO_OBJECT : PropositionAbout(C) ;
CATEGORY
[[ C has_a ZERO_OBJECT ]] = "The assertion that the category C is 'pointed', containing a unique (up to isomorphism) object that serves as both the universal source and universal sink for morphisms." ;

ZeroMorphismConstructor ::= "zero_mor" "(" "from" ":" Identifier "," "to" ":" Identifier ")" ;
TYPING
(*
* This defines the unique zero morphism 0_{A,B}: A -> B.
* Its existence is guaranteed by the presence of a zero object Z.
* It is constructed as the unique composition through Z.
)
Context: Γ ⊢ C has_a ZERO_OBJECT (Let Z be the zero object)
Γ ⊢ A, B : Object_in(C)
u_AZ := unique_to_terminal_from(A) ( The unique map A -> Z, since Z is terminal )
u_ZB := unique_from_initial_to(B) ( The unique map Z -> B, since Z is initial *)
---------------------------------------------------------------------------------
Γ ⊢ zero_mor(from:A, to:B) : Morphism(A, B) (defined as u_ZB ∘ u_AZ) ;
CATEGORY
[[ zero_mor(from:A, to:B) ]] = "The unique morphism between A and B that factors through the zero object. In an additive category, this morphism will act as the additive identity in the hom-set Hom(A,B)." ;

(* ========================================================================================================== )
( == Part 2: The Kernel as a Limit Construction (an Equalizer) == )
( ========================================================================================================== *)

KernelAsEqualizerAxiom ::= "DEFINE" "ker" "(" Identifier "f" ")" "as" "Equalizer" "(" "f" "," ZeroMorphismConstructor ")" ;
TYPING
(*
* This is the formal, constructive definition of a kernel. The kernel of a morphism f
* is not a new primitive; it IS the equalizer of f and the zero morphism.
*)
Context: Γ ⊢ C has_a ZERO_OBJECT
Γ ⊢ f : A -> B
z_AB := zero_mor(from:A, to:B)
----------------------------------------------------------------
(Γ ⊢ ker(f) : SubobjectOf(A)) <==> (Γ ⊢ Equalizer(f, z_AB) : SubobjectOf(A)) ;
CATEGORY
[[ DEFINE ker(f) as Equalizer(...) ]] = "The assertion of definitional equivalence between the kernel of f and a specific limit construction. This definition endows the kernel with a universal property 'for free': for any map g:X→A such that f∘g=0, there exists a unique mediating morphism u:X→ker(f) such that k∘u=g, where k is the kernel monomorphism. This is precisely the universal property of the equalizer." ;

KernelProperty ::= "is_kernel_of" "(" Identifier ")" ;
TYPING
(* This predicate checks if a given monomorphism m is THE kernel of f. *)
Γ ⊢ m : K -> A, Γ ⊢ f : A -> B
----------------------------------------------------------
Γ ⊢ m is_kernel_of(f) is TRUE if (m ≅ ker(f)) ;
CATEGORY
[[ m is_kernel_of(f) ]] = "The assertion that the subobject represented by the monomorphism m is isomorphic (in the slice category C/A) to the kernel of f." ;

(* ========================================================================================================== )
( == Part 3: The Cokernel as a Colimit Construction (via Duality) == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "KERNEL" "IS" "COKERNEL" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "Equalizer" "IS" "Coequalizer" ;

CokernelAsCoequalizerAxiom ::= "INFER_DUAL_AXIOM" "'CokernelAsCoequalizer'" "FROM" "AXIOM" "'KernelAsEqualizerAxiom'" ;
TYPING
(*
* This rule shows the Duality Principle in action. We do not define the cokernel from scratch.
* We apply the duality operator (-)^op to the KernelAsEqualizerAxiom.
* The system uses the DualityMapping dictionary to perform rewrites:
* 1. ker(f) -> coker(f)
* 2. Equalizer -> Coequalizer
* 3. SubobjectOf(A) -> QuotientObjectOf(B)
* The result is the correct, dual definition for the cokernel.
*)
Γ ⊢ AXIOM 'KernelAsEqualizerAxiom' : P_kernel
P_cokernel = rewrite(P_kernel, DualityMappings)
---------------------------------------------------------
Conclusion: (Γ ⊢ coker(f)) <==> (Γ ⊢ Coequalizer(f, zero_mor(from:A, to:B))) ;
CATEGORY
[[ INFER_DUAL_AXIOM ... ]] = "A constructive proof of the definition of the cokernel, derived mechanically by applying the duality functor to the definition of the kernel. It asserts that the cokernel of f is definitionally equivalent to the coequalizer of f and the zero morphism, endowing it with the corresponding universal property of a colimit." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.2: Additive categories and biproducts" ")" "==>" {
(*

ELABORATION: This section builds upon the concept of a pointed category (one with a zero object)
to define a much richer structure. An additive category is a category where the collection of
morphisms between any two objects is not just a set, but an abelian group, and composition
behaves like a bilinear map. This leads to the remarkable consequence that finite products and
finite coproducts coincide, giving rise to the "biproduct."

To elaborate, we will:

Formalize Enrichment: First, we formalize the abstract idea of a category being
"enriched" over another, which is the core concept needed to say "hom-sets are abelian groups."

Define Additive Category: We will then use this to build the formal definition of an
Additive Category as one that has a zero object, has all binary biproducts, and is enriched
over the category of Abelian Groups (Ab).

Define the Biproduct: We will formally define the biproduct object A⊕B and state its
definitive property: it is simultaneously a product and a coproduct.

State the Equivalence Theorem: We will assert the theorem that a category with all finite
products and coproducts is additive if and only if the canonical map from the coproduct to the
product is an isomorphism, providing a structural check for additivity.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing Enrichment over Abelian Groups == )
( ========================================================================================================== *)

Category_is_Enriched_over ::= Identifier "is" "ENRICHED_OVER" Identifier ;
TYPING
(*
* This defines the general property of enrichment. A category C is enriched over a monoidal category M
* if its hom-collections are objects in M, and composition is a morphism in M.
* For additive categories, the enriching category M is Ab, the category of abelian groups
* with the tensor product as the monoidal operation.
*)
Γ ⊢ C : Category, Γ ⊢ M : MonoidalCategory
∀A,B ∈ Ob(C), Hom_C(A,B) ∈ Ob(M)
∀A,B,C ∈ Ob(C), Composition : Hom_C(B,C) ⊗ Hom_C(A,B) → Hom_C(A,C) is a morphism in M.
--------------------------------------------------------------------------------------------------
Γ ⊢ C is ENRICHED_OVER M : PropositionAbout(C) ;
CATEGORY
[[ C is ENRICHED_OVER M ]] = "The property that the internal structure of the hom-sets of C mirrors the structure of the category M. The fact that composition is a morphism Hom(B,C) ⊗ Hom(A,B) → Hom(A,C) is the precise categorical statement of bilinearity." ;

(* ========================================================================================================== )
( == Part 2: The Biproduct and the Definition of an Additive Category == )
( ========================================================================================================== *)

BiproductObject ::= Identifier "⊕" Identifier ;
TYPING
(*
* The biproduct A⊕B is an object that is, simultaneously and compatibly, the product
* and coproduct of A and B. Its existence is the defining feature of additivity.
*)
Context: C is an Preadditive_Category (enriched over Ab, has zero object)
Γ ⊢ A, B : Object_in(C)
-------------------------------------------------
Γ ⊢ (A ⊕ B) is PRODUCT of (A,B)
Γ ⊢ (A ⊕ B) is COPRODUCT of (A,B) ;
CATEGORY
[[ A ⊕ B ]] = "The biproduct of A and B. It is an object equipped with projection maps (pA, pB) and injection maps (iA, iB) satisfying the product and coproduct universal properties, along with the coherence conditions pA∘iA=id, pB∘iB=id, pA∘iB=0, pB∘iA=0, and iA∘pA + iB∘pB = id." ;

AdditiveCategoryDeclaration ::= "ADDITIVE_CATEGORY" Identifier ;
TYPING
(* The master definition of an additive category, combining the prerequisites. *)
Γ ⊢ C : Category
Premise1: C has a ZERO_OBJECT
Premise2: C has a biproduct A⊕B for every pair of objects A, B.
Premise3: C is ENRICHED_OVER Ab
-----------------------------------------------------------------
Γ ⊢ C is ADDITIVE_CATEGORY ;
CATEGORY
[[ C is ADDITIVE_CATEGORY ]] = "A category equipped with a zero object and a compatible abelian group structure on its hom-sets, which manifests in the existence of biproducts. This is the foundational setting for homological algebra." ;

(* ========================================================================================================== )
( == Part 3: The Structural Equivalence Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdditivityEquivalence" ":"
"A category with finite products and coproducts is ADDITIVE IFF"
"the canonical morphism from Coproduct(A,B) to Product(A,B) is an ISOMORPHISM." ;
TYPING
(*
* In any category with products and coproducts, there is a canonical map from the coproduct to the product.
* The category is additive if and only if this map is always an isomorphism. This provides a purely
* structural way to check for additivity without direct reference to the Ab-enrichment.
*)
Context: Γ ⊢ C has finite products and coproducts
Let P = Product(A,B) with projections pA, pB.
Let C = Coproduct(A,B) with injections iA, iB.
CanonicalMap := < <id_A, 0>, <0, id_B> > : C → P
-----------------------------------------------------------------------------
(Γ ⊢ C is ADDITIVE_CATEGORY) <==> (∀A,B, Γ ⊢ CanonicalMap is ISOMORPHISM) ;
CATEGORY
[[ THEOREM AdditivityEquivalence ]] = "A fundamental theorem providing a structural criterion for additivity. It asserts that the abstract algebraic property of being enriched over Abelian Groups is equivalent to the concrete property that the natural comparison map from the coproduct to the product is always an isomorphism. This is why in additive categories, products and coproducts coincide as the biproduct." ;

}

(* ========================================================================================================== )
( == Section 1.3: Additive functors == )
( ========================================================================================================== )
(
ELABORATION: This section defines "additive functors," which are the structure-preserving maps
between additive categories. The key idea is that these functors must respect the abelian group
structure on the hom-sets. A deep elaboration requires not just stating this, but showing its powerful
equivalence to a more structural, diagrammatic property.

To elaborate, we will:

Formalize the Primary Definition: Define an additive functor as one whose action on hom-sets
is a homomorphism of abelian groups. This is the fundamental algebraic definition.

State the Equivalence Theorem: Assert the crucial theorem that a functor between additive categories
is additive if and only if it preserves finite biproducts. This bridges the algebraic definition with
a concrete, structural-diagrammatic test.

Provide a Canonical Example: Instantiate these definitions by proving that the Hom-functor
Hom(A, -) is itself a canonical example of an additive functor, demonstrating how the Ab-enrichment
(distributivity of composition) ensures this property.

Formalize the Duality: Assert that the concept of an additive functor is self-dual, which
implies that the contravariant Hom-functor Hom(-, A) is also additive, completing the picture.
*)

(* ========================================================================================================== )
( == Part 1: The Primary Definition (Respect for Enrichment) == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "ADDITIVE" ;
TYPING
(*
* This is the fundamental definition. A functor F: C -> D between additive categories
* is additive if for every pair of objects A,B in C, the induced map on hom-sets
* is a homomorphism of abelian groups.
*)
Γ ⊢ F : Functor(C, D)
Γ ⊢ C, D : ADDITIVE_CATEGORY
Condition := ∀A,B∈Ob(C), the map F_{A,B}: Hom_C(A,B) → Hom_D(F(A),F(B)) is_a GroupHomomorphism(Ab)
----------------------------------------------------------------------------------------------------------
Γ ⊢ F is ADDITIVE is TRUE if Condition holds ;
CATEGORY
[[ F is ADDITIVE ]] = "A functor that preserves the Ab-enriched structure of its domain. This means it respects the addition of morphisms, mapping F(f+g) to F(f)+F(g), and maps the zero morphism to the zero morphism. This is the correct notion of a 'linear' functor between additive categories." ;

(* ========================================================================================================== )
( == Part 2: The Key Equivalence Theorem (Structural Test) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdditiveFunctorBiproductEquivalence" ":"
"A functor F between additive categories is ADDITIVE"
"<==>"
"F preserves finite biproducts." ;
TYPING
(*
* This theorem provides a powerful, often easier-to-check, structural condition
* that is equivalent to the algebraic definition above.
)
Context: Γ ⊢ F : Functor(C, D) between ADDITIVE_CATEGORY C, D
P1 := (Γ ⊢ F is ADDITIVE) ( The group homomorphism definition *)
P2 := (∀ A,B ∈ Ob(C), the canonical map F(A⊕B) → F(A)⊕F(B) is an ISOMORPHISM)
-----------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdditiveFunctorBiproductEquivalence ]] = "A fundamental result connecting the algebraic property of additivity (respecting hom-set structure) with the diagrammatic property of preserving biproducts. This allows one to prove a functor is additive by showing it preserves the product/coproduct structure, which is often more direct." ;

(* ========================================================================================================== )
( == Part 3: The Canonical Example (The Hom-Functor) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "HomFunctorIsAdditive" ":"
"FOR_ALL object A in an AdditiveCategory C, the functor Hom_C(A, -) is ADDITIVE." ;
TYPING
(*
* We prove this using the primary definition. We must show that the map induced by
* Hom(A,-) on the hom-set Hom_C(X,Y) is a group homomorphism.
* Let g1, g2 ∈ Hom_C(X,Y). Hom(A,-) maps (g1+g2) to the map [ (h:A→X) ↦ (g1+g2)∘h ].
* It maps g1 and g2 to [h ↦ g1∘h] and [h ↦ g2∘h] respectively.
* The Ab-enrichment of C guarantees composition is bilinear, so (g1+g2)∘h = (g1∘h) + (g2∘h).
* Therefore, Hom(A,-) preserves addition and is an additive functor.
*)
Context: Γ ⊢ C : ADDITIVE_CATEGORY, Γ ⊢ A : Object_in(C)
Let F := Hom_C(A, -) : C → Ab
F_map_on_Hom(g1+g2) == (F_map_on_Hom(g1) + F_map_on_Hom(g2)) because composition distributes.
--------------------------------------------------------------------------
Γ ⊢ Functor F is ADDITIVE : ProvableProposition ;
CATEGORY
[[ THEOREM HomFunctorIsAdditive ]] = "The assertion that the covariant representable functor is always additive. This is a direct consequence of the bilinear nature of composition in an Ab-enriched category and establishes the Hom functor as a primary and foundational example of an additive functor." ;

(* ========================================================================================================== )
( == Part 4: Duality == )
( ========================================================================================================== *)

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "ADDITIVE" "IS" "ADDITIVE" ;
TYPING
---
----------------------------------------------------
(Γ ⊢ F is ADDITIVE)^op <==> (Γ ⊢ F^op is ADDITIVE) ;
CATEGORY
[[ DUALITY_MAPPING FOR ADDITIVE IS ADDITIVE ]] = "The assertion that the concept of an additive functor is self-dual. The opposite of an additive category is additive, and a functor respects the structure if and only if its opposite does. A direct corollary is that the contravariant Hom-functor, Hom(-, A), is also an additive functor." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.4: Abelian categories" ")" "==>" {
(*

ELABORATION: Section 1.4 introduces the definition of an abelian category, the foundational setting
for homological algebra. Simply stating the definition is insufficient; a deep elaboration requires
deconstructing it to reveal why each condition is necessary and what powerful consequences follow.

Our elaboration will proceed in four stages:

Formalize the Building Blocks (Normality): We will first formalize the key concepts of "normal"
monomorphisms and epimorphisms. A monomorphism is normal if it is "well-behaved" enough to be a kernel,
and dually for epimorphisms. We will define this precisely as a morphism being the kernel of its cokernel.

Construct the Master Definition: Using these building blocks, we will assemble the complete, formal
definition of an AbelianCategoryDeclaration, showing it as an additive category where these normality
conditions hold universally.

Reveal the Core Consequence (The Isomorphism Theorem): We will formalize the most important
structural consequence of the definition: that in an abelian category, the "coimage" of a morphism is
canonically isomorphic to its "image." This is what makes diagram chasing work and is often used as
an alternative definition. We will define the coimage and image constructively as coker(ker(f)) and
ker(coker(f)) respectively.

State the Canonical Examples: We will anchor the abstract definition by declaring that the category of
Abelian Groups (Ab) and the category of R-Modules (R-Mod) are the quintessential examples that
satisfy all the required axioms.

This approach shows that the definition of an abelian category is not an arbitrary list of axioms, but a
carefully chosen set of conditions designed to produce a category with the powerful structural properties
of Ab.
*)

(* ========================================================================================================== )
( == Part 1: Formalizing Normality == )
( ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "is" "NORMAL_MONOMORPHISM" ;
TYPING
(*
* A monomorphism m is normal if it arises as the kernel of some morphism.
* The canonical choice for that morphism is its own cokernel.
*)
Γ ⊢ m : K -> A, Γ ⊢ m is MONOMORPHISM
----------------------------------------------------------
Γ ⊢ m is NORMAL_MONOMORPHISM is TRUE if (m ≅ ker(coker(m))) ;
CATEGORY
[[ m is NORMAL_MONOMORPHISM ]] = "The property of a monomorphism being the kernel of its cokernel. This is a well-behavedness condition ensuring that the subobject represented by m is the solution to a universal problem defined by its corresponding quotient object." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "NORMAL_MONOMORPHISM" "IS" "NORMAL_EPIMORPHISM" ;

MorphismPropertyAssertion ::= Identifier "is" "NORMAL_EPIMORPHISM" ;
TYPING
(* Derived via duality. An epimorphism e is normal if it is the cokernel of its own kernel. *)
IsDualOf("NORMAL_MONOMORPHISM")
EquivalentTyping: Γ ⊢ e : A -> Q, Γ ⊢ e is EPIMORPHISM, (e ≅ coker(ker(e)))
-------------------------------------------------------------------------
Γ ⊢ e is NORMAL_EPIMORPHISM ;
CATEGORY
[[ e is NORMAL_EPIMORPHISM ]] = "The dual property. An epimorphism is normal if it arises as the cokernel of its kernel. This ensures the quotient object it represents is canonically related to the subobject it annihilates." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of an Abelian Category == )
( ========================================================================================================== *)

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" Identifier ;
TYPING
(* The master definition, composed of four precise conditions. *)
Γ ⊢ C : Category
Premise1: Γ ⊢ C is ADDITIVE_CATEGORY
Premise2: C has all KERNELS and COKERNELS
Premise3: ∀(m ∈ Mor(C)), ( (m is MONOMORPHISM) ⇒ (m is NORMAL_MONOMORPHISM) )
Premise4: ∀(e ∈ Mor(C)), ( (e is EPIMORPHISM) ⇒ (e is NORMAL_EPIMORPHISM) )
-------------------------------------------------------------------------
Γ ⊢ C is ABELIAN_CATEGORY ;
CATEGORY
[[ C is ABELIAN_CATEGORY ]] = "A category possessing the rich structure of the category of Abelian Groups. It is additive, has all kernels and cokernels, and crucially, every subobject is the kernel of some map and every quotient object is the cokernel of some map. This is the ideal environment for homological algebra." ;

(* ========================================================================================================== )
( == Part 3: The Core Consequence - The First Isomorphism Theorem == )
( ========================================================================================================== *)

CoimageOfMorphism ::= "Coim" "(" Identifier ")" ;
TYPING
(* In this context, the coimage of f is defined as the cokernel of its kernel. *)
Γ ⊢ f : A -> B
--------------------------------------------
Γ ⊢ Coim(f) : QuotientObjectOf(A) (defined as coker(ker(f))) ;
CATEGORY
[[ Coim(f) ]] = "The coimage of f. This is a quotient of the domain A, representing the domain modulo the kernel. In Set, this is isomorphic to the image." ;

ImageOfMorphism ::= "Im" "(" Identifier ")" ;
TYPING
(* Dually, the image of f is defined as the kernel of its cokernel. *)
Γ ⊢ f : A -> B
----------------------------------------
Γ ⊢ Im(f) : SubobjectOf(B) (defined as ker(coker(f))) ;
CATEGORY
[[ Im(f) ]] = "The image of f. This is a subobject of the codomain B. In an abelian category, this more abstract definition coincides with the intuitive notion of the image." ;

TheoremDeclaration ::= "THEOREM" "FirstIsomorphismTheoremForCategories" ":"
"A category C is ABELIAN if and only if C is Additive, has Kernels and Cokernels, and"
"the canonical morphism Coim(f) → Im(f) is an ISOMORPHISM for all f." ;
TYPING
(* This provides the most powerful and often-used characterization of an abelian category. *)
P1 := (Γ ⊢ C is ABELIAN_CATEGORY)
Let f_bar be the canonical morphism Coim(f) → Im(f).
P2 := ( Γ ⊢ C is ADDITIVE ∧ C has Kernels/Cokernels ∧ (∀f, f_bar is ISOMORPHISM) )
---------------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FirstIsomorphismTheoremForCategories ]] = "The categorical analogue of the first isomorphism theorem for groups (A/ker(f) ≅ Im(f)). It states that the conditions of normality for monos and epis are precisely equivalent to the condition that the coimage and image of every morphism are canonically isomorphic. This property is the key to all diagram-chasing proofs." ;

(* ========================================================================================================== )
( == Part 4: The Canonical Examples == )
( ========================================================================================================== *)

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" "Ab" ;
TYPING
-- Verify all premises for the category of Abelian Groups --
Premise1: IsAdditive(Ab) is TRUE.
Premise2: Ab has all kernels and cokernels.
Premise3: All monos in Ab are normal.
Premise4: All epis in Ab are normal.
-----------------------------------------------
Γ ⊢ "Ab" is ABELIAN_CATEGORY : ProvableProposition ;
CATEGORY
[[ ABELIAN_CATEGORY Ab ]] = "The category of abelian groups. It is the archetypal abelian category from which the abstract definition is derived." ;

AbelianCategoryDeclaration ::= "ABELIAN_CATEGORY" "R-Mod" ;
TYPING
-- Verify all premises for the category of left R-modules --
Context: R is a Ring
(All premises can be verified to be TRUE)
--------------------------------------------------
Γ ⊢ "R-Mod" is ABELIAN_CATEGORY : ProvableProposition ;
CATEGORY
[[ ABELIAN_CATEGORY R-Mod ]] = "The category of left modules over a ring R. This, along with Ab, is the primary working example of an abelian category in algebra and homological algebra." ;
}

(* ========================================================================================================== )
( == Section 1.5, 1.6: Exactness and Additivity Properties of Abelian Categories == )
( ========================================================================================================== )
(

ELABORATION: These sections reveal the deep interplay between the algebraic structure (additivity)

and the limit-based structure (exactness) of an abelian category. The key insight is that the

Ab-enrichment forces the diagrammatic structures to be exceptionally well-behaved.

To elaborate, we will:

I. Deconstruct the "Image Factorization":

Formalize the canonical f_bar morphism that connects the "quotient" part of a morphism

Generated code
(its Coimage) to the "subobject" part (its Image).


State the central theorem of exactness: that in an abelian category, this f_bar is always an

Generated code
isomorphism (Coimage ≅ Image). This is the First Isomorphism Theorem for categories.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

II. Deconstruct the "Biproduct":

Formalize the canonical comparison map that exists in any pointed category from the

Generated code
coproduct (A ∐ B) to the product (A × B).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

State the central theorem of additivity: that a category's hom-sets form abelian groups

Generated code
(i.e., it is additive) if and only if this canonical comparison map is always an isomorphism.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

This approach demonstrates that the abstract axioms of an abelian category have concrete, powerful

structural consequences: images and coimages are the same, and products and coproducts are the same.
*)

(* ========================================================================================================== )
( == Part I: The Exactness Property (Coimage ≅ Image) == )
( ========================================================================================================== *)

Coim_f_Constructor ::= "Coim" "(" Identifier ")" ;
Im_f_Constructor ::= "Im" "(" Identifier ")" ;
TYPING
(* Formal definitions of Coimage and Image used in this context. *)
Γ ⊢ f : A -> B in Category with Kernels/Cokernels
-----------------------------------------------------------------------------------------------------
(Γ ⊢ Coim(f) : QuotientObjectOf(A)) <==> (Γ ⊢ coker(ker(f)) : QuotientObjectOf(A))
(Γ ⊢ Im(f) : SubobjectOf(B)) <==> (Γ ⊢ ker(coker(f)) : SubobjectOf(B)) ;
CATEGORY
[[ Coim(f) ]] = "The coimage of f, defined universally as the cokernel of its kernel. It represents the domain A modulo the part that f annihilates." ;
[[ Im(f) ]] = "The image of f, defined universally as the kernel of its cokernel. It represents the part of the codomain B that is 'reachable' by f." ;

CanonicalMorphism_f_bar ::= "f_bar" "(" Identifier ")" ;
TYPING
(*
* This constructor defines the canonical map f_bar from the Coimage to the Image.
* The morphism f: A -> B can be factored through both its coimage and its image.
* The universal properties of these objects guarantee a unique mediating morphism between them.
*)
Γ ⊢ f : A -> B in ABELIAN_CATEGORY C
e := projection_to Coim(f)
m := inclusion_from Im(f)
∃! g s.t. f = g ∘ e
∃! h s.t. g = m ∘ h
-------------------------------------------------------------------------
Γ ⊢ f_bar(f) : Morphism(Coim(f), Im(f)) (defined as the unique map h) ;
CATEGORY
[[ f_bar(f) ]] = "The unique canonical morphism from the coimage of f to the image of f, which exists due to the universal properties of kernels and cokernels. The exactness of the category is captured by the properties of this specific morphism." ;

TheoremDeclaration ::= "THEOREM" "FirstIsomorphismForAbelianCategories" ":"
"IN " "ABELIAN_CATEGORY" "C" "," "FOR_ALL morphism f," "f_bar(f)" "is an ISOMORPHISM." ;
TYPING
(*
* This is the central theorem of exactness. The property of all monomorphisms and epimorphisms
* being 'normal' is precisely equivalent to this Coim-Im isomorphism holding for all f.
*)
Γ ⊢ C is ABELIAN_CATEGORY
------------------------------------------------------------
∀(f ∈ Mor(C)), (Γ ⊢ f_bar(f) is ISOMORPHISM) : MetaTheorem ;
CATEGORY
[[ THEOREM FirstIsomorphismForAbelianCategories ]] = "The fundamental theorem of exactness in abelian categories, and the categorical analogue of the First Isomorphism Theorem (G/ker(φ) ≅ Im(φ)). It asserts that the object constructed as a quotient of the domain (the Coimage) is always canonically isomorphic to the object constructed as a subobject of the codomain (the Image). This powerful property is what enables all diagram-chasing arguments." ;

(* ========================================================================================================== )
( == Part II: The Additivity Property (Coproduct ≅ Product) == )
( ========================================================================================================== *)

CanonicalMap_CoproductToProduct ::= "canonical_map" "(" Identifier "→" Identifier ")" ;
TYPING
(*
* In any category with a zero object, finite products, and finite coproducts, there exists
* a canonical map from the coproduct C = A ∐ B to the product P = A × B.
* This map is built from the universal property of the coproduct, using maps into P.
*)
Context: C is a pointed category with finite products and coproducts.
P_obj := Product(A,B)
C_obj := Coproduct(A,B)
map1 := <id_A, 0_{A,B}> : A -> P_obj
map2 := <0_{B,A}, id_B> : B -> P_obj
-------------------------------------------------------------------------
Γ ⊢ canonical_map(C_obj → P_obj) : Morphism(C_obj, P_obj) (defined as <map1, map2>) ;
CATEGORY
[[ canonical_map(A∐B → A×B) ]] = "The canonical comparison morphism that exists in any pointed category between the coproduct and the product. The properties of this map determine the additive nature of the category." ;

TheoremDeclaration ::= "THEOREM" "AdditivityViaBiproductCoincidence" ":"
"A category with finite products/coproducts and a zero object is ADDITIVE_CATEGORY"
"<==>"
"the canonical_map(Coproduct → Product) is an ISOMORPHISM for all objects." ;
TYPING
(*
* This theorem provides a purely structural criterion for additivity. It states that the
* algebraic property (Ab-enrichment) is equivalent to the diagrammatic property
* that the product and coproduct are not just related, but are naturally isomorphic.
*)
Context: C is a pointed category with finite products and coproducts.
P1 := (Γ ⊢ C is ADDITIVE_CATEGORY)
P2 := (∀A,B ∈ Ob(C), Γ ⊢ canonical_map(A∐B → A×B) is ISOMORPHISM)
--------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM AdditivityViaBiproductCoincidence ]] = "A key structural result asserting that the requirements for an additive category (zero object, Ab-enrichment) are precisely the conditions needed to make finite products and finite coproducts coincide. When they do, the resulting object is called the biproduct (A ⊕ B), and this coincidence is the defining structural feature of additivity." ;

(* ========================================================================================================== )
( == Section 1.7: Union of subobjects == )
( ========================================================================================================== )
(

ELABORATION: This section describes the behavior of subobjects in an abelian category. The key

insight is that the collection of subobjects of any given object forms a special kind of lattice.

A deep elaboration requires not just defining the union/join operation, but formalizing its

construction, contrasting it with the dual construction for intersection/meet, and stating the

powerful structural property (modularity) that this lattice is guaranteed to have in the abelian setting.

To this end, we will:

I. Deconstruct the Join/Union: We will formalize the construction of the union (join) of a

family of subobjects. This is a two-step process: (1) form the coproduct of the subobject

domains, and (2) take the image of the induced universal map into the ambient object.

II. Formalize the Dual Meet/Intersection: For completeness, we will formalize the dual

construction for the intersection (meet) of subobjects, which is given by their pullback.

III. Formalize the Lattice Property (Modularity): We will define a "modular lattice," the specific

algebraic structure that the subobject lattice possesses.

IV. State the Main Theorem: We will assert the central theorem of this section: that in any

abelian category, the lattice of subobjects of any object is always a modular lattice.
*)

(* ========================================================================================================== )
( == Part I & II: The Lattice Operations (Join/Union and Meet/Intersection) == )
( ========================================================================================================== *)

UnionOfSubobjects ::= "Join" "(" "{" {SubobjectOf} "}" ")" ;
TYPING
(*
* This rule formalizes the construction of the least upper bound (join or "union") of a
* family of subobjects {s_i} of an object X. Each s_i is represented by a mono m_i: A_i -> X.
* The construction relies on the abelian category having coproducts and images.
*)
Context: C is an ABELIAN_CATEGORY
Subobjects_Set = { s_i | s_i has representative m_i: A_i -> X }
1. Form the coproduct of the domains: CP_obj := Coproduct({ A_i })
2. Form the universal map from the coproduct: u := UniversalCoproductMorphism( from:CP_obj, to:X, via:{m_i} )
3. The union is the image of this map.
------------------------------------------------------------------------------------------------------------
Γ ⊢ Join(Subobjects_Set) : SubobjectOf(X) (defined as Image(u)) ;
CATEGORY
[[ Join({s_i}) ]] = "The supremum of the family of subobjects {s_i} in the subobject lattice Sub(X). It is constructively defined as the image of the universal map from the coproduct of the subobjects' domains. This represents the smallest subobject of X containing all the s_i." ;

IntersectionOfSubobjects ::= "Meet" "(" "{" {SubobjectOf} "}" ")" ;
TYPING
(*
* This rule formalizes the dual construction for the greatest lower bound (meet or "intersection").
* The intersection of a family of subobjects {s_i} is their limit, which is their wide pullback.
*)
Context: C is an ABELIAN_CATEGORY (which has all finite limits, including pullbacks)
Subobjects_Set = { s_i | s_i has representative m_i: A_i -> X }
1. Form the diagram of all m_i mapping to X.
2. The intersection is the limit of this diagram.
-------------------------------------------------------------------------------------------
Γ ⊢ Meet(Subobjects_Set) : SubobjectOf(X) (defined as Pullback({m_i})) ;
CATEGORY
[[ Meet({s_i}) ]] = "The infimum of the family of subobjects {s_i} in the subobject lattice Sub(X). It is constructively defined as the (wide) pullback of the representative monomorphisms. This represents the largest subobject of X contained within all of the s_i." ;

(* ========================================================================================================== )
( == Part III: The Property of the Resulting Lattice (Modularity) == )
( ========================================================================================================== *)

LatticePropertyDefinition ::= Identifier "is" "MODULAR_LATTICE" ;
TYPING
(* A lattice is modular if it satisfies the modular law (a weaker form of distributivity). *)
Γ ⊢ L : Lattice
ModularLaw := ∀x,a,b∈L, ( (x ≤ b) ⇒ (Join(x, Meet(a, b)) == Meet(Join(x, a), b)) )
--------------------------------------------------------------------------------
Γ ⊢ L is MODULAR_LATTICE is TRUE if ModularLaw holds ;
CATEGORY
[[ L is MODULAR_LATTICE ]] = "A key property of lattices that arise in algebraic contexts. A modular lattice is one where the Jordan-Hölder theorem holds. This property is stronger than a general lattice but weaker than a distributive lattice." ;

(* ========================================================================================================== )
( == Part IV: The Main Theorem Connecting the Concepts == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "SubobjectLatticeInAbelianIsModular" ":"
"IN any" "ABELIAN_CATEGORY" "C" "," "FOR_ALL object X of C,"
"the subobject lattice Sub(X) is a MODULAR_LATTICE." ;
TYPING
(*
* This is a fundamental result about the structure of abelian categories. The rich interplay
* of kernels, cokernels, products, and coproducts forces the subobject lattices to be
* exceptionally well-behaved.
*)
Γ ⊢ C is ABELIAN_CATEGORY
-----------------------------------------------------------------
∀X∈Ob(C), Γ ⊢ Sub(X) is MODULAR_LATTICE : ProvableProposition ;
CATEGORY
[[ THEOREM SubobjectLatticeInAbelianIsModular ]] = "An important structural theorem asserting that the exactness properties of an abelian category are reflected in the algebraic properties of its subobject lattices. This result is crucial for many proofs in homological algebra and module theory, as it guarantees that subobjects interact in a predictable and regular way." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.8: Exact sequences" ")" "==>" {
(*

ELABORATION: This section introduces the concept of an "exact sequence," which is arguably the
most important tool in homological algebra. It defines a very specific relationship between kernels and
images that captures the notion of "homological triviality" at a certain point. A deep elaboration
requires not just stating the definition, but deconstructing its meaning and consequences, especially
the powerful "Splitting Lemma."

Our elaboration will proceed by:

Formalizing the Local Condition: We will define the atomic property of a sequence being "exact at"
a single object. This is the core Image ≅ Kernel condition.

Defining the Short Exact Sequence (SES): We will build upon the local condition to define the
Short Exact Sequence, the most important type of exact sequence, and show how its definition
implies that the first map is a monomorphism and the last map is an epimorphism.

Formalizing the Splitting Lemma: We will deconstruct the famous Splitting Lemma by
formalizing its three equivalent conditions: the existence of a retraction, the existence of a
section, and the central object being a biproduct. This reveals the deep connection between
the sequence structure and the additive structure of the category.

Defining the General Case: Finally, we will define a "long exact sequence" as a sequence that
satisfies the local exactness condition at every intermediate object.
*)

(* ========================================================================================================== )
( == Part 1: The Local Condition (Exactness at an Object) == )
( ========================================================================================================== *)

ExactSequenceAt ::= Identifier "is" "EXACT_AT" Identifier ;
TYPING
(*
* This defines the core property. A sequence of morphisms A --f--> B --g--> C
* is exact at the object B if the image of the incoming morphism f is precisely
* the kernel of the outgoing morphism g.
*)
Context: A --f--> B --g--> C is a sequence in an ABELIAN_CATEGORY.
----------------------------------------------------------
Γ ⊢ Sequence is EXACT_AT B <==> (Image(f) ≅ Kernel(g)) ;
CATEGORY
[[ Sequence is EXACT_AT B ]] = "A statement of local homological triviality. It asserts that everything arriving at B from A via f is precisely what gets annihilated by the subsequent map g. There are no 'gaps' or 'excess' at B." ;

(* ========================================================================================================== )
( == Part 2: The Short Exact Sequence (SES) == )
(* ========================================================================================================== *)

ShortExactSequence ::= "0 →" Identifier "→" Identifier "→" Identifier "→ 0" " is SES" ;
TYPING
(*
* A short exact sequence is a sequence of this form that is exact at A, B, and C.
* These conditions imply f is a monomorphism and g is an epimorphism.
*)
Context: 0 → A --f--> B --g--> C → 0
Premise1: Sequence is EXACT_AT A ( Im(0→A)≅Ker(f) ⇒ 0≅Ker(f) ⇒ f is mono )
Premise2: Sequence is EXACT_AT B ( Im(f)≅Ker(g), the main condition )
Premise3: Sequence is EXACT_AT C ( Im(g)≅Ker(C→0) ⇒ Im(g)≅C ⇒ g is epi )
-------------------------------------------------------------------------
Γ ⊢ "0 → A → B → C → 0" is SES : ProvableProposition ;
CATEGORY
[[ 0 → A → B → C → 0 is SES ]] = "A short exact sequence. This is a fundamental building block in homological algebra, representing that the object B is an 'extension' of A by C (i.e. A is a subobject of B, and C is the corresponding quotient B/A)." ;

(* ========================================================================================================== )
( == Part 3: The Splitting Lemma == )
(* ========================================================================================================== *)

MorphismPropertyAssertion ::= Identifier "has_retraction" | Identifier "has_section" ;
TYPING
CASE "has_retraction":
Γ ⊢ f:A->B is MONOMORPHISM
∃ r:B->A s.t. (r ∘ f == id_A)
CASE "has_section":
Γ ⊢ g:B->C is EPIMORPHISM
∃ s:C->B s.t. (g ∘ s == id_C)
-------------------------------------------
Γ ⊢ ... : PropositionAbout(Morphism) ;
CATEGORY
[[ f has_retraction ]] = "f is a split monomorphism. There is a map that 'undoes' it." ;
[[ g has_section ]] = "g is a split epimorphism. There is a map that provides a right-inverse." ;

TheoremDeclaration ::= "THEOREM" "SplittingLemmaForSES" ":"
"FOR a ShortExactSequence 0→A→B→C→0, the following are equivalent:"
"(" "f has_retraction" ")" "<==>" "(" "g has_section" ")" "<==>" "(" "B ≅ A ⊕ C" ")" ;
TYPING
(*
* This is a cornerstone theorem of homological algebra. It gives checkable criteria
* for when an extension B is 'trivial' -- i.e., just the biproduct of A and C.
*)
Context: seq = "0 → A --f--> B --g--> C → 0" is SES
P1 := (Γ ⊢ f has_retraction)
P2 := (Γ ⊢ g has_section)
P3 := (Γ ⊢ B ≅ (A ⊕ C) such that the isomorphism respects the SES structure)
--------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2 <==> P3) : ProvableEquivalence ;
CATEGORY
[[ THEOREM SplittingLemmaForSES ]] = "The Splitting Lemma. It provides three equivalent conditions for a short exact sequence to 'split'. A split sequence is one where the middle object B is structurally no more complex than the biproduct (direct sum) of the objects at the ends. This theorem connects the existence of specific morphisms (retractions and sections) to the fundamental additive structure of the category." ;

(* ========================================================================================================== )
( == Part 4: The General Case (Long Exact Sequences) == )
(* ========================================================================================================== *)

LongExactSequence ::= "LONG_EXACT_SEQUENCE" "{" Identifier { "→" Identifier } "}" ;
TYPING
(* A long exact sequence is simply a sequence that is exact at every internal position. *)
Let S be the sequence A₁ → A₂ → ... → Aₙ
-------------------------------------------------------------------------
Γ ⊢ LONG_EXACT_SEQUENCE {S} is TRUE if (∀ i ∈ {2..n-1}, S is EXACT_AT Aᵢ) ;
CATEGORY
[[ LONG_EXACT_SEQUENCE {...} ]] = "A sequence of objects and morphisms, often infinite, which is exact at every position. Long exact sequences are the primary tool for relating the homology or cohomology groups of different objects and are central to algebraic topology and homological algebra." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.9, 1.10: Diagram chasing & The Five Lemma" ")" "==>" {
(*

ELABORATION: These sections introduce a powerful proof technique—diagram chasing—and its most
famous consequences, such as the Five Lemma and the Snake Lemma. A deep elaboration must
formalize the proof technique itself and then use it to justify the assertions of the lemmas.

Our elaboration will proceed by:

Formalizing the Technique: We will create a meta-rule, ProofByDiagramChase, that represents
the application of this element-wise reasoning. Its validity will be explicitly predicated on the
Freyd-Mitchell Embedding Theorem, which is the theoretical justification for the technique. This
makes the proof method itself a formal object in our grammar.

Formalizing the Setup: We will define a DiagrammaticAssertion which encapsulates the
data for a diagrammatic lemma: a commutative diagram with specific exactness properties.

Formalizing the Lemmas as Theorems: We will state the Five Lemma, the Snake Lemma, and the
3x3 Lemma as formal TheoremDeclarations. Each theorem will assert that given a specific
DiagrammaticAssertion (the premises), a certain conclusion holds.

Connecting Technique to Theorem: We will assert that the proof of each of these theorems
is a ProofByDiagramChase. This formally links the abstract statement of the lemma to the
concrete (though meta-mathematical) method used to prove it, providing a complete and rigorous
formalization of the section's content.

*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Proof Technique == )
( ========================================================================================================== *)

ProofByDiagramChase ::= "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;
TYPING
(*
* This defines the proof technique as a valid meta-level inference rule. The rule is only sound
* because the Freyd-Mitchell Embedding Theorem guarantees we can treat the objects and morphisms
* as if they were modules and homomorphisms, where chasing elements makes sense.
*)
Context: Current category C is ABELIAN.
Γ ⊢ FreydMitchellEmbeddingTheorem is valid.
-----------------------------------------------------
Γ ⊢ PROOF by DIAGRAM_CHASE ... : SoundProofTechnique ;
CATEGORY
[[ PROOF by DIAGRAM_CHASE ... ]] = "A meta-mathematical proof object. It represents a a proof that proceeds by treating morphisms in an abstract abelian category as functions between sets/modules and 'chasing' elements through the diagram. Its soundness is guaranteed by the deep Freyd-Mitchell Embedding Theorem." ;

(* ========================================================================================================== )
( == Part 2: Formalizing the Lemmas == )
( ========================================================================================================== *)

DiagrammaticAssertion ::= "DIAGRAMMATIC_ASSERTION" string_literal "{" "Diagram" ":" DiagramDeclaration "," "Premises" ":" {Proposition} "}" ;
TYPING
(* This structure holds the premises for a diagrammatic lemma. *)
Γ ⊢ diag : DiagramDeclaration
∀ p ∈ Premises, Γ ⊢ p : Proposition
---------------------------------------------------------
Γ ⊢ DIAGRAMMATIC_ASSERTION ... : SetOfPremises ;
CATEGORY
[[ DIAGRAMMATIC_ASSERTION ... ]] = "The complete set of premises for a diagrammatic lemma, specifying the shape of the diagram, its commutativity, and the exactness of its sequences." ;

TheoremDeclaration_FromDiagramChase ::= "THEOREM" string_literal ":" "(" DiagrammaticAssertion "⇒" Proposition ")" "proven_by" ProofByDiagramChase ;
TYPING
(* This links a theorem to its proof method. *)
Γ ⊢ premises : SetOfPremises
Γ ⊢ conclusion : Proposition
Γ ⊢ proof_method : SoundProofTechnique
IsSound(premises, conclusion, proof_method)
---------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ... proven_by DIAGRAM_CHASE ]] = "A formal theorem whose provided justification is a diagram chase. This explicitly grounds the theorem's validity in the element-wise reasoning permitted by the ambient abelian category." ;

(* --- Concrete Instance: The Five Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "TheFiveLemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "FiveLemmaSetup" "{"
"Diagram" ":" "The standard 5-column commutative diagram with two rows" ","
"Premises" ":" "{" "Top row is EXACT_SEQUENCE" "," "Bottom row is EXACT_SEQUENCE" ","
"f1 is ISO" "," "f2 is ISO" "," "f4 is ISO" "," "f5 is ISO" "}"
"}"
"⇒"
"f3 is ISOMORPHISM"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

(* --- Concrete Instance: The Snake Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "TheSnakeLemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "SnakeLemmaSetup" "{"
"Diagram" ":" "A 2x3 commutative diagram with vertical maps" ","
"Premises" ":" "{" "Rows are short exact sequences" "}"
"}"
"⇒"
"( ∃ connecting_homomorphism δ:ker(h)→coker(f) s.t. the resulting 6-term sequence is EXACT )"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

(* --- Concrete Instance: The 3x3 Lemma --- *)
TheoremDeclaration_FromDiagramChase ::= "THEOREM" "The3x3Lemma" ":" "("
"DIAGRAMMATIC_ASSERTION" "3x3LemmaSetup" "{"
"Diagram" ":" "A 3x3 commutative diagram" ","
"Premises" ":" "{" "All columns are SES" "," "Bottom two rows are SES" "}"
"}"
"⇒"
"(Top row is also a SES)"
")" "proven_by" "PROOF" "by" "DIAGRAM_CHASE" "justified_by" "FreydMitchellEmbeddingTheorem" ;

}

(* ELABORATION: This section defines "exact functors" in the rich context of abelian categories.
While the general notion of a functor preserving certain limits/colimits has been seen before,
the abelian setting provides a much sharper and more powerful characterization. An exact functor
is the "correct" type of morphism between abelian categories, as it preserves the structure of
short exact sequences, which are the fundamental building blocks of homological algebra.

A deep elaboration will proceed by:

Formalizing Half-Exactness: We will define LEFT_EXACT and RIGHT_EXACT functors in this specific context and state their powerful criterion: a functor is left exact if and only if it preserves kernels, and dually for right exactness and cokernels.

Formalizing Full Exactness: We will define an EXACT functor as one that is both left and right exact, and then state the main theorem: this algebraic condition is precisely equivalent to the preservation of all short exact sequences.

Analyzing the Canonical Example (Hom Functor): We will deeply analyze the exactness properties of the Hom functor. We will prove that the covariant Hom functor is always left exact.

Connecting to Projectives/Injectives: We will close the loop with previous chapters by showing that the condition under which the Hom functor becomes fully exact is precisely the definition of projective (or injective) objects. This reveals that projectivity/injectivity are "exactness conditions" on the Hom functor, a profound insight.
*)

(* ========================================================================================================== )
( == Part 1: Half-Exact Functors and their Criteria == )
( ========================================================================================================== *)
(In an abelian category, the general test for preserving finite limits/colimits simplifies dramatically.)

FunctorProperty ::= Identifier "is" "LEFT_EXACT_in_Abelian" ;
TYPING
(*
* In an additive category, a functor automatically preserves finite products/coproducts (biproducts)
* iff it is additive. As an abelian category has all finite limits constructed from products and kernels,
* the test for left exactness reduces to checking if the functor preserves kernels.
*)
Γ ⊢ F : Functor(C, D), Γ ⊢ C, D : ADDITIVE_CATEGORY
Γ ⊢ C, D : have all Kernels
---------------------------------------------------------------------------------
(Γ ⊢ F is LEFT_EXACT) <==> (Γ ⊢ F preserves KERNELS) ;
CATEGORY
[[ F is LEFT_EXACT_in_Abelian ]] = "A functor that preserves the limit-based part of the homological structure. The equivalence with kernel preservation provides a simple and powerful test for this property. The covariant Hom functor Hom(A,-) is the canonical example." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "LEFT_EXACT_in_Abelian" "IS" "RIGHT_EXACT_in_Abelian" ;

FunctorProperty ::= Identifier "is" "RIGHT_EXACT_in_Abelian" ;
TYPING
(* Derived via duality. A functor is right exact iff it preserves cokernels. *)
IsDualOf("LEFT_EXACT_in_Abelian")
----------------------------------------------------------------------------------
(Γ ⊢ F is RIGHT_EXACT) <==> (Γ ⊢ F preserves COKERNELS) ;
CATEGORY
[[ F is RIGHT_EXACT_in_Abelian ]] = "A functor that preserves the colimit-based part of the homological structure. The equivalence with cokernel preservation is the dual test. The tensor product functor A⊗- is the canonical example." ;

(* ========================================================================================================== )
( == Part 2: Full Exactness and Short Exact Sequences == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "is" "EXACT_FUNCTOR_in_Abelian" ;
TYPING
(* An exact functor is one that is both left and right exact. *)
Γ ⊢ F is LEFT_EXACT_in_Abelian
Γ ⊢ F is RIGHT_EXACT_in_Abelian
------------------------------------------
Γ ⊢ F is EXACT_FUNCTOR_in_Abelian ;
CATEGORY
[[ F is EXACT_FUNCTOR_in_Abelian ]] = "A functor that preserves all the fundamental homological structure of its domain. This is the strongest and most desirable property for a functor in homological algebra." ;

TheoremDeclaration ::= "THEOREM" "ExactnessViaShortExactSequences" ":"
"A functor F between Abelian Categories is EXACT"
"<==>"
"F sends Short Exact Sequences to Short Exact Sequences." ;
TYPING
(* This theorem shows that preserving the atomic 'SES' structure is equivalent to preserving all finite limits and colimits. *)
Context: Γ ⊢ F : Functor(C, D) between ABELIAN_CATEGORY C, D
P1 := (Γ ⊢ F is EXACT_FUNCTOR_in_Abelian)
P2 := (∀(s : SES in C), (F(s) is SES in D))
-------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM ExactnessViaShortExactSequences ]] = "A fundamental theorem connecting the algebraic definition of exactness (preserving kernels and cokernels) to the sequence-based definition. It confirms that the short exact sequence is the essential structure that an exact functor must preserve." ;

(* ========================================================================================================== )
( == Part 3 & 4: The Hom Functor, Projectives, and Injectives == )
( ========================================================================================================== *)
(This connects the abstract theory back to core examples and previously defined concepts.)

TheoremDeclaration ::= "THEOREM" "CovariantHomIsLeftExact" ":"
"For any object A in an Abelian Category C, the functor Hom_C(A, -): C → Ab is LEFT_EXACT." ;
TYPING
(*
* Proof sketch: We must show F=Hom(A,-) preserves kernels. Let k:K→B be ker(g:B→C).
* We must show F(k) is ker(F(g)). This means the sequence 0 → Hom(A,K) → Hom(A,B) → Hom(A,C)
* is exact in Ab, which is precisely the definition of the kernel K's universal property.
*)
Context: Γ ⊢ C is ABELIAN_CATEGORY, Γ ⊢ A : Object_in(C)
F := Hom_C(A,-)
-----------------------------------
Γ ⊢ F is LEFT_EXACT : ProvableProposition ;
CATEGORY
[[ THEOREM CovariantHomIsLeftExact ]] = "A cornerstone result of homological algebra. It asserts that the representable functor Hom(A,-) is always left exact. This property stems directly from the universal property of the kernel." ;

TheoremDeclaration ::= "THEOREM" "ExactHomCharacterizesProjectives" ":"
"An object P in an Abelian Category C is PROJECTIVE"
"<==>"
"the functor Hom_C(P, -) is EXACT." ;
TYPING
(*
* A functor is exact if it's left exact AND right exact. We already know Hom(P,-) is left exact.
* So it's exact iff it's right exact, which means it sends epis to epis.
* Hom(P,-) sending an epi e:A→B to an epi means Hom(P,A)→Hom(P,B) is surjective.
* This surjectivity is precisely the 'lifting property' that defines a projective object P.
*)
Context: Γ ⊢ P : Object_in(AbelianCategory C)
P1 := (Γ ⊢ P is PROJECTIVE_OBJECT)
P2 := (Γ ⊢ Hom_C(P,-) is EXACT_FUNCTOR_in_Abelian)
----------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM ExactHomCharacterizesProjectives ]] = "A deep characterization of projective objects. It reveals that projectivity is not an arbitrary lifting property, but is precisely the condition required to make the covariant Hom functor fully exact. A projective object is an object 'from which' the process of representation is homologically perfect." ;

DualTheoremInference ::= "INFER_DUAL_THEORY" "'InjectiveTheoryFromHom'" "FROM" "THEORY" "'ProjectiveTheoryFromHom'" ;
TYPING
(* By applying the duality functor (-)^op to the entire theory block for covariant Hom, we get the dual theory. )
( 1. Covariant Hom(A,-) -> Contravariant Hom(-,A) )
( 2. LEFT_EXACT -> LEFT_EXACT (this is a tricky self-dual concept under f^op, but the property holds) )
( 3. PROJECTIVE -> INJECTIVE )
( 4. EXACT -> EXACT )
( The results are: )
( Thm 1: Contravariant Hom(-,I) is always LEFT_EXACT. )
( Thm 2: An object I is INJECTIVE iff the functor Hom_C(-,I) is EXACT. *)
Γ ⊢ TheoryBlock["ProjectiveTheoryFromHom"] : CoherentTheoryFragment
--------------------------------------------------------------------
Γ ⊢ TheoryBlock["InjectiveTheoryFromHom"] := (TheoryBlock["ProjectiveTheoryFromHom"])^op ;
CATEGORY
[[ INFER_DUAL_THEORY ... ]] = "A constructive proof of the corresponding theory for injective objects. It asserts that the contravariant Hom functor is always left exact, and that injective objects are precisely those objects for which the contravariant Hom functor is fully exact. This reveals injectivity as the condition for a 'perfect receiver' in homological algebra." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.12: Torsion theories" ")" "==>" {
(*

ELABORATION: This section defines a "torsion theory," a powerful concept that generalizes the
decomposition of an abelian group into its torsion subgroup and torsion-free quotient. A torsion theory
provides a canonical way to split any object in an abelian category into a "torsion part" and a
"torsion-free part." A deep elaboration requires deconstructing this concept into its essential
components: the orthogonality of the classes, the universal decomposition, and the resulting closure
and reflectivity properties.

Our elaboration will proceed by:

Formalizing the Core Orthogonality: We will define the fundamental relationship between the torsion class (T) and the torsion-free class (F): the fact that there are no non-trivial morphisms between them.

Formalizing the Universal Decomposition: The purpose of a torsion theory is to guarantee that every object X fits into a canonical short exact sequence 0 → tX → X → fX → 0, where tX is its maximal torsion subobject and fX is its maximal torsion-free quotient. We will formalize this structure.

Constructing the Master Definition: We will combine orthogonality and universal decomposition into the complete, formal definition of a Torsion Theory.

Stating the Characterization Theorem: We will formalize the powerful theorem that characterizes a torsion theory by the closure properties of its constituent classes (e.g., the torsion class is closed under quotients). This provides an alternative, structural way to define and identify torsion theories.

Connecting to Adjunctions: We will reveal the deep connection to the theory of reflective subcategories by stating the theorem that a torsion theory (T,F) implies that T is a coreflective subcategory and F is a reflective subcategory.

*)

(* ========================================================================================================== )
( == Part 1: The Core Orthogonality Condition == )
( ========================================================================================================== *)

OrthogonalObjectClasses ::= Identifier "⊥" Identifier ;
TYPING
(*
* This predicate defines the core relationship between the two classes T and F.
* They are orthogonal if the Hom-set between any object in T and any object in F is the zero object.
*)
Γ ⊢ T, F : ClassOfObjects(C)
Condition := ∀ (A ∈ T), ∀ (B ∈ F), (Hom_C(A, B) ≅ {0})
---------------------------------------------------
Γ ⊢ (T ⊥ F) is TRUE if Condition holds : Proposition ;
CATEGORY
[[ T ⊥ F ]] = "The assertion of Hom-orthogonality. It states that from the perspective of the torsion-free objects, all torsion objects are trivial (isomorphic to the zero object), and dually. This is the fundamental separation property of a torsion theory." ;

(* ========================================================================================================== )
( == Part 2: The Universal Decomposition Sequence == )
( ========================================================================================================== *)

TorsionShortExactSequence ::= "TorsionSES_for" "(" Identifier ")" "decomposes_as" "(" Identifier "," Identifier ")" ;
TYPING
(*
* This rule asserts the existence of the canonical short exact sequence for an object X.
* This SES defines the maximal torsion subobject tX and the maximal torsion-free quotient fX.
*)
Γ ⊢ X : Object_in(AbelianCategory C)
Γ ⊢ T, F : ClassOfObjects(C)
----------------------------------------------------------------------------------------------------------------------
Γ ⊢ TorsionSES_for(X) ... is TRUE if ( ∃ SES "0 → tX → X → fX → 0" s.t. (tX ∈ T) ∧ (fX ∈ F) ) ;
CATEGORY
[[ TorsionSES_for(X) ... ]] = "The canonical short exact sequence associated with object X by the torsion theory. The object tX is the 'torsion radical' of X, and fX is its 'torsion-free part'. The existence and uniqueness (up to isomorphism) of this sequence for every object is the central utility of the theory." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition of a Torsion Theory == )
( ========================================================================================================== *)

TorsionTheoryDeclaration ::= "TORSION_THEORY" "(" "Torsion" ":" Identifier "," "Free" ":" Identifier ")" ;
TYPING
(*
* A pair of classes (T,F) forms a torsion theory if it satisfies both the orthogonality
* and the decomposition conditions.
*)
Γ ⊢ T, F : ClassOfObjects(AbelianCategory C)
Premise1: Γ ⊢ T ⊥ F
Premise2: ∀ X ∈ Ob(C), (Γ ⊢ TorsionSES_for(X) decomposes_as(T,F))
------------------------------------------------------------------
Γ ⊢ TORSION_THEORY (Torsion:T, Free:F) : ValidTorsionTheory ;
CATEGORY
[[ TORSION_THEORY (T, F) ]] = "A canonical decomposition of an abelian category into two orthogonal classes such that every object has a unique resolution into a subobject from one class and a quotient from the other. It is a fundamental organizing principle for abelian categories." ;

(* ========================================================================================================== )
( == Part 4: The Characterization via Closure Properties == )
( ========================================================================================================== *)

ClassClosedUnder ::= Identifier "is_closed_under" ("QUOTIENTS" | "COPRODUCTS" | "SUBOBJECTS" | "PRODUCTS" | "EXTENSIONS") ;
TYPING
(* Defines various closure properties for a class of objects. *)
Γ ⊢ A : ClassOfObjects(AbelianCategory C)
CASE "QUOTIENTS": ∀(a∈A, e:a→x is EPI), x∈A
CASE "COPRODUCTS": ∀({a_i}⊆A), Coproduct({a_i})∈A
CASE "SUBOBJECTS": ∀(a∈A, m:x→a is MONO), x∈A
CASE "PRODUCTS": ∀({a_i}⊆A), Product({a_i})∈A
CASE "EXTENSIONS": ∀(SES 0→A→B→C→0), (A∈A ∧ C∈A) ⇒ B∈A
-----------------------------------------------------
Γ ⊢ A is_closed_under ... : PropositionAbout(A) ;
CATEGORY
[[ A is_closed_under ... ]] = "A statement about the stability of the class A with respect to a standard categorical construction. These properties reveal the structural nature of the class." ;

TheoremDeclaration ::= "THEOREM" "TorsionTheoryClosureCriterion" ":"
"A pair (T,F) is a TORSION_THEORY IFF"
"(" "T is_closed_under QUOTIENTS and COPRODUCTS, and"
"F is_closed_under SUBOBJECTS and PRODUCTS" ")" ;
TYPING
(* This is a standard characterization theorem for torsion theories. *)
P1 := (Γ ⊢ TORSION_THEORY(T, F))
P2 := ( Γ ⊢ T is_closed_under QUOTIENTS ∧ Γ ⊢ T is_closed_under COPRODUCTS ∧
Γ ⊢ F is_closed_under SUBOBJECTS ∧ Γ ⊢ F is_closed_under PRODUCTS )
-------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM TorsionTheoryClosureCriterion ]] = "A key structural theorem that provides an alternative definition for a torsion theory. It asserts that the universal decomposition property is equivalent to a specific set of closure properties for the two classes. This often provides a more direct way to prove that a given pair constitutes a torsion theory." ;

(* ========================================================================================================== )
(* == Part 5: The Connection to Reflective Subcategories == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "TorsionClassesInduceAdjunctions" ":"
"IF (T,F) is a TORSION_THEORY in C, THEN"
"(" "T is a COREFLECTIVE subcategory of C, and"
" F is a REFLECTIVE subcategory of C." ")" ;
TYPING
(*
* This theorem reveals the deep connection between torsion theories and adjunctions.
* The decomposition provides the universal arrows for the reflections.
*)
Context: (T,F) is a TORSION_THEORY in C.
For object X, the SES is 0 → tX → X → fX → 0.
Conclusion1: F is REFLECTIVE_IN C.
Reflector Functor L(X) := fX.
Reflection Arrow η_X := the map X → fX.
Conclusion2: T is COREFLECTIVE_IN C.
Coreflector Functor R(X) := tX.
Coreflection Arrow ε_X := the map tX → X.
-----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM TorsionClassesInduceAdjunctions ]] = "A fundamental result that recasts the concept of a torsion theory in the language of adjunctions. It asserts that the torsion-free class F is a reflective subcategory, where the reflector functor L sends an object X to its maximal torsion-free quotient fX. Dually, the torsion class T is a coreflective subcategory, where the coreflector functor R sends X to its maximal torsion subobject tX. This provides a powerful, modern perspective on the structure of torsion theories." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.13: Finitizations of abelian categories" ")" "==>" {
(*

ELABORATION: This section provides a formal way to talk about the "finite" part of a large
abelian category. The key insight is that "finiteness" is not about the number of objects, but about
how objects are constructed. An object is "finitely presented" if it can be described by a finite
number of generators and a finite number of relations. The main result is that the collection of all
such objects forms a self-contained, well-behaved subcategory which is itself abelian.

A deep elaboration requires deconstructing this concept step-by-step:

Finitely Generated: We first formalize the weaker notion of a "finitely generated" object,
which is an object that can be constructed as a quotient of a finite "building block".

Finitely Presented: We then build upon this to define a "finitely presented" object, which
is finitely generated, and where the "relations" needed to construct it are also finitely generated.

The Finitization Construction: We formalize the construction of the "finitization" of a
category C as the full subcategory C_fp consisting of all finitely presented objects.

The Main Theorem: We state the crucial theorem: this subcategory C_fp is itself an abelian
category. This ensures that the 'finite part' of an abelian category is a well-behaved world
where homological algebra can be done.

This approach reveals that the finitization is a canonical way to extract the core algebraic essence
of a larger abelian category.
*)

(* ========================================================================================================== )
( == Part 1: The Building Block - Finitely Generated Objects == )
( ========================================================================================================== *)

Biproduct_Power ::= Identifier "^" integer_literal ;
TYPING
(* This syntactic rule defines the n-th biproduct power of an object G. *)
Γ ⊢ G : Object_in(ADDITIVE_CATEGORY C)
Γ ⊢ n : integer_literal, n ≥ 0
-----------------------------------------------------------------
Γ ⊢ G^n : Object_in(C) (defined as G ⊕ G ⊕ ... ⊕ G, n times) ;
CATEGORY
[[ G^n ]] = "The n-fold biproduct of the object G. In R-Mod, if G is the ring R, this is the free module Rⁿ." ;

ObjectPropertyAssertion ::= Identifier "is" "FINITELY_GENERATED" "by" Identifier ;
TYPING
(*
* An object X is finitely generated by G if it is a quotient of some finite power of G.
* The object G is typically a generator for the category.
)
Γ ⊢ X : Object_in(ADDITIVE_CATEGORY C)
Γ ⊢ G : Object_in(C) ( G is usually a generator object *)
Condition := ∃ (n ∈ ℕ) s.t. ( ∃ (e : G^n → X is EPIMORPHISM) )
------------------------------------------------------------------------------------
Γ ⊢ X is FINITELY_GENERATED by G is TRUE if Condition holds ;
CATEGORY
[[ X is FINITELY_GENERATED by G ]] = "The property that the object X can be completely described by a finite amount of information from the generator G. It is 'spanned' by a finite number of elements of G." ;

(* ========================================================================================================== )
( == Part 2: The Core Concept - Finitely Presented Objects == )
( ========================================================================================================== *)

ObjectPropertyAssertion ::= Identifier "is" "FINITELY_PRESENTED" ;
TYPING
(*
* This is the core definition. An object X is finitely presented if it fits into a specific
* kind of exact sequence, called a "finite presentation".
* This sequence shows that X is finitely generated (by P₀) and that the kernel of that
* generation (the "relations") is also finitely generated (by P₁).
*)
Γ ⊢ X : Object_in(ADDITIVE_CATEGORY C)
Let G be a generator for C.
Condition := ∃ (P₁, P₀ are FINITELY_GENERATED by G) s.t.
( ∃ EXACT_SEQUENCE "P₁ → P₀ → X → 0" )
------------------------------------------------------------------------------------
Γ ⊢ X is FINITELY_PRESENTED is TRUE if Condition holds ;
CATEGORY
[[ X is FINITELY_PRESENTED ]] = "The property of an object being determined by both a finite number of generators and a finite number of relations. This is a crucial finiteness condition in algebra, ensuring the object is 'algebraically small' and computable." ;

(* ========================================================================================================== )
( == Part 3: The Main Construction - The Finitization Subcategory == )
( ========================================================================================================== *)

FinitizationSubcategoryCtor ::= "FinitizationOf" "(" Identifier ")" ;
TYPING
(*
* This constructor takes an abelian category C and builds its "finitization", C_fp.
* C_fp is the full subcategory whose objects are precisely the finitely presented objects of C.
*)
Γ ⊢ C : ABELIAN_CATEGORY
FP_Objects := { X ∈ Ob(C) | Γ ⊢ X is FINITELY_PRESENTED }
----------------------------------------------------------------------------------
Γ ⊢ FinitizationOf(C) : FullSubcategory(C) on objects FP_Objects ;
CATEGORY
[[ FinitizationOf(C) ]] = "The finitization of C, denoted C_fp. This subcategory isolates the 'algebraically finite' core of the larger category C. For example, the finitization of R-Mod is the category of finitely presented R-modules." ;

(* ========================================================================================================== )
( == Part 4: The Main Theorem - The Finitization is Abelian == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "FinitizationIsAbelian" ":"
"IF" Identifier "C" "is an ABELIAN_CATEGORY with a generator,"
"THEN" "FinitizationOf(C)" "is an ABELIAN_CATEGORY." ;
TYPING
(*
* This is a deep and powerful theorem. Proving that C_fp is an abelian category requires
* showing that it is closed under all the necessary constructions (biproducts, kernels, cokernels).
* The most difficult part is proving that the kernel of a morphism between two finitely presented
* objects is itself finitely presented.
*)
Premise: Γ ⊢ C is ABELIAN_CATEGORY (with suitable properties like a generator)
--------------------------------------------------------------------------
Conclusion: Γ ⊢ FinitizationOf(C) is ABELIAN_CATEGORY : MetaTheorem ;
CATEGORY
[[ THEOREM FinitizationIsAbelian ]] = "A key closure property in the theory of abelian categories. It guarantees that the collection of finitely presented objects is not just a grab-bag, but a self-contained, well-behaved algebraic universe in which all the powerful tools of homological algebra (like exact sequences and diagram chasing) can be applied. It ensures that finite constructions remain finite." ;

}

(*
ELABORATION: Section 1.14 presents the Freyd-Mitchell Embedding Theorem, one of the most profound
and consequential results in the theory of abelian categories. It is not a theorem within
a category, but a statement about all small abelian categories. Its importance lies in the fact
that it justifies a powerful and intuitive proof technique—diagram chasing—which would otherwise
be informal and potentially invalid.

A deep elaboration requires us to not only state the theorem but to formalize its role as a
justification for this proof method. We will therefore:

Formalize the Theorem: We will state the Freyd-Mitchell Embedding Theorem as a formal
meta-theorem within our grammar, precisely specifying its premises (a small abelian category)
and its conclusion (the existence of a full, faithful, and exact embedding into a category of modules).

Formalize the Consequence: We will then introduce a formal "Justification Axiom." This axiom
will be a meta-level implication, stating that IF the Freyd-Mitchell Embedding Theorem is true,
THEN the technique of diagram chasing is a valid and sound method of proof.

Formalize the Technique: Finally, we will re-state the ProofByDiagramChase construct,
explicitly showing that its own validity is contingent on the Justification Axiom.

This approach transforms the theorem from a mere statement of fact into the foundational pillar that
supports the entire edifice of element-based reasoning in abstract homological algebra.
*)

(* ========================================================================================================== )
( == Part 1: The Freyd-Mitchell Embedding Theorem (The Statement) == )
(* ========================================================================================================== *)

FreydMitchellEmbeddingTheorem ::= "THEOREM" "FreydMitchellEmbedding" ":"
"FOR_ALL small abelian category A,"
"∃ Ring R and ∃ Functor F: A → R-Mod s.t."
"F is FULLY_FAITHFUL and EXACT." ;
TYPING
(*
* This is a meta-theorem about the structure of all small abelian categories.
* It is asserted as a foundational axiom of our meta-theory.
*)
Premise: Γ ⊢ A : ABELIAN_CATEGORY, Γ ⊢ A is SMALL
-----------------------------------------------------------------------------------------
Conclusion: ∃ (R:Ring, F:Functor(A,Category(R-Mod))) s.t. (F is FULLY_FAITHFUL ∧ F is EXACT_FUNCTOR) ;
CATEGORY
[[ THEOREM FreydMitchellEmbedding ]] = "A foundational meta-theorem asserting the existence of a concrete representation for any abstract small abelian category. It guarantees that the objects and morphisms of A, no matter how abstractly defined, behave precisely as if they were modules and module homomorphisms. This is the bridge between the abstract and concrete worlds of homological algebra." ;

(* ========================================================================================================== )
( == Part 2: The Justification Axiom (The Consequence) == )
(* ========================================================================================================== *)

DiagramChasingJustificationAxiom ::= "JUSTIFICATION_AXIOM" ":" FreydMitchellEmbeddingTheorem "==>" "DiagramChasing_is_SOUND_TECHNIQUE" ;
TYPING
(*
* This is a meta-level inference rule. It states that the truth of the embedding theorem
* directly implies the soundness of diagram chasing as a proof method.
*)
Γ ⊢ FreydMitchellEmbeddingTheorem is TRUE
-------------------------------------------------
Γ ⊢ DiagramChasing_is_SOUND_TECHNIQUE : Proposition ;
CATEGORY
[[ JUSTIFICATION_AXIOM ... ]] = "A meta-inference rule that connects the existence theorem to a specific proof methodology. It formalizes the logical step: 'Because any small abelian category behaves like a category of modules, we are justified in reasoning about its morphisms as if they were functions and its objects as if they had elements.'" ;

(* ========================================================================================================== )
( == Part 3: The Proof Technique Itself (The Application) == )
(* ========================================================================================================== *)

ProofByDiagramChase ::= "PROOF" "by" "DIAGRAM_CHASE" ;
TYPING
(*
* This rule represents the application of the proof technique. Its own validity as a step in
* a larger proof rests on the justification axiom.
)
Premise1: The proposition P to be proven is a statement about a diagram in an ABELIAN_CATEGORY.
Premise2: Γ ⊢ DiagramChasing_is_SOUND_TECHNIQUE ( From the Justification Axiom )
Premise3: An element-wise proof of P exists. ( An oracle check that the chase is correct *)
-------------------------------------------------------------------------------------------------
Γ ⊢ (PROOF by DIAGRAM_CHASE proves P) : ValidProofStep ;
CATEGORY
[[ PROOF by DIAGRAM_CHASE ]] = "The application of the justified proof technique. It represents the act of transporting the diagrammatic problem into a concrete category of modules (via the guaranteed embedding F), performing an element-wise proof there, and then reflecting the conclusion back into the abstract category. The properties of the embedding (full, faithful, exact) guarantee this reflection is valid." ;


MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 2: 'Regular categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {
MetaDirectiveAnalysis ::= "(" "Elaborate on Section 2.1 & 2.2: The Definition and Properties of a Regular Category" ")" "==>" {
(*
ELABORATION: A regular category is a crucial generalization of an abelian category to a non-additive
setting like Set or Grp. It captures the essential 'exactness' properties needed for a good theory of
images and equivalence relations. A deep elaboration requires deconstructing its definition into three
fundamental pillars:

Existence of Structure: The category must have a basic level of structure, namely all finite limits (products, equalizers, pullbacks).

Well-behaved Quotients: There must be a well-defined class of "surjective-like" maps, the regular epimorphisms, which form a factorization system with monomorphisms. A regular epimorphism is one that arises as a coequalizer.

Coherence of Structure: The limit structure and the quotient structure must be compatible. This is captured by the crucial axiom that regular epimorphisms are stable under pullback.

Our formalization will build the master definition of a regular category from these three axioms and then state the key theorem that in such a category, regular epimorphisms are always strong epimorphisms, clarifying their nature.
*)

(* --- Pillar 1: Basic Structure (Finite Limits) --- )
CategoryPropertyDefinition ::= Identifier "has" "FINITE_LIMITS" ;
TYPING
( A category has finite limits if it has a terminal object and all pullbacks. *)
Γ ⊢ C : Category
Γ ⊢ C has TerminalObject
Γ ⊢ C has AllPullbacks
-------------------------------------------------
Γ ⊢ C has FINITE_LIMITS : PropositionAbout(C) ;
CATEGORY
[[ C has FINITE_LIMITS ]] = "The foundational property ensuring the category has enough structure to support products, equalizers, and kernel pairs." ;

(* --- Pillar 2: Well-behaved Quotients (Regular Epis & Factorization) --- )
MorphismPropertyAssertion ::= Identifier "is" "REGULAR_EPIMORPHISM" ;
TYPING
( A morphism e is a regular epimorphism if it is the coequalizer of some parallel pair of morphisms. *)
Γ ⊢ e : A -> B
Condition := ∃ (f,g : X -> A) s.t. (e ≅ Coequalizer(f, g))
-----------------------------------------------------------------
Γ ⊢ e is REGULAR_EPIMORPHISM is TRUE if Condition holds ;
CATEGORY
[[ e is REGULAR_EPIMORPHISM ]] = "A well-behaved epimorphism that arises as a quotient. This is the correct notion of 'surjection' in a regular category." ;

(* --- Pillar 3: Coherence (Pullback Stability) --- )
ClassProperty_IsStableUnderPullback ::= Identifier "is" "STABLE_UNDER_PULLBACK" ;
TYPING
( This predicate asserts that a class of morphisms E has the pullback stability property. *)
Γ ⊢ E : ClassOfMorphisms
Condition := ∀ (e: A→B in E), ∀ (f: C→B),
Let (p: P→C) be the pullback of e along f,
Then (p ∈ E)
-----------------------------------------------------------------------------
Γ ⊢ E is STABLE_UNDER_PULLBACK is TRUE if Condition holds ;
CATEGORY
[[ E is STABLE_UNDER_PULLBACK ]] = "A crucial coherence condition. It ensures that the property of being in class E (e.g., being a regular epimorphism) is preserved when changing the base of the morphism via pullback." ;

(* --- The Master Definition --- )
RegularCategoryDeclaration ::= "REGULAR_CATEGORY" Identifier ;
TYPING
( A category is regular if it satisfies the three pillars. *)
Γ ⊢ C : Category
Premise1: Γ ⊢ C has FINITE_LIMITS
Premise2: C has a FACTORIZATION_SYSTEM(RegularEpi, Mono)
Premise3: The class RegularEpi is STABLE_UNDER_PULLBACK in C
-------------------------------------------------------------
Γ ⊢ C is REGULAR_CATEGORY ;
CATEGORY
[[ C is REGULAR_CATEGORY ]] = "A category with finite limits and a stable system of quotients (regular epimorphisms). This is the correct setting for a well-behaved theory of relations and exactness in a non-additive context. The category of Sets is the archetypal example." ;

(* --- The Key Property from Section 2.2 --- *)
TheoremDeclaration ::= "THEOREM" "RegularEpisAreStrong" ":"
"IN a" "REGULAR_CATEGORY" "C" "," "every REGULAR_EPIMORPHISM is a STRONG_EPIMORPHISM." ;
TYPING
Context: Γ ⊢ C is REGULAR_CATEGORY
-------------------------------------------------------------------
(Γ ⊢ e is REGULAR_EPIMORPHISM) ⇒ (Γ ⊢ e is STRONG_EPIMORPHISM) : MetaTheorem ;
CATEGORY
[[ THEOREM RegularEpisAreStrong ]] = "A key structural result connecting two important classes of epimorphisms. In a regular category, the constructive property of being a coequalizer implies the abstract diagonal-filler property of being orthogonal to all monomorphisms." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 2.3 & 2.5: Exact Sequences and Equivalence Relations" ")" "==>" {
(*
ELABORATION: This combined elaboration is crucial because, in a regular category, the concepts of "exactness" and "equivalence relation" are deeply intertwined. Unlike in an abelian category, where exactness is defined by Im(f) = Ker(g), here it is defined by the relationship between a quotient map (a regular epimorphism) and its "kernel," which is replaced by the more general notion of a kernel pair.

The main thrust of these sections is to show that a regular category is precisely the right setting to ensure that internal equivalence relations are "effective"—that is, every well-behaved relation gives rise to a well-behaved quotient, and that quotient map perfectly regenerates the original relation as its kernel pair.

Our elaboration will proceed by:

Formalizing the Tools: We will explicitly define the two core concepts: the KernelPairConstructor (which replaces the kernel) and the InternalEquivalenceRelation (the object of study).

Defining the Fundamental Sequence: We will define the canonical "exact sequence" in a regular category: a regular epimorphism presented as the coequalizer of its kernel pair. This is the non-additive analogue of a short exact sequence involving a cokernel.

Stating the Main Theorems: We will formalize the two key theorems that link these concepts:
a. The kernel pair of any regular epimorphism is always an internal equivalence relation.
b. The central theorem: in a regular category, every internal equivalence relation is "effective"—it arises as the kernel pair of its own quotient map (its coequalizer). This is the categorical version of the First Isomorphism Theorem for non-additive structures like sets and groups.
*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Core Concepts == )
( ========================================================================================================== *)

KernelPairConstructor ::= "KernelPair" "(" Identifier ")" ;
TYPING
(*
* A Kernel Pair of f:A->B is the pullback of f with itself. It consists of the object K
* and two projection morphisms k1, k2 which select all pairs of elements of A that
* f maps to the same element in B.
*)
Γ ⊢ f : A -> B in Category with Pullbacks
PullbackSquare(k1:K->A, k2:K->A, f:A->B, f:A->B) exists
----------------------------------------------------------
Γ ⊢ KernelPair(f) : pair(Morphism(K,A)) ;
CATEGORY
[[ KernelPair(f) ]] = "The subobject of the product A×A representing the relation 'is mapped to the same element by f'. The pair of morphisms (k1, k2) forms an internal equivalence relation on A, serving as the correct generalization of a kernel in a non-pointed category." ;

InternalEquivalenceRelation ::= "INTERNAL_EQUIV_RELATION" "(" Identifier "," Identifier ")" "on" Identifier ;
TYPING
(*
* An internal equivalence relation on A is a pair of morphisms (r1,r2) from an object R to A
* such that the induced map <r1,r2>:R->A×A is a monomorphism, and which internally satisfies
* the axioms of an equivalence relation.
*)
Context: C has finite limits. Γ ⊢ A : Object_in(C)
Γ ⊢ r1:R->A, Γ ⊢ r2:R->A s.t. <r1,r2> is MONOMORPHISM.
Axiom_Reflexivity: ∃ (δ:A→R s.t. r1∘δ=id_A ∧ r2∘δ=id_A)
Axiom_Symmetry: ∃ (σ:R→R s.t. r1∘σ=r2 ∧ r2∘σ=r1)
Axiom_Transitivity: Let R' = Pullback(r2,r1). ∃ (τ:R'→R s.t. ...)
------------------------------------------------------------------------------------------
Γ ⊢ INTERNAL_EQUIV_RELATION (r1,r2) on A : Proposition ;
CATEGORY
[[ INTERNAL_EQUIV_RELATION (r1,r2) on A ]] = "A categorical formalization of an equivalence relation on the object A. The object R represents the 'set of related pairs', and the diagrams for reflexivity, symmetry, and transitivity enforce the standard axioms without resorting to a notion of elements." ;

(* ========================================================================================================== )
( == Part 2: The Canonical Exact Sequence in a Regular Category == )
( ========================================================================================================== *)

RegularExactSequenceDeclaration ::= "is_RegularExactSequence" "(" Identifier "," Identifier "," Identifier ")" ;
TYPING
(*
* A sequence K --(k1,k2)--> A --q--> Q is a "regular exact sequence" if q is a regular
* epimorphism and (k1, k2) is its kernel pair. This is the fundamental unit of exactness.
*)
Γ ⊢ k1:K->A, k2:K->A, q:A->Q
Premise1: Γ ⊢ q is REGULAR_EPIMORPHISM
Premise2: Γ ⊢ (k1,k2) ≅ KernelPair(q)
------------------------------------------------
Γ ⊢ is_RegularExactSequence(K, A, Q) : Proposition ;
CATEGORY
[[ is_RegularExactSequence(K,A,Q) ]] = "The assertion that the object Q is the quotient of A by the equivalence relation K. This sequence is the non-additive analogue of the short exact sequence 0 → Ker → A → Coker → 0 in an abelian category." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorems Linking the Concepts == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "KernelPairIsEquivalenceRelation" ":"
"In a category with pullbacks, the KernelPair of any morphism is an INTERNAL_EQUIV_RELATION." ;
TYPING
Γ ⊢ C has Pullbacks
Γ ⊢ f : A -> B
Let (k1,k2) = KernelPair(f)
----------------------------------------------------------------
Γ ⊢ INTERNAL_EQUIV_RELATION (k1,k2) on A : ProvableProposition ;
CATEGORY
[[ THEOREM KernelPairIsEquivalenceRelation ]] = "A foundational result stating that the process of forming a kernel pair always produces a well-behaved internal equivalence relation. This provides the canonical source for such relations in category theory." ;

TheoremDeclaration ::= "THEOREM" "RegularCategoriesHaveEffectiveRelations" ":"
"A category C is REGULAR if and only if C has finite limits, regular epis are stable under pullback,"
"and every INTERNAL_EQUIV_RELATION is effective." ;
TYPING
(*
* This is the refined main theorem. Being 'effective' means the relation gives rise to a quotient
* map for which it is the kernel pair. This connects all the previous definitions.
*)
P1 := (Γ ⊢ C is REGULAR_CATEGORY)
Relation_is_Effective(R) := (Let q=Coequalizer(R). Then (R ≅ KernelPair(q)))
P2 := ( Γ ⊢ C has FINITE_LIMITS ∧ RegularEpis are STABLE_UNDER_PULLBACK ∧ ∀R, Relation_is_Effective(R) )
-------------------------------------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM RegularCategoriesHaveEffectiveRelations ]] = "The central theorem of regular categories. It asserts that the abstract definition of regularity is precisely equivalent to the concrete property that every internal equivalence relation is 'effective'—that is, it arises as the kernel pair of its own quotient map. This guarantees that the process of forming quotients by equivalence relations is robust, well-behaved, and forms a closed system, which is the cornerstone of exactness in non-additive settings." ;
}

(* ========================================================================================================== )
( == Section 2.6: Exact Categories (Barr-Exact) == )
( ========================================================================================================== )
(
ELABORATION: This section introduces "Barr-exact" categories, a crucial strengthening of regular
categories. While a regular category ensures that quotients by equivalence relations exist and are stable,
an exact category adds the final, powerful condition that these quotients are also "well-behaved" with
respect to composition. This seemingly small addition makes the category behave much more like the
category of Sets and is the key to a powerful embedding theorem.

To elaborate, we will:

Formalize the New Axiom: The key new property for an exact category is that the class of regular
epimorphisms is closed under composition. We will formalize this as a distinct, checkable property.

Construct the Master Definition: We will define a BARR_EXACT_CATEGORY by building directly
upon the REGULAR_CATEGORY definition, adding this new axiom. This shows the hierarchical nature
of these categorical structures.

Define the Structure-Preserving Map: We will define the "correct" kind of functor between
exact categories: a BARR_EXACT_FUNCTOR, which preserves all the relevant structure (finite limits
and regular epimorphisms). This sets the stage for the embedding theorem.
*)

(* --- The New Axiom: Stability of Quotients under Composition --- )
ClassProperty_IsClosedUnderComposition ::= Identifier "is" "CLOSED_UNDER_COMPOSITION" ;
TYPING
( This predicate asserts that a class of morphisms is closed under the composition operation. *)
Γ ⊢ E : ClassOfMorphisms
Condition := ∀ (f:A→B ∈ E), ∀ (g:B→C ∈ E), ( (g∘f) ∈ E )
---------------------------------------------------------------------------------
Γ ⊢ E is CLOSED_UNDER_COMPOSITION is TRUE if Condition holds ;
CATEGORY
[[ E is CLOSED_UNDER_COMPOSITION ]] = "A fundamental closure property for a class of morphisms. When applied to regular epimorphisms, it ensures that taking a quotient of a quotient is itself a well-defined quotient." ;

(* --- The Master Definition --- )
BarrExactCategoryDeclaration ::= "BARR_EXACT_CATEGORY" Identifier ;
TYPING
( A category is Barr-exact if it is regular and its regular epis are closed under composition. *)
Γ ⊢ C : Category
Premise1: Γ ⊢ C is REGULAR_CATEGORY
Premise2: The class RegularEpi in C is CLOSED_UNDER_COMPOSITION
----------------------------------------------------------
Γ ⊢ C is BARR_EXACT_CATEGORY ;
CATEGORY
[[ C is BARR_EXACT_CATEGORY ]] = "A category that is not only regular, but where the process of taking quotients is itself regular and stable. This is a very strong exactness condition, met by categories like Set, Grp, and all Toposes. They are the ideal setting for non-abelian, set-like categorical logic." ;

(* --- The Structure-Preserving Functor --- )
BarrExactFunctorDeclaration ::= Identifier "is" "BARR_EXACT_FUNCTOR" ;
TYPING
( This defines the "exact functor" in the context of Barr-exact categories. *)
Γ ⊢ F : Functor(C,D)
Premise1: F preserves FINITE_LIMITS
Premise2: F preserves REGULAR_EPIMORPHISMS
-------------------------------------------
Γ ⊢ F is BARR_EXACT_FUNCTOR ;
CATEGORY
[[ F is BARR_EXACT_FUNCTOR ]] = "The structure-preserving map between exact categories. Such a functor respects both the limit-based structure (products, pullbacks) and the colimit-based quotient structure (regular epimorphisms) of its domain." ;

(* ========================================================================================================== )
( == Section 2.7: An Embedding Theorem (Barr's Theorem) == )
( ========================================================================================================== )
(
ELABORATION: This section states Barr's Embedding Theorem, the non-additive analogue of the famous
Freyd-Mitchell theorem for abelian categories. It provides the ultimate justification for using
set-theoretic, "element-based" intuition and reasoning when working in an abstract exact category.
A deep elaboration must formalize both the theorem and its crucial consequence.
*)

(* --- The Statement of the Theorem --- )
BarrEmbeddingTheorem ::= "THEOREM" "BarrEmbedding" ":"
"FOR_ALL small exact category C,"
"∃ a full, faithful, and exact embedding Functor F: C → Psh(K) for some category K." ;
TYPING
( This is a meta-theorem about the structure of all small exact categories. *)
Premise: Γ ⊢ C : BARR_EXACT_CATEGORY, Γ ⊢ C is SMALL
---------------------------------------------------------------------------------------
Conclusion: ∃ (K:Category, F:Functor(C, Psh(K))) s.t.
(F is FULLY_FAITHFUL) ∧ (F is BARR_EXACT_FUNCTOR) ;
CATEGORY
[[ THEOREM BarrEmbedding ]] = "A foundational meta-theorem asserting that any abstract small exact category behaves precisely as if it were a special category of presheaves (set-valued functors). This theorem justifies using element-like reasoning when working in an exact category, as it guarantees a concrete representation exists. It plays a role analogous to the Freyd-Mitchell theorem for abelian categories." ;

(* --- The Consequence: Justification for Element-Based Reasoning --- )
ElementLikeReasoningJustificationAxiom ::= "JUSTIFICATION_AXIOM" ":" BarrEmbeddingTheorem "==>" "'GeneralizedElementReasoning_is_SOUND_in_ExactCats'" ;
TYPING
( This formalizes the main takeaway from the theorem. *)
Γ ⊢ BarrEmbeddingTheorem is TRUE
-------------------------------------------------
Γ ⊢ "Reasoning via generalized elements in Exact Cats is sound" : Proposition ;
CATEGORY
[[ JUSTIFICATION_AXIOM ... ]] = "A meta-inference rule that connects the existence theorem to a specific proof methodology. It formalizes the logical step: 'Because any small exact category behaves like a category of presheaves (which have 'generalized elements' via the Yoneda Lemma), we are justified in using set-based intuition and element-chasing arguments for proofs within this abstract setting.'" ;

MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 3: 'Algebraic theories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.1: The calculus of relations" ")" "==>" {
(*
ELABORATION: This section formalizes the concept of a "relation" in a regular category. A relation
is no longer a subset of a Cartesian product, but a subobject of a categorical product. The "calculus"
refers to the operations for composing and manipulating these relations. A deep elaboration requires
us to define a relation constructively, then define its composition in terms of the fundamental
categorical operations of pullbacks and images, and finally to show that these operations give rise
to a new categorical structure.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition of a Relation == )
( ========================================================================================================== *)

RelationDeclaration ::= Identifier "is_a" "RELATION" "from" Identifier "to" Identifier ;
TYPING
(*

A relation R from A to B is formally defined as a subobject of their product, A × B.

This requires the ambient category C to have finite products, a property guaranteed by

the assumption that C is a regular category.
*)
Context: C is a REGULAR_CATEGORY
Γ ⊢ A, B : Object_in(C)

Γ ⊢ R is_a RELATION from A to B <==> (Γ ⊢ R : SubobjectOf(A × B)) ;
CATEGORY
[[ R is_a RELATION from A to B ]] = "A categorical relation. It is a subobject of the product A×B, which generalizes the set-theoretic notion of a subset of a Cartesian product. The subobject represents the 'graph' of the relation." ;

(* ========================================================================================================== )
( == Part 2: The Core "Calculus" Operation: Composition == )
( ========================================================================================================== *)

RelationComposition ::= RelationDeclaration "∘" RelationDeclaration ;
TYPING
(*

The composition of a relation S:A⇸B with a relation R:B⇸C is defined by a pullback-then-image construction.

This construction is the categorical analogue of the set-theoretic definition:

R∘S = { (a,c) | ∃b s.t. (a,b)∈S and (b,c)∈R }

The pullback finds all such triples (a,b,c) and the image projects out the (a,c) pairs.

This requires the ambient category to be regular, which guarantees it has both pullbacks and images.
*)
Context: C is a REGULAR_CATEGORY
Γ ⊢ S : RELATION from A to B (represented by mono m_S: S_obj → A×B)
Γ ⊢ R : RELATION from B to C (represented by mono m_R: R_obj → B×C)
-- Step 1: Find the common 'b' values via pullback.
p_B_S := proj_B ∘ m_S : S_obj → B
p_B_R := proj_B ∘ m_R : R_obj → B
P_obj := PullbackObject(p_B_S, p_B_R)
-- Step 2: Project the results into A×C.
map_to_A := proj_A ∘ m_S ∘ proj_S(P_obj) : P_obj → A
map_to_C := proj_C ∘ m_R ∘ proj_R(P_obj) : P_obj → C
composite_map := <map_to_A, map_to_C> : P_obj → A×C
-- Step 3: The composition is the image of this map.

Γ ⊢ R ∘ S : RELATION from A to C (defined as Image(composite_map)) ;
CATEGORY
[[ R ∘ S ]] = "The composition of relations, generalizing relational composition in set theory. It is constructed by finding all 'chains' of length two (the pullback step) and then taking the subobject of the endpoints (the image step). This is the fundamental operation in the category of relations, Rel(C)." ;

(* ========================================================================================================== )
( == Part 3: Other Calculus Operations == )
( ========================================================================================================== *)

OppositeRelation ::= RelationDeclaration "^op" ;
TYPING
(* The opposite of a relation R:A⇸B is a relation R^op:B⇸A, found by swapping the components. *)
Γ ⊢ R : SubobjectOf(A × B)
Let τ : A × B → B × A be the canonical swap isomorphism.
Let m_R : R_obj → A × B be the representative mono for R.

Γ ⊢ R^op : SubobjectOf(B × A) (defined as Image(τ ∘ m_R)) ;
CATEGORY
[[ R^op ]] = "The opposite or converse of a relation, analogous to the transpose of a matrix." ;

IdentityRelation ::= "Id_Rel" "(" Identifier ")" ;
TYPING
(* The identity relation on A is the subobject corresponding to the diagonal map Δ: A → A×A. *)
Γ ⊢ A : Object_in(REGULAR_CATEGORY C)
Let Δ : A → A × A be the diagonal monomorphism.

Γ ⊢ Id_Rel(A) : RELATION from A to A (represented by Δ) ;
CATEGORY
[[ Id_Rel(A) ]] = "The identity relation on A, representing the relation 'is equal to'. It is the graph of the identity function, and it serves as the identity morphism for relation composition." ;

(* ========================================================================================================== )
( == Part 4: The Category of Relations == )
( ========================================================================================================== )

CategoryOfRelations ::= "Rel" "(" Identifier ")" ;
TYPING
(* These operations form a new category, Rel(C). *)
Γ ⊢ C : REGULAR_CATEGORY
Premise_Objects: Objects(Rel(C)) := Objects(C)
Premise_Morphisms: Morphisms_{Rel(C)}(A, B) := { R | Γ ⊢ R is_a RELATION from A to B }
Premise_Composition: Composition in Rel(C) := RelationComposition
Premise_Identities: IdentityMorphism for A in Rel(C) := Id_Rel(A)

Γ ⊢ Rel(C) : Category ;
CATEGORY
[[ Rel(C) ]] = "The category of relations on C. This construction takes a regular category C and produces a new category where the morphisms are relations. This new category has additional structure, such as being a 2-category with inclusions of relations as 2-cells." ;

}

(* ========================================================================================================== )
( == Section 3.2-3.4: Categorical Approach to Universal Algebra (Lawvere Theories) == )
(
ELABORATION: These sections represent a profound conceptual shift, moving universal algebra from a set-theoretic
foundation (sets with operations and equations) to a purely categorical one. The key idea, developed by
William Lawvere, is that an entire algebraic theory (like the theory of groups) can be encoded as a special
kind of category, and a specific algebra (like a particular group) is simply a structure-preserving
functor from that theory-category into Set.

A deep elaboration requires us to formalize this entire pipeline: from the definition of the abstract
"theory-category," to the definition of a "model" as a functor, to the construction of the familiar
"category of models."

Our formalization will proceed by:

Formalizing the Theory: We will define LawvereTheory as a category with finite products whose
objects are abstract "arities" (powers of a single base object). The morphisms of this category are the
"abstract operations" of the theory.

Formalizing the Model: We will define a ModelOfTheory as a product-preserving functor from the theory
category to Set. This functor is the semantic interpretation of the theory: it assigns a concrete carrier
set to the base object and concrete functions to the abstract operations. The functoriality itself ensures
that the theory's axioms (encoded as commutative diagrams) hold true for the model.

Formalizing the Category of Models: We will show how to construct Mod(T, Set), the familiar
category of all algebras for a theory T (e.g., Grp or Mon), where the objects are the model-functors
and the morphisms are natural transformations between them.

Illustrating with an Example: We will instantiate this entire framework with the concrete theory of
Monoids, showing how its operations (multiplication, unit) and axioms (associativity, unitality) are
perfectly captured by the morphisms and commutative diagrams of its Lawvere theory.
*)

(* ========================================================================================================== )
( == Part 1: The Theory-Category (The Syntax) == )
( ========================================================================================================== *)

LawvereTheoryDeclaration ::= "LAWVERE_THEORY" Identifier "with_base_object" Identifier ";" ;
TYPING
(*

The formal definition of a Lawvere Theory. It is a category T with two key properties:

It has all finite products.

Every object in it is isomorphic to a finite product of a single base object, T_obj.

The objects T_obj^n (for n=0,1,2,...) represent the abstract "arities" of the theory's operations.
*)
Γ ⊢ T : Category
Premise1: Γ ⊢ T has FINITE_PRODUCTS
Premise2: ∃ (T_obj ∈ Ob(T)) s.t. (∀X∈Ob(T), ∃n∈ℕ s.t. X ≅ Product(T_obj, n))

Γ ⊢ LAWVERE_THEORY T with_base_object T_obj : AlgebraicTheory ;
CATEGORY
[[ LAWVERE_THEORY T ... ]] = "A syntactic category whose structure embodies an algebraic theory. The objects T_obj^n are the 'types' of arity n, and the morphisms f: T_obj^n → T_obj^m represent the abstract operations of the theory. Composition in the category corresponds to substitution of operations." ;

OperationInTheory ::= "OPERATION" Identifier ":" Identifier "^" integer_literal "→" Identifier "^" integer_literal ";" ;
TYPING
(* An operation is simply a morphism in the Lawvere theory. *)
Context: T is a LAWVERE_THEORY with base object T_obj
Γ ⊢ n, m : integer_literal

Γ ⊢ OPERATION name : T_obj^n → T_obj^m : Morphism(Product(T_obj, n), Product(T_obj, m)) in T ;
CATEGORY
[[ OPERATION name : T_obj^n → T_obj^m ]] = "An m-tuple of n-ary operations defined syntactically as a morphism in the theory category. For example, a binary operation like group multiplication is a morphism T_obj² → T_obj¹." ;

AxiomInTheory ::= "AXIOM" string_literal ":" "Diagram" "(" {Morphism} ")" "COMMUTES" ";" ;
TYPING
(* An axiom is an assertion that two morphisms in the theory are equal, i.e., a diagram commutes. *)
Context: T is a LAWVERE_THEORY
Γ ⊢ f, g : Morphism(A, B) in T

Γ ⊢ AXIOM ... : (f == g) in T ;
CATEGORY
[[ AXIOM ... ]] = "An equational law of the algebraic theory, encoded as a commutative diagram. For example, the associativity of multiplication is encoded by the commuting of the diagram corresponding to the equation μ(μ(x,y),z) = μ(x,μ(y,z))." ;

(* ========================================================================================================== )
( == Part 2: The Model-Functor and Category of Models (The Semantics) == )
( ========================================================================================================== *)

ModelOfTheory ::= "MODEL" Identifier "of" LawvereTheoryDeclaration "in" CategoryDeclaration ";" ;
TYPING
(* A model is a product-preserving functor from the theory-category to a target category (usually Set). *)
Γ ⊢ T : LAWVERE_THEORY, Γ ⊢ C : Category with FINITE_PRODUCTS
Γ ⊢ M : Functor(T, C)
Premise_PreservesProducts: ∀X,Y∈Ob(T), M(Product(X,Y)) ≅ Product(M(X), M(Y))

Γ ⊢ MODEL M of T in C : T_Algebra ;
CATEGORY
[[ MODEL M of T in C ]] = "An algebra, or semantic interpretation of the theory T. The functor M assigns a concrete object in C (the 'carrier') to the base object T_obj and interprets the abstract operation-morphisms of T as concrete morphisms in C. The functoriality guarantees that all the theory's axioms are satisfied by these concrete operations." ;

CategoryOfModels ::= "Mod" "(" LawvereTheoryDeclaration "," CategoryDeclaration ")" ;
TYPING
(* The category of T-Models in C has the models as objects and natural transformations as morphisms. *)
Γ ⊢ T : LAWVERE_THEORY, Γ ⊢ C : Category
Objects := { M | Γ ⊢ M : MODEL of T in C }
Morphisms := { α : M₁ ⇒ M₂ | Γ ⊢ α : NaturalTransformation }

Γ ⊢ Mod(T, C) : Category ;
CATEGORY
[[ Mod(T, C) ]] = "The category of all T-algebras in C. For instance, if T is the theory of Monoids and C is Set, then Mod(T, Set) is precisely the category Mon. This construction provides the bridge from the abstract syntax of a theory to the concrete category of its models." ;

(* ========================================================================================================== )
( == Concrete Example: The Lawvere Theory of Monoids == )
( ========================================================================================================== *)

LAWVERE_THEORY "T_Mon" "with_base_object" "X" {
"Operations" : {
OPERATION "μ" : X^2 → X^1 ; (* The binary multiplication )
OPERATION "η" : X^0 → X^1 ; ( The nullary unit element )
},
"Axioms" : {
AXIOM "Associativity" : "Diagram involving μ(μ(x,y),z) and μ(x,μ(y,z))" COMMUTES ;
AXIOM "Left Unitality" : "Diagram involving μ(η, x)" COMMUTES ;
AXIOM "Right Unitality" : "Diagram involving μ(x, η)" COMMUTES ;
}
};
TYPING
( This declares the theory of monoids. A model M: T_Mon -> Set will be a product-preserving functor. *)
M(X) := S (a carrier set)
M(X²) ≅ M(X) × M(X) = S × S
M(X⁰) ≅ M(X)⁰ = {∗} (a singleton set, the terminal object in Set)
M(μ) : M(X²) → M(X¹) becomes a concrete function f_μ : S×S → S.
M(η) : M(X⁰) → M(X¹) becomes a concrete function f_η : {∗} → S, which is equivalent to picking an element e ∈ S.
-- The functoriality M(diag commutes) => M(diag) commutes means:
-- The abstract associativity diagram becomes the concrete law: f_μ(f_μ(a,b),c) = f_μ(a,f_μ(b,c)).
-- The abstract unitality diagrams become the concrete laws: f_μ(a,e) = a and f_μ(e,a) = a.
-- Therefore, the data (S, f_μ, e) is precisely a monoid.

Γ ⊢ "Any MODEL of T_Mon in Set is a Monoid." : ProvableProposition ;
CATEGORY
[[ MODEL of T_Mon in Set ]] = "A concrete monoid. The Lawvere theory framework demonstrates that the entire structure of a monoid—its carrier set, its binary operation, its unit element, and its axioms—is perfectly captured by a single product-preserving functor." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.5-3.7: Properties of Algebraic Categories" ")" "==>" {
(*
ELABORATION: This elaboration deconstructs the bundled summary of properties for algebraic categories, formalizing each major result from Sections 3.5, 3.6, and 3.7 as a distinct, detailed theorem. This approach clarifies the specific structural guarantees that come from a category being "algebraic" (i.e., a category of models for a Lawvere theory).
*)

(* ========================================================================================================== )
( == Section 3.5: Limits and Colimits in Algebraic Categories == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "AlgebraicCategoriesAreCompleteAndCocomplete" ":"
"Every ALGEBRAIC_CATEGORY is both complete and cocomplete." ;
TYPING
(*
* This theorem is a consequence of the fact that limits and colimits in a category of models Mod(T, Set)
* can be constructed "pointwise" in the base category, Set. Since Set itself is complete and
* cocomplete, Mod(T, Set) inherits these properties.
*)
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> ((Γ ⊢ C is COMPLETE) ∧ (Γ ⊢ C is COCOMPLETE))
----------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM AlgebraicCategoriesAreCompleteAndCocomplete ]] = "A fundamental structural property. It asserts that the category of models inherits the excellent completeness properties of its base category (usually Set). Limits in an algebraic category are computed by taking the limit of the underlying sets and endowing it with the algebraic structure in a canonical way. A similar, though more complex, construction holds for colimits." ;

(* ========================================================================================================== )
( == Section 3.6: The Exactness Properties of Algebraic Categories == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "AlgebraicCategoriesAreRegular" ":"
"Every ALGEBRAIC_CATEGORY is a REGULAR_CATEGORY." ;
TYPING
(*
* This property is also inherited from the base category Set, which is the archetypal regular category.
* The necessary structures—finite limits, stable (RegularEpi, Mono) factorizations—are created
* "pointwise" in Set and lift to the category of models.
*)
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> (Γ ⊢ C is REGULAR_CATEGORY)
----------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM AlgebraicCategoriesAreRegular ]] = "An assertion of the well-behaved exactness properties of algebraic categories. This guarantees that they have a robust theory of images (factorizations) and effective equivalence relations, making them suitable for a wide range of algebraic constructions even in a non-additive setting." ;

(* ========================================================================================================== )
( == Section 3.9 (Context for 3.7): Free Objects == )
( ========================================================================================================== )

ForgetfulFunctor_Algebraic ::= "U" ":" Identifier "→" "Set" ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ U : C → Set : ForgetfulFunctor ;
CATEGORY
[[ U : C → Set ]] = "The forgetful functor that maps an algebra to its underlying set of elements, forgetting the operations and axioms." ;

FreeFunctor_Algebraic ::= "F" ":" "Set" "→" Identifier ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ F : Set → C : Functor ;
CATEGORY
[[ F : Set → C ]] = "The free functor, which constructs the 'freest' possible algebra on a given set of generators. This involves building a term algebra and quotienting by the theory's equational laws." ;

TheoremDeclaration ::= "THEOREM" "ExistenceOfFreeFunctorAdjunction" ":"
"For every ALGEBRAIC_CATEGORY C, the forgetful functor U:C→Set has a left adjoint F, the Free Functor." ;
TYPING
(Γ ⊢ C is ALGEBRAIC_CATEGORY) ==> (∃ F s.t. FunctionalAdjunction(F, U_{C}))
---------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ExistenceOfFreeFunctorAdjunction ]] = "The assertion of the free-forgetful adjunction (F ⊣ U), a hallmark of algebraic categories. The existence of the free functor guarantees that for any set of generators, there is a universal algebra satisfying the theory's laws, from which all other homomorphisms are uniquely determined. This is the categorical foundation of 'free objects' in algebra." ;

(* ========================================================================================================== )
( == Section 3.7: The Algebraic Lattices of Subobjects == )
( ========================================================================================================== )

LatticeElementProperty ::= Identifier "is" "COMPACT_IN" Identifier ;
TYPING
(* An element c in a complete lattice L is compact if its relationship to any join can be witnessed by a finite sub-join. *)
Γ ⊢ L : CompleteLattice
Γ ⊢ c : ElementOf(L)
Condition := ∀S ⊆ L, (c ≤ Join(S)) ==> (∃ S_fin ⊆ S, (|S_fin| is finite) ∧ (c ≤ Join(S_fin)) )
-----------------------------------------------------------------------------------------------
Γ ⊢ c is COMPACT_IN L is TRUE if Condition holds ;
CATEGORY
[[ c is COMPACT_IN L ]] = "A lattice-theoretic notion of finiteness. A compact element cannot be 'reached' by an infinite process without also being reached by a finite part of that process." ;

LatticePropertyDeclaration ::= Identifier "is" "ALGEBRAIC_LATTICE" ;
TYPING
(* A complete lattice is algebraic if every element is the join of the compact elements below it. *)
Γ ⊢ L : CompleteLattice
Condition := ∀x ∈ L, (x == Join({c ∈ L | c is COMPACT_IN L ∧ c ≤ x}))
----------------------------------------------------------------------
Γ ⊢ L is ALGEBRAIC_LATTICE is TRUE if Condition holds ;
CATEGORY
[[ L is ALGEBRAIC_LATTICE ]] = "A type of complete lattice that is richly supplied with compact elements. These lattices are characteristic of algebraic structures." ;

TheoremDeclaration ::= "THEOREM" "SubobjectLatticesInAlgebraicCategoriesAreAlgebraic" ":"
"In any ALGEBRAIC_CATEGORY C, for any object X, the subobject lattice Sub(X) is an ALGEBRAIC_LATTICE." ;
TYPING
Γ ⊢ C : ALGEBRAIC_CATEGORY
--------------------------------------------------------------------
∀X ∈ Ob(C), (Γ ⊢ Sub(X) is ALGEBRAIC_LATTICE) : MetaTheorem ;
CATEGORY
[[ THEOREM SubobjectLatticesInAlgebraicCategoriesAreAlgebraic ]] = "A deep structural result connecting the algebraic nature of the category to the lattice-theoretic nature of its subobjects. In this context, the compact elements of the subobject lattice Sub(X) correspond precisely to the finitely generated sub-algebras of X. The theorem states that any sub-algebra is the directed union of its finitely generated sub-algebras." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.8, 3.10: Algebraic Functors and Characterization" ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.8: Algebraic Functors" ")" "==>" {
(*

ELABORATION: This section defines the "correct" notion of a structure-preserving map between two
algebraic categories. The central idea is that an algebraic category (like Grp or Ring) is a category
of "sets with extra structure." A functor between such categories should not be arbitrary; it must
respect this underlying "set-based" foundation.

The way to formalize this respect is to require the functor to commute with the process of "forgetting"
the algebraic structure. For any algebraic category C, there is a forgetful functor U_C: C → Set that
maps an algebra to its underlying set. An algebraic functor F: C → D must behave such that if you
take an algebra in C, apply F to get an algebra in D, and then forget D's structure to get a set, the result
should be the same (up to natural isomorphism) as just forgetting C's structure in the first place.

Our elaboration will formalize this principle through three main steps:

The Components: We will clearly define the players: the Algebraic Categories and their canonical Forgetful Functors.

The Master Definition: We will define an Algebraic Functor by the property that it commutes with these forgetful functors up to a natural isomorphism.

The Origin Theorem: We will state the crucial theorem that explains where algebraic functors come from: they are precisely the functors induced by morphisms between the underlying Lawvere theories. This connects the semantic notion of an algebraic functor to the syntactic notion of a map between theories.
*)

(* ========================================================================================================== )
( == Part 1: The Components (The Stage and the Players) == )
( ========================================================================================================== *)

AlgebraicCategoryDeclaration ::= Identifier "is" "ALGEBRAIC_CATEGORY" ;
TYPING
(* A category C is algebraic if it is equivalent to the category of models of some Lawvere theory in Set. *)
∃ (T : LAWVERE_THEORY) s.t. (Γ ⊢ C ≅ Mod(T, Set))
---------------------------------------------------
Γ ⊢ C is ALGEBRAIC_CATEGORY ;
CATEGORY
[[ C is ALGEBRAIC_CATEGORY ]] = "A category that is the semantic realization of some finite-product theory. These categories, like Grp, Mon, and Ring, share a rich common structure." ;

ForgetfulFunctor_Algebraic ::= "U_" Identifier ;
TYPING
(* This constructor defines the forgetful functor U_C: C -> Set for an algebraic category C. *)
Γ ⊢ C : ALGEBRAIC_CATEGORY
-------------------------------------------
Γ ⊢ U_C : Functor(C, Set) ;
CATEGORY
[[ U_C ]] = "The canonical forgetful functor that maps an algebra in C to its underlying set of elements, forgetting the operations and axioms." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition (Commutation with Forgetting) == )
( ========================================================================================================== *)

AlgebraicFunctorDeclaration ::= Identifier "is" "ALGEBRAIC_FUNCTOR" ;
TYPING
(*
* The formal definition of an algebraic functor F: C -> D. It must commute with the respective
* forgetful functors up to a natural isomorphism. This ensures it maps underlying sets to
* underlying sets in a coherent way.
*)
Γ ⊢ F : Functor(C, D)
Γ ⊢ C, D : ALGEBRAIC_CATEGORY
Let U_C := ForgetfulFunctor_Algebraic of C
Let U_D := ForgetfulFunctor_Algebraic of D
Condition: ∃ (α : NaturalIsomorphism s.t. α : U_D ∘ F ⇒ U_C)
----------------------------------------------------------------
Γ ⊢ F is ALGEBRAIC_FUNCTOR is TRUE if Condition holds ;
CATEGORY
[[ F is ALGEBRAIC_FUNCTOR ]] = "A structure-preserving map between algebraic categories. The requirement that it commutes with the forgetful functors is the key coherence condition. It means that the process of 'applying F then forgetting' is naturally the same as just 'forgetting'. The functor F must act on the algebraic structure in a way that is compatible with how it acts on the underlying sets." ;

(* ========================================================================================================== )
( == Part 3: The Origin Theorem (The Source of Algebraic Functors) == )
( ========================================================================================================== *)

LawvereTheoryMorphism ::= "THEORY_MORPHISM" Identifier ":" LawvereTheoryDeclaration "→" LawvereTheoryDeclaration ;
TYPING
(* A morphism between two Lawvere theories is a functor that preserves the finite product structure. *)
Γ ⊢ T1, T2 : LAWVERE_THEORY
-------------------------------------------------------------------------------------
Γ ⊢ THEORY_MORPHISM φ : T1 → T2 : Functor(T1, T2) which preserves FINITE_PRODUCTS ;
CATEGORY
[[ THEORY_MORPHISM φ : T1 → T2 ]] = "A structure-preserving map between the syntactic theories themselves. It translates the operations and axioms of theory T1 into the language of theory T2." ;

InducedFunctorOnModels ::= "Mod" "(" LawvereTheoryMorphism ")" ;
TYPING
(* A theory morphism φ: T1 → T2 induces a functor in the opposite direction on the categories of models. *)
Γ ⊢ φ : THEORY_MORPHISM(T1 → T2)
ActionOnObjects: (A T2-Model M:T2→Set) ↦ (the T1-Model M∘φ : T1→Set)
--------------------------------------------------------------------------
Γ ⊢ Mod(φ) : Functor(Mod(T2, Set), Mod(T1, Set)) ;
CATEGORY
[[ Mod(φ) ]] = "The functor between model categories induced by a theory morphism φ. It acts via pre-composition, taking a model of T2 and restricting it along φ to produce a model of T1. For example, a theory morphism from the theory of rings to the theory of monoids induces the forgetful functor from Ring to Mon." ;

TheoremDeclaration ::= "THEOREM" "CharacterizationOfAlgebraicFunctors" ":"
"A functor F: C → D is ALGEBRAIC"
"<==>"
"F is naturally isomorphic to Mod(φ) for some THEORY_MORPHISM φ." ;
TYPING
(* This provides a complete characterization. *)
P1 := (Γ ⊢ F is ALGEBRAIC_FUNCTOR)
P2 := ∃(φ : THEORY_MORPHISM(T_D → T_C)) s.t. (Γ ⊢ F ≅ Mod(φ))
----------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM CharacterizationOfAlgebraicFunctors ]] = "A fundamental theorem revealing the origin of algebraic functors. It asserts that every semantic map between algebraic categories arises from a corresponding syntactic map between their underlying Lawvere theories. This establishes a deep duality between the syntactic world of theories and the semantic world of their models." ;
}

(*
ELABORATION: This section presents the Beck Characterization Theorem, a deep and powerful result that provides an "internal"
way to recognize an algebraic category. Instead of needing to find an external Lawvere theory T
and prove an equivalence C ≅ Mod(T, Set), this theorem gives a checklist of properties internal
to C that are necessary and sufficient.

A deep elaboration requires us to formally deconstruct this checklist into its constituent parts,
showing how each condition contributes to the overall "algebraic" nature of the category.

Our formalization will proceed by:

Formalizing the Key Object (The Generator): We will define the special properties the
generator G must have. It must be a "regular projective" object, a specific kind of "freeness"
suited to the regular category context.

Formalizing the Construction Principle: We will formalize the idea that every object in the
category must be "built from" the generator. This is captured by the property that every
object is a regular quotient of a coproduct of copies of the generator.

Assembling the Master Theorem: We will combine these properties into the full statement of
Beck's Characterization Theorem, showing that a category satisfying these internal structural
axioms is guaranteed to be equivalent to a category of models for some Lawvere theory.
*)

(* ========================================================================================================== )
( == Part 1: The Properties of the Generator == )
( ========================================================================================================== )

ObjectPropertyAssertion ::= Identifier "is" "REGULAR_PROJECTIVE" ;
TYPING
(*

An object P is regular projective if it has the lifting property specifically with respect

to the class of regular epimorphisms. This is a weaker condition than full projectivity but

is the precise notion of 'freeness' relevant for regular and algebraic categories.
*)
Γ ⊢ P : Object
Condition := ∀(e:A→B is REGULAR_EPIMORPHISM), the map (f↦e∘f) : Hom(P,A)→Hom(P,B) is a surjection.

Γ ⊢ P is REGULAR_PROJECTIVE is TRUE if Condition holds ;
CATEGORY
[[ P is REGULAR_PROJECTIVE ]] = "The property of an object having sufficient 'freeness' to lift through any regular quotient map. In an algebraic category, the free algebra on one generator is the canonical example of a regular projective generator." ;

(* ========================================================================================================== )
( == Part 2: The Construction Principle from the Generator == )
( ========================================================================================================== )

CoproductOfGenerator ::= "Coproduct_over" "(" Identifier ")" "of" Identifier ;
TYPING
(* This constructor defines the coproduct of a generator G over an index set I. *)
Γ ⊢ G : Object_in(Category C), Γ ⊢ C has Coproducts
Γ ⊢ I : Set

Γ ⊢ Coproduct_over(I) of G : Object_in(C) ;
CATEGORY
[[ Coproduct_over(I) of G ]] = "The coproduct of I copies of the generator G, written ∐_I G. In an algebraic category, this object plays the role of the 'free object on I generators'." ;

CategoryProperty_IsRegularlyCoveredByGenerator ::= Identifier "is" "REGULARLY_COVERED_BY" Identifier ;
TYPING
(*

This is a global property of the category. It asserts that every object X can be

constructed from the generator G by first taking a large enough coproduct of G and then

forming a regular quotient of it.
*)
Context: Γ ⊢ C : Category, Γ ⊢ G : Object_in(C)
Condition := ∀ X ∈ Ob(C), ∃ (I:Set) s.t. ( ∃ (e: Coproduct_over(I) of G → X s.t. e is REGULAR_EPIMORPHISM) )

Γ ⊢ C is REGULARLY_COVERED_BY G is TRUE if Condition holds ;
CATEGORY
[[ C is REGULARLY_COVERED_BY G ]] = "The assertion that the generator G is sufficient to construct every other object in the category using only the canonical 'algebraic' constructions of coproducts (for gathering generators) and regular epimorphisms (for imposing relations)." ;

(* ========================================================================================================== )
( == Part 3: The Master Characterization Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "BeckCharacterizationOfAlgebraicCategories" ":"
"A category C is ALGEBRAIC_CATEGORY if and only if:"
"{" "1. C is COCOMPLETE;"
"2. C has a REGULAR_PROJECTIVE generator G;"
"3. C is REGULARLY_COVERED_BY G."
"}" ;
TYPING
(* This is the formal typing for the master characterization theorem. *)
P1 := (Γ ⊢ C is ALGEBRAIC_CATEGORY)

P2_Cocomplete := (Γ ⊢ C is COCOMPLETE)
P2_Generator := (∃ G ∈ Ob(C) s.t. (Γ ⊢ G is GENERATOR) ∧ (Γ ⊢ G is REGULAR_PROJECTIVE))
P2_Covering := (Γ ⊢ C is REGULARLY_COVERED_BY G)
P2 := (P2_Cocomplete ∧ P2_Generator ∧ P2_Covering)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM BeckCharacterizationOfAlgebraicCategories ]] = "A deep theorem providing a complete internal characterization of algebraic categories. It asserts that the 'external' property of being equivalent to a category of models for a Lawvere theory is precisely the same as a set of 'internal' structural properties: having all colimits, possessing a sufficiently 'free' generator, and being built entirely from that generator via coproducts and quotients. This allows one to identify a category as algebraic from the inside out, without needing to first construct its theory." ;

(*
ELABORATION: This section elaborates on the advanced topics that conclude the study of algebraic
theories. A deep elaboration requires deconstructing each concept—commutativity, tensor product, and
Morita equivalence—into its formal definition and its primary consequence or characterization, showing
how these concepts build a meta-theory about the relationships between algebraic theories themselves.
*)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.11: Commutative Theories" ")" "==>" {
(*
ELABORATION: This section defines a special, powerful property of an algebraic theory. A theory is "commutative"
not merely if a single binary operation is commutative, but in a much deeper sense: every operation must be
a homomorphism for every other operation. This syntactic property within the Lawvere theory has a profound
semantic consequence: it endows the category of models with a symmetric monoidal structure (a tensor product).

A deep elaboration requires us to:

Formalize the Commutativity Axiom: We will define the "interchange law" between two
abstract operations as a commutative diagram in the Lawvere theory. This is the heart of the definition.

Define a Commutative Theory: We will define a COMMUTATIVE LawvereTheoryDeclaration as a theory where this
interchange law holds for every pair of its operations.

State the Main Consequence: We will formalize the main theorem, which asserts that the category
of models for a commutative theory is always a symmetric monoidal category.

Provide Canonical Examples: We will contrast the theory of R-modules (which is commutative) with the
theory of Groups (which is not, unless the groups are abelian), showing how the interchange law
manifests as the familiar distributivity law in the case of modules, and how its failure explains
the lack of a canonical tensor product for general groups.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Commutativity Axiom (The Interchange Law) == )
( ========================================================================================================== *)

CommutativityAxiom ::= "AXIOM" "Interchange" "for" "(" OperationDeclaration "," OperationDeclaration ")" "COMMUTES" ;
TYPING
(*

This axiom formalizes the idea that an n-ary operation f and an m-ary operation g commute.

This is expressed by an "interchange square". Imagine an n×m matrix of variables. Applying g to

each row and then f to the results must be the same as applying f to each column and then g to the results.

This is encoded as a commutative diagram in the Lawvere theory T with base object X.
)
Context: T is a LAWVERE_THEORY with base object X
Γ ⊢ f : Morphism(X^n, X), Γ ⊢ g : Morphism(X^m, X) in T
-- Build the diagram paths
Path1 := f ∘ (g × ... × g) : X^(nm) → X (* Apply g to n rows, then f to the result )
Path2 := g ∘ (f × ... × f) : X^(nm) → X (* Apply f to m columns, then g to the result *)

Γ ⊢ AXIOM Interchange for (f,g) COMMUTES <==> (Path1 == Path2) in T ;
CATEGORY
[[ AXIOM Interchange for (f,g) COMMUTES ]] = "The assertion of the interchange law for operations f and g. It is the syntactic condition within the Lawvere theory that guarantees the operations can be applied in any order without changing the overall result. When f is addition and g is multiplication, this is the distributivity law." ;

(* ========================================================================================================== )
( == Part 2: The Definition of a Commutative Theory == )
( ========================================================================================================== *)

CommutativeLawvereTheory ::= "COMMUTATIVE" LawvereTheoryDeclaration ;
TYPING
(* A Lawvere theory is commutative if the interchange law holds for every pair of its operations. *)
Γ ⊢ T : LAWVERE_THEORY
Condition := ∀ (op1, op2 ∈ Operations(T)), (Γ ⊢ AXIOM Interchange for (op1,op2) COMMUTES)

Γ ⊢ T is COMMUTATIVE ;
CATEGORY
[[ COMMUTATIVE LAWVERE_THEORY T ]] = "An algebraic theory in which all operations are mutually homomorphic. This compatibility is a very strong condition with powerful consequences for the category of models." ;

(* ========================================================================================================== )
( == Part 3: The Main Semantic Consequence == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CommutativeTheoriesYieldMonoidalCategories" ":"
"IF T is a COMMUTATIVE Lawvere Theory, THEN the category Mod(T,Set) is a symmetric monoidal category." ;
TYPING
(*

The tensor product of two models, M₁ and M₂, is constructed on the tensor product of their underlying sets.

The commutative (interchange) axiom is precisely what is needed to define the action of any operation

on the tensor product set S₁⊗S₂ in a canonical, coherent way.
*)
Γ ⊢ T is COMMUTATIVE

Γ ⊢ Mod(T, Set) is SYMMETRIC_MONOIDAL_CATEGORY : ProvableProposition ;
CATEGORY
[[ THEOREM CommutativeTheoriesYieldMonoidalCategories ]] = "A deep result connecting the syntactic property of commutativity in a theory to the semantic property of having a tensor product structure on its category of models. For example, because the theory of abelian groups is commutative, the category Ab has a tensor product (⊗_ℤ). The non-commutativity of the theory of general groups is why Grp does not have such a canonical tensor product." ;

(* ========================================================================================================== )
( == Part 4: The Canonical Examples == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "TheoryOfRModulesIsCommutative" "of" CommutativeLawvereTheory ;
TYPING
(*

The theory of R-modules has addition (+ : 2→1) and scalar multiplication for each r∈R (s_r : 1→1).

We must check the interchange law for all pairs.

(+, +): This holds because addition is commutative and associative in an R-module.

(s_r, s_q): This holds because s_r(s_q(x)) = (rq)x = (qr)x = s_q(s_r(x)) (if R is commutative).

(+, s_r): The interchange diagram for these two operations is precisely the distributivity law:

s_r(x + y) = s_r(x) + s_r(y).

Since all pairs commute, the theory is commutative.
*)
Let T_RMod be the Lawvere Theory for R-modules.

Γ ⊢ T_RMod is COMMUTATIVE : ProvableProposition ;
CATEGORY
[[ INSTANCE TheoryOfRModulesIsCommutative ... ]] = "A key example of a commutative theory. The familiar axiom of distributivity for modules is a specific instance of the general interchange law. Because the theory is commutative, the category R-Mod has a tensor product (⊗_R), as predicted by the main theorem." ;

TheoremInstantiation ::= "INSTANCE" "TheoryOfGroupsIsNotCommutative" ;
TYPING
(*

The theory of groups has one binary operation, multiplication (μ : 2→1), and a nullary unit.

For the theory to be commutative, μ must commute with itself.

The interchange law for (μ, μ) is the statement: μ(μ(a,b), μ(c,d)) = μ(μ(a,c), μ(b,d)).

This is known as the Eckmann-Hilton argument. In a group, this identity holds if and only if

the group is abelian. Therefore, the Lawvere theory for general, non-abelian groups is not commutative.
*)
Let T_Grp be the Lawvere Theory for Groups.

Γ ⊢ (T_Grp is COMMUTATIVE <==> Models are Abelian) : ProvableEquivalence ;
CATEGORY
[[ INSTANCE TheoryOfGroupsIsNotCommutative ... ]] = "A key counterexample. The self-interchange law for group multiplication only holds if the group is abelian. This demonstrates that the property of being a commutative theory is a very strong condition, corresponding to abelian-like structures. The failure of this syntactic condition in the theory is the ultimate reason for the failure of the category Grp to have a canonical tensor product." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.12: Tensor product of theories" ")" "==>" {
(*
ELABORATION: This section provides a powerful categorical tool for combining two distinct algebraic theories
into a single, richer theory. The key idea is to construct a new theory, the "Tensor Product" T₁⊗T₂,
whose models are precisely those objects that possess both a T₁-structure and a T₂-structure, with the
added crucial condition that these two structures are "compatible." This compatibility is formalized as the
requirement that every operation from the first theory must be a homomorphism for every operation from
the second theory.

A deep elaboration requires that we first formalize this semantic target—the "bialgebra"—and then show how
the syntactic construction of the tensor product of theories is precisely the object that generates it.
*)

(* ========================================================================================================== )
( == Part 1: The Semantic Target - The Bialgebra == )
( ========================================================================================================== )
(Before defining the theory T₁⊗T₂, we must define what we want its models to be.)

BialgebraDeclaration ::= Identifier "is" "T1_T2_Bialgebra" ;
TYPING
(*

A (T₁,T₂)-bialgebra is a set S that is equipped with both a T₁-algebra structure and a T₂-algebra

structure, such that the operations are compatible.
*)
Context: Γ ⊢ T1, T2 : LAWVERE_THEORY
Γ ⊢ S : Set
Premise1: S has a T1-algebra structure (functor M₁: T₁→Set with carrier S).
Premise2: S has a T2-algebra structure (functor M₂: T₂→Set with carrier S).
Premise3: (Compatibility) Every operation from T₁ commutes with every operation from T₂.

Γ ⊢ S is T1_T2_Bialgebra : ProvableProposition ;
CATEGORY
[[ S is T1_T2_Bialgebra ]] = "An algebra with two compatible structures. The compatibility condition is the interchange law between operations from the different theories. For example, a Ring is a (Theory_Monoids, Theory_AbelianGroups)-Bialgebra, where the compatibility is the distributivity of multiplication over addition." ;

CategoryOfBialgebras ::= "Bialg" "(" LawvereTheoryDeclaration "," LawvereTheoryDeclaration ")" ;
TYPING
(* The category of (T₁,T₂)-bialgebras in Set. *)
Objects := { S | Γ ⊢ S is T1_T2_Bialgebra }
Morphisms := { f:S₁→S₂ | f is a homomorphism for both the T₁ and T₂ structures }

Γ ⊢ Bialg(T1, T2) : Category ;
CATEGORY
[[ Bialg(T1, T2) ]] = "The category of all (T₁,T₂)-bialgebras. This is our semantic target category." ;

(* ========================================================================================================== )
( == Part 2: The Syntactic Construction - The Tensor Product Theory == )
( ========================================================================================================== )
(This is the syntactic object whose models will be the bialgebras defined above.)

TensorProductOfTheories ::= LawvereTheoryDeclaration "⊗" LawvereTheoryDeclaration ;
TYPING
(*

The tensor product of two Lawvere theories is a new Lawvere theory. It is the coproduct

in the category of Lawvere theories.

Its operations are the union of the operations of T₁ and T₂, and its axioms include all axioms

from T₁ and T₂, plus all interchange law axioms between pairs of operations from T₁ and T₂.
*)
Γ ⊢ T1, T2 : LAWVERE_THEORY
T_tensor := a new LAWVERE_THEORY where:
Operations(T_tensor) := Operations(T1) ∪ Operations(T2)
Axioms(T_tensor) := Axioms(T1) ∪ Axioms(T2) ∪ { InterchangeAxiom(f,g) | f∈Ops(T1), g∈Ops(T2) }

Γ ⊢ T1 ⊗ T2 : LAWVERE_THEORY (defined by this construction) ;
CATEGORY
[[ T1 ⊗ T2 ]] = "The Lawvere theory whose operations are the disjoint union of the operations of T1 and T2, and whose axioms are the combined axioms of both theories plus new axioms enforcing that every operation from T1 commutes with every operation from T2. It is the syntactic embodiment of compatible, combined structures." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Connecting Syntax and Semantics) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "TensorProductModelsAreBialgebras" ":"
"The category of models of a tensor product of theories is equivalent to the category of bialgebras." ;
TYPING
(* This theorem is the universal property of the tensor product of theories. *)
Γ ⊢ T1, T2 : LAWVERE_THEORY
P1_SemanticCategory := Bialg(T1, T2)
P2_ModelCategory := Mod(T1 ⊗ T2, Set)

Γ ⊢ P1_SemanticCategory ≅ P2_ModelCategory : EquivalenceOfCategories ;
CATEGORY
[[ THEOREM TensorProductModelsAreBialgebras ]] = "The fundamental theorem of the tensor product of theories. It asserts that our syntactic construction (T₁⊗T₂) is the correct one, as its semantic models (Mod(T₁⊗T₂, Set)) are precisely the category of objects that have both a T₁-structure and a T₂-structure in a compatible way (Bialg(T₁, T₂))." ;

(* ========================================================================================================== )
( == Concrete Example: The Theory of Rings == )
( ========================================================================================================== )

TheoremInstantiation ::= "INSTANCE" "TheoryOfRingsAsTensorProduct" "of" TensorProductOfTheories ;
TYPING
(*

We instantiate the theory with the canonical example: Rings.

A ring has a monoid structure (for multiplication) and an abelian group structure (for addition).

The compatibility condition is that multiplication distributes over addition.

This is exactly the interchange law communion between the monoid operation and the group operations.
*)
T_Mon := LAWVERE_THEORY for Monoids
T_Ab := LAWVERE_THEORY for Abelian Groups

Γ ⊢ TheoryOfRings ≅ (T_Mon ⊗ T_Ab) : IsomorphismOfTheories ;
-- Consequence via the main theorem:
Γ ⊢ Mod(TheoryOfRings, Set) ≅ Bialg(T_Mon, T_Ab)
Γ ⊢ Category("Ring") ≅ Bialg(T_Mon, T_Ab) ;
CATEGORY
[[ INSTANCE TheoryOfRingsAsTensorProduct ]] = "A concrete realization of the tensor product of theories. It asserts that the syntactic theory of rings is the tensor product of the theory of monoids and the theory of abelian groups. The distributivity law is not an ad-hoc axiom, but is the necessary interchange axiom that arises from the tensor product construction. Consequently, the category of Rings is precisely the category of (Monoid, Abelian Group)-bialgebras." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 3.13: Morita Equivalence" ")" "==>" {
(*
ELABORATION: This section, "A glance at Morita theory," introduces one of the most profound equivalence
relations in algebra. The central idea is that two different algebraic theories (and thus two different
rings, in the classic example) can be syntactically distinct yet semantically identical, meaning their
categories of models are equivalent. This is a much weaker notion than isomorphism of theories.

A deep elaboration requires us to not just state this definition, but to deconstruct the canonical
example—the equivalence of a ring R with its matrix ring Mₙ(R)—to show how this equivalence is
achieved. This requires formalizing the "bridge" object, the Progenerator, that facilitates the
equivalence.

Our elaboration will proceed by:

Formalizing the Master Definition: We will define MoritaEquivalence as an equivalence between
two Lawvere theories whose categories of models are equivalent.

Formalizing the Bridge (The Progenerator): We will define the concept of a Progenerator
Module, the special type of module that is used to construct the equivalence between two
Morita-equivalent rings.

Formalizing the Equivalence Functors: We will define the Tensor and Hom functors that are
constructed from the progenerator and which witness the categorical equivalence.

Stating the Main Theorem: We will formalize the classic Morita Theorem for rings, showing
that two rings are Morita equivalent if and only if such a progenerator exists, and we will
instantiate this with the canonical example of R and Mₙ(R).
*)

(* ========================================================================================================== )
( == Part 1: The Master Definition (Semantic Equivalence of Theories) == )
( ========================================================================================================== *)

MoritaEquivalence ::= LawvereTheoryDeclaration "is" "MORITA_EQUIVALENT_TO" LawvereTheoryDeclaration ;
TYPING
(*

The definition of Morita equivalence is purely semantic: two theories are Morita equivalent

if they generate equivalent categories of models. This is the ultimate test of theories

having the same "expressive power."
*)
Γ ⊢ T1, T2 : LAWVERE_THEORY

(Γ ⊢ T1 is MORITA_EQUIVALENT_TO T2) <==> (Γ ⊢ Mod(T1,Set) ≅ Mod(T2,Set)) ;
CATEGORY
[[ T1 is MORITA_EQUIVALENT_TO T2 ]] = "An equivalence relation on theories. It asserts that while the syntactic presentations T₁ and T₂ may be different, the semantic universes they describe (their categories of models) are structurally identical. It separates the 'syntactic flavor' of a theory from its 'semantic substance'." ;

(* ========================================================================================================== )
( == Part 2: The Canonical Example - The Tools for Ring Equivalence == )
( ========================================================================================================== )
(To show two rings R and S are Morita equivalent, we need to find a special module that acts as a bridge.)

ProgeneratorModule ::= Identifier "is" "PROGENERATOR_MODULE" "over" Identifier ;
TYPING
(*

A progenerator is a module P that is a finitely generated, projective generator for the category.

These are the "nicest" possible modules and are the key to building Morita equivalences.
*)
Context: R is a Ring, C = R-Mod
Γ ⊢ P : Object_in(C)
Premise1: Γ ⊢ P is FINITELY_GENERATED
Premise2: Γ ⊢ P is PROJECTIVE
Premise3: Γ ⊢ P is a GENERATOR for C

Γ ⊢ P is PROGENERATOR_MODULE over R ;
CATEGORY
[[ P is PROGENERATOR_MODULE over R ]] = "A module P that is the perfect 'building block' for the category R-Mod. Its properties ensure that it can be used to reconstruct the entire category and relate it to other categories of modules. The canonical example is the free module Rⁿ." ;

MoritaEquivalenceFunctor_Tensor ::= "- ⊗_" Identifier Identifier ;
MoritaEquivalenceFunctor_Hom ::= "Hom_" Identifier "(" Identifier ", -)" ;
TYPING
(*

Given two rings R and S, and a (S,R)-bimodule P, these constructors define the

functors that will witness the Morita equivalence.
*)
Context: R, S are Rings, P is an (S,R)-Bimodule
Functor1 := (- ⊗_R P) : R-Mod → S-Mod
Functor2 := (Hom_S(P, -)) : S-Mod → R-Mod

Γ ⊢ Functor1 : Functor, Γ ⊢ Functor2 : Functor ;
CATEGORY
[[ - ⊗_R P ]] = "The functor that provides one half of a Morita equivalence. It takes an R-module and transforms it into an S-module." ;
[[ Hom_S(P, -) ]] = "The functor that provides the other half of the equivalence, going in the reverse direction." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem for Rings == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "MoritaTheoremForRings" ":"
"Two rings R and S are Morita equivalent IFF there exists a Progenerator P in R-Mod"
"such that S is isomorphic to the endomorphism ring of P." ;
TYPING
(* This is the central theorem of Morita theory. *)
Γ ⊢ R, S : Ring
P1 := (TheoryOfModulesFor(R) is MORITA_EQUIVALENT_TO TheoryOfModulesFor(S))
P2 := (∃ P ∈ Ob(R-Mod) s.t. (P is PROGENERATOR_MODULE ∧ S ≅ End_{R-Mod}(P)))

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM MoritaTheoremForRings ]] = "The fundamental theorem of Morita Theory. It asserts that the abstract categorical notion of model equivalence is precisely equivalent to a concrete algebraic condition: the existence of a progenerator bimodule that connects the two rings. This provides a powerful, constructive tool for proving Morita equivalence." ;

(* ========================================================================================================== )
( == Part 4: Instantiating the Canonical Example == )
( ========================================================================================================== *)

TheoremInstantiation ::= "INSTANCE" "MoritaEquivalenceOfMatrixRings" "of" "MoritaTheoremForRings" ;
TYPING
(*

We apply the theorem to show that R is Morita equivalent to the matrix ring Mₙ(R).

We need to find a progenerator P in R-Mod such that Mₙ(R) is its endomorphism ring.

The object P = Rⁿ (the free module of rank n) is the perfect candidate.
*)
Let R_ring := a chosen Ring
Let S_ring := MatrixRing(n, R_ring)
-- Check premises of P2 from the theorem
Premise_Module: Let P := R_ring^n. P is an object in R-Mod.
Premise_Progenerator: Γ ⊢ P is PROGENERATOR_MODULE over R_ring. (This is a standard result for free modules).
Premise_EndoRing: End_{R-Mod}(P) = End_{R-Mod}(Rⁿ) ≅ Mₙ(R) = S_ring. (This is also a standard result).
-- Conclude P1 from the theorem
Conclusion: (TheoryOfModulesFor(R_ring) is MORITA_EQUIVALENT_TO TheoryOfModulesFor(S_ring))

Γ ⊢ INSTANCE ... : ProvableProposition ;
CATEGORY
[[ INSTANCE MoritaEquivalenceOfMatrixRings ... ]] = "The canonical example of Morita equivalence. It demonstrates that although the rings R and Mₙ(R) are very different (e.g., one can be commutative while the other is not), their module categories are equivalent. This means they share all 'module-theoretic' properties, such as being abelian, having enough injectives, etc. The equivalence is witnessed by the free module Rⁿ acting as the progenerator." ;
}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 4: 'Monads', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.1: Monads and their algebras" ")" "==>" {
(*
ELABORATION (Deeper Dive): This elaboration refines the formal definition of a monad and its algebras
by separating the data from the axioms, and then instantiates these abstract definitions with the
canonical and most intuitive example: the List Monad in the category of Sets.

This process will demonstrate that:

A monad is a "monoid in the category of endofunctors," with the functor List as the object,
flatten as the multiplication, and singleton as the unit.

An algebra for the List monad is precisely a monoid in the traditional sense. The monad's
coherence laws force the algebra's structure map to behave like an associative binary operation
with a unit.

This makes the abstract definitions concrete and reveals the deep connection between monads and classical algebraic structures.
*)

(* ========================================================================================================== )
( == Part 1: Refined Formal Definitions of Monad and Algebra == )
( ========================================================================================================== )

MonadAssociativityAxiom ::= "AXIOM" "MonadAssociativity" "holds_for" MonadData ;
TYPING
(* This axiom asserts the commuting of the square diagram for monad multiplication. )
( μ ⋅ T(μ) == μ ⋅ μ_T *)
Context: (T, η, μ) is MonadData
----------------------------------------------------------------------
Γ ⊢ AXIOM MonadAssociativity ... is TRUE if (μ ∘ T(μ) == μ ∘ μ_T) ;
CATEGORY
[[ AXIOM MonadAssociativity ... ]] = "The coherence law ensuring that the order in which nested applications of the monad are flattened does not matter. This is the analogue of the law (x*y)*z = x*(y*z) for monoids." ;

MonadUnitalityAxiom ::= "AXIOM" "MonadUnitality" "holds_for" MonadData ;
TYPING
(* This axiom asserts the commuting of the two triangle diagrams for the monad unit. )
( μ ⋅ T(η) == id_T AND μ ⋅ η_T == id_T *)
Context: (T, η, μ) is MonadData
---------------------------------------------------------------------------------------------
Γ ⊢ AXIOM MonadUnitality ... is TRUE if ( (μ ∘ T(η) == id_T) ∧ (μ ∘ μ_T == id_T) ) ;
CATEGORY
[[ AXIOM MonadUnitality ... ]] = "The coherence laws ensuring that the monad's unit behaves as a two-sided identity for the multiplication. This is the analogue of the laws x*e = x and e*x = x for monoids." ;

MonadDeclaration ::= "MONAD" Identifier "on" Identifier "is" "{" "Data" ":" MonadData ";" "Verification" ":" "{" MonadAssociativityAxiom ";" MonadUnitalityAxiom "}" "}" ;
TYPING
(* The refined master definition, separating data from verification. *)
Γ ⊢ data : MonadData_Type
Γ ⊢ AXIOM MonadAssociativity holds_for data
Γ ⊢ AXIOM MonadUnitality holds_for data
-------------------------------------------
Γ ⊢ MONAD T on C ... : Monad_on(C) ;
CATEGORY
[[ MONAD ... ]] = "The refined declaration of a monad, explicitly separating the structural data (functor, unit, multiplication) from the axiomatic verification that this data satisfies the required coherence laws." ;

(* ========================================================================================================== )
( == Part 2: Instantiation with the List Monad == )
( ========================================================================================================== )

MONAD "ListMonad" on "Set" is {
"Data" : MonadData ::= "ENDOFUNCTOR" "List : Set → Set" ","
"UNIT" "η_List : Id_Set ⇒ List" ","
"MULTIPLICATION" "μ_List : List ∘ List ⇒ List" ;
TYPING
Functor_List(S) := { all finite lists of elements from S }
Unit_η_List_at(S) := (x ∈ S ↦ [x])
Mult_μ_List_at(S) := ( L ∈ List(List(S)) ↦ flatten(L) )
-------------------------------------------------------------
Γ ⊢ List, η_List, μ_List are well-defined ;
CATEGORY
[[ List ]] = "The list functor." ;
[[ η_List ]] = "The 'singleton' or 'return' natural transformation." ;
[[ μ_List ]] = "The 'flatten' or 'join' natural transformation." ;

Generated code
"Verification" : {
    AXIOM "MonadAssociativity" "holds_for" "ListMonadData" ;
    TYPING
        (* flatten(map(flatten, [[a],[b,c]])) == flatten(flatten([[[a]],[[b,c]]])) *)
        (* flatten([[a],[b,c]]) == flatten([[a,b,c]]) *)
        (* [a,b,c] == [a,b,c] *)
        Holds TRUE.
        ------------------------------------------
        Γ ⊢ "ListMonad satisfies associativity" ;

    AXIOM "MonadUnitality" "holds_for" "ListMonadData" ;
    TYPING
        (* Left Unit: flatten(map(singleton, [a,b])) = flatten([[a],[b]]) = [a,b] = id([a,b]) *)
        (* Right Unit: flatten(singleton([a,b])) = flatten([[[a,b]]]) = [a,b] = id([a,b]) *)
        Holds TRUE.
        ----------------------------------------
        Γ ⊢ "ListMonad satisfies unitality" ;
}


} ;

(* ========================================================================================================== )
( == Part 3: T-Algebras for the List Monad are Monoids == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "ListAlgebrasAreMonoids" ":"
"An algebra for the ListMonad is equivalent to a monoid." ;
TYPING
(* This is a classic result that makes the concept of a T-algebra concrete. )
-- Let (A, h) be a T_List-Algebra, where h : List(A) → A.
-- Define a binary operation * and a unit element e from the structure map h:
Define_op(a,b) := h([a, b])
Define_unit() := h([])
-- Now, prove that the axioms for a T-List-Algebra force (A, op, unit) to be a monoid.
-- 1. Algebra Unitality implies Monoid Unitality:
-- The algebra axiom is h ⋅ η_A = id_A.
-- Applied to an element x: h(η_A(x)) = x => h([x]) = x.
-- Then, x * e = h([x, e]) = h([x, h([])]). Also, e * x = h([h([]), x]).
-- A more complex proof involving the algebra associativity axiom is needed to show h([x, h([])]) = h([x]) = x.
-- 2. Algebra Associativity implies Monoid Associativity:
-- The algebra axiom is h ⋅ List(h) = h ⋅ μ_A.
-- Applied to a list [[a,b],[c]]:
-- LHS: h(List(h)([[a,b],[c]])) = h([h([a,b]), h([c])]) = h([ab, c]) = (ab)c
-- RHS: h(μ_A([[a,b],[c]])) = h(flatten([[a,b],[c]])) = h([a,b,c])
-- A similar argument for [a,[b,c]] shows h([a,b,c]) = a(bc).
-- Therefore, (ab)c = a(bc).
----------------------------------------------------------------------------------------------------
Conclusion: (Γ ⊢ (A,h) is T_List_Algebra) <==> (Γ ⊢ (A, Define_op, Define_unit) is Monoid) ;
CATEGORY
[[ THEOREM ListAlgebrasAreMonoids ]] = "A fundamental theorem that provides the primary intuition for Eilenberg-Moore algebras. It asserts that to specify an algebra for the List monad on a set A is precisely to specify a monoid structure on A. The structure map h of the algebra acts as a universal 'fold' or 'reduce' operation for the monoid." ;

TheoremDeclaration ::= "THEOREM" "CategoryOfListAlgebrasIsMon" ":"
"The Eilenberg-Moore category for the ListMonad is equivalent to the category of Monoids." ;
TYPING
C_T := CategoryOfAlgebras("ListMonad")
Mon := CategoryOf("Monoids")
------------------------------------------
Γ ⊢ C_T ≅ Mon : EquivalenceOfCategories ;
CATEGORY
[[ THEOREM CategoryOfListAlgebrasIsMon ]] = "The category-level consequence of the previous theorem. It asserts that the entire semantic universe generated by the List monad is precisely the familiar category of monoids and monoid homomorphisms." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.2: Monads and adjunctions" ")" "==>" {
(*
ELABORATION: This section reveals the fundamental theorem of monad theory: that the concepts of "adjunction"
and "monad" are two sides of the same coin. Every adjunction gives rise to a monad, and every monad
can be "resolved" into an adjunction. A deep elaboration requires formalizing both directions of this
correspondence as explicit, constructive theorems.
*)

(* ========================================================================================================== )
( == Part 1: From Adjunction to Monad (The Standard Construction) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "AdjunctionInducesMonad" ":"
"Every adjunction F ⊣ G gives rise to a MONAD T = G∘F." ;
TYPING
(*

This is a constructive theorem. Given an adjunction, we can build a monad.

The proof involves defining the monad's components (T, η, μ) from the adjunction's

components and then proving that they satisfy the monad axioms.
*)
Context: Γ ⊢ F ⊣ G : Adjunction(C, D) with unit η_adj and counit ε_adj.
-- Construction of Monad Components --
Monad_T := G ∘ F : C → C
Monad_η := η_adj : Id_C ⇒ G∘F
Monad_μ := G(ε_adj_F) : G(F(G(F))) ⇒ G(F)

Conclusion: Γ ⊢ MONAD Monad_T on C is { Data:(T,η,μ), ... } : ProvableProposition ;
CATEGORY
[[ THEOREM AdjunctionInducesMonad ]] = "An assertion of the canonical construction of a monad from any adjunction. The endofunctor is the composite of the adjoint functors, the unit of the monad is the unit of the adjunction, and the multiplication of the monad is derived from the counit. This is the primary source of monads in category theory." ;

(* ========================================================================================================== )
( == Part 2: From Monad to Adjunction (The Eilenberg-Moore Resolution) == )
( ========================================================================================================== *)

EilenbergMooreAdjunctionConstructor ::= "EM_Adjunction_of" "(" MonadDeclaration ")" ;
TYPING
(*

This is the converse construction. Given a monad T, we can construct the Eilenberg-Moore

category C^T and an adjunction between it and the base category C.
*)
Context: Γ ⊢ T : MONAD on C
-- Construction of Adjunction Components --
Category_C_T := CategoryOfAlgebras(T)
Forgetful_U := The functor U^T: C^T → C that maps an algebra (A,h) to its carrier A.
Free_F := The functor F^T: C → C^T that maps an object X to the "free algebra" (T(X), μ_X).

Conclusion: Γ ⊢ F^T ⊣ U^T : Adjunction(C, C^T) ;
CATEGORY
[[ EM_Adjunction_of(T) ]] = "The Eilenberg-Moore resolution of a monad T. This construction builds the 'semantic' category C^T of T-algebras and reveals a canonical 'free-forgetful' adjunction F^T ⊣ U^T. The free functor constructs the free T-algebra on an object, and the forgetful functor extracts the underlying object." ;

(* ========================================================================================================== )
( == Part 3: The Equivalence Theorem (Closing the Loop) == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "MonadAdjunctionCorrespondence" ":"
"The monad induced by the EM_Adjunction_of(T) is isomorphic to the original monad T." ;
TYPING
(* This theorem states that the process is well-behaved: if we start with T, build its adjunction, and then build the monad from that adjunction, we get back to where we started. *)
Context: Γ ⊢ T : MONAD on C
Let Adj := EM_Adjunction_of(T).
Let T_prime := Monad induced by Adj.

Γ ⊢ T ≅ T_prime : NaturalIsomorphism ;
CATEGORY
[[ THEOREM MonadAdjunctionCorrespondence ]] = "The assertion that there is a close relationship between monads on a category C and adjunctions over C. The Eilenberg-Moore construction is a universal way to resolve any monad into a specific kind of free-forgetful adjunction. This correspondence is the heart of monadic theory, linking abstract algebraic structures (monads) to concrete universal mapping properties (adjunctions)." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.3: Limits and colimits in categories of algebras" ")" "==>" {
(*
ELABORATION: This section investigates how the rich structure of a base category C is inherited by the category
of algebras C^T for a monad T. The key result is that the forgetful functor U^T: C^T → C is exceptionally
well-behaved with respect to limits, but surprisingly poorly-behaved with respect to colimits. A deep elaboration
requires formalizing these properties precisely, highlighting this fundamental asymmetry.
*)

(* ========================================================================================================== )
( == Part 1: The Powerful Limit Properties of the Forgetful Functor == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "ForgetfulFunctorFromAlgebrasCreatesLimits" ":"
"The forgetful functor U^T from the category of T-algebras to the base category, U^T: C^T → C, 'creates' limits." ;
TYPING
(*

"Creates limits" is the strongest possible preservation property. It means that if a diagram of algebras

has an underlying diagram in C which possesses a limit, then not only does a limit for the algebra

diagram exist, but it is unique and is mapped by U^T to the underlying limit in C.
*)
Let U_T := The forgetful functor from CategoryOfAlgebras(T) to C.

Γ ⊢ U_T creates ALL_LIMITS : ProvableProposition ;
CATEGORY
[[ THEOREM ForgetfulFunctorFromAlgebrasCreatesLimits ]] = "A fundamental structural result. It asserts that to compute a limit in the category of algebras, one can simply compute the limit of the underlying objects in the base category and then equip the resulting limit object with the unique T-algebra structure that makes all the limit cone projections into T-algebra homomorphisms. This makes limits in algebraic categories very well-behaved and easy to construct." ;

CorollaryDeclaration ::= "COROLLARY" "CompletenessOfAlgebraCategories" "to" "ForgetfulFunctorCreatesLimits" ":"
"IF the base category C is complete, THEN the category of T-algebras C^T is also complete." ;
TYPING
(* This is a direct and powerful consequence of the main theorem. *)
Premise1: Γ ⊢ C is COMPLETE_CATEGORY
Premise2: Γ ⊢ ForgetfulFunctor U^T from C^T to C creates LIMITS

Γ ⊢ CategoryOfAlgebras(T) is COMPLETE_CATEGORY : ProvableProposition ;
CATEGORY
[[ COROLLARY CompletenessOfAlgebraCategories ]] = "The practical and important consequence of the main theorem: the desirable property of completeness is always inherited by the category of algebras from its base category. If a category has all limits, so does any category of algebras built upon it." ;

(* ========================================================================================================== )
( == Part 2: The Weaker Colimit Properties of the Forgetful Functor == )
( ========================================================================================================== )
(The situation for colimits is much more subtle. In general, U^T does NOT preserve colimits.)

ReflexivePair ::= "REFLEXIVE_PAIR" "(" Identifier "," Identifier ")" "with_splitting" Identifier ;
TYPING
(* A reflexive pair is a parallel pair of morphisms that share a common right inverse (a section or splitting). *)
Γ ⊢ f, g : A → B
∃ (s: B → A) s.t. (f∘s == id_B) ∧ (g∘s == id_B)

Γ ⊢ (f, g) is REFLEXIVE_PAIR with_splitting s : Proposition;
CATEGORY
[[ REFLEXIVE_PAIR ... ]] = "A special type of diagram whose coequalizer is better-behaved than a general coequalizer. This structure appears naturally in simplicial objects, descent theory, and other advanced algebraic contexts where objects are built by identifying parts of other objects." ;

TheoremDeclaration ::= "THEOREM" "ForgetfulFunctorPreservesCertainCoequalizers" ":"
"The forgetful functor U^T: C^T → C does not preserve all colimits, but it does preserve coequalizers of reflexive pairs." ;
TYPING
(*

This theorem identifies a crucial class of colimits that are preserved. This is a key technical lemma

for many results in monadic theory, such as Beck's Monadicity Theorem.
*)
Let U_T := The forgetful functor from CategoryOfAlgebras(T) to C.
Let (f,g) be a REFLEXIVE_PAIR of T-algebra homomorphisms.
Let q := Coequalizer(f, g) in C^T.

Γ ⊢ U_T(q) is Coequalizer(U_T(f), U_T(g)) in C : ProvableProposition ;
CATEGORY
[[ THEOREM ForgetfulFunctorPreservesCertainCoequalizers ]] = "A key result on the colimit behavior of algebraic categories. It highlights a fundamental asymmetry: while limits of algebras are computed on the underlying objects, colimits (like coproducts or general coequalizers) generally are not. The construction of a colimit algebra usually involves a more complex process than just taking the colimit of the underlying objects. This theorem carves out an important special case where the simpler construction is valid." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.4: Characterization of monadic categories" ")" "==>" {
(*
ELABORATION: This section addresses the fundamental "recognition problem" for monadic categories, as answered
by Beck's Monadicity Theorem. The question is: given an arbitrary functor U:A→C, how can we tell if A is
equivalent to a category of algebras C^T and U is the forgetful functor for some monad T?

A deep elaboration requires deconstructing Beck's theorem into its precise, checkable conditions. It provides
a powerful checklist to determine if a functor is "secretly" a forgetful functor from a category of algebras.
*)

(* ========================================================================================================== )
( == Part 1: The Definition and the Problem == )
( ========================================================================================================== )

FunctorProperty ::= Identifier "is" "MONADIC" ;
TYPING
(*

A functor U is monadic if it establishes an equivalence between its domain A and the

Eilenberg-Moore category C^T for the monad T induced by U's adjunction.

This is checked via the "comparison functor" K.
*)
Γ ⊢ U : Functor(A, C)
Let T be the monad induced by the adjunction that U is part of (if it exists).
Let C_T be the Eilenberg-Moore category for T.
There exists a comparison functor K: A → C_T.

Γ ⊢ U is MONADIC <==> (K is an EquivalenceOfCategories) ;
CATEGORY
[[ U is MONADIC ]] = "The property of a functor being equivalent to the forgetful functor from a category of algebras. A monadic functor reveals that its domain category A is, for all intents and purposes, a category of algebras over its codomain C." ;

(* ========================================================================================================== )
( == Part 2: The Conditions of Beck's Theorem == )
( ========================================================================================================== )

FunctorProperty ::= Identifier "reflects" "ISOMORPHISMS" ;
TYPING
(* A functor U reflects isomorphisms if its action on morphisms is so 'faithful' that it doesn't hide any isomorphisms. *)
Γ ⊢ U : Functor(A, C)

Γ ⊢ U reflects ISOMORPHISMS is TRUE if (∀(f in A), (U(f) is ISO ==> f is ISO)) ;
CATEGORY
[[ U reflects ISOMORPHISMS ]] = "A key 'conservativity' condition. It ensures that no structural information about isomorphisms is lost when applying the functor U. This is a crucial property for any functor that purports to be 'forgetful'." ;

U_SplitPair ::= "U_SPLIT_PAIR" "(" Identifier "," Identifier ")" ;
TYPING
(* A U-split pair is a parallel pair in the domain A whose image under U is a reflexive pair in C. *)
Γ ⊢ U: Functor(A, C)
Γ ⊢ f, g : X → Y in A

Γ ⊢ (f, g) is U_SPLIT_PAIR <==> (Γ ⊢ (U(f), U(g)) is REFLEXIVE_PAIR in C) ;
CATEGORY
[[ U_SPLIT_PAIR ... ]] = "A pair of maps that becomes 'splittable' after forgetting the A-structure. The coequalizer of this pair in A represents the reconstruction of the algebraic structure that was forgotten, using the splitting data that exists in the base category C. The existence and preservation of this coequalizer is the key technical condition in Beck's theorem." ;

(* ========================================================================================================== )
( == Part 3: Beck's Precise Monadicity Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "BeckMonadicityTheorem" ":"
"A functor U:A→C is MONADIC if and only if:"
"{" "1. U has a left adjoint;"
"2. U reflects isomorphisms;"
"3. A has coequalizers of all U-split pairs, and U preserves them." "}" ;
TYPING
(* This is the formal typing of the master characterization theorem. *)
P1 := (Γ ⊢ U is MONADIC)

P2_Adjoint := (U has a LeftAdjoint)
P2_ReflectsIso := (Γ ⊢ U reflects ISOMORPHISMS)
P2_Coeq := (A has coequalizers of all U-split pairs) ∧ (U preserves these coequalizers)
P2 := (P2_Adjoint ∧ P2_ReflectsIso ∧ P2_Coeq)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM BeckMonadicityTheorem ]] = "A deep and powerful characterization theorem. It provides a concrete checklist of internal properties for a functor U that are necessary and sufficient to guarantee it is monadic. It is the primary tool for identifying categories of algebras in disguise. For example, it can be used to prove that the forgetful functor from compact Hausdorff spaces to Set is monadic, revealing a hidden algebraic nature." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.5: The adjoint lifting theorem" ")" "==>" {
(*
ELABORATION: This section addresses a fundamental question of compositionality for algebraic structures. Suppose we have two algebraic structures, described by monads T on category C and T' on category D. Further, suppose we have functors connecting the base categories, K:C→D and L:D→C. The Adjoint Lifting Theorem provides conditions under which a structure-preserving map L between the base categories can be "lifted" to a structure-preserving map L̄ between the corresponding categories of algebras.

A deep elaboration requires formalizing the problem setup and the theorem's precise conclusion, revealing it as a universal property for constructing functors between Eilenberg-Moore categories.
*)

(* ========================================================================================================== )
( == Part 1: The Problem Setup == )
( ========================================================================================================== )

AdjointLiftingProblemSetup ::= "LIFTING_PROBLEM_SETUP" "{"
"Monad" MonadDeclaration "on" Identifier ","
"Monad" MonadDeclaration "on" Identifier ","
"Functor" FunctorDeclaration ","
"NaturalTransformation" NaturalTransformationDeclaration "as" "DistributiveLaw"
"}" ;
TYPING
(* This rule defines the necessary data for the lifting problem. *)
Γ ⊢ T : MONAD on C, Γ ⊢ T_prime : MONAD on D
Γ ⊢ L : Functor(D, C)
Γ ⊢ t : NaturalTransformation( T∘L, L∘T_prime )
(The natural transformation 't' must satisfy coherence conditions to be a 'monad morphism'.)

Γ ⊢ LIFTING_PROBLEM_SETUP ... : LiftingProblem ;
CATEGORY
[[ LIFTING_PROBLEM_SETUP ... ]] = "The data required to state the Adjoint Lifting Theorem. It consists of two monads on two categories, a functor L relating the base categories, and a distributive law 't' that specifies how the functor L interacts with the two monadic structures. This law is the key compatibility condition." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem and the Lifted Functor == )
( ========================================================================================================== )

LiftedFunctor ::= "LiftedFunctor" "(" AdjointLiftingProblemSetup ")" ;
TYPING
(* This constructor defines the 'lifted' functor L̄ : D^T' → C^T that the theorem guarantees exists. *)
Γ ⊢ problem : LiftingProblem
Let D_T_prime be the Eilenberg-Moore category for T'.
Let C_T be the Eilenberg-Moore category for T.

Γ ⊢ LiftedFunctor(problem) : Functor(D_T_prime, C_T) ;
CATEGORY
[[ LiftedFunctor(problem) ]] = "The functor L̄ between categories of algebras that is 'lifted' from the functor L between the base categories. For a T'-algebra (A,h:T'A→A), L̄ assigns the T-algebra structure on the object L(A) via the composite map T(L(A)) --t_A--> L(T'(A)) --L(h)--> L(A). The distributive law 't' is essential for this construction." ;

TheoremDeclaration ::= "THEOREM" "AdjointLiftingTheorem" ":"
"Given a LIFTING_PROBLEM_SETUP, the functor L:D→C lifts to a unique functor L̄: D^T' → C^T."
"Furthermore, if L has a left adjoint K, then L̄ also has a left adjoint K̄." ;
TYPING
(* This is the formal typing of the main theorem. *)
P1_Exists := (∀ problem:LiftingProblem, ∃! LiftedFunctor(problem))
P2_Adjoints := ( (∃ K s.t. K ⊣ L) ==> (∃ K_bar s.t. K_bar ⊣ LiftedFunctor(problem)) )

Γ ⊢ (P1_Exists ∧ P2_Adjoints) : MetaTheorem ;
CATEGORY
[[ THEOREM AdjointLiftingTheorem ]] = "A powerful theorem for constructing functors between categories of algebras. It states that a compatible functor between the base categories can be uniquely lifted. Crucially, it also provides a mechanism for lifting adjunctions from the base level to the algebraic level. This is fundamental for comparing different algebraic theories and their categories of models." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.6: Monads with rank" ")" "==>" {
(*
ELABORATION: This section generalizes the study of monads and their algebras by incorporating the concept of "rank," a measure of size based on a regular cardinal. The key idea is that "well-behaved" categories (locally presentable categories) are built from objects of a certain 'size' or 'rank', and a monad with 'rank' preserves this size-based structure. This ensures that the corresponding category of algebras is also well-behaved.

A deep elaboration requires us to formalize this size-based framework step-by-step:

Formalize the "size" parameter: the regular cardinal α.

Generalize the concept of "finitely presented" to "α-presentable".

Define the class of well-behaved categories these objects build: "locally α-presentable categories".

Define the property of a monad that respects this structure: a "monad with rank α".

State the main theorem, which asserts that these properties are preserved when constructing the category of algebras.
*)

(* ========================================================================================================== )
( == Part 1: Generalizing Finiteness to α-Presentability == )
( ========================================================================================================== )

RegularCardinal ::= "REGULAR_CARDINAL" Identifier ;
TYPING
(* A cardinal α is regular if its cofinality is equal to itself. Informally, it can't be reached by a smaller number of smaller cardinals. *)
Let α be a cardinal number.
cof(α) == α
-------------------------------------------
Γ ⊢ REGULAR_CARDINAL α : SetTheoreticProperty ;
CATEGORY
[[ REGULAR_CARDINAL α ]] = "A type of 'well-behaved' infinite cardinal. Aleph-null (ℵ₀), corresponding to 'finite', is the smallest infinite regular cardinal. Regular cardinals provide robust stopping points for transfinite constructions and serve as the correct notion of 'size' for generalizing categorical properties." ;

AlphaFilteredColimit ::= RegularCardinal "-FILTERED_COLIMIT" ;
TYPING
(* A colimit over a diagram whose index category is α-filtered (a generalization of filtered). *)
Γ ⊢ α : REGULAR_CARDINAL
Γ ⊢ L is COLIMIT of D:J->C
Γ ⊢ J is α_FILTERED_CATEGORY
-----------------------------------------
Γ ⊢ L is α-FILTERED_COLIMIT ;
CATEGORY
[[ α-FILTERED_COLIMIT ]] = "A colimit that represents a 'direct limit' of a system of size α. For α=ℵ₀, this is a standard filtered colimit." ;

ObjectPropertyAssertion ::= Identifier "is" RegularCardinal "-PRESENTABLE" ;
TYPING
(* An object A is α-presentable if the Hom(A,-) functor preserves α-filtered colimits. This generalizes 'finitely presented'. *)
Γ ⊢ A : Object, Γ ⊢ α : REGULAR_CARDINAL
Hom_Functor(A, -) preserves α-FILTERED_COLIMITS
---------------------------------------------------------
Γ ⊢ A is α-PRESENTABLE ;
CATEGORY
[[ A is α-PRESENTABLE ]] = "A categorical notion of 'smallness' or 'compactness' relative to the cardinal α. For α=ℵ₀, this corresponds to being a finitely presented object in an algebraic category." ;

(* ========================================================================================================== )
( == Part 2: Monads with Rank and the Main Theorem == )
( ========================================================================================================== )

MonadWithRank ::= "MONAD_WITH_RANK" RegularCardinal ;
TYPING
(* A monad T has rank α if its underlying endofunctor preserves α-filtered colimits. *)
Γ ⊢ T : MONAD on C, Γ ⊢ α : REGULAR_CARDINAL
The endofunctor T preserves α-FILTERED_COLIMITS
--------------------------------------------------
Γ ⊢ T is a MONAD_WITH_RANK α ;
CATEGORY
[[ MONAD_WITH_RANK α ]] = "A monad that is 'bounded in size' by the cardinal α. It does not create new, larger structures from α-sized pieces. Monads arising from Lawvere theories (finitary operations) are monads with rank ℵ₀." ;

LocallyPresentableCategory ::= "LOCALLY" RegularCardinal "-PRESENTABLE_CATEGORY" ;
TYPING
(* A category is locally α-presentable if it is cocomplete and has a set of α-presentable generators. *)
Γ ⊢ C : Category
Premise1: C is COCOMPLETE
Premise2: ∃ S ⊆ Ob(C) s.t. (S is a set of α-PRESENTABLE objects that generates C)
------------------------------------------------------------------------------------------
Γ ⊢ C is LOCALLY α-PRESENTABLE_CATEGORY ;
CATEGORY
[[ LOCALLY α-PRESENTABLE_CATEGORY ]] = "A very well-behaved category that is 'built from' objects of size α. These categories have excellent completeness and accessibility properties. All algebraic categories are locally finitely presentable (i.e., locally ℵ₀-presentable)." ;

TheoremDeclaration ::= "THEOREM" "RankTheoremForMonadicCategories" ":"
"IF C is a LOCALLY α-PRESENTABLE_CATEGORY and T is a MONAD_WITH_RANK α,"
"THEN the algebra category C^T is also a LOCALLY α-PRESENTABLE_CATEGORY." ;
TYPING
P1 := (Γ ⊢ C is LOCALLY α-PRESENTABLE_CATEGORY)
P2 := (Γ ⊢ T is a MONAD_WITH_RANK α on C)
-----------------------------------------------------------------------------------
Conclusion: Γ ⊢ CategoryOfAlgebras(T) is LOCALLY α-PRESENTABLE_CATEGORY : MetaTheorem ;
CATEGORY
[[ THEOREM RankTheoremForMonadicCategories ]] = "A powerful preservation theorem. It asserts that the excellent structural properties of a locally presentable category are preserved when one constructs the category of algebras for a monad of the appropriate rank. This guarantees that the category of algebras for a 'small' algebraic theory is itself 'small' and well-behaved in the same way." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 4.7: A glance at descent theory" ")" "==>" {
(*
ELABORATION: Descent theory addresses a fundamental question in geometry and algebra: when can an object
be reconstructed from "local data"? Given a "cover" map p:U→X, we can study an object E over X by pulling
it back to U, getting pE. This "local data" isn't enough; we also need "gluing data" on the overlaps
(the pullback U×_X U) that tells us how to piece pE back together. The theory of monads provides the
perfect algebraic language for this gluing data. The key insight is that a cover map induces a comonad
(the dual of a monad), and the necessary gluing data for an object is precisely the structure of a
coalgebra for this comonad. When this reconstruction process is perfect, the cover is called an "effective
descent morphism."
*)

(* ========================================================================================================== )
( == Part 1: The Core Concepts - Comonads and Coalgebras == )
( ========================================================================================================== )

ComonadDeclaration ::= "COMONAD" Identifier "on" Identifier "is" "{" "Data" ":" ComonadData ";" "Axioms" ":" ComonadAxioms "}" ;
TYPING
(* A comonad is the formal dual of a monad. *)
IsDualOf("MONAD")
EquivalentTyping:
Data: (Endofunctor G:C→C, Counit ε:G⇒Id, Comultiplication δ:G⇒G²)
Axioms: Coassociativity, Counitality

Γ ⊢ COMONAD G on C ... : Comonad_on(C) ;
CATEGORY
[[ COMONAD G on C ... ]] = "The dual of a monad. It provides a canonical way to 'co-freely' decompose an object. The counit ε maps G(X)→X, and the comultiplication δ maps G(X)→G(G(X))." ;

G_CoalgebraDeclaration ::= "G_COALGEBRA" Identifier "is" "{" "Data" ":" G_CoalgebraData ";" "Axioms" ":" G_CoalgebraAxioms "}" ;
TYPING
(* A coalgebra is the formal dual of an algebra. The structure map goes in the opposite direction. *)
IsDualOf("T_ALGEBRA")
EquivalentTyping:
Data: (Carrier A, StructureMap k: A→G(A))
Axioms: Coassociativity, Counitality

Γ ⊢ G_COALGEBRA ... : G_Coalgebra_over(G);
CATEGORY
[[ G_COALGEBRA (A,k) ... ]] = "An object A equipped with a structure map k:A→G(A) that is coherently compatible with the comonad's structure. It represents an object that can be 'decomposed' via the comonad G." ;

(* ========================================================================================================== )
( == Part 2: The Descent Construction == )
( ========================================================================================================== )

ComonadFromAdjunctionConstructor ::= "ComonadFromAdjunction" "(" AdjunctionDeclaration ")" ;
TYPING
(* A cover map p:U→X often arises from an adjunction. This constructor builds the associated comonad. *)
Context: Γ ⊢ p_sharp ⊣ p_star : Adjunction(Cat/X, Cat/U) (Pullback adjunction)
Comonad_G := p_star ∘ p_sharp

Γ ⊢ ComonadFromAdjunction ... : COMONAD on Cat/U ;
CATEGORY
[[ ComonadFromAdjunction ... ]] = "The canonical comonad induced by the pullback-pushforward adjunction associated with a cover map p. The coalgebras for this comonad are the 'descent data'." ;

CategoryOfDescentData ::= "Desc" "(" "cover" ":" MorphismDeclaration ")" ;
TYPING
(* The category of descent data for a cover p is the category of coalgebras for the comonad it induces. *)
Γ ⊢ p: U → X
G := ComonadFromCover(p)

Γ ⊢ Desc(cover: p) ≅ CategoryOfCoalgebras(G) ;
CATEGORY
[[ Desc(cover: p) ]] = "The category of 'gluable' objects over the cover U. An object in Desc(p) is an object E over U equipped with an isomorphism on the overlap U×_X U that satisfies a cocycle condition. This data is equivalent to a G-coalgebra structure." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem of Descent == )
( ========================================================================================================== )

EffectiveDescentMorphism ::= Identifier "is" "EFFECTIVE_DESCENT_MORPHISM" ;
TYPING
(* A cover morphism p is of effective descent if the reconstruction process is perfect. )
Γ ⊢ p: U → X
Let Desc_p := CategoryOfDescentData(p)
Let C_X := The category of objects over X (e.g., Cat/X)
The pullback functor p: C_X → Desc_p is an EquivalenceOfCategories

Γ ⊢ p is EFFECTIVE_DEScent_MORPHISM ;
CATEGORY
[[ p is EFFECTIVE_DESCENT_MORPHISM ]] = "A property of a cover map p indicating that it is 'faithfully flat' in a categorical sense. It guarantees that the category of objects over the base X is equivalent to the category of gluable 'descent data' over the cover U. This means that to define an object over X is the same as to define a compatible family of objects over U." ;
}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 5: 'Accessible categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.2: Locally presentable categories" ")" "==>" {
(*
ELABORATION: This section defines the main class of 'well-behaved' categories studied in this theory: the
locally λ-presentable categories. These are categories that are entirely 'built from' a set of λ-presentable
building blocks using colimits. This property is shown to have extremely powerful structural consequences,
making these categories a foundational setting for modern algebra and category theory.
*)

(* ========================================================================================================== )
( == Part 1: The Master Definition == )
( ========================================================================================================== *)

LocallyPresentableCategory ::= "LOCALLY" RegularCardinal "-PRESENTABLE_CATEGORY" ;
TYPING
(*
* The formal definition of a locally λ-presentable category C requires two conditions:
* 1. C is cocomplete (it has all the 'glue' needed to build things).
* 2. There exists a small set S of λ-presentable objects which generates the entire category
* under colimits. That is, every object in C can be written as a colimit of objects from S.
*)
Γ ⊢ C : Category, Γ ⊢ λ : REGULAR_CARDINAL
Premise1: C is COCOMPLETE
Premise2: ∃ S ⊆ Ob(C) s.t. (S is a SET) ∧ (∀ A∈S, A is λ-PRESENTABLE) ∧ (S generates C under colimits)
----------------------------------------------------------------------------------------------------------
Γ ⊢ C is LOCALLY λ-PRESENTABLE_CATEGORY ;
CATEGORY
[[ LOCALLY λ-PRESENTABLE_CATEGORY ]] = "A very well-behaved category that is 'algebraic in nature' at the scale of λ. It is guaranteed to be built from a small set of 'compact' objects of size λ. Categories of models for algebraic theories (like Grp, R-Mod) are the canonical examples of locally finitely (i.e., ℵ₀-) presentable categories." ;

(* ========================================================================================================== )
( == Part 2: The Powerful Structural Consequences == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LocallyPresentableImpliesComplete" ":"
"Every LOCALLY_PRESENTABLE_CATEGORY is also a COMPLETE category." ;
TYPING
(Γ ⊢ C is LOCALLY_PRESENTABLE_CATEGORY) ==> (Γ ⊢ C is COMPLETE_CATEGORY)
--------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocallyPresentableImpliesComplete ]] = "A powerful structural guarantee. The assumption of being built from small objects via colimits (cocompleteness) is strong enough to force the existence of all limits as well. This is a form of the Adjoint Functor Theorem, and it shows the deep symmetry inherent in these categories." ;

TheoremDeclaration ::= "THEOREM" "LocallyPresentableAreWellBehaved" ":"
"Every LOCALLY_PRESENTABLE_CATEGORY is well-powered, well-copowered, and has a (StrongEpi, Mono) factorization system." ;
TYPING
(Γ ⊢ C is LOCALLY_PRESENTABLE_CATEGORY) ==> (Γ ⊢ C is WELL-POWERED ∧ C is WELL-COPOWERED ∧ C has StrongEpiMonoFactorization)
----------------------------------------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocallyPresentableAreWellBehaved ]] = "An assertion that locally presentable categories possess all the standard 'niceness' properties expected of an algebraic category. They have well-behaved subobject and quotient lattices, and a canonical image factorization system." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.2: Locally presentable categories" ")" "==>" {
(*
ELABORATION: This section defines the main class of 'well-behaved' categories studied in this theory: the
locally λ-presentable categories. These are categories that are entirely 'built from' a set of λ-presentable
building blocks using colimits. This property is shown to have extremely powerful structural consequences,
making these categories a foundational setting for modern algebra and category theory.
*)

(* ========================================================================================================== )
( == Part 1: The Master Definition == )
( ========================================================================================================== *)

LocallyPresentableCategory ::= "LOCALLY" RegularCardinal "-PRESENTABLE_CATEGORY" ;
TYPING
(*
* The formal definition of a locally λ-presentable category C requires two conditions:
* 1. C is cocomplete (it has all the 'glue' needed to build things).
* 2. There exists a small set S of λ-presentable objects which generates the entire category
* under colimits. That is, every object in C can be written as a colimit of objects from S.
*)
Γ ⊢ C : Category, Γ ⊢ λ : REGULAR_CARDINAL
Premise1: C is COCOMPLETE
Premise2: ∃ S ⊆ Ob(C) s.t. (S is a SET) ∧ (∀ A∈S, A is λ-PRESENTABLE) ∧ (S generates C under colimits)
----------------------------------------------------------------------------------------------------------
Γ ⊢ C is LOCALLY λ-PRESENTABLE_CATEGORY ;
CATEGORY
[[ LOCALLY λ-PRESENTABLE_CATEGORY ]] = "A very well-behaved category that is 'algebraic in nature' at the scale of λ. It is guaranteed to be built from a small set of 'compact' objects of size λ. Categories of models for algebraic theories (like Grp, R-Mod) are the canonical examples of locally finitely (i.e., ℵ₀-) presentable categories." ;

(* ========================================================================================================== )
( == Part 2: The Powerful Structural Consequences == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LocallyPresentableImpliesComplete" ":"
"Every LOCALLY_PRESENTABLE_CATEGORY is also a COMPLETE category." ;
TYPING
(Γ ⊢ C is LOCALLY_PRESENTABLE_CATEGORY) ==> (Γ ⊢ C is COMPLETE_CATEGORY)
--------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocallyPresentableImpliesComplete ]] = "A powerful structural guarantee. The assumption of being built from small objects via colimits (cocompleteness) is strong enough to force the existence of all limits as well. This is a form of the Adjoint Functor Theorem, and it shows the deep symmetry inherent in these categories." ;

TheoremDeclaration ::= "THEOREM" "LocallyPresentableAreWellBehaved" ":"
"Every LOCALLY_PRESENTABLE_CATEGORY is well-powered, well-copowered, and has a (StrongEpi, Mono) factorization system." ;
TYPING
(Γ ⊢ C is LOCALLY_PRESENTABLE_CATEGORY) ==> (Γ ⊢ C is WELL-POWERED ∧ C is WELL-COPOWERED ∧ C has StrongEpiMonoFactorization)
----------------------------------------------------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocallyPresentableAreWellBehaved ]] = "An assertion that locally presentable categories possess all the standard 'niceness' properties expected of an algebraic category. They have well-behaved subobject and quotient lattices, and a canonical image factorization system." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.3: Accessible categories" ")" "==>" {
(*
ELABORATION: This section introduces a significant weakening of the concept of a locally presentable
category. An "accessible" category still relies on a set of λ-presentable building blocks, but it is not
required to be cocomplete. Instead, it is only required to have the specific colimits—the λ-filtered
ones—that are necessary to test for λ-presentability. This makes the concept much more general,
encompassing a wider range of examples.
*)

(* ========================================================================================================== )
( == The Master Definition == )
( ========================================================================================================== *)

AccessibleCategory ::= RegularCardinal "-ACCESSIBLE_CATEGORY" ;
TYPING
(*
* A category C is λ-accessible if it satisfies two conditions:
* 1. C has all λ-filtered colimits.
* 2. There exists a small SET S of λ-presentable objects such that every object in C
* is a λ-filtered colimit of objects from S. (This is weaker than generating under ALL colimits).
*)
Γ ⊢ C : Category, Γ ⊢ λ : REGULAR_CARDINAL
Premise1: C has all λ-FILTERED_COLIMITS
Premise2: ∃ S ⊆ Ob(C) s.t. (S is a SET) ∧ (∀ A∈S, A is λ-PRESENTABLE) ∧ (every object is a λ-filtered colimit of objects from S)
--------------------------------------------------------------------------------------------------------------------------------
Γ ⊢ C is a λ-ACCESSIBLE_CATEGORY ;
CATEGORY
[[ λ-ACCESSIBLE_CATEGORY ]] = "A category generated by a set of 'small' objects of size λ using only direct limits of size λ. This is a broad and important class of categories that includes all locally presentable categories, but also others that may lack some colimits. It represents a robust notion of being 'algebraic in spirit' without requiring full cocompleteness." ;

(* ========================================================================================================== )
( == The Relationship to Locally Presentable == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "LocallyPresentableImpliesAccessible" ":"
"Every LOCALLY_PRESENTABLE_CATEGORY is an ACCESSIBLE category of the same rank." ;
TYPING
(Γ ⊢ C is LOCALLY λ-PRESENTABLE_CATEGORY) ==> (Γ ⊢ C is a λ-ACCESSIBLE_CATEGORY)
-------------------------------------------------------------------------------
Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM LocallyPresentableImpliesAccessible ]] = "The assertion that local presentability is a strictly stronger condition than accessibility. A locally presentable category is cocomplete, so it certainly has all λ-filtered colimits, and its generating set of λ-presentable objects is sufficient, thus satisfying the accessibility criteria. The converse is not true." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.4: Raising the degree of accessibility" ")" "==>" {
(*
ELABORATION: This section explores the relationship between different 'levels' of presentability and
accessibility. It answers the question: if a category is built from small pieces of size λ, what can we
say about its structure at a larger size κ? The main result is that these properties are upwardly stable:
a category built from λ-sized pieces can also be seen as being built from κ-sized pieces for any larger
regular cardinal κ.

A deep elaboration requires that we first formalize the key technical lemma that underpins this stability,
and then state the main theorems for both accessible and locally presentable categories.
*)

(* ========================================================================================================== )
( == Part 1: The Prerequisite Lemma - Presentability is Stable Upwards == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "PresentabilityIsStableUpwards" ":"
"IF λ < κ are regular cardinals, THEN any λ-PRESENTABLE object is also κ-PRESENTABLE." ;
TYPING
(*
* This is the core technical result needed for this section. The proof rests on the following facts:
* 1. An object A is κ-presentable if Hom(A,-) preserves κ-filtered colimits.
* 2. If κ > λ, then any κ-filtered category is also a λ-filtered category.
* 3. Therefore, any κ-filtered colimit is also a λ-filtered colimit.
* 4. If A is λ-presentable, Hom(A,-) preserves ALL λ-filtered colimits.
* 5. Thus, Hom(A,-) must preserve the subset of them that are κ-filtered colimits.
* 6. Therefore, A is κ-presentable.
*)
Context: λ, κ are REGULAR_CARDINALs with λ < κ.
Premise1: Γ ⊢ A is λ-PRESENTABLE (i.e., Hom(A,-) preserves λ-filtered colimits)
Premise2: (D:J→C is κ-filtered colimit) ==> (D is λ-filtered colimit)
-------------------------------------------------------------------------------------------------
Conclusion: Hom(A,-) preserves κ-filtered colimits, which implies (Γ ⊢ A is κ-PRESENTABLE). ;
CATEGORY
[[ THEOREM PresentabilityIsStableUpwards ]] = "The assertion that the property of being a 'small' or 'compact' object is preserved as the notion of 'large' increases. This lemma is the engine that drives the stability results for accessible and locally presentable categories." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem for Accessible Categories == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "RaisingTheDegreeOfAccessibility" ":"
"IF a category C is λ-ACCESSIBLE, THEN C is also κ-ACCESSIBLE for every regular cardinal κ > λ." ;
TYPING
(*
* This is the main theorem for accessible categories. It shows that accessibility is stable upwards.
* Proof Sketch:
* 1. Let C be λ-accessible. C is generated by a set S_λ of λ-presentable objects.
* 2. By the "PresentabilityIsStableUpwards" theorem, every object in S_λ is also κ-presentable.
* 3. A non-trivial result shows that the category C will also have all κ-filtered colimits.
* 4. A further result shows that the same set S_λ is sufficient to generate C using κ-filtered colimits.
* 5. Therefore, C satisfies the definition of a κ-accessible category.
*)
P1 := (Γ ⊢ C is a λ-ACCESSIBLE_CATEGORY)
P2 := (∀ (κ : REGULAR_CARDINAL, κ > λ), (Γ ⊢ C is a κ-ACCESSIBLE_CATEGORY))
---------------------------------------------------------------------------
(P1 ==> P2) : MetaTheorem ;
CATEGORY
[[ THEOREM RaisingTheDegreeOfAccessibility ]] = "A key stability result for accessible categories. It guarantees that if a category is constructible from λ-small pieces via λ-direct limits, it is also constructible from κ-small pieces via κ-direct limits for any larger scale κ. This shows that accessibility is a very robust property." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem for Locally Presentable Categories == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "RaisingTheDegreeOfPresentability" ":"
"IF a category C is LOCALLY λ-PRESENTABLE, THEN C is also LOCALLY κ-PRESENTABLE for every regular cardinal κ > λ." ;
TYPING
(*
* This is the corresponding, stronger result for locally presentable categories.
* Proof sketch:
* 1. Let C be locally λ-presentable. By definition, C is cocomplete, so it has all κ-filtered colimits.
* 2. Let S_κ be the set of all κ-presentable objects in C. We need to show S_κ is a generating set.
* 3. The proof shows that every object in a locally λ-presentable category can be expressed
* as a κ-filtered colimit of κ-presentable objects, which satisfies the definition.
*)
P1 := (Γ ⊢ C is LOCALLY λ-PRESENTABLE_CATEGORY)
P2 := (∀ (κ : REGULAR_CARDINAL, κ > λ), (Γ ⊢ C is LOCALLY κ-PRESENTABLE_CATEGORY))
---------------------------------------------------------------------------------
(P1 ==> P2) : MetaTheorem ;
CATEGORY
[[ THEOREM RaisingTheDegreeOfPresentability ]] = "A fundamental stability result for the theory of locally presentable categories. It asserts that this 'well-behaved' property is stable upwards. It means that a category like Grp, which is locally finitely (ℵ₀-) presentable, is automatically locally ℵ₁-presentable, locally ℵ₂-presentable, and so on, confirming its robustness across all scales of construction." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.5: Functors with rank" ")" "==>" {
(*
ELABORATION: This section defines the "correct" notion of a structure-preserving map between accessible
or locally presentable categories. Such a functor must be "small" or "bounded" in a way that respects
the size-based structure of its domain. This property is called having a "rank." The main result connects
this idea back to the theory of adjoints, showing that right adjoints between these well-behaved categories
are automatically bounded in this way.
*)

(* ========================================================================================================== )
( == Part 1: The Definition of Rank == )
( ========================================================================================================== *)

FunctorProperty ::= Identifier "has" "RANK" RegularCardinal ;
TYPING
(*
* This is the core definition. A functor F has rank λ if it preserves λ-filtered colimits.
* This is precisely the condition required to test for λ-presentability, but now applied to the functor itself.
* It means the functor is "λ-continuous".
*)
Γ ⊢ F : Functor(C, D), Γ ⊢ λ : REGULAR_CARDINAL
-------------------------------------------------------------------------------
Γ ⊢ F has RANK λ <==> (F preserves λ-FILTERED_COLIMITS) ;
CATEGORY
[[ F has RANK λ ]] = "The property of a functor being 'continuous' with respect to structures of size λ. It ensures that the functor's behavior on a large, λ-directed system is determined by its behavior on the smaller components. A functor arising from a Lawvere theory (i.e., with finitary operations) has rank ℵ₀." ;

(* ========================================================================================================== )
( == Part 2: The Main Theorem (Adjoints Have Rank) == )
( ========================================================================================================== *)
(This theorem provides the main source of functors with rank.)

TheoremDeclaration ::= "THEOREM" "RightAdjointsBetweenLPCatsHaveRank" ":"
"IF F: C ⇆ D :G is an adjunction between LOCALLY λ-PRESENTABLE categories,"
"THEN the right adjoint G has a rank (specifically, rank λ)." ;
TYPING
Context: Γ ⊢ C, D are LOCALLY λ-PRESENTABLE_CATEGORY
Γ ⊢ F ⊣ G : Adjunction(C,D)
------------------------------------------------------
Conclusion: Γ ⊢ G has RANK λ : ProvableProposition ;
CATEGORY
[[ THEOREM RightAdjointsBetweenLPCatsHaveRank ]] = "A version of the Adjoint Functor Theorem tailored to the context of locally presentable categories. It asserts that any right adjoint between such well-behaved categories is automatically 'bounded' and respects the size-based structure of its domain. Dually, the left adjoint F preserves λ-presentable objects. This shows the deep compatibility between the theory of adjunctions and the theory of presentable categories." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 5.6: Sketches" ")" "==>" {
(*
ELABORATION: This section provides the ultimate "syntactic" characterization of locally presentable
categories. A "sketch" is a purely formal, graphical way to specify a theory—it's a category together with
a designated set of cones and cocones that are to be interpreted as limits and colimits. A "model" of a sketch
is a functor that realizes this specification. The main theorem establishes a profound equivalence: the categories
that are locally presentable (a semantic, object-based property) are precisely the categories of models of some sketch
(a syntactic, specification-based property).
*)

(* ========================================================================================================== )
( == Part 1: The Syntax - The Sketch == )
( ========================================================================================================== *)

SketchDeclaration ::= "SKETCH" Identifier "is" "{" "UnderlyingCategory" ":" Identifier "," "LimitCones" ":" {ConeDeclaration} "," "ColimitCocones" ":" {CoconeDeclaration} "}" ;
TYPING
(* A sketch is a category J equipped with two sets of diagrams that are marked for interpretation. *)
Γ ⊢ J : SmallCategory
Γ ⊢ Cones : Set of Cone(in J)
Γ ⊢ Cocones : Set of Cocone(in J)
-----------------------------------------------------------------------------------------------------
Γ ⊢ SKETCH S ... : Sketch_Type ;
CATEGORY
[[ SKETCH S ... ]] = "A syntactic specification of a categorical theory. It consists of a small category (the 'alphabet' of types and operations) and a collection of diagrams within it that are designated to become limits and colimits in any valid model. This provides a uniform language for specifying products, coproducts, equalizers, and other complex structures." ;

(* ========================================================================================================== )
( == Part 2: The Semantics - The Model == )
( ========================================================================================================== *)

ModelOfSketch ::= "MODEL_OF" SketchDeclaration "in" CategoryDeclaration ;
TYPING
(*
* A model of a sketch S in a category C is a functor F from the sketch's underlying category
* that turns every designated cone into a limit cone and every designated cocone into a colimit cone.
*)
Γ ⊢ S : Sketch_Type, Γ ⊢ C : Category
Γ ⊢ F : Functor(UnderlyingCategory(S), C)
Premise1: ∀ cone ∈ LimitCones(S), F(cone) is a LIMIT_CONE in C
Premise2: ∀ cocone ∈ ColimitCocones(S), F(cocone) is a COLIMIT_CONE in C
-------------------------------------------------------------------------------
Γ ⊢ MODEL_OF S in C : SketchModel_Type ;
CATEGORY
[[ MODEL_OF S in C ]] = "A semantic realization of the theory specified by the sketch S. The functor acts as an interpretation map, assigning concrete objects and morphisms in the target category C to the abstract symbols in the sketch, in a way that satisfies all the specified limit and colimit axioms." ;

CategoryOfSketchModels ::= "Mod" "(" SketchDeclaration "," CategoryDeclaration ")" ;
TYPING
(* The category of all models of a sketch S in C. *)
Γ ⊢ S : Sketch_Type, Γ ⊢ C : Category
Objects := { F | F is a MODEL_OF S in C }
Morphisms := { α : F₁ ⇒ F₂ | α is a NaturalTransformation }
---------------------------------------------------------------
Γ ⊢ Mod(S, C) : Category ;
CATEGORY
[[ Mod(S, C) ]] = "The category of all models of the sketch S in C. For example, if S is a sketch for the theory of categories, then Mod(S, Set) would be the category of all small categories." ;

(* ========================================================================================================== )
( == Part 3: The Main Characterization Theorem == )
( ========================================================================================================== *)

TheoremDeclaration ::= "THEOREM" "GabrielUlmerDuality" ":"
"A category C is LOCALLY_PRESENTABLE if and only if C is equivalent to the category of models of some sketch." ;
TYPING
P1 := (Γ ⊢ C is LOCALLY_PRESENTABLE_CATEGORY)
P2 := (∃ (S:Sketch_Type) s.t. C ≅ Mod(S, Set))
-------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM GabrielUlmerDuality ]] = "A profound characterization theorem that establishes a duality between the 'semantic' world of locally presentable categories and the 'syntactic' world of sketches. It asserts that any category with the nice semantic property of being built from small generators can be completely described by a finite amount of syntactic data (a sketch), and vice versa. This is a cornerstone of modern categorical logic and algebraic theory." ;
}


MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 6: 'Enriched category theory', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.1: Symmetric monoidal closed categories" ")" "==>" {
(*
ELABORATION (Deeper Dive): This elaboration focuses exclusively on the foundational concepts of Section 6.1.
It deconstructs the definition of a Symmetric Monoidal Closed Category into its most fundamental, formal components.
We are moving beyond simply naming the axioms to formalizing the diagrams they represent.

This elaboration will proceed in three stages:

Monoidal Category: We will meticulously define the associator, left_unitor, and right_unitor
as natural isomorphisms. Then, we will formalize the Pentagon Axiom and Triangle Axiom as
explicit commutative diagrams that these isomorphisms must satisfy. This makes the coherence of a
monoidal category fully explicit.

Symmetric Monoidal Category: We will add the braiding natural isomorphism and formalize its
own coherence law, the Hexagon Axiom, which ensures its compatibility with the associator.

Symmetric Monoidal Closed Category: We will define the crucial concept of an InternalHomObject
and state the Tensor-Hom Adjunction, which is the universal property that defines the "closed"
structure and makes the category a suitable environment for enriched category theory.
*)

(* ========================================================================================================== )
( == Part 1: The Monoidal Category Deconstructed == )
( ========================================================================================================== )

MonoidalCategoryDeclaration ::= "MONOIDAL_CATEGORY" Identifier "is" "{"
"Data" ":" MonoidalCategoryData ";"
"Constraints" ":" "{" AssociatorDeclaration ";" LeftUnitorDeclaration ";" RightUnitorDeclaration "}" ";"
"Axioms" ":" "{" PentagonAxiom ";" TriangleAxiom "}" ";"
"}" ;
TYPING
(* This is the master definition, combining the data, the constraint isomorphisms, and the coherence axioms for those constraints. *)
Γ ⊢ data : MonoidalCategoryData_Type
Γ ⊢ α : NaturalIsomorphism, Γ ⊢ λ : NaturalIsomorphism, Γ ⊢ ρ : NaturalIsomorphism
Γ ⊢ PentagonAxiom_holds_for(α)
Γ ⊢ TriangleAxiom_holds_for(α,λ,ρ)
--------------------------------------------------------------------------------------
Γ ⊢ MONOIDAL_CATEGORY ... : MonoidalCategory ;
CATEGORY
[[ MONOIDAL_CATEGORY V ... ]] = "A category V with a tensor product that is associative and unital up to coherent, specified isomorphisms." ;

(* --- The Constraint Isomorphisms --- )
AssociatorDeclaration ::= "associator" "α" ":" "( _ ⊗ _ ) ⊗ " "≅" " ⊗ ( _ ⊗ _ )" ;
TYPING
( The associator α is a natural isomorphism between two functors from V×V×V to V. *)
Functor_LHS(A,B,C) := (A ⊗ B) ⊗ C
Functor_RHS(A,B,C) := A ⊗ (B ⊗ C)
----------------------------------------------------------------
Γ ⊢ α : NaturalIsomorphism(Functor_LHS, Functor_RHS) ;
CATEGORY
[[ associator α ... ]] = "The natural isomorphism with components α_{A,B,C} : (A⊗B)⊗C → A⊗(B⊗C) that witnesses the associativity of the tensor product." ;

LeftUnitorDeclaration ::= "left_unitor" "λ" ":" "( I ⊗ _ )" "≅" "Id" ;
TYPING
(* The left unitor λ is a natural isomorphism from the functor (I ⊗ -) to the identity functor. *)
Functor_LHS(A) := I ⊗ A
Functor_RHS(A) := A
------------------------------------------------------------
Γ ⊢ λ : NaturalIsomorphism(Functor_LHS, Functor_RHS) ;
CATEGORY
[[ left_unitor λ ... ]] = "The natural isomorphism with components λ_A : I⊗A → A that witnesses the fact that the unit object I is a left identity for the tensor product." ;

RightUnitorDeclaration ::= "right_unitor" "ρ" ":" "( _ ⊗ I )" "≅" "Id" ;
TYPING
(* The right unitor ρ is a natural isomorphism from the functor (- ⊗ I) to the identity functor. *)
Functor_LHS(A) := A ⊗ I
Functor_RHS(A) := A
-------------------------------------------------------------
Γ ⊢ ρ : NaturalIsomorphism(Functor_LHS, Functor_RHS) ;
CATEGORY
[[ right_unitor ρ ... ]] = "The natural isomorphism with components ρ_A : A⊗I → A that witnesses the fact that the unit object I is a right identity for the tensor product." ;

(* --- The Coherence Axioms --- )
PentagonAxiom ::= "AXIOM" "PentagonIdentity" ":" "FOR_ALL A,B,C,D, the pentagon diagram commutes." ;
TYPING
( This axiom states that for any four objects, the following diagram of α-isomorphisms must commute. *)
Path1_Top := α_{A⊗B, C, D} ∘ α_{A, B, C⊗D}
Path2_Bottom := (Id_A ⊗ α_{B,C,D}) ∘ α_{A, B⊗C, D} ∘ (α_{A,B,C} ⊗ Id_D)
----------------------------------------------------------------
Γ ⊢ PentagonIdentity holds if (Path1_Top == Path2_Bottom) ;
CATEGORY
[[ AXIOM PentagonIdentity ... ]] = "Mac Lane's Coherence Theorem for monoidal categories. It guarantees that any two ways of re-associating a long tensor product using the associator α will result in the same composite isomorphism. This means parentheses can be dropped without ambiguity." ;

TriangleAxiom ::= "AXIOM" "TriangleIdentity" ":" "FOR_ALL A,B, the triangle diagram commutes." ;
TYPING
(* This axiom states that the associator is compatible with the unitors. *)
Path_Direct := ρ_A ⊗ Id_B
Path_Indirect := (Id_A ⊗ λ_B) ∘ α_{A, I, B}
-----------------------------------------------------------
Γ ⊢ TriangleIdentity holds if (Path_Direct == Path_Indirect) ;
CATEGORY
[[ AXIOM TriangleIdentity ... ]] = "The coherence law relating the associator and the unitors. It ensures that the two canonical ways to remove the unit object from the expression A⊗I⊗B are the same, guaranteeing that the unitors are well-behaved." ;

(* ========================================================================================================== )
( == Part 2: The Symmetric Monoidal Category == )
( ========================================================================================================== )

SymmetricMonoidalCategoryDeclaration ::= "SYMMETRIC" MonoidalCategoryDeclaration "with" "{"
BraidingDeclaration ";"
HexagonAxiom ";"
"}" ;
TYPING
Γ ⊢ V : MONOIDAL_CATEGORY
Γ ⊢ γ : Braiding_Type
Γ ⊢ HexagonAxiom_holds_for(V's associator α, γ)
--------------------------------------------------
Γ ⊢ SYMMETRIC ... : SymmetricMonoidalCategory ;
CATEGORY
[[ SYMMETRIC MONOIDAL_CATEGORY V ... ]] = "A monoidal category with a commutative tensor product, where commutativity is witnessed by a coherent natural isomorphism γ." ;

BraidingDeclaration ::= "braiding" "γ" ":" "_ ⊗ " "≅" " ⊗ " ;
TYPING
(* The braiding γ is a natural isomorphism from the tensor functor to itself with swapped arguments. *)
Functor_Tensor(A,B) := A ⊗ B
Functor_Tensor_Swapped(A,B) := B ⊗ A
SymmetryCondition: γ{B,A} ∘ γ_{A,B} == id_{A⊗B}
---------------------------------------------------------------------------------------
Γ ⊢ γ : NaturalIsomorphism(Functor_Tensor, Functor_Tensor_Swapped) which is symmetric ;
CATEGORY
[[ braiding γ ... ]] = "The symmetry isomorphism, with components γ_{A,B} : A⊗B → B⊗A. It witnesses the commutativity of the tensor product." ;

HexagonAxiom ::= "AXIOM" "HexagonIdentity" ":" "FOR_ALL A,B,C, the hexagon diagram commutes." ;
TYPING
(* This is the coherence law that makes the braiding compatible with associativity. *)
Path1 := α_{A,C,B} ∘ γ_{A, B⊗C} ∘ α_{A,B,C}
Path2 := (Id_A ⊗ γ_{B,C}) ∘ α_{A,C,B} ∘ (γ_{A,B} ⊗ Id_C)
-----------------------------------------------------------
Γ ⊢ HexagonIdentity holds if (Path1 == Path2) ;
CATEGORY
[[ AXIOM HexagonIdentity ... ]] = "The coherence law for a symmetric monoidal category. It guarantees that the braiding interacts correctly with the associator, ensuring that all diagrammatic calculations involving both associativity and commutativity are unambiguous." ;

(* ========================================================================================================== )
( == Part 3: The Symmetric Monoidal Closed Category == )
( ========================================================================================================== )

SymmetricMonoidalClosedCategoryDeclaration ::= SymmetricMonoidalCategoryDeclaration "which_is_CLOSED_by" "{"
InternalHomObjectDeclaration ";"
TensorHomAdjunctionTheorem ";"
"}" ;
TYPING
Γ ⊢ V : SYMMETRIC_MONOIDAL_CATEGORY
Γ ⊢ exists_internal_hom
Γ ⊢ exists_adjunction
---------------------------------------------------
Γ ⊢ ... which_is_CLOSED ... : SymmetricMonoidalClosedCategory ;
CATEGORY
[[ ... which_is_CLOSED ... ]] = "The required structure for an enriching category V. It is a symmetric monoidal category that also possesses an internal hom-object, making it a suitable universe for both 'logic' (hom) and 'conjunction' (tensor)." ;

InternalHomObjectDeclaration ::= "INTERNAL_HOM_OBJECT" "[" Identifier "," Identifier "]" ;
TYPING
(* The internal hom is an object in V representing the collection of morphisms between two other objects. *)
Γ ⊢ B, C : Object_in(V)
--------------------------
Γ ⊢ [B, C] : Object_in(V) ;
CATEGORY
[[ [B, C] ]] = "The internal hom-object, or exponential object. It is the object in V that represents the 'function space' from B to C." ;

TensorHomAdjunctionTheorem ::= "THEOREM" "TensorHomAdjunction" ":" "The functor (-⊗B) is left adjoint to the functor [B,-]." ;
TYPING
(* This adjunction is the universal property that defines the internal hom object. *)
Let F(A) := A ⊗ B
Let G(C) := [B, C]
------------------------------------------------------------------------------------------
Γ ⊢ F ⊣ G : Adjunction(V,V) which is equivalent to Hom_V(A⊗B, C) ≅ Hom_V(A, [B,C]) ;
CATEGORY
[[ THEOREM TensorHomAdjunction ... ]] = "The assertion of the currying/uncurrying isomorphism at the categorical level. This natural isomorphism is the defining property of a closed category. It provides the mechanism for converting morphisms out of a tensor product into morphisms into an internal hom-object, which is the heart of enriched category theory." ;
}

(*
ELABORATION: This section defines the central object of study for the chapter: a "V-enriched category,"
or "V-category." Having established the necessary structure for the enriching category V (it must be
a monoidal category), we can now generalize the very definition of a category. A deep elaboration must
show how each component of the standard definition—hom-sets, composition functions, identities—is
replaced by its V-enriched analogue.

Our formalization will proceed by deconstructing the definition of a V-category into its two main parts:

The Data: We will formalize the "data" of a V-category C. This consists of a collection of objects,
and then, for each pair of objects, a "hom-object" C(A,B) in V, a "composition" morphism ∘ in V,
and an "identity" morphism j in V.

The Axioms: We will formalize the axioms that this data must satisfy. The familiar associativity and
unitality laws are no longer simple equations about function application but become commuting diagrams
of morphisms within the enriching category V. These diagrams crucially involve the structural
isomorphisms (the associator α and unitors λ, ρ) of V itself.

This approach reveals that an enriched category is not just a category with extra properties, but a
fundamentally different kind of structure whose laws are expressed in the language of its enriching base V.
*)

(* ========================================================================================================== )
( == Part 1: The Data of a V-Category == )
( ========================================================================================================== )

EnrichedCategoryData ::= "DATA_V_Category" "{"
"Objects" ":" "{" {Identifier} "}" ";"
"HomObjects" ":" "{" {HomObjectDeclaration} "}" ";"
"Composition" ":" "{" {CompositionMorphismDeclaration} "}" ";"
"Identities" ":" "{" {IdentityMorphismDeclaration_Enriched} "}" ";"
"}" ;
TYPING
(* This rule defines the raw structural data of a V-category, before any axioms are checked. *)
Context: Γ ⊢ V : MonoidalCategory
-- All components are checked for well-typedness within V --
∀ hom_obj ∈ HomObjects, its declared type is an Object_in(V).
∀ comp_mor ∈ Composition, it is a Morphism_in(V) of the correct type.
∀ id_mor ∈ Identities, it is a Morphism_in(V) of the correct type.

Γ ⊢ DATA_V_Category ... : EnrichedCategoryData_Type ;
CATEGORY
[[ DATA_V_Category ... ]] = "The structural data for a V-enriched category. It comprises the collection of objects and the families of hom-objects, composition morphisms, and identity morphisms, all interpreted within the enriching category V." ;

HomObjectDeclaration ::= "hom" "(" Identifier "," Identifier ")" "is" Identifier ";" ;
TYPING
(* This rule declares that for the pair of C-objects (A,B), the hom-object is the V-object C(A,B). *)
Γ ⊢ C_A, C_B : Object_in(EnrichedCategory C)

Γ ⊢ hom(C_A, C_B) is V_obj : HomObject_in(V) ;
CATEGORY
[[ hom(A,B) is V_obj ]] = "The assignment of the object V_obj from the enriching category V to serve as the 'collection of morphisms' between objects A and B in the enriched category C." ;

CompositionMorphismDeclaration ::= "compose_" Identifier "" Identifier "" Identifier " : " "C(" Identifier "," Identifier ") ⊗ C(" Identifier "," Identifier ") → C(" Identifier "," Identifier ")" ;
TYPING
(* Defines the composition morphism in V. *)
Context: EnrichedCategory C, MonoidalCategory V

Γ ⊢ compose_ABC : Morphism( C(B,C) ⊗ C(A,B), C(A,C) ) in V ;
CATEGORY
[[ compose_ABC ... ]] = "The composition morphism. It replaces the set-theoretic composition function, acting on the tensor product of hom-objects to produce a result in another hom-object. It is a morphism inside V." ;

IdentityMorphismDeclaration_Enriched ::= "id_" Identifier " : " "I → C(" Identifier "," Identifier ")" ;
TYPING
(* Defines the identity-selecting morphism in V. *)
Context: EnrichedCategory C, MonoidalCategory V with UnitObject I

Γ ⊢ id_A : Morphism( I, C(A,A) ) in V ;
CATEGORY
[[ id_A ... ]] = "The identity morphism for object A. It replaces the selection of an identity element, instead using a morphism from V's monoidal unit I to pick out the identity in the hom-object C(A,A). It is a morphism inside V." ;

(* ========================================================================================================== )
( == Part 2: The Axioms of a V-Category == )
( ========================================================================================================== )

EnrichedAssociativityAxiom ::= "AXIOM" "EnrichedAssociativity" ":" "The associativity pentagon commutes in V." ;
TYPING
(*

This axiom asserts that the familiar associativity pentagon is now a commutative diagram of morphisms in V.

It connects the composition morphisms ∘ of the enriched category C with the associator isomorphism α of V.

The diagram asserts: ∘_ACD ∘ (∘_ABC ⊗ id) == ∘_ABD ∘ (id ⊗ ∘_BCD) ∘ α_{C(C,D),C(B,C),C(A,B)}
*)
Context: EnrichedCategoryData C, MonoidalCategory V
(Diagram expressed as equality of composite V-morphisms holds for all A,B,C,D)

Γ ⊢ AXIOM EnrichedAssociativity is TRUE ;
CATEGORY
[[ AXIOM EnrichedAssociativity ]] = "The coherence law ensuring that composition in the enriched category is associative. The law itself is expressed as a commutative diagram in the enriching category V, demonstrating how the structure of V dictates the laws of C." ;

EnrichedUnitalityAxiom ::= "AXIOM" "EnrichedUnitality" ":" "The unit law triangles commute in V." ;
TYPING
(*

This axiom asserts that the identity morphisms behave correctly. This is also a commutative diagram in V,

connecting composition ∘, identities id, and the unitor isomorphisms λ and ρ of V.

The left unit law asserts: ∘_AAB ∘ (id_A ⊗ id) == ρ (where ρ is the right unitor of V)
*)
Context: EnrichedCategoryData C, MonoidalCategory V
(Diagrams for left and right unitality commute in V for all A,B)

Γ ⊢ AXIOM EnrichedUnitality is TRUE ;
CATEGORY
[[ AXIOM EnrichedUnitality ]] = "The coherence law ensuring that the identity morphisms in the enriched category behave as units for composition. This law is expressed as a commutative diagram in V, showing how identities in C are governed by the monoidal unit and unitors of V." ;

EnrichedCategoryDeclaration ::= "V_CATEGORY" Identifier "enriched_in" Identifier "is" "{"
EnrichedCategoryData ";"
"AXIOMS" "(" "EnrichedAssociativity" "," "EnrichedUnitality" ")"
"}" ;
TYPING
(* Fully assembled master definition. *)
Γ ⊢ V : MonoidalCategory
Γ ⊢ data : EnrichedCategoryData_Type for C, enriched in V
Γ ⊢ EnrichedAssociativity axiom holds for data
Γ ⊢ EnrichedUnitality axiom holds for data

Γ ⊢ V_CATEGORY C ... : EnrichedCategory_over(V) ;
CATEGORY
[[ V_CATEGORY C ... ]] = "A category C whose hom-sets are replaced by hom-objects from a monoidal category V. Its laws of composition and identity are expressed as commuting diagrams of morphisms within V, using V's own structural isomorphisms. Standard categories are Set-categories." ;

(*
ELABORATION: This section formalizes the crucial concept of "change of base," a mechanism for
translating a category enriched in one monoidal category V into a category enriched in another, W.
This is the primary tool for relating different enriched worlds and, most importantly, for extracting
the familiar "underlying ordinary category" from any V-category.

A deep elaboration requires us to deconstruct this process into its constituent parts:

The Tool (The Strong Monoidal Functor): We will first formalize the structure-preserving map F: V → W that enables the translation. This is a functor that coherently respects the tensor product and unit of the monoidal categories.

The Construction (The Change of Base Functor): We will then formalize the construction itself, showing how a V-category C and a monoidal functor F produce a new W-category, which we will denote F_*(C). The formalization will make the construction explicit: showing how F is applied to the hom-objects and how its structural isomorphisms are used to define the new composition and identity morphisms.

The Key Application (The Underlying Ordinary Category): Finally, we will reveal the most important application of this machinery. We will show that the intuitive notion of the "underlying ordinary category" is not a new, ad-hoc definition but is a specific instance of the change of base construction. We will formalize this by demonstrating that applying the change of base along the canonical Hom_V(I, -) functor from V to Set precisely yields the underlying category.
*)

(* ========================================================================================================== )
( == Part 1: The Tool - Strong Monoidal Functors == )
(* ========================================================================================================== *)

StrongMonoidalFunctor ::= "STRONG_MONOIDAL_FUNCTOR" Identifier ":" MonoidalCategoryDeclaration "→" MonoidalCategoryDeclaration ;
TYPING
(*

A strong monoidal functor F:V→W is a functor equipped with natural isomorphisms

that coherently relate its action to the tensor products and units of V and W.
*)
Γ ⊢ F : Functor(V, W), Γ ⊢ V, W : MonoidalCategory
Let (⊗_V, I_V) and (⊗_W, I_W) be the respective monoidal structures.
There exist natural isomorphisms (which must satisfy coherence diagrams):
μ_{A,B} : F(A) ⊗_W F(B) → F(A ⊗_V B)
ε : I_W → F(I_V)

Γ ⊢ F is a STRONG_MONOIDAL_FUNCTOR ;
CATEGORY
[[ STRONG_MONOIDAL_FUNCTOR F ... ]] = "A structure-preserving map between monoidal categories. It is the correct notion of 'morphism' for monoidal categories and is the essential tool for changing the base of enrichment. It provides a dictionary for translating the tensorial structure of V into the tensorial structure of W." ;

(* ========================================================================================================== )
( == Part 2: The Construction - Changing the Base of Enrichment == )
(* ========================================================================================================== *)

ChangeOfBaseConstructor ::= Identifier "_" "(" EnrichedCategoryDeclaration ")" ;
TYPING
(

This constructor takes a V-category C and a strong monoidal functor F:V→W

and produces a W-category F_*(C). The typing rule below is the constructive definition.
)
Γ ⊢ F : StrongMonoidalFunctor(V, W), Γ ⊢ C : V_CATEGORY
Let F have structural isomorphisms μ and ε.
-- Define the new W-category C' = F_(C) --

Objects(C') := Objects(C)

HomObjects_{C'}(A,B) := F(HomObjects_C(A,B))

Composition_{C'} : Hom_{C'}(B,C) ⊗_W Hom_{C'}(A,B) → Hom_{C'}(A,C) is defined as the composite:
F(C(B,C)) ⊗_W F(C(A,B)) --μ⁻¹--> F(C(B,C) ⊗_V C(A,B)) --F(∘_C)--> F(C(A,C))

Identities_{C'} : I_W → Hom_{C'}(A,A) is defined as the composite:
I_W --ε--> F(I_V) --F(id_C_A)--> F(C(A,A))

Γ ⊢ F_(C) : W_CATEGORY ;
CATEGORY
[[ F_(C) ]] = "The change of base of the V-category C along the monoidal functor F. This construction allows one to view C as if it were enriched in W, by systematically applying the functor F to all of its structural components (hom-objects, composition, identities). The structural isomorphisms of F are crucial for re-connecting these components correctly in the new enriching category W." ;

(* ========================================================================================================== )
( == Part 3: The Key Application - The Underlying Ordinary Category == )
(* ========================================================================================================== *)

UnderlyingOrdinaryCategory ::= "UnderlyingCategory_of" "(" EnrichedCategoryDeclaration ")" ;
TYPING
(*

This rule asserts that the concept of an "underlying ordinary category" is not a new primitive,

but is precisely the result of a specific change of base operation.
*)
Context: Γ ⊢ C : V_CATEGORY, where V is a SymmetricMonoidalClosedCategory.

Define the target category: W := (Set, ×, {∗}), the category of sets with the Cartesian monoidal structure.

Define the monoidal functor: F_underlying := Hom_V(I, -) : V → Set. This is a strong monoidal functor.

The underlying category of C is definitionally equivalent to the change of base of C along this specific functor.

Γ ⊢ UnderlyingCategory_of(C) ≅ F_underlying_*(C) : EquivalenceOfCategories ;
CATEGORY
[[ UnderlyingCategory_of(C) ]] = "The underlying Set-enriched (i.e., ordinary) category of a V-category C. This theorem reveals that this fundamental concept is a canonical instance of changing the base of enrichment. The hom-sets of the underlying category are formed by taking the 'global elements' of the V-hom-objects, a process formalized by applying the functor Hom_V(I, -) to each one. This construction is the essential bridge from the abstract world of enriched category theory back to standard, set-based category theory." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.3 & 6.7: Enriched Functors, Adjunctions, and the Yoneda Lemma" ")" "==>" {
(*
ELABORATION (Deeper Dive): This elaboration meticulously deconstructs the core concepts of enriched
functors, transformations, adjunctions, and the Yoneda Lemma. Instead of treating them as monolithic
definitions, we will formalize them by separating their "Data" from the "Axioms" (the commuting
diagrams in the enriching category V) that this data must satisfy. This reveals the precise,
diagrammatic nature of the laws governing these enriched structures.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the V-Functor == )
( ========================================================================================================== )

EnrichedFunctorData ::= "DATA_V_Functor" "{"
"ActionOnObjects" ":" {ObjectMapping} ";"
"ActionOnHomObjects" ":" {HomObjectMorphism} ";"
"}" ;
TYPING
(* This declares the raw structural data of a V-functor F: C → D. *)
Context: V-categories C, D enriched in V.
F_obj : Ob(C) → Ob(D) is a function.
F_hom : is a family of V-morphisms { F_AB : C(A,B) → D(F(A),F(B)) | A,B ∈ Ob(C) }.
---------------------------------------------------------------------------------
Γ ⊢ DATA_V_Functor ... : EnrichedFunctorData_Type ;
CATEGORY
[[ DATA_V_Functor ... ]] = "The data for a V-functor, consisting of its effect on objects and its action on hom-objects, expressed as a family of morphisms in the enriching category V." ;

EnrichedFunctorAxiom_Composition ::= "AXIOM" "EnrichedFunctor_PreservesComposition" "for" EnrichedFunctorData ;
TYPING
(*
* This axiom asserts that the V-functor F respects composition. This is a commutative
* diagram of morphisms within the enriching category V.
*)
Context: F_data from C to D.
Diagram_Path1 := compose_D_FAFBFС ∘ (F_BC ⊗ F_AB)
Diagram_Path2 := F_AC ∘ compose_C_ABC
-------------------------------------------------------------------------
Γ ⊢ AXIOM ... holds if (Diagram_Path1 == Diagram_Path2) in V;
CATEGORY
[[ AXIOM EnrichedFunctor_PreservesComposition ]] = "The coherence law ensuring that a V-functor is compatible with composition. It asserts that 'composing then mapping' is the same as 'mapping then composing', where the comparison takes place in the enriching category V." ;

EnrichedFunctorAxiom_Identity ::= "AXIOM" "EnrichedFunctor_PreservesIdentity" "for" EnrichedFunctorData ;
TYPING
(* This axiom asserts that F respects identities, again as a commutative diagram in V. *)
Context: F_data from C to D. For each A in C:
Diagram_Path1 := F_AA ∘ id_C_A
Diagram_Path2 := id_D_FA
----------------------------------------------------------------
Γ ⊢ AXIOM ... holds if (Diagram_Path1 == Diagram_Path2) in V;
CATEGORY
[[ AXIOM EnrichedFunctor_PreservesIdentity ]] = "The coherence law ensuring a V-functor respects identity morphisms. It states that 'mapping the identity-selecting morphism for A' is the same as 'the identity-selecting morphism for F(A)'." ;

EnrichedFunctorDeclaration ::= "V_FUNCTOR" Identifier ":" EnrichedCategoryDeclaration "→" EnrichedCategoryDeclaration "is" "{"
EnrichedFunctorData ";"
"Verification" ":" "{" EnrichedFunctorAxiom_Composition ";" EnrichedFunctorAxiom_Identity "}"
"}" ;
TYPING
(* The fully assembled, verified definition of a V-functor. *)
Γ ⊢ data : EnrichedFunctorData_Type
Γ ⊢ AXIOM ..._PreservesComposition for data
Γ ⊢ AXIOM ..._PreservesIdentity for data
------------------------------------------------
Γ ⊢ V_FUNCTOR ... : EnrichedFunctor_over(V) ;
CATEGORY
[[ V_FUNCTOR F ... ]] = "A structure-preserving map between V-enriched categories, defined by its data and the verification that this data satisfies the required coherence axioms in the enriching category V." ;

(* ========================================================================================================== )
( == Part 2: Deconstructing the V-Natural Transformation == )
( ========================================================================================================== )

EnrichedNaturalTransformation ::= "V_NATURAL_TRANSFORMATION" Identifier ":" EnrichedFunctorDeclaration "⇒" EnrichedFunctorDeclaration ;
TYPING
(*
* A V-natural transformation α between V-functors F, G: C → D is a family of morphisms
* α_A : F(A) → G(A) in the UNDERLYING ordinary category of D.
* This family must satisfy a V-enriched naturality square.
* An equivalent, more powerful definition is a family of V-morphisms {α_A : I → D(F(A), G(A))}
* satisfying a coherence axiom in V.
*)
Context: V-Functors F, G : C → D.
Let α be a family of morphisms { α_A : I → D(F(A), G(A)) } in V.
-------------------------------------------------------------------------------
Γ ⊢ α is V_NATURAL_TRANSFORMATION if V_NaturalityAxiom for α holds ;
CATEGORY
[[ V_NATURAL_TRANSFORMATION α ... ]] = "A morphism between V-functors. Its components are 'global elements' (morphisms from the unit I) in the hom-objects of the target V-category, and they must cohere in a way dictated by the structure of V." ;

V_NaturalityAxiom ::= "AXIOM" "V_Naturality" "for" "transformation" Identifier ;
TYPING
(*
* This axiom asserts the commutativity of the V-enriched naturality square for each f in C(A,B).
* The diagram in V is: compose_D ∘ (id ⊗ α_A) ∘ G_AB == compose_D ∘ (α_B ⊗ id) ∘ F_AB
*)
... (diagram commutes in V for all hom-objects) ...
------------------------------------------------
Γ ⊢ AXIOM V_Naturality ... is TRUE ;
CATEGORY
[[ AXIOM V_Naturality ... ]] = "The coherence law for a V-natural transformation. It ensures that the components of the transformation are compatible with the V-functor actions on all hom-objects. It is the enriched analogue of the classic naturality square." ;

(* ========================================================================================================== )
( == Part 3: The Enriched Adjunction and Yoneda Lemma == )
( ========================================================================================================== )

EnrichedAdjunctionDeclaration ::= "V_ADJUNCTION" EnrichedFunctorDeclaration "⊣" EnrichedFunctorDeclaration ;
TYPING
(*
* The adjunction is defined by a V-natural isomorphism of hom-objects.
* This means for each pair (A,B), there is an isomorphism D(F(A),B) ≅ C(A,G(B)) in V,
* and this family of isomorphisms constitutes a V-natural transformation.
*)
Γ ⊢ F:C→D, Γ ⊢ G:D→C are V_FUNCTORS
----------------------------------------------------------------------------------------
Γ ⊢ F ⊣ G if D(F(-), -) and C(-, G(-)) are V-naturally isomorphic as V-functors C^op × D → V ;
CATEGORY
[[ V_ADJUNCTION F ⊣ G ]] = "The enriched version of an adjunction. The natural bijection of hom-sets is elevated to a natural isomorphism of hom-objects in the enriching category V. This is the most powerful and fundamental expression of the adjunction concept." ;

EnrichedPresheafCategory ::= "[" EnrichedCategoryDeclaration "^op" "," Identifier "]" ;
TYPING
Γ ⊢ C : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
---------------------------------------------------------------------------
Γ ⊢ [C^op, V] : V_CATEGORY of V-functors from C^op to V ;
CATEGORY
[[ [C^op, V] ]] = "The V-category of all V-enriched presheaves on C. Its objects are V-functors from C^op to V, and its hom-objects are the objects of V-natural transformations." ;

TheoremDeclaration ::= "THEOREM" "EnrichedYonedaIsomorphism" ":"
"The hom-object of V-natural transformations [y(A), P] is isomorphic in V to the object P(A)." ;
TYPING
Context: Γ ⊢ C : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
Let y: C → [C^op, V] be the enriched Yoneda embedding V-functor.
Γ ⊢ A : Object_in(C), Γ ⊢ P : Object_in([C^op, V])
LHS := HomObject_{[C^op,V]}( y(A), P )
RHS := P(A) (the V-object resulting from evaluating P at A)
----------------------------------------------------------------
Γ ⊢ LHS ≅ RHS : Isomorphism in V ;
CATEGORY
[[ THEOREM EnrichedYonedaIsomorphism ]] = "The core assertion of the enriched Yoneda Lemma. It provides a canonical isomorphism in the enriching category V between the object of V-natural transformations from a representable presheaf and a presheaf's value at the representing object. This demonstrates that the principle of representation is fundamental and holds in any sufficiently structured enriched context." ;

CorollaryDeclaration ::= "COROLLARY" "EnrichedYonedaEmbeddingIsFullyFaithful" "to" "EnrichedYonedaIsomorphism" ;
TYPING
(* This is a direct consequence of the main theorem. *)
Let P = y(B) in the EnrichedYonedaIsomorphism.
Then [C^op,V](yA, yB) ≅ yB(A) = C(A,B).
This isomorphism of hom-objects means the Yoneda embedding y is full and faithful.
-------------------------------------------------------------------------------
Γ ⊢ "The enriched Yoneda embedding y: C → [C^op, V] is a fully faithful V-functor." ;
CATEGORY
[[ COROLLARY ... ]] = "The practical consequence of the Yoneda Lemma. It guarantees that any V-category C is perfectly mirrored inside its category of V-enriched presheaves, preserving the full V-enriched structure of its hom-objects. This allows problems in C to be translated into the often better-behaved category of V-presheaves." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 6.5 & 6.6: Tensors and Weighted Limits" ")" "==>" {
(*
ELABORATION: This combined elaboration formalizes the most general notions of colimits and limits
in an enriched setting. The key insight is that the standard notions of coproducts and products, which
are limits/colimits over discrete diagrams, are generalized to "tensors" and "cotensors" where we
can take a copower/power by an object from the enriching category V itself.

This idea is then taken to its ultimate conclusion with the concept of "weighted" limits and colimits.
Instead of a simple diagram shape, we now have a diagram D and a "weighting functor" W that specifies
the precise way the components of D should be combined to form the universal object. All other limit
and colimit constructions in a V-category are shown to be special cases of this single, powerful universal
construction.

This elaboration will proceed by:

Formalizing Tensors and Cotensors: Define the tensor (copower) and cotensor (power) via their
fundamental universal property, which is an enriched adjunction.

Formalizing Weighted (Co)Limits: Define the master concepts of the weighted limit and weighted
colimit, again via their universal property, which involves an object of enriched natural transformations.

Stating the Unification Theorem: Assert the crucial theorem that tensors and cotensors are not
new, independent ideas, but are specific, simple instances of weighted colimits and limits, respectively.
This demonstrates that the weighted (co)limit is the single unifying concept for all such constructions.
*)

(* ========================================================================================================== )
( == Part 1: Tensors (Copowers) and Cotensors (Powers) == )
( ========================================================================================================== )

TensorDeclaration ::= Identifier "⊗" Identifier ;
TYPING
(*
* This defines the tensor or "copower" of an object X in the V-category C by an object v from V.
* Its defining property is the enriched adjunction which must hold for all objects Y in C.
*)
Context: Γ ⊢ C : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
Γ ⊢ v:Object_in(V), Γ ⊢ X:Object_in(C)
UniversalProperty := (∀Y∈Ob(C), C(v⊗X, Y) ≅ V(v, C(X,Y)) is a natural isomorphism in V)
-------------------------------------------------------------------------------------
Γ ⊢ v⊗X : Object_in(C) (defined by its UniversalProperty) ;
CATEGORY
[[ v⊗X ]] = "The tensor (or copower) of X by v. It is the enriched analogue of a coproduct of 'v copies' of X. It represents the universal object in C for receiving V-morphisms from v into the hom-object C(X,Y)." ;

CotensorDeclaration ::= "[" Identifier "," Identifier "]" ;
TYPING
(*
* This defines the cotensor or "power" of an object X in C by an object v from V.
* It is the dual concept to the tensor, defined by a different enriched adjunction.
*)
Context: Γ ⊢ C : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
Γ ⊢ v:Object_in(V), Γ ⊢ X:Object_in(C)
UniversalProperty := (∀Y∈Ob(C), C(Y, [v,X]) ≅ V(v, C(Y,X)) is a natural isomorphism in V)
--------------------------------------------------------------------------------------
Γ ⊢ [v,X] : Object_in(C) (defined by its UniversalProperty) ;
CATEGORY
[[ [v,X] ]] = "The cotensor (or power) of X by v. It is the enriched analogue of a product of 'v copies' of X. It represents the universal object in C that receives V-morphisms from v 'for every map out of Y'." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "Tensor" "IS" "Cotensor" ;

(* ========================================================================================================== )
( == Part 2: The General Theory of Weighted (Co)Limits == )
( ========================================================================================================== )

WeightedLimitDeclaration ::= "{" Identifier "," Identifier "}" ;
TYPING
(*
* The weighted limit of a V-functor D:J→C, with weight W:J^op→V, is an object {W,D} in C.
* Its universal property connects the hom-object C(X,{W,D}) to the object of enriched
* natural transformations between the weight W and the representable functor C(X,D-).
*)
Context: Γ ⊢ C, J : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
Γ ⊢ D : V_FUNCTOR(J → C), Γ ⊢ W: V_FUNCTOR(J^op → V)
UniversalProperty := (∀X∈Ob(C), C(X, {W,D}) ≅ [J^op, V](W, C(X,D(-))) is an isomorphism in V)
-----------------------------------------------------------------------------------------------
Γ ⊢ {W,D} : Object_in(C) (defined by its UniversalProperty) ;
CATEGORY
[[ {W,D} ]] = "The weighted limit of the diagram D with respect to the weight W. The weight specifies how the different parts of the diagram D are to be 'weighted' in the construction of the limit object. This is the most general possible notion of a limit in enriched category theory." ;

WeightedColimitDeclaration ::= "{" Identifier "∗" Identifier "}" ;
TYPING
(*
* The weighted colimit is the dual concept. The universal property is now for morphisms out of the object.
*)
Context: Γ ⊢ C, J : V_CATEGORY, Γ ⊢ V : SymmetricMonoidalClosedCategory
Γ ⊢ D : V_FUNCTOR(J → C), Γ ⊢ W: V_FUNCTOR(J → V)
UniversalProperty := (∀X∈Ob(C), C({W∗D}, X) ≅ [J, V](W, C(D(-),X)) is an isomorphism in V)
----------------------------------------------------------------------------------------------
Γ ⊢ {W∗D} : Object_in(C) (defined by its UniversalProperty) ;
CATEGORY
[[ {W∗D} ]] = "The weighted colimit of the diagram D with respect to the weight W. This is the most general possible notion of a colimit in enriched category theory." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "WeightedLimit" "IS" "WeightedColimit" ;

(* ========================================================================================================== )
( == Part 3: Unification - Tensors as Weighted Colimits == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "TensorsAreWeightedColimits" ":"
"The tensor v⊗X is the weighted colimit of the diagram selecting X, with weight v." ;
TYPING
(*
* This theorem provides the explicit construction that shows tensors are a special case of weighted colimits.
* To prove v⊗X ≅ {W∗D}, we choose a specific diagram D and weight W and show that the universal
* property for the weighted colimit reduces to the universal property for the tensor.
*)
Let V_1 be the terminal V-category (one object, identity hom-object I).
1. Let D : V_1 → C be the V-functor that selects the object X.
2. Let W : V_1 → V be the V-functor that selects the object v.
3. The universal property for the weighted colimit {W∗D} states:
C({W∗D}, Y) ≅ [V_1, V](W, C(D(-),Y)) for any Y in C.
4. An enriched natural transformation from a constant functor W=v to another functor F is simply
a morphism in V from v to the value of F. So, [V_1, V](W, C(D(-),Y)) ≅ V(v, C(X,Y)).
5. Therefore, C({W∗D}, Y) ≅ V(v, C(X,Y)).
6. This is precisely the universal property defining the tensor v⊗X.
-----------------------------------------------------------------------------------------------
Conclusion: (Γ ⊢ v⊗X ≅ {W∗D}) for these specific W and D : ProvableIsomorphism ;
CATEGORY
[[ THEOREM TensorsAreWeightedColimits ]] = "The assertion that the concept of a tensor (copower) is a specific instance of the more general weighted colimit construction. This reveals that weighted colimits are the single, unifying framework for all such 'constructive' universal properties in enriched category theory." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'CotensorsAreWeightedLimits'" "FROM" "THEOREM" "'TensorsAreWeightedColimits'" ;
TYPING
(*
* By applying the duality functor (-)^op to the previous theorem, we mechanically derive the dual result.
* The system uses the DualityMapping dictionary:
* 1. Tensor -> Cotensor
* 2. Weighted Colimit -> Weighted Limit
* The resulting proposition is the valid dual theorem.
*)
Γ ⊢ THEOREM 'TensorsAreWeightedColimits' : P_colim
P_lim = rewrite(P_colim, DualityMappings)
-------------------------------------------------------------
Conclusion: The Cotensor [v,X] is the weighted limit of the diagram selecting X, weighted by v. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual theorem, derived mechanically by applying the duality functor. It asserts that the concept of a cotensor (power) is a specific instance of the more general weighted limit construction, completing the unification." ;

}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 7: 'Topological categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.1: Exponentiable spaces" ")" "==>" {
(*
ELABORATION: This section addresses a famous shortcoming of the category of topological spaces,
Top: it is not a "Cartesian Closed Category" (CCC). In a CCC, the operation of taking a product
with an object X, (- × X), must have a right adjoint. The object this adjoint produces is the
"exponential object" or "function space object" Y^X. In Top, this is not always possible.

This section defines the "exponentiable spaces" as precisely those objects X for which this
adjunction exists. A deep elaboration requires us to formalize this "local" version of the CCC
property. We will:

Formalize the Players: Define the category Top and the product functor (- × X).

Formalize the Core Property: Define the property of a space X being EXPONENTIABLE by asserting
the existence of a right adjoint to the product functor.

Formalize the Resulting Structure: Define the EXPONENTIAL_OBJECT Y^X as the result of applying
this right adjoint, and state the resulting Tensor-Hom-like adjunction that defines it.

State the Core Problem: Formalize the theorem that Top is NOT a CCC, which is the motivation for
identifying the special subclass of exponentiable spaces.
*)

(* ========================================================================================================== )
( == Part 1: The Context and the Core Property == )
( ========================================================================================================== *)

CategoryDeclaration ::= "CATEGORY" "Top" ;
TYPING
(* A declaration of the category of all topological spaces and continuous maps. *)
Objects := { T | T is a TopologicalSpace }
Morphisms := { f | f is a ContinuousMap }

Γ ⊢ Top : Category ;
CATEGORY
[[ Top ]] = "The category of topological spaces, the primary setting for this chapter." ;

ProductFunctor_Top ::= "×" Identifier ;
TYPING
(* This defines the endofunctor (- × X) on Top. *)
Γ ⊢ Top : Category
Γ ⊢ X : Object_in(Top)

Γ ⊢ (× X) : Functor(Top, Top) ;
CATEGORY
[[ × X ]] = "The functor that takes a topological space Y to the product space Y × X, equipped with the product topology. The failure of this functor to always have a right adjoint is the central problem." ;

ObjectPropertyAssertion ::= Identifier "is" "EXPONENTIABLE" ;
TYPING
(*

This is the master definition. A space X is exponentiable if the functor (- × X)

has a right adjoint. This is the "local" version of the Cartesian closed property.
*)
Context: Category is Top
Γ ⊢ X : Object_in(Top)
Let F_X := ProductFunctor_Top(X)

Γ ⊢ X is EXPONENTIABLE is TRUE if (F_X has a RightAdjoint) ;
CATEGORY
[[ X is EXPONENTIABLE ]] = "A property of a topological space X asserting that it is a 'well-behaved' factor in products. This property guarantees that for any other space Y, there exists a 'function space' Y^X with a topology (the compact-open topology) that appropriately represents the continuous maps from X to Y." ;

(* ========================================================================================================== )
( == Part 2: The Exponential Object and the Adjunction == )
( ========================================================================================================== *)

ExponentialObject_Top ::= Identifier "^" Identifier ;
TYPING
(* If X is exponentiable, we can define the exponential object Y^X. *)
Γ ⊢ X is EXPONENTIABLE, Γ ⊢ Y : Object_in(Top)
Let G_X be the right adjoint to (× X).

Γ ⊢ Y^X : Object_in(Top) (defined as G_X(Y)) ;
CATEGORY
[[ Y^X ]] = "The exponential object, or function space, of continuous maps from X to Y, equipped with the compact-open topology. Its existence is guaranteed by the exponentiability of X." ;

TheoremDeclaration ::= "THEOREM" "ExponentiationAdjunctionInTop" ":"
"IF X is exponentiable, THEN (- × X) ⊣ (-)^X, which means Hom_Top(A × X, Y) ≅ Hom_Top(A, Y^X)." ;
TYPING
(* This is the adjunction that defines the exponential object. *)
Context: Γ ⊢ X is EXPONENTIABLE
P1 := (Γ ⊢ Functor_Product(X) ⊣ Functor_Exponential(X))
P2 := (NaturalIsomorphism( Hom_Top(A×X, Y), Hom_Top(A, Y^X) ))

(P1 <==> P2) : MetaTheorem ;
CATEGORY
[[ THEOREM ExponentiationAdjunctionInTop ]] = "The assertion of the currying/uncurrying isomorphism for continuous maps, which holds precisely when the space X is exponentiable. This is the defining universal property of the function space topology." ;

(* ========================================================================================================== )
( == Part 3: The Problem - Top is Not Cartesian Closed == )
( ========================================================================================================== *)

CategoryPropertyDefinition ::= Identifier "is" "CARTESIAN_CLOSED_CATEGORY" ;
TYPING
(* A category is a CCC if it has all finite products and every object is exponentiable. *)
Γ ⊢ C : Category
Premise1: C has a TerminalObject and all binary Products.
Premise2: ∀X ∈ Ob(C), (Γ ⊢ X is EXPONENTIABLE)

Γ ⊢ C is CARTESIAN_CLOSED_CATEGORY ;
CATEGORY
[[ C is CARTESIAN_CLOSED_CATEGORY ]] = "A category with a product structure that is compatible with its hom-sets, creating an internal logic that mirrors typed lambda calculus. Set is the canonical example." ;

TheoremDeclaration ::= "THEOREM" "TopIsNotCartesianClosed" ":"
"The category Top is not a CARTESIAN_CLOSED_CATEGORY because not all of its objects are EXPONENTIABLE." ;
TYPING
Γ ⊢ Top has finite products.
∃ X ∈ Ob(Top) s.t. (Γ ⊢ X is EXPONENTIABLE is FALSE)
(e.g., the rationals Q with the subspace topology)

Γ ⊢ Top is CARTESIAN_CLOSED_CATEGORY is FALSE : ProvableProposition ;
CATEGORY
[[ THEOREM TopIsNotCartesianClosed ]] = "A fundamental (and inconvenient) fact of general topology. The failure of Top to be cartesian closed motivates the search for 'nice' subcategories of spaces, like the compactly generated spaces, that do have this desirable property." ;
}

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.2: Compactly generated spaces" ")" "==>" {
(*
ELABORATION: This section provides a solution to the problem identified in 7.1. The category Top is
not cartesian closed, so we seek a "nice" full subcategory that is. The category of Compactly
Generated Weak Hausdorff spaces (CGWH) is such a category. This is a classic categorical strategy:
when your ambient category is poorly behaved, find a well-behaved reflective subcategory to work in.

A deep elaboration requires us to:

Formalize the Properties: Define the constituent properties of the 'nice' spaces.

Construct the Subcategory: Formalize the category CGWH as the full subcategory of Top on
objects with these properties.

Formalize the Reflection: Define the "k-ification" functor k which acts as the reflector
from Top to CGWH, and state its adjunction with the inclusion functor.

State the Main Theorem: Assert the central result: the category CGWH is a Cartesian Closed
Category, which solves the problem.
*)

(* ========================================================================================================== )
( == Part 1: The Properties and the Subcategory == )
( ========================================================================================================== *)

ObjectPropertyAssertion ::= Identifier "is" "COMPACTLY_GENERATED" ;
TYPING
(* A space X is compactly generated if its topology is determined by maps from compact Hausdorff spaces into it. *)
Γ ⊢ X: Object_in(Top)
Condition := (A ⊆ X is closed) ⇔ (∀ K compact Hausdorff, ∀ f:K→X continuous, f⁻¹(A) is closed in K)
---------------------------------------------------------------------------------------------------
Γ ⊢ X is COMPACTLY_GENERATED is TRUE if Condition holds ;
CATEGORY
[[ X is COMPACTLY_GENERATED ]] = "Also known as a k-space. This is a topological space whose topology is 'tested by compacta'. This condition remedies many of the pathological behaviors of general topological spaces." ;

ObjectPropertyAssertion ::= Identifier "is" "WEAK_HAUSDORFF" ;
TYPING
(* A space X is weak Hausdorff if the image of any continuous map from a compact Hausdorff space is closed. *)
Γ ⊢ X: Object_in(Top)
Condition := ∀ K compact Hausdorff, ∀ f:K→X continuous, Image(f) is a closed subset of X.
----------------------------------------------------------------------------------------
Γ ⊢ X is WEAK_HAUSDORFF is TRUE if Condition holds ;
CATEGORY
[[ X is WEAK_HAUSDORFF ]] = "A separation axiom weaker than Hausdorff but strong enough, when combined with being compactly generated, to ensure good categorical behavior." ;

CGWH_Category ::= "CGWH" ;
TYPING
(* CGWH is the full subcategory of Top of spaces with both properties. *)
Let CGWH_Objects := { X ∈ Ob(Top) | (X is COMPACTLY_GENERATED) ∧ (X is WEAK_HAUSDORFF) }
-------------------------------------------------------------------------------------
Γ ⊢ CGWH : FullSubcategory(Top) on objects CGWH_Objects ;
CATEGORY
[[ CGWH ]] = "The category of Compactly Generated Weak Hausdorff spaces. This is the 'nice' category of spaces that serves as a convenient setting for algebraic topology and category theory." ;

(* ========================================================================================================== )
( == Part 2: The Reflection and the Main Theorem == )
( ========================================================================================================== *)

k_ificationFunctor ::= "k" ":" "Top → CGWH" ;
TYPING
(* The k-ification functor k is the reflector. It takes a space X and gives it a new, possibly finer, compactly generated topology. *)
Γ ⊢ Top, CGWH : Category
------------------------------
Γ ⊢ "k" : Functor(Top, CGWH) ;
CATEGORY
[[ "k" : Top → CGWH ]] = "The k-ification functor. It is the left adjoint to the inclusion functor I: CGWH ↪ Top. It maps any topological space to its 'best approximation' within the category of compactly generated spaces." ;

TheoremDeclaration ::= "THEOREM" "CGWH_isReflectiveInTop" ":"
"The category CGWH is a REFLECTIVE subcategory of Top, with the k-ification functor as its reflector." ;
TYPING
Let I : CGWH ↪ Top be the inclusion functor.
Let k : Top → CGWH be the k-ification functor.
---------------------------------------------------
Γ ⊢ k ⊣ I : Adjunction(Top, CGWH) ;
CATEGORY
[[ THEOREM CGWH_isReflectiveInTop ]] = "The assertion that the k-ification functor is the left adjoint to the inclusion of CGWH into Top. This establishes CGWH as a well-behaved, reflective subcategory." ;

TheoremDeclaration ::= "THEOREM" "CGWH_isCartesianClosed" ":"
"The category CGWH is a CARTESIAN_CLOSED_CATEGORY." ;
TYPING
(* This is the solution to the motivating problem. *)
Γ ⊢ CGWH : Category
Premise1: CGWH has finite products.
Premise2: ∀X ∈ Ob(CGWH), X is EXPONENTIABLE (in the category CGWH).
(That is, for Y in CGWH, the function space Y^X is also in CGWH).
-------------------------------------------------------------------------
Γ ⊢ CGWH is CARTESIAN_CLOSED_CATEGORY : ProvableProposition ;
CATEGORY
[[ THEOREM CGWH_isCartesianClosed ]] = "The central result establishing CGWH as a 'cartesian closed core' of Top. This theorem guarantees that function spaces between nice spaces are themselves nice, providing a stable and complete universe for doing category theory in a topological setting." ;
}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 7.3: Topological functors" ")" "==>" {
(*
ELABORATION: This section abstracts a key property of the forgetful functor U: Top → Set. Its
"topological" nature is not just that it forgets structure, but that it allows structure to be
put back in a canonical way. Specifically, for any set X and any collection of functions pointing
to or from it, there is a unique "initial" or "final" topology on X making them all continuous.
This concept is generalized to define a "topological functor."

A deep elaboration requires us to:

Formalize the Lifting Problem: Define the "structured sink" (a set with maps into it)
and "structured source" (a set with maps out of it) that serve as the input data for the lifting problem.

Formalize the Universal Solutions: Define the "Initial Lift" and "Final Lift" as the unique
solutions to these problems. These are the core universal properties.

Define the Master Concept: Define a TOPOLOGICAL_FUNCTOR as a functor that admits initial
lifts for all possible structured sinks.

State the Powerful Consequences: Assert the main theorem that a topological functor is
extremely well-behaved: its domain is complete and cocomplete, and it has both a left and
right adjoint. This shows why the property is so important.
*)

(* ========================================================================================================== )
( == Part 1: The Lifting Problem and its Solutions == )
( ========================================================================================================== *)

StructuredSink ::= "STRUCTURED_SINK" "{" "TargetObject" ":" Identifier "," "SourceMaps" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(* A structured sink for a functor U:C→B is an object B_o in the base category B, together with a family of B-morphisms pointing to it. *)
Let U:C→B be a functor.
Γ ⊢ B_o : Object_in(B)
Γ ⊢ Family_f = { f_i : U(A_i) → B_o | A_i ∈ Ob(C) }

Γ ⊢ STRUCTURED_SINK S = { B_o, Family_f } : Sink_for_Functor(U) ;
CATEGORY
[[ STRUCTURED_SINK S ]] = "The data for an initial lift problem. It consists of an unstructured object B_o in the base category and a 'cone' of maps from various structured objects into it. The problem is to find the 'coarsest' structure on B_o that makes all these maps morphisms in the source category C." ;

InitialLift ::= "INITIAL_LIFT" "(" StructuredSink ")" "is" "{" "LiftedObject" ":" Identifier "," "LiftedMorphisms" ":" "{" {MorphismDeclaration} "}" "}" ;
TYPING
(*

An initial lift is the universal solution to the structured sink problem. It finds an object C_o in C

and morphisms m_i such that U(C_o)=B_o, U(m_i)=f_i, and this solution is universal (initial).
*)
Γ ⊢ S = { B_o, {f_i:U(A_i)→B_o} } : Sink_for_Functor(U)
SolutionExists := ∃ (C_o ∈ Ob(C)) and ∃ {m_i:A_i→C_o in C} s.t.
(1) U(C_o) == B_o
(2) U(m_i) == f_i for all i
UniversalProperty := For any other solution (C'_o, {m'_i}), ∃! (h:C'_o→C_o in C) s.t. U(h)=id and m_i∘h = m'_i.

Γ ⊢ INITIAL_LIFT ... is a valid lift if SolutionExists and holds UniversalProperty ;
CATEGORY
[[ INITIAL_LIFT S ]] = "The universal solution to a structured sink problem. In the context of Top, this corresponds to putting the initial (coarsest) topology on a set that makes a given family of functions into it continuous." ;

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "StructuredSink" "IS" "StructuredSource" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "InitialLift" "IS" "FinalLift" ;

(* ========================================================================================================== )
( == Part 2: The Master Definition and its Consequences == )
( ========================================================================================================== *)

TopologicalFunctorDeclaration ::= Identifier "is" "TOPOLOGICAL_FUNCTOR" ;
TYPING
(*

The master definition. A functor U is topological if it admits an initial lift for EVERY

conceivable structured sink. Because of duality, this implies it also admits final lifts for all sources.
*)
Γ ⊢ U : Functor(C, B)
Condition := ∀ (S : Sink_for_Functor(U)), ∃ a unique INITIAL_LIFT for S.

Γ ⊢ U is TOPOLOGICAL_FUNCTOR ;
CATEGORY
[[ U is TOPOLOGICAL_FUNCTOR ]] = "A functor that is 'forgetful' in the most structured and well-behaved way possible. It not only forgets structure but provides a canonical way to uniquely reconstruct initial and final structures from unstructured data. This property is characteristic of functors from categories of topological or algebraic structures to Set." ;

TheoremDeclaration ::= "THEOREM" "ConsequencesOfBeingTopological" ":"
"Any TOPOLOGICAL_FUNCTOR U:C→B has the following properties:"
"{" "1. C is complete and cocomplete;"
"2. U has both a left and a right adjoint;"
"3. U preserves and reflects both limits and colimits." "}" ;
TYPING
(Γ ⊢ U is TOPOLOGICAL_FUNCTOR) ==> ( (C is COMPLETE ∧ C is COCOMPLETE) ∧ (U has a LeftAdjoint ∧ U has a RightAdjoint) ∧ ... )

Γ ⊢ THEOREM ... : MetaTheorem ;
CATEGORY
[[ THEOREM ConsequencesOfBeingTopological ]] = "A powerful result asserting that the abstract lifting property of a topological functor guarantees that both the functor and its domain category are exceptionally well-behaved. The existence of all limits and colimits in the domain can be proven constructively using the initial and final lift machinery." ;

TheoremInstantiation ::= "INSTANCE" "ForgetfulFunctorForTopIsTopological" "of" TopologicalFunctorDeclaration ;
TYPING
Let U: Top → Set be the forgetful functor.
(This can be proven to satisfy the initial lift condition for all sinks)

Γ ⊢ U is TOPOLOGICAL_FUNCTOR : ProvableProposition ;
CATEGORY
[[ INSTANCE ... ]] = "The assertion that the standard forgetful functor from Top to Set is the archetypal example of a topological functor. The existence of initial and final topologies in general topology is the concrete manifestation of this abstract categorical property." ;
}


MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 8: 'Fibred categories', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(* ========================================================================================================== )
( == Section 8.1: Fibrations == )
(
ELABORATION: This section defines the central object of study: the fibration. A fibration is a functor
p: E → B that models a "family of categories indexed by B". The key mechanism that allows this indexing
is the "Cartesian arrow," a special type of morphism in the total category E that provides a universal
way to "pull back" or "reindex" data from one fibre to another.

Our elaboration will proceed by:

Formalizing the Core Concepts: We will define the concepts of a morphism "lying over" another and the
universal "lifting problem" that defines a Cartesian arrow.

Defining Fibrations: We will define a Fibration as a functor where this lifting problem always has a solution.

Defining the Consequences: We will show how this definition gives rise to the "fibre categories" (the
indexed family) and the "reindexing functors" (the pullbacks) that are the main purpose of the theory.

Formalizing the Dual Theory: We will use the Duality Principle to mechanically derive the entire
corresponding theory for the dual concept of an "Opfibration" and its "coCartesian arrows."
*)

(* ========================================================================================================== )
( == Part 1: Cartesian Arrows and the Definition of a Fibration == )
( ========================================================================================================== )

FibrationProjectionFunctor ::= "FIB_PROJECTION" Identifier ":" Identifier "→" Identifier ;
TYPING
(* This simply declares the functor that will be tested for the fibration property. *)
Γ ⊢ E, B : Category
-----------------------------------------
Γ ⊢ FIB_PROJECTION p : E → B : Functor(E, B) ;
CATEGORY
[[ FIB_PROJECTION p : E → B ]] = "A functor from a total category E to a base category B, which is a candidate for being a fibration." ;

MorphismLiesOver ::= Identifier "lies_over" Identifier ;
TYPING
(* A morphism f in the total category lies over a morphism u in the base category if the projection functor p maps f to u. *)
Context: Γ ⊢ p: E → B
Γ ⊢ f : Morphism_in(E), Γ ⊢ u : Morphism_in(B)
---------------------------------------------------
Γ ⊢ f lies_over u <==> (p(f) == u) ;
CATEGORY
[[ f lies_over u ]] = "The assertion that the morphism f is a 'lift' of the base morphism u into the total category." ;

CartesianArrow ::= Identifier "is" "CARTESIAN_ARROW" "for" "(" "target_object" ":" Identifier "," "base_morphism" ":" Identifier ")" ;
TYPING
(*
* This is the Universal Property that defines a Cartesian arrow. An arrow f:Y→X in E is Cartesian for a base arrow u:I→J
* if f lies over u, and for ANY other arrow g:Z→X lying over v (where u=v∘w), there exists a UNIQUE vertical
* morphism h:Z→Y (i.e. lying over the identity) such that g = f∘h.
*)
Context: Γ ⊢ p: E → B
Γ ⊢ f:Y→X in E, Γ ⊢ u:p(Y)→p(X) in B, Γ ⊢ X in E
Condition1: f lies_over u
Condition2_Universal: ∀ (g:Z→X in E), ∀ (w:p(Z)→p(Y) in B),
( (g lies_over u∘w) ⇒ (∃! h:Z→Y in E s.t. (h lies_over id_{p(Y)}) ∧ (g == f∘h)) )
-------------------------------------------------------------------------------------------------------------
Γ ⊢ f is CARTESIAN_ARROW for (X, u) is TRUE if Condition1 ∧ Condition2_Universal ;
CATEGORY
[[ f is CARTESIAN_ARROW for (X, u) ]] = "A morphism f in the total category that is a universal solution to the problem of lifting paths that end at X and factor through u. It represents the 'best possible' way to pull the object X back along the path u to the object Y." ;

FibrationDeclaration ::= Identifier "is" "FIBRATION" ;
TYPING
(* A functor p: E → B is a fibration if for every lifting problem, a Cartesian arrow exists. *)
Γ ⊢ p : Functor(E, B)
Condition := ∀ (X ∈ Ob(E)), ∀ (u: I → p(X) in B), (∃ (f:Y→X in E) s.t. f is CARTESIAN_ARROW for (X, u))
---------------------------------------------------------------------------------------------------------
Γ ⊢ p is FIBRATION is TRUE if Condition holds ;
CATEGORY
[[ p is FIBRATION ]] = "A functor that defines a coherent 'indexed family of categories'. The guaranteed existence of Cartesian arrows ensures that for any path u:I→J in the base, there is a well-defined 'pullback' or 'reindexing' functor from the fibre over J to the fibre over I." ;

(* ========================================================================================================== )
( == Part 2: Fibres and Reindexing Functors == )
( ========================================================================================================== )

FibreCategory ::= "Fibre" "(" FibrationDeclaration "," Identifier ")" ;
TYPING
(* The fibre over an object I in the base is the subcategory of E of all objects lying over I and all vertical morphisms. *)
Context: Γ ⊢ p: E → B is FIBRATION, Γ ⊢ I : Object_in(B)
Fibre_Objects := { X ∈ Ob(E) | p(X) == I }
Fibre_Morphisms := { f ∈ Mor(E) | p(f) == id_I }
------------------------------------------------------------
Γ ⊢ Fibre(p, I) : Subcategory(E) ;
CATEGORY
[[ Fibre(p, I) ]] = "The fibre category E_I. This is the 'category at index I' in the family of categories defined by the fibration p." ;

ReindexingFunctor ::= "ReindexingFunctor" "(" Identifier ")" ;
TYPING
(*
* For a fibration p and a base morphism u:I→J, the reindexing functor u*: E_J → E_I is
* constructed by choosing a Cartesian lift for each object in the fibre E_J.
)
Context: Γ ⊢ p: E → B is FIBRATION, Γ ⊢ u : I→J in B
ActionOnObjects(X_J ∈ Ob(Fibre(p, J))) := The domain Y of the chosen Cartesian lift f:Y→X_J for u.
ActionOnMorphisms(...) := The unique vertical map given by the universal property.
-----------------------------------------------------------------------------------------
Γ ⊢ ReindexingFunctor(u) : Functor(Fibre(p, J), Fibre(p, I)) ;
CATEGORY
[[ ReindexingFunctor(u) ]] = "The pullback or reindexing functor u. It is the canonical map between fibres induced by the base morphism u. Its existence is guaranteed by the fibration property." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory (Opfibrations) == )
( ========================================================================================================== )

DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "FIBRATION" "IS" "OPFIBRATION" ;
DualityMappingAxiom ::= "DUALITY_MAPPING" "FOR" "CARTESIAN_ARROW" "IS" "COCARTESIAN_ARROW" ;

OpfibrationDeclaration ::= Identifier "is" "OPFIBRATION" ;
TYPING
(* An Opfibration is a fibration for the opposite category. p:E→B is an opfibration iff p^op:E^op→B^op is a fibration. *)
IsDualOf("FIBRATION")
-----------------------------
Γ ⊢ p is OPFIBRATION ;
CATEGORY
[[ p is OPFIBRATION ]] = "A functor that defines a 'covariantly indexed' family of categories. Moving along a path u:I→J in the base induces a 'pushforward' functor u_!: E_I → E_J. This structure is defined by the guaranteed existence of coCartesian arrows." ;

CoCartesianArrow ::= Identifier "is" "COCARTESIAN_ARROW" "for" "(" "source_object" ":" Identifier "," "base_morphism" ":" Identifier ")" ;
TYPING
(* A coCartesian arrow is a Cartesian arrow in the opposite category. *)
IsDualOf("CARTESIAN_ARROW")
-----------------------------
Γ ⊢ f is COCARTESIAN_ARROW ;
CATEGORY
[[ f is COCARTESIAN_ARROW ]] = "A morphism f in the total category that is a universal solution for lifting paths that start at a given object. It is the primitive used to construct pushforward/reindexing functors in an opfibration." ;

PushforwardFunctor ::= "PushforwardFunctor" "(" Identifier ")" ;
TYPING
(* The dual of the reindexing functor. *)
IsDualOf("ReindexingFunctor")
------------------------------------
Γ ⊢ PushforwardFunctor(u) : Functor(Fibre(p, I), Fibre(p, J)) ;
CATEGORY
[[ PushforwardFunctor(u) ]] = "The pushforward functor u_!. It is the canonical map between fibres induced by the base morphism u in an opfibration." ;

(*
ELABORATION: This section defines the "morphisms between fibrations." Just as a functor is a
structure-preserving map between categories, a Cartesian functor is a structure-preserving map
between fibrations. The key idea is that such a functor must not only respect the projection to the
base category, but it must also respect the special "Cartesian" structure of the total categories.

A deep elaboration requires us to deconstruct the definition into its two fundamental axioms and then
assemble them into a master definition, which in turn allows us to define the category of all
fibrations over a given base.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Definition == )
( ========================================================================================================== )
(A Cartesian functor F must satisfy two axioms that formalize its structure-preserving nature.)

CommutesWithProjectionsAxiom ::= "AXIOM" "CommutesWithProjections" "for" FunctorDeclaration "between" FibrationDeclaration "and" FibrationDeclaration ;
TYPING
(*

This axiom asserts that the main triangle commutes. The functor F must map objects and morphisms

in a fibre of the source fibration to the corresponding fibre in the target fibration.
*)
Context: Γ ⊢ F : Functor(E, E'), Γ ⊢ p : FIBRATION(E→B), Γ ⊢ p' : FIBRATION(E'→B)

Γ ⊢ AXIOM ... holds TRUE if (p' ∘ F == p) ;
CATEGORY
[[ AXIOM CommutesWithProjections ... ]] = "The assertion that the functor F respects the fibred structure. It guarantees that for any object I in the base category, F maps the fibre E_I into the fibre E'_I. This is the most basic compatibility condition." ;

PreservesCartesianArrowsAxiom ::= "AXIOM" "PreservesCartesianArrows" "for" FunctorDeclaration "between" FibrationDeclaration "and" FibrationDeclaration ;
TYPING
(*

This is the crucial axiom that ensures the special structure of the fibration is preserved.

The functor F must map Cartesian arrows to Cartesian arrows.
*)
Context: Γ ⊢ F : Functor(E, E'), Γ ⊢ p : FIBRATION(E→B), Γ ⊢ p' : FIBRATION(E'→B)
Condition := ∀(f ∈ Mor(E)), ( (f is CARTESIAN_ARROW in E) ⇒ (F(f) is CARTESIAN_ARROW in E') )

Γ ⊢ AXIOM ... holds TRUE if Condition is met ;
CATEGORY
[[ AXIOM PreservesCartesianArrows ... ]] = "The assertion that the functor F is compatible with the universal reindexing structure of the fibrations. By preserving Cartesian arrows, the functor ensures that the diagrams for reindexing in the source fibration are mapped to valid reindexing diagrams in the target fibration." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition and its Consequence == )
( ========================================================================================================== )

CartesianFunctorDeclaration ::= "CARTESIAN_FUNCTOR" Identifier ":" FibrationDeclaration "→" FibrationDeclaration ;
TYPING
(*

The master definition combines the two axioms. A functor F is a Cartesian functor if it

commutes with the projections and preserves Cartesian arrows.
*)
Γ ⊢ p: E → B is FIBRATION, Γ ⊢ p': E' → B is FIBRATION
Γ ⊢ F : Functor(E, E')
Premise1: Γ ⊢ AXIOM CommutesWithProjections for F, p, p' holds TRUE
Premise2: Γ ⊢ AXIOM PreservesCartesianArrows for F, p, p' holds TRUE

Γ ⊢ CARTESIAN_FUNCTOR F : p → p' is a valid declaration ;
CATEGORY
[[ CARTESIAN_FUNCTOR F : p → p' ]] = "A morphism between fibrations over a common base. It is a functor between the total categories that respects the partitioning into fibres and, crucially, preserves the universal 'pullback' structure defined by the Cartesian arrows. This ensures the functor induces a natural transformation between the corresponding pseudofunctors." ;

CategoryOfFibrations ::= "Fib" "(" Identifier ")" ;
TYPING
(* For a fixed base category B, we can form a category of all fibrations over B. *)
Γ ⊢ B : Category
Objects := { p | Γ ⊢ p is FIBRATION over B }
Morphisms := { F | Γ ⊢ F is CARTESIAN_FUNCTOR between fibrations over B }

Γ ⊢ Fib(B) : Category ;
CATEGORY
[[ Fib(B) ]] = "The category of all fibrations over the base B. This category is in fact a 2-category, where the 2-morphisms are 'vertical' natural transformations between Cartesian functors." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.3: Fibrations via pseudo-functors (The Grothendieck Construction)" ")" "==>" {
(*
ELABORATION: This is one of the most fundamental and beautiful results in category theory. It establishes
an equivalence between two different ways of looking at "indexed families of categories":

The geometric perspective: A fibration p:E→B. This is a single, large "total category" E with a projection functor down to a "base category" B. The structure is given by "Cartesian arrows" that allow "pullbacks" between fibers.

The algebraic perspective: A pseudofunctor F: B^op → Cat (a functor that preserves structure up to isomorphism). This is an explicit assignment of a category F(I) to each object I in the base, and a reindexing functor F(u) to each arrow u.

The Grothendieck Construction is the explicit recipe for turning an algebraic pseudofunctor into its geometric
fibration counterpart, and its inverse is the process of "unpacking" a fibration into a pseudofunctor. A deep
elaboration requires formalizing both directions of this correspondence and then stating the main equivalence theorem.
*)

(* ========================================================================================================== )
( == Part 1: From Fibration to Pseudofunctor (The "Unpacking") == )
( ========================================================================================================== )

PseudofunctorFromFibration ::= "Pseudofunctor_of" "(" FibrationDeclaration ")" ;
TYPING
(*

This constructor takes a geometric fibration and 'unpacks' it into its corresponding algebraic indexed family.

The result is a pseudofunctor because the composition of reindexing functors is not strictly associative,

but only associative up to a canonical natural isomorphism.
*)
Context: Γ ⊢ p: E → B is FIBRATION
-- Define the action of the resulting pseudofunctor F: B^op → Cat
ActionOnObjects(I ∈ Ob(B)): F(I) := Fibre(p, I)
ActionOnMorphisms(u: I→J in B): F(u) := ReindexingFunctor(u) : Fibre(p,J) → Fibre(p,I)

Γ ⊢ Pseudofunctor_of(p) : PseudoFunctor(B^op, Cat) ;
CATEGORY
[[ Pseudofunctor_of(p) ]] = "The process of interpreting a fibration as a contravariant, Cat-valued pseudofunctor. This deconstructs the unified total category E into an explicit collection of fibre categories and the reindexing functors that relate them. It translates the geometric structure into an algebraic one." ;

(* ========================================================================================================== )
( == Part 2: From Pseudofunctor to Fibration (The Grothendieck Construction) == )
( ========================================================================================================== )

GrothendieckConstruction ::= "∫" PseudoFunctorDeclaration ;
TYPING
(*

This is the constructive part. Given an algebraic pseudofunctor F, it builds a single geometric

total category E and a fibration p. The result is often called the "category of elements" of F.
*)
Context: Γ ⊢ F : PseudoFunctor(B^op, Cat)
-- Construct the Total Category E = ∫ F
Objects(E) := { (I, x) | I ∈ Ob(B), x ∈ Ob(F(I)) }
Morphisms(E) from (I,x) to (J,y) := { (u, f) | u:I→J in B, f:x → F(u)(y) in F(I) }
-- Define the Projection Functor p: E → B
p((I,x)) := I
p((u,f)) := u
-- This construction results in a functor p:E→B which can be proven to be a fibration.

Γ ⊢ ∫ F : FIBRATION over B ;
CATEGORY
[[ ∫ F ]] = "The Grothendieck Construction. It is a canonical procedure for assembling an indexed family of categories (a pseudofunctor) into a single, unified total category. The resulting functor from this total category to the indexing category is always a fibration. It translates the algebraic description into a geometric one." ;

(* ========================================================================================================== )
( == Part 3: The Main Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "GrothendieckEquivalence" ":"
"The 2-category of fibrations over B is equivalent to the 2-category of pseudofunctors from B^op to Cat." ;
TYPING
(*

This theorem asserts that the two constructions defined above are inverses to each other,

yielding a fundamental equivalence of 2-categories.
*)
Let Fib_2Cat(B) be the 2-category of fibrations over B.
Let PsFun_2Cat(B^op, Cat) be the 2-category of pseudofunctors.
Let G_unpack := the 2-functor from Fib_2Cat to PsFun_2Cat given by the Part 1 construction.
Let I_construct := the 2-functor from PsFun_2Cat to Fib_2Cat given by the Part 2 construction.

Γ ⊢ G_unpack and I_construct form an EquivalenceOf2Categories ;
CATEGORY
[[ THEOREM GrothendieckEquivalence ]] = "A foundational result in category theory establishing a profound duality between the 'geometric' notion of a fibration and the 'algebraic' notion of a Cat-valued pseudofunctor. This allows theorems and insights from one perspective to be translated directly into the other, providing two powerful ways to reason about indexed structures." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.4: Fibred adjunctions" ")" "==>" {
(*
ELABORATION: This section lifts the fundamental concept of an adjunction to the setting of fibrations.
The core idea is that an adjunction between two fibrations is not a single adjunction, but a "family"
of adjunctions, one for each fibre, that are coherently linked by the reindexing functors. A deep
elaboration requires defining this "pointwise" adjunction and then introducing the crucial "Beck-Chevalley
condition," which is the coherence law that guarantees these pointwise adjunctions can be glued together
into a single, global adjunction on the total categories.
*)

(* ========================================================================================================== )
( == Part 1: The Definition (Pointwise Adjunctions) == )
( ========================================================================================================== )

FibredAdjunctionDeclaration ::= "FIBRED_ADJUNCTION" CartesianFunctorDeclaration "⊣" CartesianFunctorDeclaration ;
TYPING
(*

A pair of Cartesian functors (F,G) between two fibrations p and p' over the same base B forms a fibred adjunction

if for every object I in the base category, the restricted functors on the fibres form an adjunction.
*)
Γ ⊢ F : CARTESIAN_FUNCTOR p → p', Γ ⊢ G : CARTESIAN_FUNCTOR p' → p
Condition_PointwiseAdjunction :=
∀ (I ∈ Ob(BaseCategory(p))),
Let F_I := RestrictionOf(F, to:Fibre(p,I)) : Fibre(p,I) → Fibre(p',I)
Let G_I := RestrictionOf(G, to:Fibre(p',I)) : Fibre(p',I) → Fibre(p,I)
(F_I ⊣ G_I) is an Adjunction(Fibre(p,I), Fibre(p',I))

Γ ⊢ FIBRED_ADJUNCTION F ⊣ G is a valid declaration if Condition_PointwiseAdjunction holds ;
CATEGORY
[[ FIBRED_ADJUNCTION F ⊣ G ]] = "A family of adjunctions, indexed by the base category of the fibrations, that is coherent with respect to the fibration structure. The 'fibrewise' adjunctions F_I ⊣ G_I are the primary structure. This is the 'pointwise' definition of an adjunction in a fibred setting." ;

(* ========================================================================================================== )
( == Part 2: The Beck-Chevalley Condition (The Coherence Law) == )
( ========================================================================================================== )

BeckChevalleyCondition ::= "satisfies" "BECK_CHEVALLEY_CONDITION" ;
TYPING
(*

This is a crucial coherence condition. It asserts that for a fibred adjunction, the reindexing

functors commute with the adjoints' units and counits in a specific way.

For a base morphism u:I→J, the condition asserts that the canonical natural transformation u* ∘ G_J → G_I ∘ u*

(which always exists for the right adjoint G) is an isomorphism.
)
Context: Γ ⊢ F ⊣ G is a FIBRED_ADJUNCTION between p:E→B and p':E'→B
Condition := ∀ (u:I→J in B), the canonical comparison transformation β_u : u ∘ G_J ⇒ G_I ∘ u* is an ISOMORPHISM.

Γ ⊢ (F ⊣ G) satisfies BECK_CHEVALLEY_CONDITION is TRUE if Condition holds ;
CATEGORY
[[ satisfies BECK_CHEVALLEY_CONDITION ]] = "A key coherence property for a fibred adjunction. It ensures that the process of 'reindexing then applying the right adjoint' is naturally isomorphic to 'applying the right adjoint then reindexing'. This property is crucial for the stability of adjoints in indexed settings and is the necessary condition for gluing the pointwise adjunctions into a global one." ;

(* ========================================================================================================== )
( == Part 3: The Main Theorem (Connecting Pointwise and Global) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "FibredAdjunctionEquivalence" ":"
"A pair of cartesian functors (F,G) forms a global adjunction F ⊣ G between the total categories"
"<==>"
"(F,G) forms a FIBRED_ADJUNCTION and satisfies the BECK_CHEVALLEY_CONDITION." ;
TYPING
(* This theorem states that the global property is equivalent to the pointwise property plus the coherence condition. *)
Let F:E→E' and G:E'→E be cartesian functors.
P1_Global := (F ⊣ G is an Adjunction(E, E'))

P2_Pointwise := (Γ ⊢ FIBRED_ADJUNCTION F ⊣ G)
P3_Coherence := (Γ ⊢ (F ⊣ G) satisfies BECK_CHEVALLEY_CONDITION)

Γ ⊢ (P1_Global <==> (P2_Pointwise ∧ P3_Coherence)) : ProvableEquivalence ;
CATEGORY
[[ THEOREM FibredAdjunctionEquivalence ]] = "The assertion that a coherent 'pointwise' fibred adjunction is the same thing as a single global adjunction between the total categories. The Beck-Chevalley condition provides the necessary and sufficient coherence to ensure the family of fibrewise adjunctions can be glued together into a single, unified adjunction, and vice versa." ;
}

(*
ELABORATION: This section addresses the question of how the structural property of completeness
(the existence of all small limits) behaves in the context of fibrations. It provides a powerful
theorem that allows one to deduce the completeness of the large "total category" E from the
completeness of its smaller, more manageable components: the base category B and the individual
fibre categories E_I.

A deep elaboration requires us to not only state the theorem but to formalize the constructive
proof, showing exactly how a limit in the total category is built from limits in the base and
the fibres. This reveals why the conditions of the theorem are necessary.
*)

(* ========================================================================================================== )
( == Part 1: The Main Criterion Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "FibrationCompletenessCriterion" ":"
"A fibration p:E→B has a complete total category E if:"
"{" "1. The base B is complete;"
"2. All fibres E_I are complete;"
"3. All reindexing functors u* are continuous (preserve limits)." "}" ;
TYPING
(*

This theorem provides a set of sufficient conditions for the total category of a fibration to be complete.

The conditions are precisely those needed to carry out the constructive proof formalized below.
*)
Context: Γ ⊢ p: E → B is FIBRATION
Premise1: Γ ⊢ B is COMPLETE_CATEGORY
Premise2: ∀ (I ∈ Ob(B)), (Γ ⊢ Fibre(p, I) is COMPLETE_CATEGORY)
Premise3: ∀ (u ∈ Mor(B)), (Γ ⊢ ReindexingFunctor(u) preserves small LIMITS)

Conclusion: Γ ⊢ E is COMPLETE_CATEGORY : MetaTheorem ;
CATEGORY
[[ THEOREM FibrationCompletenessCriterion ]] = "A fundamental construction theorem for limits in a fibration. It asserts that if the base and all fibres are complete, and the reindexing structure is continuous, then the entire total category is also complete. This allows one to verify a global property of the large category E by checking local properties of its smaller constituent parts." ;

(* ========================================================================================================== )
( == Part 2: The Constructive Proof Formalized == )
( ========================================================================================================== )

LimitConstructor_in_Fibration ::= "CONSTRUCT_LIMIT_IN_FIBRATION" "of" "diagram" Identifier "as" "{"
"STEP 1 (Base Limit):" LimitDeclaration "in Base" ";"
"STEP 2 (Fibre Diagram Construction):" DiagramDeclaration "in Fibre" ";"
"STEP 3 (Fibre Limit):" LimitDeclaration "in Fibre" ";"
"}" ;
TYPING
(*

This rule formalizes the standard proof of the completeness criterion. It is a meta-level

algorithm for constructing the limit of a diagram D:J→E in the total category.
*)
Context: Let all premises of the FibrationCompletenessCriterion hold.
Γ ⊢ D : Diagram(J, E)
-- Step 1 --
D_base := p ∘ D : Diagram(J, B)
L_base_cone := LIMIT of D_base in B
L_base_apex := Apex(L_base_cone)
-- Step 2 --
L_fibre_cat := Fibre(p, L_base_apex)
Diagram_in_Fibre D_fib := The diagram constructed by pulling back objects of D along the base limit cone legs.
-- Step 3 --
L_fibre_cone := LIMIT of D_fib in L_fibre_cat
L_total_apex := Apex(L_fibre_cone)

Conclusion: Γ ⊢ L_total_apex is the apex of the LIMIT of D in E : ProvableProposition ;
CATEGORY
[[ CONSTRUCT_LIMIT_IN_FIBRATION ... ]] = "The formal representation of the standard proof of the fibration completeness theorem. It is a canonical algorithm for constructing arbitrary limit objects in a fibration. The process involves first finding the 'address' of the limit in the base category, then constructing a new diagram within that specific fibre by pulling back the original data (this requires continuous reindexing), and finally computing the limit within that fibre." ;

(* ========================================================================================================== )
( == Part 3: The Dual Theory for Cocompleteness == )
( ========================================================================================================== )

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'OpfibrationCocompletenessCriterion'" "FROM" "THEOREM" "'FibrationCompletenessCriterion'" ;
TYPING
(*

By applying the duality functor (-)^op, we derive the corresponding theorem for opfibrations and cocompleteness.

System rewrites: fibration→opfibration, complete→cocomplete, limit→colimit, reindexing(u*)→pushforward(u_!).
*)
Γ ⊢ THEOREM 'FibrationCompletenessCriterion' : P_lim
P_colim = rewrite(P_lim, DualityMappings)

Conclusion (rewritten theorem): An opfibration p:E→B has a cocomplete total category E if:

The base B is cocomplete;

All fibres E_I are cocomplete;

All pushforward functors u_! preserve colimits. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof of the dual theorem for cocompleteness, derived mechanically by applying the duality functor. It provides a criterion for assembling a cocomplete total category from its cocomplete base and fibres, showcasing the perfect symmetry of the theory." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability" ")" "==>" {
(*
ELABORATION: This combined elaboration tackles two related, advanced topics. The first concerns the crucial
notion of "smallness" for fibrations, which is necessary to avoid set-theoretic paradoxes and for the
category of all fibrations over B to be a well-behaved 2-category. The second topic, "definability,"
connects this entire theory to mathematical logic by showing how fibrations provide a categorical semantics
for first-order theories.

This elaboration will:

Formalize Smallness: Define a LocallySmallFibration as one where each fibre category is a small
category (i.e., its objects and morphisms form sets).

Connect Smallness to Structure: State the theorem that this smallness condition is precisely what is
required for the pseudofunctor produced by the Grothendieck Construction to land in the 2-category of
small categories, Cat. This solidifies the Grothendieck Equivalence.

Formalize the Logic Connection (Definability):
a. Define a FirstOrderTheory as a syntactic object.
b. Define the Lindenbaum-Tarski Fibration associated with a theory T, where the fibres are categories
of provable formulas in a given context.
c. State the main theorem of definability: that this syntactically constructed fibration has a terminal
object (a "generic model") if and only if the theory admits "elimination of quantifiers."
*)

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability Part 1: Locally Small Fibrations (Section 8.6)" ")" "==>" {
(*
ELABORATION: This section focuses on the crucial "size" condition required for the theory of fibrations to be well-behaved, particularly concerning the Grothendieck Equivalence. While the total category E of a fibration p:E→B can be large, many important results depend on the individual fibres being "small" (i.e., having sets of objects and morphisms). This property is called local smallness.

A deep elaboration will proceed by:

Formalizing the Master Definition: We will provide the formal definition of a LOCALLY_SMALL fibration, where the property is a universal quantification over the fibres.

Stating the Main Consequence: We will state the refined version of the Grothendieck Equivalence theorem, showing that local smallness is the precise condition on the 'geometric' side (fibrations) that corresponds to the 'algebraic' side (pseudofunctors) having the 2-category of small categories, Cat, as its codomain.

Providing a Canonical Example: We will formalize the "codomain fibration" and show that it is locally small if and only if the base category itself is locally small. This provides a clear, concrete instance of the abstract definition and connects it to a familiar property.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition == )
( ========================================================================================================== )

LocallySmallFibration ::= "LOCALLY_SMALL" FibrationDeclaration ;
TYPING
(*
* This is the master definition. A fibration is locally small if each of its fibre categories is a
* small category in the set-theoretic sense (i.e., its collection of objects and its collection
* of morphisms are both sets, not proper classes).
*)
Context: Γ ⊢ p: E → B is FIBRATION
Condition := ∀ (I ∈ Ob(B)), (Γ ⊢ Fibre(p, I) is SMALL_CATEGORY)
-----------------------------------------------------------------------
Γ ⊢ p is a LOCALLY_SMALL Fibration ;
CATEGORY
[[ LOCALLY_SMALL Fibration p ]] = "A fibration whose indexed categories are all small. This is a crucial 'well-behavedness' condition that ensures the collection of all such fibrations over a base B forms a manageable 2-category and avoids set-theoretic size issues. It is the correct setting for the Grothendieck Equivalence." ;

(* ========================================================================================================== )
( == Part 2: The Main Consequence (The Refined Grothendieck Equivalence) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "RefinedGrothendieckEquivalence" ":"
"The 2-category of LOCALLY_SMALL fibrations over B is equivalent to the 2-category of pseudofunctors from B^op to Cat (the 2-category of small categories)." ;
TYPING
Let Fib_small(B) be the 2-category of locally small fibrations over B.
Let PsFun(B^op, Cat) be the 2-category of pseudofunctors into the category of small categories.
------------------------------------------------------------------------------------------
Γ ⊢ Fib_small(B) ≅ PsFun(B^op, Cat) : EquivalenceOf2Categories ;
CATEGORY
[[ THEOREM RefinedGrothendieckEquivalence ]] = "The precise statement of the Grothendieck Equivalence. The condition of local smallness on the fibration side corresponds exactly to the codomain of the pseudofunctor being the 2-category of small categories, Cat. This solidifies the connection between the geometric and algebraic viewpoints and places it on a firm set-theoretic foundation." ;

(* ========================================================================================================== )
( == Part 3: A Canonical Example (The Codomain Fibration) == )
( ========================================================================================================== )

CodomainFibration ::= "cod" ":" ArrowCategoryDeclaration "→" Identifier ;
TYPING
(*
* This defines the codomain fibration for a category C.
* The total category is the arrow category C^→.
* The projection functor 'cod' maps an arrow f:A→B to its codomain B.
*)
Γ ⊢ C_arrow : ArrowCategory(C)
Γ ⊢ C : Category
------------------------------------------------------------------
Γ ⊢ cod : C_arrow → C is a FIBRATION (This is a standard result) ;
CATEGORY
[[ cod : C^→ → C ]] = "The codomain fibration. The fibre over an object X is the slice category C/X. The Cartesian arrows are the pullback squares in C. This is a foundational example of a fibration." ;

CategoryPropertyDefinition ::= Identifier "is" "LOCALLY_SMALL" ;
TYPING
(* This defines the familiar property for a standard category. *)
Γ ⊢ C : Category
Condition := ∀A,B∈Ob(C), IsSet(Hom_C(A,B))
----------------------------------------------------
Γ ⊢ C is LOCALLY_SMALL : PropositionAbout(C) ;
CATEGORY
[[ C is LOCALLY_SMALL ]] = "The standard property of a category having set-sized collections of morphisms between any two objects. Note: This does not require the collection of all objects to be a set." ;

CorollaryDeclaration ::= "COROLLARY" "CodomainFibrationSmallness" ":"
"IF a category C is locally small and has pullbacks, THEN its codomain fibration is a LOCALLY_SMALL_FIBRATION." ;
TYPING
(*
* This corollary connects the property of the base category to the property of the fibration.
* Proof Sketch:
* 1. The codomain functor cod: C^→ → C is a fibration.
* 2. To be a LOCALLY_SMALL fibration, we need each fibre Fibre(cod, X) to be a small category.
* 3. The fibre over an object X is precisely the slice category C/X.
* 4. A standard result states that if C is locally small and has pullbacks (so it's well-powered), its slice categories are also small.
* 5. Therefore, the codomain fibration is locally small.
*)
Premise: Γ ⊢ C is LOCALLY_SMALL ∧ C has Pullbacks
Let p := CodomainFibration(C).
----------------------------------------------------------
Conclusion: Γ ⊢ p is a LOCALLY_SMALL Fibration : ProvableProposition ;
CATEGORY
[[ COROLLARY CodomainFibrationSmallness ]] = "The assertion that the canonical codomain fibration of a well-behaved category is itself well-behaved with respect to size. This provides a large and natural class of examples for the concept of a locally small fibration and demonstrates how the property is inherited from the base." ;

}

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 8.6 & 8.7: Fibrations, Smallness, and Definability Part 2: Definability and the Connection to Logic (Section 8.7)" ")" "==>" {
(*
ELABORATION: This section focuses on one of the most profound applications of fibration theory: providing a
geometric semantics for mathematical logic. The core idea is to construct a fibration directly from the syntax
of a first-order theory. In this "syntactic fibration," categorical structures correspond directly to logical concepts:
objects are formulas, morphisms are proofs, and reindexing functors are substitutions. The main theorem then reveals a deep
connection between a model-theoretic property of the theory (quantifier elimination) and a categorical property of
its fibration (the existence of a universal object).

This elaboration will deconstruct this correspondence by:

Formalizing the Logical Syntax: We will create rules for the components of a logical theory (contexts, substitutions, formulas-in-context) that will serve as the building blocks for the fibration.

Formalizing the Lindenbaum-Tarski Construction: We will define the LT_Fibration constructor, showing precisely how the syntactic components from Part 1 are assembled into the Base Category, the Total Category, and the Projection Functor. We will highlight that the reindexing functor in this fibration is substitution.

Stating the Main Definability Theorem: We will state the central theorem connecting logic and category theory: the existence of a "generic model" (a terminal object) in the syntactic fibration is equivalent to the logical property of quantifier elimination.
*)

(* ========================================================================================================== )
( == Part 1: The Logical Syntax as Categorical Objects == )
( ========================================================================================================== )

LogicalContext ::= "CONTEXT" "{" {Identifier ":" Identifier} "}" ;
TYPING
(* A context is a finite list of typed variables, serving as an object in the base category of the fibration. *)
is_finite_list_of_typed_variables(l)
-------------------------------------------
Γ ⊢ CONTEXT {l} : Object_in(ContextCategory) ;
CATEGORY
[[ CONTEXT {x₁:T₁ ...} ]] = "A context Γ, representing the collection of free variables currently available. This serves as an object in the base category of the syntactic fibration, with each distinct context being a different object." ;

SubstitutionMorphism ::= "SUBSTITUTION" Identifier ":" LogicalContext "→" LogicalContext "by" "{" {Identifier "↦" Expression} "}" ;
TYPING
(* A substitution is a list of terms, serving as a morphism between contexts. *)
Γ ⊢ σ : Identifier, Γ ⊢ Γ_src : LogicalContext, Γ ⊢ Δ_tgt : LogicalContext
is_valid_substitution(map, from: Γ_src, to: Δ_tgt)
-------------------------------------------------------------------------
Γ ⊢ SUBSTITUTION σ ... : Morphism(Γ_src, Δ_tgt) in ContextCategory ;
CATEGORY
[[ SUBSTITUTION σ ... ]] = "A substitution of terms for variables. This serves as a morphism in the base category of the syntactic fibration, mapping one context to another." ;

FormulaInContext ::= "FORMULA" "(" LogicalContext "," string_literal ")" ;
TYPING
(* A formula-in-context is the primary object of the total category. *)
Γ ⊢ Γ_ctx : LogicalContext
well_formed_formula(φ, in_context: Γ_ctx)
----------------------------------------------------
Γ ⊢ FORMULA (Γ_ctx, φ) : Object_in(TotalFormulaCategory);
CATEGORY
[[ FORMULA (Γ, φ) ]] = "The pair of a context Γ and a formula φ whose free variables are in Γ. This serves as an object in the total category of the syntactic fibration. It represents a proposition in a specific variable environment." ;

(* ========================================================================================================== )
( == Part 2: The Lindenbaum-Tarski Fibration Construction == )
( ========================================================================================================== )

LindenbaumTarskiFibration ::= "LT_Fibration" "(" FirstOrderTheory ")" ;
TYPING
(*
* This is the canonical construction that turns a syntactic theory into a fibration.
* Base Category B: Objects are LogicalContexts, Morphisms are SubstitutionMorphisms.
* Total Category E: Objects are FormulaInContext. A morphism from (Γ,φ) to (Δ,ψ) is a substitution σ:Γ→Δ
* such that the theory T proves φ[σ] ⇒ ψ.
* Projection p: E → B maps (Γ, φ) to Γ and a proof-morphism σ to the underlying substitution σ.
* This functor p can be shown to be a fibration.
*)
Γ ⊢ T : FirstOrderTheory
-----------------------------------------------------
Γ ⊢ LT_Fibration(T) : FIBRATION ;
CATEGORY
[[ LT_Fibration(T) ]] = "The syntactic fibration of a theory T. Its fibres are categories of formulas and provable entailments. Its reindexing functors, induced by substitution, correspond to the pullback of formulas along substitutions. The entire structure of logical deduction for the theory T is encoded geometrically in this fibration." ;

(* ========================================================================================================== )
( == Part 3: The Main Definability Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "DefinabilityAndGenericModels" ":"
"The LT_Fibration(T) has a terminal object (a 'generic model')"
"<==>"
"the theory T admits elimination of quantifiers." ;
TYPING
P1 := (Γ ⊢ LT_Fibration(T) has a TERMINAL_OBJECT)
P2 := (Γ ⊢ T has a model-theoretic property called 'elimination of quantifiers')
--------------------------------------------------------------------------------
Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM DefinabilityAndGenericModels ]] = "A deep result connecting a logical property of a theory (elimination of quantifiers) with a categorical property of its associated fibration (existence of a terminal object). A terminal object in the syntactic fibration is a 'formula of all formulas'—a generic predicate from which all other predicates can be uniquely pulled back. The theorem states that a theory possesses such a universal formula if and only if it is simple enough that all its existential questions can be answered with quantifier-free formulas. This provides a powerful geometric interpretation of a core concept in model theory." ;

}
MetaDirectiveAnalysis ::= "(" "For each of: CHAPTER 1: 'Locales', extend the constructed grammar to integrate the formalized content of the section." ")" "==>" {

(* ========================================================================================================== )
( == Section 1.1: The intuitionistic propositional calculus == )
( ========================================================================================================== )
(*
ELABORATION: This section formalizes the syntax and deduction rules of intuitionistic logic. This logic
is the internal logic of Heyting algebras and toposes, and its syntax serves as the raw material for
the Lindenbaum-Tarski algebra construction in the next section. We will formalize the propositions
and the deduction rules as categorical constructs, anticipating the Curry-Howard-Lambek correspondence.
*)

(* --- The Syntax of Propositions --- *)

IntuitionisticProposition ::= Terminal("⊤") | Terminal("⊥") | Identifier | "(" IntuitionisticProposition "∧" IntuitionisticProposition ")" | "(" IntuitionisticProposition "∨" IntuitionisticProposition ")" | "(" IntuitionisticProposition "→" IntuitionisticProposition ")" ;
TYPING
(* Propositions are the objects of our logical category. *)
Γ ⊢ p : IntuitionisticProposition
-----------------------------------
Γ ⊢ p : Object_in(Cat_of_Proofs) ;
CATEGORY
[[ p : IntuitionisticProposition ]] = "A proposition, viewed as an object in the category of proofs (a Cartesian Closed Category). A proof of the proposition will be a morphism into this object." ;

(* --- The Form of Judgments and Proofs --- *)

DeductionSequent ::= "{" {IntuitionisticProposition} "}" "⊢" IntuitionisticProposition ;
TYPING
(* A sequent Γ ⊢ p asserts the existence of a proof. This corresponds to the existence of a morphism. )
Context_Γ := {p_i} ( The set of assumptions *)
Conclusion_p := p
---------------------------------------------------------------------------------------------------
Γ ⊢ ({p_i} ⊢ p) <==> (∃ proof_morphism : Product({[[p_i]]}) → [[p]] in Cat_of_Proofs) ;
CATEGORY
[[ {p_i} ⊢ p ]] = "An assertion of provability. Categorically, it is the statement that the hom-set Hom( [[Γ]], [[p]] ) is inhabited, where [[Γ]] is the product of the objects corresponding to the propositions in Γ." ;

(* --- The Inference Rules as Formal Constructions --- *)

AssumptionRule ::= "ASSUME" "(" IntuitionisticProposition ")" "from" DeductionSequent ;
TYPING
(* The axiom rule of natural deduction: an assumption is a proof. *)
Γ ⊢ {p_i} ⊢ ...
p_k ∈ {p_i}
-------------------
Γ ⊢ {p_i} ⊢ p_k ;
CATEGORY
[[ ASSUME(p_k) from ... ]] = "The projection morphism proj_k from the product object [[Γ]] = Π[[p_i]] to its k-th component, [[p_k]]. This is the fundamental proof object corresponding to using an assumption." ;

ConjunctionIntroductionRule ::= "AND_INTRO" "(" DeductionSequent "," DeductionSequent ")" ;
TYPING
(* To prove a conjunction, you must prove both conjuncts. *)
Γ ⊢ p , Γ ⊢ q
-----------------
Γ ⊢ (p ∧ q) ;
CATEGORY
[[ AND_INTRO(proof_p, proof_q) ]] = "The universal morphism <proof_p, proof_q> into the product object [[p]] × [[q]], guaranteed to exist by the universal property of the product." ;

ConjunctionEliminationRule ::= "AND_ELIM_" ("LEFT"|"RIGHT") "(" DeductionSequent ")" ;
TYPING
(* If you have a proof of a conjunction, you have a proof of each part. *)
Γ ⊢ (p ∧ q) Γ ⊢ (p ∧ q)
------------- -------------
Γ ⊢ p Γ ⊢ q ;
CATEGORY
[[ AND_ELIM_LEFT(proof_pandq) ]] = "The composition of the proof morphism proof_pandq with the first projection, proj₁ ∘ proof_pandq. This extracts the proof of the left conjunct from the proof of the product." ;

ImplicationIntroductionRule ::= "IMPLIES_INTRO" "(" DeductionSequent ")" ;
TYPING
(* To prove an implication, assume the antecedent and derive the consequent. *)
Γ, {p} ⊢ q
---------------
Γ ⊢ (p → q) ;
CATEGORY
[[ IMPLIES_INTRO(proof_of_q_from_p) ]] = "The currying of the proof morphism proof_of_q_from_p : [[Γ]]×[[p]] → [[q]] to a new morphism curry(proof) : [[Γ]] → [[q]]^[[p]]. This is the universal property of the exponential object." ;

ImplicationEliminationRule ::= "MODUS_PONENS" "(" DeductionSequent "," DeductionSequent ")" ;
TYPING
(* If you have a proof of an implication and its antecedent, you have a proof of its consequent. *)
Γ ⊢ p , Γ ⊢ (p → q)
---------------------
Γ ⊢ q ;
CATEGORY
[[ MODUS_PONENS(proof_p, proof_p_implies_q) ]] = "The composition eval ∘ <proof_p_implies_q, proof_p>, where <...> is the universal map into the product [[q]]^[[p]] × [[p]] and eval is the evaluation morphism eval: [[q]]^[[p]] × [[p]] → [[q]]." ;

TruthIntroductionRule ::= "TRUTH_INTRO" ;
TYPING
(* Truth is always provable, from any context. *)
---
Γ ⊢ ⊤ ;
CATEGORY
[[ TRUTH_INTRO ]] = "The unique morphism ! from the object [[Γ]] to the terminal object, [[⊤]]." ;

FalsityEliminationRule ::= "EX_FALSO_QUODLIBET" "(" DeductionSequent "," IntuitionisticProposition ")" ;
TYPING
(* From a proof of falsity, any proposition can be derived. *)
Γ ⊢ ⊥
-----------
Γ ⊢ p ;
CATEGORY
[[ EX_FALSO_QUODLIBET(proof_of_false, target_p) ]] = "The composition ! ∘ proof_of_false, where proof_of_false is a morphism [[Γ]] → [[⊥]] and ! is the unique morphism from the initial object [[⊥]] to the target object [[p]]." ;
}

(* ========================================================================================================== )
( == Section 1.2: Heyting algebras == )
( ========================================================================================================== )
(*
ELABORATION: This section introduces the algebraic semantics for intuitionistic logic: the Heyting algebra.
This structure is central to the entire chapter, as a "frame" (the basis for locales) is a special kind of
complete Heyting algebra. A deep elaboration requires us to formalize not just the definition, but the
key insight behind it: the implication operator → is defined by an adjunction with the meet operator ∧.
This reveals the fundamentally categorical nature of intuitionistic logic.

Our formalization will proceed by:

Deconstructing the Definition: We will define a HeytingAlgebraDeclaration by explicitly
requiring an underlying bounded lattice and then adding the new implication operator.

Formalizing the
Adjunction Axiom: The core of the TYPING rule will be to formalize the universal property that
defines implication: (c ∧ a ≤ b) ⇔ (c ≤ (a → b)). This is the adjunction (- ∧ a) ⊣ (a → -).

Defining the Homomorphisms: We will define the structure-preserving maps between Heyting
algebras, showing that they must preserve not just the lattice structure but also this new
implication structure.

Stating the Fundamental Connection to Logic: We will formalize the Lindenbaum-Tarski theorem as a
key TheoremDeclaration, asserting that the algebra of provable statements in intuitionistic logic
forms the archetypal Heyting algebra. This bridges the syntax of the previous section with the
algebraic semantics of this one.
*)

(* ========================================================================================================== )
( == Part 1: The Definition and its Core Adjunction == )
( ========================================================================================================== )

HeytingAlgebraDeclaration ::= "HEYTING_ALGEBRA" Identifier "is" "{" "UnderlyingLattice" ":" BoundedLatticeDeclaration "," "Implication" ":" OperationDeclaration "}" ;
TYPING
(*
* The typing rule verifies that the given data forms a Heyting algebra.
* It checks that we have a bounded lattice, and a binary operation →.
* The crucial condition is the Adjointness Axiom, which uniquely defines the → operator
* in relation to the meet ∧ and the ordering ≤.
*)
Γ ⊢ L : BoundedLattice
Γ ⊢ (→) : Morphism(Product(Carrier(L),Carrier(L)), Carrier(L))
Axiom_Adjointness: ∀ a,b,c ∈ Carrier(L), ( (c ∧ a ≤ b) <==> (c ≤ (a → b)) )
--------------------------------------------------------------------------------
Γ ⊢ HEYTING_ALGEBRA H ... : HeytingAlgebra_Type ;
CATEGORY
[[ HEYTING_ALGEBRA H ]] = "A bounded lattice that serves as a sound and complete model for intuitionistic propositional logic. The implication operation (Heyting implication) is precisely the right adjoint to the meet operation, viewed as a functor on the poset category. This adjunction is expressed as (- ∧ a) ⊣ (a → -)." ;

(* ========================================================================================================== )
( == Part 2: The Structure-Preserving Maps == )
( ========================================================================================================== )

HeytingAlgebraHomomorphism ::= "HEYTING_HOMOMORPHISM" Identifier ":" HeytingAlgebraDeclaration "→" HeytingAlgebraDeclaration ;
TYPING
(* A Heyting homomorphism must preserve all the structure: the lattice operations and the implication. *)
Γ ⊢ f : Morphism(HA₁, HA₂)
f is a BoundedLatticeHomomorphism
f preserves HeytingImplication: ∀a,b ∈ HA₁, f(a → b) == f(a) → f(b)
----------------------------------------------------------------------
Γ ⊢ f is a HEYTING_HOMOMORPHISM ;
CATEGORY
[[ f : HEYTING_HOMOMORPHISM ]] = "A structure-preserving map between Heyting algebras. It is a morphism in the category Heyt." ;

(* ========================================================================================================== )
( == Part 3: The Bridge from Logic to Algebra == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "LindenbaumTarskiForIPC" ":" "The set of intuitionistic propositions, under the relation of provable equivalence, forms the initial HEYTING_ALGEBRA." ;
TYPING
(*
* This is a meta-theorem. It asserts that the syntactic constructions of Section 1.1
* provide the canonical model for the algebraic structures of Section 1.2.
* The proof involves showing that the set of equivalence classes of propositions, with the
* ordering p≤q iff p⊢q, and the operations defined by the logical connectives,
* satisfy all the axioms of a Heyting algebra.
*)
Let IPC_Prop be the set of IntuitionisticPropositions.
Let ~ be the equivalence relation p~q iff (p⊢q and q⊢p).
Let LT_Algebra = IPC_Prop / ~.
------------------------------------------------------------------------------
Γ ⊢ LT_Algebra is a HEYTING_ALGEBRA : ProvableProposition ;
CATEGORY
[[ THEOREM "LindenbaumTarskiForIPC" ]] = "The assertion that the syntactic category of intuitionistic proofs, when quotiented by provable equivalence, yields a canonical semantic model in the category of Heyting algebras. This is the fundamental bridge from the syntax of intuitionistic logic to its algebraic semantics, and it establishes that the Heyting algebra is the 'correct' algebraic model for this logic." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 1.3: Locales" ")" "==>" {
(*
ELABORATION: The original definition of a locale was compact: "a locale is the dual of a frame."
This is the central insight, but a deep elaboration requires formalizing the machinery of this duality.
The key is to understand that while the objects (locales) are abstract, the morphisms between
them are concrete, and it is in the definition of these morphisms that the crucial arrow-reversal
occurs.

This elaboration will therefore:

Formalize the two categories, Frm (of frames) and Loc (of locales), as distinct entities.

Explicitly define a LocaleMorphism by showing it is concretely represented by a FrameHomomorphism
traveling in the opposite direction.

State the foundational duality as a formal theorem, asserting that the category Loc is, by
construction, precisely the opposite category of Frm.
*)

(* ========================================================================================================== )
( == Part 1: Formalizing the Two Interacting Categories == )
( ========================================================================================================== )

CategoryOfFrames ::= "Frm" ;
TYPING
(* This rule declares the category of Frames. *)
Objects(Frm) := { F | Γ ⊢ F : FRAME }
Morphisms(Frm) := { g | Γ ⊢ g : FRAME_HOMOMORPHISM }
-------------------------------------------------------
Γ ⊢ Frm : Category ;
CATEGORY
[[ Frm ]] = "The category whose objects are frames (complete Heyting algebras) and whose morphisms are frame homomorphisms (preserving finite meets and arbitrary joins). This is the 'algebraic' side of the duality." ;

CategoryOfLocales ::= "Loc" ;
TYPING
(* This rule declares the category of Locales. Its full definition is given by the duality theorem below. *)
Objects(Loc) := { L | Γ ⊢ L : LOCALE }
Morphisms(Loc) := { f | Γ ⊢ f : LOCALE_MORPHISM }
------------------------------------------------------
Γ ⊢ Loc : Category ;
CATEGORY
[[ Loc ]] = "The category of locales, or 'pointless spaces'. This is the 'spatial' or 'geometric' side of the duality, constructed to have better categorical properties (e.g., being cocomplete) than the category of topological spaces." ;

(* ========================================================================================================== )
( == Part 2: The Core of the Duality - The Locale Morphism == )
( ========================================================================================================== )

LocaleMorphismDeclaration ::= "LOCALE_MORPHISM" Identifier ":" LocaleDeclaration "→" LocaleDeclaration ;
TYPING
(*
* This is the heart of the elaboration. It defines what a morphism between locales IS.
* A locale morphism f: L₁ → L₂ is defined to be, and is represented by, a frame
* homomorphism g: Frame(L₂) → Frame(L₁) that goes in the REVERSE direction.
*)
Γ ⊢ f : Identifier
Γ ⊢ L₁ : LOCALE, Γ ⊢ L₂ : LOCALE
Let F₁ = Frame(L₁), F₂ = Frame(L₂).
-------------------------------------------------------------------------------------------------------------
(Γ ⊢ LOCALE_MORPHISM f : L₁ → L₂) <==> (∃ g:FRAME_HOMOMORPHISM s.t. g: F₂ → F₁) ;
CATEGORY
[[ LOCALE_MORPHISM f : L₁ → L₂ ]] = "A morphism between locales. It is representationally a frame homomorphism between their corresponding frames, but going in the opposite direction. This reversal of arrows is the essence of the Frm-Loc duality. If a continuous map of spaces h: X₁ → X₂ induces a frame homomorphism h⁻¹: Ω(X₂) → Ω(X₁) on the open sets, then the corresponding locale morphism goes f: Ω(X₁) → Ω(X₂), preserving the original direction of the map." ;

(* ========================================================================================================== )
( == Part 3: The Foundational Duality Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "LocaleFrameDuality" ":" "The category Loc is the opposite of the category Frm." ;
TYPING
(*
* This theorem formalizes the definition of the category of locales. It is not something to be proven
* from other axioms, but is the foundational constructive definition of Loc.
*)
Let Frm be the category of frames and frame homomorphisms.
Let Loc be the category of locales and locale morphisms.
-----------------------------------------------------------------
Γ ⊢ Loc ≅ Frm^op : IsomorphismOfCategories ;
CATEGORY
[[ THEOREM LocaleFrameDuality ]] = "The assertion of the foundational duality that defines locale theory. It states that the category of 'spaces' (Loc) is constructed as the formal opposite of the category of 'algebras' (Frm). This principled construction is motivated by the desire to turn certain limits in Frm (like products of frames) into more geometrically intuitive colimits in Loc (coproducts of locales), thereby creating a category of spaces with better categorical properties." ;

}

TheoremDeclaration ::= "THEOREM" "FrmIsComplete" ":" "The category Frm of frames and frame homomorphisms is complete." ;
TYPING
(*
* This is an established result in the theory of frames. A category is complete if it has
* all small limits. For frames, this can be proven by explicitly constructing products
* and equalizers. The product of a family of frames is their cartesian product with
* pointwise-defined operations, and equalizers can also be constructed directly.
*)
Category("Frm") has all small limits.
--------------------------------------
Γ ⊢ THEOREM "FrmIsComplete" is a ProvableProposition ;
CATEGORY
[[ THEOREM "FrmIsComplete" ]] = "The assertion that Frm, the category of the 'algebras' of pointless topology, is a well-behaved algebraic category with respect to limits. This provides the solid foundation from which we will deduce properties of the 'spatial' category Loc." ;

DualTheoremInference ::= "INFER_DUAL_THEOREM" "'LocIsCocomplete'" "FROM" "THEOREM" "'FrmIsComplete'" ;
TYPING
(*
* This is the core logical step of the section, formalized as an application of the Duality Principle.
* The logic proceeds as follows:
* 1. By the definition of an opposite category, a limit in a category C corresponds to a colimit in C^op.
* 2. Therefore, if a category C is complete (has all limits), its opposite C^op must be cocomplete (have all colimits).
* 3. We have the theorem "FrmIsComplete".
* 4. By the foundational duality, Loc ≅ Frm^op.
* 5. Therefore, Loc must be cocomplete.
*)
(Γ ⊢ Frm is COMPLETE)^op <==> (Γ ⊢ Frm^op is COCOMPLETE) <==> (Γ ⊢ Loc is COCOMPLETE)
------------------------------------------------------------------------------------
Conclusion: The category Loc has all small colimits. ;
CATEGORY
[[ INFER_DUAL_THEOREM ... ]] = "A constructive proof, via the Duality Principle, that the category of locales is cocomplete. This demonstrates the power of the abstract approach: instead of constructing coproducts and coequalizers of locales directly (which is difficult), we construct the simpler products and equalizers of frames and deduce the result via duality." ;

TheoremDeclaration ::= "THEOREM" "LocaleCoproductViaFrameProduct" ":" "The frame of the coproduct of locales is the product of their frames." ;
TYPING
(*
* This theorem makes the abstract deduction concrete for the most important colimit, the coproduct.
* Let L₁ and L₂ be locales, with corresponding frames F₁ and F₂.
* The coproduct in Loc is L₁ ∐ L₂.
* The product in Frm is F₁ × F₂.
* Because the functor Frame: Loc → Frm^op is an equivalence, it must turn coproducts into products.
* Frame(L₁ ∐ L₂) ≅ Frame(L₁) × Frame(L₂)
*)
Γ ⊢ L₁, L₂ : LOCALE
-----------------------------------------------------------------------
Γ ⊢ Frame(L₁ ∐ L₂) ≅ (Frame(L₁) × Frame(L₂)) : Isomorphism in Frm ;
CATEGORY
[[ THEOREM "LocaleCoproductViaFrameProduct" ]] = "The assertion of the concrete formula for the coproduct of locales. To find the coproduct (sum) of two 'pointless spaces', one takes the product of their 'algebras of opens'. This is a canonical example of how geometric constructions in Loc are realized by algebraic constructions in Frm." ;

(* ========================================================================================================== )
( == Section 1.5: Nuclei == )
( ========================================================================================================== )
(*
ELABORATION: This section provides the frame-theoretic tool for constructing sub-objects in the
category of locales. A "nucleus" on a frame acts as a closure operator, and its set of fixed points
canonically defines a sublocale. A deep elaboration requires us to formally deconstruct the definition
of a nucleus into its constituent axioms, then formalize the construction of the 'frame of fixed points'
that it induces, and finally, state the main theorem that connects this algebraic construction to the
geometric concept of a sublocale.
*)

(* ========================================================================================================== )
( == Part 1: The Formal Definition of a Nucleus == )
( ========================================================================================================== )
(A nucleus is a function on a frame that satisfies four specific axioms.)

NucleusDeclaration ::= "NUCLEUS" Identifier "on" FrameDeclaration ;
TYPING
(*
* This typing rule checks the four defining axioms for a function j: F → F to be a nucleus.
* The first three define a closure operator, and the fourth ensures compatibility with the frame structure.
*)
Γ ⊢ j : Morphism(F, F) in Poset_Category
Axiom_Inflationary: ∀ a∈F, a ≤ j(a)
Axiom_Monotone: ∀ a,b∈F, (a≤b ⇒ j(a)≤j(b))
Axiom_Idempotent: ∀ a∈F, j(j(a)) == j(a)
Axiom_PreservesMeets: ∀ a,b∈F, j(a∧b) == j(a)∧j(b)
-----------------------------------------------------------------
Γ ⊢ NUCLEUS j on F is a valid declaration ;
CATEGORY
[[ NUCLEUS j on F ]] = "A closure operator on a frame that also respects the finite meet structure. It projects elements of the frame F onto a subset of 'j-closed' elements. Each nucleus corresponds to a way of embedding a smaller locale into a larger one." ;

(* ========================================================================================================== )
( == Part 2: The Construction of the Sublocale's Frame == )
( ========================================================================================================== )
(The set of fixed points of a nucleus itself forms a frame.)

FrameOfFixedPoints ::= "Fix" "(" NucleusDeclaration ")" ;
TYPING
(*
* This rule defines the new frame constructed from the fixed points of a nucleus j.
* The carrier set is the set of j-closed elements. The operations are mostly inherited,
* but the join operation must be 'closed' by applying j.
*)
Context: Γ ⊢ j : NUCLEUS on F
Carrier_F_j := { a ∈ F | j(a) == a }
Meet_in_F_j := Meet_in_F (since j preserves meets)
Join_in_F_j(S) := j(Join_in_F(S))
-------------------------------------------------------------------------------------------------------
Γ ⊢ Fix(j) : FRAME (whose carrier is Carrier_F_j and operations are defined as above) ;
CATEGORY
[[ Fix(j) ]] = "The frame of j-fixed-points, denoted F_j. This is the sub-poset of the original frame F consisting of all the elements that are 'closed' under the nucleus j. The theorem is that this collection of fixed points, with a slightly modified join operation, itself forms a new frame, which is the frame of the corresponding sublocale." ;

(* ========================================================================================================== )
( == Part 3: The Main Correspondence Theorem == )
( ========================================================================================================== )
(This theorem provides the crucial link between the algebraic tool and the geometric concept.)

SublocaleDeclaration ::= "SUBLOCALE" Identifier "of" LocaleDeclaration ;
TYPING
(* A sublocale corresponds to a quotient frame, which is represented by a surjective frame homomorphism. *)
Γ ⊢ L₁, L₂ : LOCALE
-----------------------------------------------------------------------------------------------
Γ ⊢ L₁ is SUBLOCALE of L₂ if the corresponding locale morphism L₁→L₂ is a monomorphism in Loc ;
CATEGORY
[[ S is SUBLOCALE of L ]] = "A locale S that is a subspace of a locale L. In the dual category of frames, this corresponds to a surjective frame homomorphism from Frame(L) onto Frame(S)." ;

TheoremDeclaration ::= "THEOREM" "SublocaleNucleusCorrespondence" ":"
"The sublocales of a locale L are in bijective correspondence with the nuclei on its frame F." ;
TYPING
(*
* This is the statement of the correspondence. The proof shows that every surjective frame homomorphism
* (defining a sublocale) gives rise to a nucleus, and every nucleus gives rise to a surjective
* frame homomorphism (onto its frame of fixed points).
*)
Let L be a LOCALE with Frame F.
Set1 := { S | Γ ⊢ S is SUBLOCALE of L }
Set2 := { j | Γ ⊢ j is NUCLEUS on F }
---------------------------------------------------------------------
Γ ⊢ Bijection(Set1, Set2) : IsomorphismOfPosets ;
CATEGORY
[[ THEOREM SublocaleNucleusCorrespondence ]] = "The fundamental theorem of sublocales. It establishes a perfect one-to-one correspondence between the geometric notion of a sublocale and the algebraic notion of a nucleus on the corresponding frame. This allows geometric questions about subspaces to be translated into algebraic questions about closure operators, which are often easier to analyze." ;

(* ELABORATION: These sections define special classes of locale morphisms that have good geometric

properties. The definitions are purely categorical, relying on the existence of adjoints to the

underlying frame homomorphism, which beautifully illustrates the power of adjoint functors to capture

geometric meaning. A deep elaboration requires deconstructing these adjunctional definitions.
*)

(*
ELABORATION: This section defines a special class of locale morphisms that mirrors the important topological
concept of an "open map." A continuous function h: X → Y is open if the image of any open set in X is
an open set in Y. This property is captured in the dual world of frames by a beautiful adjunctional
property of the corresponding frame homomorphism.

A deep elaboration requires us to deconstruct this adjunctional property, showing that the definition of
an "open" locale morphism is not arbitrary but is the precise categorical translation of its topological
counterpart.

Our formalization will proceed by:

Formalizing the "Direct Image" Functor: A locale morphism f:L₁→L₂ is represented by a frame
homomorphism g:F₂→F₁ (the "inverse image"). The topological notion of a "direct image" map becomes,
in this abstract setting, the left adjoint to g. We will formalize this left adjoint, g_!, as the
core new piece of structure.

Formalizing the "Good Behavior" Condition: The mere existence of a left adjoint is not quite enough.
The direct image of an intersection of open sets must be the intersection of their images. This translates
to the condition that the left adjoint g_! must preserve finite meets. We will formalize this as a distinct
property.

Constructing the Master Definition: We will define an OPEN_LOCALE_MORPHISM as one whose
underlying frame homomorphism possesses a left adjoint that also preserves finite meets. This combines
the previous two pieces into the complete, formal definition.
*)

(* ========================================================================================================== )
( == Part 1: The Left Adjoint (The "Direct Image" Analogue) == )
( ========================================================================================================== )

DirectImageFunctor_of_FrameHom ::= "g_!" "(" Identifier ")" ;
TYPING
(*
* This constructor defines the left adjoint g_! to a frame homomorphism g.
* The existence of this adjoint is the first condition for the original locale map to be open.
)
Context: Γ ⊢ g : FrameHomomorphism(from:F₂, to:F₁)
-------------------------------------------------------------------------------------------------
Γ ⊢ g_!(g) : Functor(F₁, F₂) is a valid declaration if ( ∃ Functor f s.t. f ⊣ g ) ;
CATEGORY
[[ g_!(g) ]] = "The left adjoint to the frame homomorphism g. In the topological setting where g is the inverse image map h⁻¹:Ω(Y)→Ω(X), this left adjoint g_! corresponds to the direct image map h_:Ω(X)→Ω(Y). Its existence is the categorical statement that a direct image map is well-defined on the frame." ;

(* ========================================================================================================== )
( == Part 2: The Good Behavior Condition (Preserving Meets) == )
( ========================================================================================================== )

FunctorProperty_PreservesMeets ::= Identifier "preserves" "FINITE_MEETS" ;
TYPING
(*
* This predicate asserts that a functor between frames (viewed as categories) preserves finite meets.
* This is the second condition the left adjoint must satisfy.
)
Γ ⊢ f : Functor(F₁, F₂) between Frames F₁, F₂
Condition_Top: f(1_{F₁}) == 1_{F₂}
Condition_Meets: ∀ a,b ∈ F₁, f(a ∧ b) == f(a) ∧ f(b)
------------------------------------------------------------------------------------------
Γ ⊢ f preserves FINITE_MEETS is TRUE if Condition_Top ∧ Condition_Meets ;
CATEGORY
[[ f preserves FINITE_MEETS ]] = "The property of a poset map being a Heyting algebra homomorphism. When applied to the left adjoint g_!, this condition corresponds to the topological property that the direct image map preserves finite intersections, i.e., h_(U₁∩U₂) = h_(U₁)∩h_(U₂)." ;

(* ========================================================================================================== )
( == Part 3: The Master Definition of an Open Locale Morphism == )
( ========================================================================================================== )

OpenLocaleMorphismDeclaration ::= "OPEN" LocaleMorphismDeclaration ;
TYPING
(*
* This is the master definition, combining the previous two components. A locale morphism f is
* open if its corresponding frame homomorphism g has a left adjoint, g_!, and that left
* adjoint preserves finite meets.
*)
Γ ⊢ f : LocaleMorphism(from:L₁, to:L₂)
Let g be the frame_homomorphism(F₂, F₁) corresponding to f.
Premise1_AdjointExists: ∃ (left_adj = g_!(g))
Premise2_AdjointIsNice: Γ ⊢ left_adj preserves FINITE_MEETS
-------------------------------------------------------------------------------------------------
Γ ⊢ OPEN f is a valid declaration if Premise1_AdjointExists ∧ Premise2_AdjointIsNice ;
CATEGORY
[[ OPEN f : L₁ → L₂ ]] = "A locale morphism f whose corresponding frame homomorphism g:Frame(L₂)→Frame(L₁) possesses a left adjoint that preserves finite meets. The existence of this specific kind of left adjoint is the precise, abstract, categorical translation of the condition that the original continuous map of spaces was an open map. This definition demonstrates the power of adjoint functors to capture geometric properties in a purely algebraic setting." ;

(*
ELABORATION: This section defines "etale morphisms" of locales, which are the point-free, categorical
analogue of "local homeomorphisms" in classical topology. The definition is a beautiful example of how
deep geometric properties can be captured by abstract categorical conditions. It builds directly upon the
definition of an open morphism from the previous section by adding a powerful coherence law to the
underlying adjunction.

A deep elaboration requires us to deconstruct this extra coherence law—the Beck-Chevalley condition—and
show how it formally captures the geometric notion of being "stable under base change," which is the
hallmark of a local homeomorphism.

Our formalization will proceed by:

Formalizing the Beck-Chevalley Condition: We will first provide a formal declaration for the
Beck-Chevalley condition itself. This is a general property of an adjunction in a category with pullbacks,
asserting that the adjunction behaves well with respect to "changing the base" of a morphism.

Constructing the Master Definition: We will then define an ETALE_LOCALE_MORPHISM as a morphism that is
firstly an OPEN_LOCALE_MORPHISM, and secondly, whose defining frame-homomorphism adjunction
(g_! ⊣ g) satisfies this Beck-Chevalley condition.

Stating the Key Geometric Equivalence: Finally, we will state the main theorem that justifies this
entire construction: the assertion that a map between sober topological spaces is a local homeomorphism
if and only if its corresponding locale morphism is etale. This connects the abstract, adjunctional
definition back to its concrete geometric intuition.
*)

(* ========================================================================================================== )
( == Part 1: The Coherence Law (The Beck-Chevalley Condition) == )
( ========================================================================================================== )

BeckChevalleyCondition ::= "BECK_CHEVALLEY_CONDITION" "for_adjunction" "(" Identifier "⊣" Identifier ")" ;
TYPING
(*

The Beck-Chevalley condition for an adjunction F ⊣ G. In a category with pullbacks,

for any pullback square, a canonical natural transformation (the base change map)

relates the two ways of going around the square with the adjoints. The condition

asserts that this canonical transformation is always an isomorphism.
*)
Context: Γ ⊢ F ⊣ G : Adjunction(C,D), where C and D have pullbacks.
∀ (pullback_square in D), the canonical base change natural transformation
β : F_pullback ∘ G_base → G_pullback ∘ F_base is an ISOMORPHISM.

Γ ⊢ BECK_CHEVALLEY_CONDITION for (F ⊣ G) is a valid proposition ;
CATEGORY
[[ BECK_CHEVALLEY_CONDITION for (F ⊣ G) ]] = "A fundamental coherence law for an adjunction, ensuring its stability under base change (pullback). It guarantees that the process of 'pulling back along f then applying the right adjoint G' is naturally isomorphic to 'applying G then pulling back along the pullback of f'. This property is crucial for a structure to be considered truly 'geometric'." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of an Etale Morphism == )
( ========================================================================================================== )

EtaleLocaleMorphismDeclaration ::= "ETALE" LocaleMorphismDeclaration ;
TYPING
(*

An etale morphism is an open morphism whose defining adjunction is particularly well-behaved

with respect to pullbacks in the category of frames.

The definition requires two premises:

The morphism must first satisfy the conditions for being open.

The adjunction g_! ⊣ g that witnesses its openness must satisfy the Beck-Chevalley condition.
*)
Premise1_IsOpen: Γ ⊢ f is OPEN_LOCALE_MORPHISM
Let (g_! ⊣ g) be the adjunction for f in the category Frm.
Premise2_IsStable: The adjunction (g_! ⊣ g) satisfies the BECK_CHEVALLEY_CONDITION.

Γ ⊢ ETALE f is a valid declaration if Premise1_IsOpen ∧ Premise2_IsStable ;
CATEGORY
[[ ETALE f : L₁ → L₂ ]] = "A locale morphism that corresponds to a local homeomorphism of spaces. The definition builds on that of an open morphism by adding the stringent Beck-Chevalley condition to the adjunction g_! ⊣ g. This extra coherence axiom is the precise, abstract, categorical translation of the 'stability under base change' property that is characteristic of local homeomorphisms, demonstrating their fundamental geometric nature." ;

(* ========================================================================================================== )
( == Part 3: The Geometric Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "EtaleIsLocalHomeomorphism" ":"
"A continuous map h between sober spaces is a LOCAL_HOMEOMORPHISM"
"<==>"
"the corresponding locale morphism Ω(h) is ETALE." ;
TYPING
(* This theorem is the ultimate justification for the abstract definition of an etale morphism. *)
Context: Γ ⊢ h : Morphism(X, Y) in the subcategory of Sober Spaces.
P1 := (h is a LOCAL_HOMEOMORPHISM)
P2 := (The locale morphism Ω(h) corresponding to h is an ETALE_LOCALE_MORPHISM)

Γ ⊢ (P1 <==> P2) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "EtaleIsLocalHomeomorphism" ]] = "The assertion of a perfect correspondence between a key geometric concept from classical topology (local homeomorphisms) and a purely algebraic, adjunctional property in locale theory (being an etale morphism). This theorem demonstrates the success of the locale-theoretic program in capturing geometric intuition in a point-free, categorical language." ;

(*
ELABORATION: These sections reveal the fundamental connection and duality between the world of classical,
point-set topology (Top) and the world of point-free, algebraic topology (Loc). This connection is
not an isomorphism, but a more subtle and powerful relationship: an adjunction. A deep elaboration
requires us to formally construct the two functors that bridge these worlds and then to use the
unit and counit of their adjunction to precisely define the "well-behaved" subcategories on which
this relationship becomes an equivalence.
*)

(* ========================================================================================================== )
( == Part 1: The Functors Bridging the Two Worlds == )
( ========================================================================================================== )
(We first formalize the two key functors: Ω, which extracts the "logic" from a space,
and pt, which reconstructs a "space" from a logic.)

OmegaFunctor ::= "Ω" ":" "Top → Loc" ;
TYPING
(* This functor takes a topological space and produces its locale of open sets. *)
ActionOnObjects( X : Object_in(Top) ):
Let F_X be the FRAME of open sets of X.
Ω(X) := the LOCALE whose frame is F_X.
ActionOnMorphisms( h : Morphism(X,Y) in Top ):
Let g_h : Frame(Ω(Y)) → Frame(Ω(X)) be the frame homomorphism defined by taking the inverse image, g_h(U) := h⁻¹(U).
Ω(h) := the LOCALE_MORPHISM corresponding to the frame homomorphism g_h.
--------------------------------------------------------------------------------
Γ ⊢ Ω : Functor(Top, Loc) ;
CATEGORY
[[ Ω : Top → Loc ]] = "The 'open sets' functor. It is a contravariant construction on the underlying frames, but covariant on the locales themselves. It extracts the observable, algebraic essence of a space, forgetting its underlying points." ;

PointsFunctor ::= "pt" ":" "Loc → Top" ;
TYPING
(* This functor takes a locale and constructs its space of 'points'. *)
ActionOnObjects( L : LOCALE ):
Let F_L := Frame(L).
Let Pts := { p | p is a FRAME_HOMOMORPHISM from F_L to the 2-element frame {0,1} }.
The topology on Pts is generated by opens of the form { p ∈ Pts | p(a) = 1 } for each a ∈ F_L.
pt(L) := the TopologicalSpace (Pts, topology).
ActionOnMorphisms( f : Morphism(L₁, L₂) in Loc):
Let g_f : Frame(L₂) → Frame(L₁) be the corresponding frame homomorphism.
pt(f) is the continuous map pt(L₁) → pt(L₂) that sends a point p:Frame(L₁)→{0,1} to the composite p ∘ g_f.
--------------------------------------------------------------------------------
Γ ⊢ pt : Functor(Loc, Top) ;
CATEGORY
[[ pt : Loc → Top ]] = "The 'points' functor. It provides the best possible reconstruction of a classical topological space from the purely algebraic data of a locale. It is the bridge from the point-free world back to the point-set world." ;

(* ========================================================================================================== )
( == Part 2: The Main Adjunction and its Unit/Counit == )
( ========================================================================================================== )
(The two functors are not inverse, but adjoint.)

TheoremDeclaration ::= "THEOREM" "OmegaIsLeftAdjointToPoints" ":" "The funtor Ω is left adjoint to the functor pt, (Ω ⊣ pt)." ;
TYPING
Γ ⊢ Ω : Functor(Top, Loc), Γ ⊢ pt : Functor(Loc, Top)
----------------------------------------------------------------------------------
Γ ⊢ Ω ⊣ pt : Adjunction(Top, Loc) <==> Hom_Loc(Ω(X), L) ≅ Hom_Top(X, pt(L)) ;
CATEGORY
[[ THEOREM "OmegaIsLeftAdjointToPoints" ]] = "The assertion of the fundamental adjunction between topology and locale theory. The natural bijection means that a continuous map from a space X to the 'space of points' of a locale L corresponds uniquely to a locale morphism from the 'locale of opens' of X to L. This is the central organizing principle of the theory." ;

UnitOfOmegaPtAdjunction ::= "η" ":" "Id_Top ⇒ pt ∘ Ω" ;
TYPING
(* The unit η_X of the adjunction is a continuous map from a space X to the space of points of its own locale of opens. *)
Γ ⊢ η : NaturalTransformation(Id_Top, pt ∘ Ω)
Component_at_X(η_X : X → pt(Ω(X))):
Maps a point x∈X to the frame homomorphism p_x: Ω(X)→{0,1} defined by p_x(U) = 1 iff x∈U.
--------------------------------------------------------------------------
Γ ⊢ η is the UNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ η ]] = "The unit of the adjunction. For each space X, the map η_X tests whether X can be fully recovered from its points. A space is 'sober' if this map is an isomorphism." ;

CounitOfOmegaPtAdjunction ::= "ε" ":" "Ω ∘ pt ⇒ Id_Loc" ;
TYPING
(* The counit ε_L is a locale morphism from the locale of opens of its space of points back to the original locale. *)
Γ ⊢ ε : NaturalTransformation(Ω ∘ pt, Id_Loc)
Component_at_L(ε_L : Ω(pt(L)) → L):
Defined by the frame homomorphism g_L: Frame(L) → Frame(Ω(pt(L))) that sends an element a∈Frame(L)
to the open set { p:Frame(L)→{0,1} | p(a)=1 }.
-------------------------------------------------------------------------
Γ ⊢ ε is the COUNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ ε ]] = "The counit of the adjunction. For each locale L, the map ε_L tests whether L has enough points to define its structure. A locale is 'spatial' if this map is an isomorphism." ;

(* ========================================================================================================== )
( == Part 3 (Elaborated): Sober Spaces, Spatial Locales, and the Equivalence == )
(* ELABORATION: This is a deep dive into the core result connecting topology to locale theory.

We will deconstruct the definitions of "sober" and "spatial", showing how they are precisely

the conditions required for the unit and counit of the fundamental Ω ⊣ pt adjunction to be isomorphisms.

This reveals that the equivalence is not an accident, but a direct consequence of the universal

properties that define the bridge between the two worlds.
*)

(* ========================================================================================================== )
( == 3a. The Unit of the Adjunction and the Test for Spaces (Sobriety) == )
( ========================================================================================================== )

UnitOfOmegaPtAdjunction ::= "η" ":" "Id_Top ⇒ pt ∘ Ω" ;
TYPING
(*
* This defines the unit of the adjunction, η. For each topological space X, η provides a
* canonical continuous map η_X from the space X itself to the space of points of its own locale of opens.
* We can define this map constructively:
* 1. The space pt(Ω(X)) has as its points the frame homomorphisms p: Frame(Ω(X)) → {0,1}.
* 2. Frame(Ω(X)) is just the lattice of open sets of X, denoted Open(X).
* 3. For any point x ∈ X, we can define such a homomorphism p_x by checking membership: p_x(U) = 1 iff x ∈ U.
* The map η_X is precisely the function that sends a point x to its corresponding homomorphism p_x.
*)
Component_at_X(η_X : X → pt(Ω(X))) := (x ↦ (p_x : Open(X)→{0,1}))
--------------------------------------------------------------------------
Γ ⊢ η is the UNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ η ]] = "The unit of the adjunction. For each space X, the map η_X tests whether the space X can be fully recovered from its own 'point-like structures' (the prime open filters). If this map is an isomorphism, the space is 'sober'." ;

SoberSpaceDeclaration ::= "SOBER_SPACE" Identifier ;
TYPING
(*
* A space X is defined as sober if the unit map η_X is a homeomorphism (an isomorphism in Top).
* η_X being injective means no two distinct points have the exact same collection of open neighborhoods.
* η_X being surjective means every frame homomorphism Open(X)→{0,1} (an abstract 'point') is realized
* by an actual point x ∈ X.
*)
Γ ⊢ X : Object_in(Top)
Let η_X be the X-component of the UnitOfOmegaPtAdjunction.
-----------------------------------------------------------
Γ ⊢ X is SOBER_SPACE is TRUE if (η_X is an ISOMORPHISM in Top) ;
CATEGORY
[[ SOBER_SPACE X ]] = "A topological space that has 'exactly the right amount' of points: no two points share the exact same open neighborhoods (a T₀-like property), and every collection of open sets that 'behaves like a point' (a prime open filter) actually corresponds to a unique concrete point. All Hausdorff spaces are sober." ;

(* ========================================================================================================== )
( == 3b. The Counit of the Adjunction and the Test for Locales (Spatiality) == )
( ========================================================================================================== )

CounitOfOmegaPtAdjunction ::= "ε" ":" "Ω ∘ pt ⇒ Id_Loc" ;
TYPING
(*
* This defines the counit ε. For each locale L, it is a locale morphism ε_L from the locale of opens of
* its space of points, Ω(pt(L)), back to the original locale L.
* This locale morphism is defined by its corresponding frame homomorphism g in the opposite direction: g_L: Frame(L) → Frame(Ω(pt(L))).
* 1. Frame(Ω(pt(L))) is the lattice of open sets of the space pt(L).
* 2. The map g_L sends an 'open' a ∈ Frame(L) to the concrete open set in pt(L) consisting of all
* points p that "satisfy" a.
* g_L(a) := { p ∈ pt(L) | p(a) = 1 }
*)
Component_at_L(ε_L : Ω(pt(L)) → L) is defined by the frame homomorphism:
g_L(a ∈ Frame(L)) ↦ {p:Frame(L)→{0,1} | p(a)=1 }
-------------------------------------------------------------------------
Γ ⊢ ε is the COUNIT of the adjunction (Ω ⊣ pt) ;
CATEGORY
[[ ε ]] = "The counit of the adjunction. For each locale L, the map ε_L tests whether the locale can be fully recovered from its algebra of open sets. If this map is an isomorphism, the locale is 'spatial'." ;

SpatialLocaleDeclaration ::= "SPATIAL_LOCALE" Identifier ;
TYPING
(*
* A locale L is defined as spatial if the counit map ε_L is an isomorphism in Loc.
* This is equivalent to its underlying frame homomorphism g_L being an isomorphism in Frm.
* This holds if and only if for any two distinct elements a,b in Frame(L), there is some point
* p: Frame(L)→{0,1} that can distinguish them (i.e., p(a) ≠ p(b)).
*)
Γ ⊢ L : LOCALE
Let ε_L be the L-component of the CounitOfOmegaPtAdjunction.
--------------------------------------------------------------
Γ ⊢ L is SPATIAL_LOCALE is TRUE if (ε_L is an ISOMORPHISM in Loc) ;
CATEGORY
[[ SPATIAL_LOCALE L ]] = "A locale that is fully determined by its points; it has 'enough points' to separate all of its 'opens'. These are precisely the locales that arise as the lattice of open sets of some sober space." ;

(* ========================================================================================================== )
( == 3c. The Equivalence Theorem == )
( ========================================================================================================== )
(This theorem brings all the preceding definitions together into a single, powerful statement.)

CategoryOfSoberSpaces ::= "SoberTop" ;
TYPING
SoberObjects := { X ∈ Ob(Top) | Γ ⊢ X is SOBER_SPACE }
------------------------------------------------------------
Γ ⊢ SoberTop : FullSubcategory(Top) on objects SoberObjects ;
CATEGORY
[[ SoberTop ]] = "The category of sober spaces, which is the largest subcategory of Top on which the unit of the Ω⊣pt adjunction is an isomorphism. It is a reflective subcategory of Top." ;

CategoryOfSpatialLocales ::= "SpatialLoc" ;
TYPING
SpatialObjects := { L ∈ Ob(Loc) | Γ ⊢ L is SPATIAL_LOCALE }
----------------------------------------------------------------
Γ ⊢ SpatialLoc : FullSubcategory(Loc) on objects SpatialObjects ;
CATEGORY
[[ SpatialLoc ]] = "The category of spatial locales, which is the largest subcategory of Loc on which the counit of the Ω⊣pt adjunction is an isomorphism. It is a coreflective subcategory of Loc." ;

TheoremDeclaration ::= "THEOREM" "SoberSpatialEquivalence" ":"
"The Ω ⊣ pt adjunction restricts to an equivalence of categories between SoberTop and SpatialLoc." ;
TYPING
(*
* This is the main result. The properties of sobriety and spatiality are precisely the conditions
* needed for the unit and counit to be isomorphisms, which is a defining characteristic of an
* equivalence of categories mediated by an adjunction.
*)
Let Ω_res := the restriction of Ω to SoberTop.
Let pt_res := the restriction of pt to SpatialLoc.
------------------------------------------------------------------------------
Γ ⊢ Ω_res and pt_res form an EquivalenceOfCategories(SoberTop, SpatialLoc) ;
CATEGORY
[[ THEOREM "SoberSpatialEquivalence" ]] = "The culminating result of point-set topology's interaction with locale theory. It asserts that for the large and important class of sober spaces, no information is lost by shifting to the point-free perspective of locales, as there is a perfect, invertible dictionary between the two worlds. The functor Ω provides the translation from the spatial world to the algebraic/logical world, and the functor pt provides the translation back." ;

(* ELABORATION: These sections reveal the power of the locale-theoretic approach by demonstrating how

core topological properties like compactness and regularity can be defined in a completely "point-free"

manner, using only the algebraic structure of the frame of opens. A deep elaboration requires not just

stating these definitions, but deconstructing them to show how the point-free axioms are a direct

and faithful translation of the original topological intuition.
*)

(*
ELABORATION: This section defines the crucial topological property of compactness in the completely
point-free language of locales and their underlying frames. A deep elaboration requires not just stating
the final axiom, but deconstructing it to show how it is a direct and faithful algebraic translation
of the familiar topological phrase: "every open cover has a finite subcover."

This elaboration will proceed in three stages:

Formalizing the Pieces: We will create formal grammar rules for the algebraic concepts of
a "Frame Cover" (a set of frame elements whose join is the top element) and a
"Finite Subcover" (a finite subset of a cover that still joins to the top). This translates the
topological language into the algebraic language of the frame.

Constructing the Master Definition: We will then use these formalized pieces to build the master
definition of a COMPACT frame. A frame will be defined as compact if for every possible
FrameCover, there exists a FiniteSubcover. We then define a compact locale as one whose
frame is compact.

Stating the Justification Theorem: Finally, we will formalize the crucial theorem that justifies
this entire abstract enterprise. We will assert that for any well-behaved (sober) topological space,
it is compact in the classical sense if and only if its locale of opens is compact in this
new, point-free sense. This connects the abstract definition back to its concrete geometric origins.
*)

(* ========================================================================================================== )
( == Part 1: Deconstructing the Point-Free Axiom == )
( ========================================================================================================== )
(First, we translate the topological terms into the algebraic language of frames.)

FrameCover ::= "COVER" "of" FrameDeclaration "by" "{" {Identifier} "}" ;
TYPING
(*
* This defines a "cover" in the algebraic sense. A collection of "opens" (frame elements)
* is a cover if their union (join) is the whole space (the top element '1').
*)
Γ ⊢ F : FRAME
Γ ⊢ S : Set of ElementsOf(F)
---------------------------------------------------------
Γ ⊢ COVER of F by S is valid if (Join(S) == TopElement(F)) ;
CATEGORY
[[ COVER of F by S ]] = "An algebraic representation of an open cover. The set S is a subset of the frame F, and the condition that its join is the top element is the direct, point-free translation of the topological statement that the union of the corresponding open sets covers the entire space." ;

FiniteSubcover ::= "FINITE_SUBCOVER" "of" FrameCover "by" "{" {Identifier} "}" ;
TYPING
(*
* This defines a "finite subcover" in the algebraic sense. It is a finite subset of a
* given cover that is, itself, still a cover.
*)
Γ ⊢ C = (COVER of F by S)
Γ ⊢ S_fin : Set of ElementsOf(F)
Premise1_Subset: S_fin ⊆ S
Premise2_Finite: |S_fin| is finite
Premise3_Covers: Join(S_fin) == TopElement(F)
-------------------------------------------------------------------
Γ ⊢ FINITE_SUBCOVER of C by S_fin is a valid subcover ;
CATEGORY
[[ FINITE_SUBCOVER of C by S_fin ]] = "An algebraic representation of a finite subcover. It is a finite subset of the original covering set S that is still 'large enough' to join to the top element of the frame, meaning its corresponding union of open sets still covers the whole space." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition for Compactness == )
( ========================================================================================================== )

CompactFrameDeclaration ::= "COMPACT" FrameDeclaration ;
TYPING
(*
* This is the master definition, built from the pieces above. A frame is compact if for
* every possible cover, a finite subcover can be found.
*)
Γ ⊢ F : FRAME
Condition := ∀ (C : FrameCover of F), (∃ (S : FiniteSubcover of C))
-----------------------------------------------------------------
Γ ⊢ F is COMPACT is TRUE if Condition holds ;
CATEGORY
[[ COMPACT FRAME F ]] = "A frame that satisfies the point-free version of the Heine-Borel property. The definition is a direct, formal translation of 'every open cover has a finite subcover' into the algebraic language of joins in a complete lattice." ;

CompactLocaleDeclaration ::= "COMPACT" LocaleDeclaration ;
TYPING
(* A locale is defined as compact if and only if its underlying frame is compact. *)
Γ ⊢ L : LOCALE
----------------------------------------------------
Γ ⊢ L is COMPACT <==> (Frame(L) is COMPACT_FRAME) ;
CATEGORY
[[ COMPACT LOCALE L ]] = "A 'pointless space' that is compact. The property is defined not by reference to any points, but by reference to the algebraic compactness property of its associated frame of 'opens'." ;

(* ========================================================================================================== )
( == Part 3: The Justification (Connecting back to Topology) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CorrespondenceOfCompactness" ":"
"A sober space X is compact in the topological sense"
"<==>"
"its locale of opens Ω(X) is a COMPACT locale." ;
TYPING
(*
* This theorem asserts that our abstract, point-free definition is the 'correct' one,
* as it perfectly coincides with the classical definition for all well-behaved spaces.
*)
Context: Γ ⊢ X is SOBER_SPACE
P1_Topological := (X is a COMPACT_TOPOLOGICAL_SPACE)
P2_Localic := (Ω(X) is a COMPACT_LOCALE)
---------------------------------------------------
Γ ⊢ (P1_Topological <==> P2_Localic) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "CorrespondenceOfCompactness" ]] = "The assertion that the locale-theoretic definition of compactness is a faithful generalization of the topological definition. For the large and important class of sober spaces, the two definitions are equivalent, justifying the use of the more abstract, algebraic definition in the point-free setting." ;
}

(*
ELABORATION: This section defines the crucial topological separation property of regularity in the
completely point-free language of locales and their underlying frames. A deep elaboration requires not just
stating the final axiom, but deconstructing it to show how it is a direct and faithful algebraic
translation of the familiar topological idea: "a point can be separated from a closed set by disjoint
open neighborhoods." Since locales have no points, this must be rephrased. The key insight is to capture
this separation using a new relation, "way below" (≺), which formalizes the notion of one open set being
"securely nested" inside another.

This elaboration will proceed in three stages:

Formalizing the Core Tool (The "Way Below" Relation): We will formalize the ≺ relation,
which is the algebraic substitute for the topological idea of "closure of U is contained in V". This
is the fundamental building block for defining regularity without points.

Constructing the Master Definition: We will use the ≺ relation to define a regular frame as one
where every element is the join (union) of all the elements that are "way below" it. This is the
precise, point-free translation of the regularity axiom. We then define a regular locale as one whose
frame is regular.

Stating the Justification Theorem: We will formalize the crucial theorem that justifies this
entire abstract enterprise. We will assert that for any well-behaved (sober) topological space,
it is regular in the classical sense if and only if its locale of opens is regular in this
new, point-free sense. This connects the abstract definition back to its concrete geometric origins.
*)

(* ========================================================================================================== )
( == Part 1: The Core Tool - The "Way Below" Relation == )
( ========================================================================================================== )

WayBelowRelation ::= Expression "≺" Expression ;
TYPING
(*
* This rule formalizes the "way below" or "well inside" relation, b ≺ a.
* The intuition is that the closure of the open set corresponding to b is contained within the open set for a.
* The point-free definition captures this by asserting the existence of a "separating" open c (the
* complement of the closure of b) such that b and c are disjoint, but a and c together cover the whole space.
*)
Context: F is a FRAME. Γ ⊢ a,b: ElementsOf(F)
------------------------------------------------------------------
Γ ⊢ (b ≺ a) is TRUE if (∃c∈F s.t. b∧c==0 ∧ a∨c==1) ;
CATEGORY
[[ b ≺ a ]] = "The assertion that the element b is 'way below' the element a. This provides a point-free way to express that the closure of the open set corresponding to b is contained within the open set corresponding to a. It formalizes the notion of being 'securely nested' or 'well inside'." ;

(* ========================================================================================================== )
( == Part 2: The Master Definition of a Regular Locale == )
( ========================================================================================================== )

RegularFrameDeclaration ::= "REGULAR" FrameDeclaration ;
TYPING
(*
* A frame is defined as regular if every element 'a' can be reconstructed as the join of all the
* elements 'b' that are "way below" it. This means every open set can be built up from the
* collection of all open sets that are securely nested inside it. This is the precise algebraic
* translation of the T₃ separation axiom.
*)
Γ ⊢ F : FRAME
Condition_Regularity := ∀ (a ∈ Carrier(F)), ( a == ⋁{ b ∈ Carrier(F) | Γ ⊢ b ≺ a } )
------------------------------------------------------------------------------------
Γ ⊢ F is REGULAR is TRUE if Condition_Regularity holds ;
CATEGORY
[[ REGULAR FRAME F ]] = "A frame that satisfies the point-free version of the T₃ (regularity) separation axiom. This property ensures a high degree of 'separation' between the open sets of the frame, mirroring the ability to separate points from closed sets in a regular topological space." ;

RegularLocaleDeclaration ::= "REGULAR" LocaleDeclaration ;
TYPING
(* A locale is defined as regular if and only if its underlying frame is regular. *)
Γ ⊢ L : LOCALE
----------------------------------------------------
Γ ⊢ L is REGULAR <==> (Frame(L) is a REGULAR_FRAME) ;
CATEGORY
[[ REGULAR LOCALE L ]] = "A 'pointless space' that is regular. The property is defined not by reference to any points, but by reference to the algebraic regularity property of its associated frame of 'opens'." ;

(* ========================================================================================================== )
( == Part 3: The Justification (Connecting back to Topology) == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "CorrespondenceOfRegularity" ":"
"A sober space X is regular in the topological sense"
"<==>"
"its locale of opens Ω(X) is a REGULAR locale." ;
TYPING
(*
* This theorem asserts that our abstract, point-free definition is the 'correct' one,
* as it perfectly coincides with the classical definition for all well-behaved spaces.
*)
Context: Γ ⊢ X is SOBER_SPACE
P1_Topological := (X is a REGULAR_TOPOLOGICAL_SPACE)
P2_Localic := (Ω(X) is a REGULAR_LOCALE)
---------------------------------------------------
Γ ⊢ (P1_Topological <==> P2_Localic) : ProvableEquivalence ;
CATEGORY
[[ THEOREM "CorrespondenceOfRegularity" ]] = "The assertion that the locale-theoretic definition of regularity is a faithful generalization of the topological definition. For the large and important class of sober spaces, the two definitions are equivalent, justifying the use of the more abstract, algebraic definition in the point-free setting." ;
(* ========================================================================================================== )
( == Section 2.1: Sheaves on a locale == )
( ========================================================================================================== )
(*
ELABORATION: This section defines the central object of study: the sheaf. A sheaf is a "presheaf"
that additionally satisfies a "gluing axiom." A deep elaboration requires us to deconstruct this axiom
into its formal, testable components: the notion of a 'cover', a 'matching family' of data on that
cover, and the unique 'amalgamation' (or gluing) of that data.
*)

(* --- The Prerequisite: Presheaves on a Locale --- *)

PresheafOnLocale ::= "PRESHEAF" Identifier "on" LocaleDeclaration ;
TYPING
(* A presheaf of sets on a locale L is a contravariant functor from its frame F (viewed as a category) to Set. *)
Γ ⊢ L : LOCALE
Let F = Frame(L).
--------------------------------------------------------------
Γ ⊢ PRESHEAF P on L : Functor(F^op, Set) ;
CATEGORY
[[ PRESHEAF P on L ]] = "An object in the category [Frame(L)^op, Set], representing a family of sets indexed by the 'opens' of the locale L, equipped with restriction maps. It is 'data that can be restricted'." ;

(* --- Deconstructing the Gluing Axiom --- *)

CoverOfOpen ::= "COVER" "of" Identifier "by" "{" {Identifier} "}" ;
TYPING
(* A cover of an open 'a' in a frame F is a set of opens {a_i} whose join is 'a'. *)
Context: Γ ⊢ F : FRAME
Γ ⊢ a : ElementOf(F)
Γ ⊢ S = {a_i} : Set of ElementsOf(F)
-----------------------------------------------------------
Γ ⊢ COVER of a by S is valid if (a == ⋁{a_i ∈ S}) ;
CATEGORY
[[ COVER of a by S ]] = "An algebraic representation of an open cover of 'a', representing the context for a gluing problem." ;

MatchingFamily ::= "MATCHING_FAMILY" "{" {Identifier} "}" "for" "(" PresheafOnLocale "," CoverOfOpen ")" ;
TYPING
(*
* A matching family for a presheaf P on a cover S of 'a' is a selection of sections s_i ∈ P(a_i)
* that are compatible on overlaps.
*)
Γ ⊢ P : PRESHEAF on L, Γ ⊢ C = (COVER of a by S)
Family_s := { s_i ∈ P(a_i) | a_i ∈ S }
Compatibility_Condition := ∀ a_i,a_j ∈ S, P(incl_{ij})(s_i) == P(incl_{ji})(s_j) in P(a_i ∧ a_j)
--------------------------------------------------------------------------------------------------
Γ ⊢ MATCHING_FAMILY Family_s ... is valid if Compatibility_Condition holds ;
CATEGORY
[[ MATCHING_FAMILY ... ]] = "A collection of local data that is consistent and thus 'gluable'. The compatibility condition ensures that the data agrees on all intersections." ;

SheafGluingAxiom ::= "AXIOM" "SheafGluingCondition" "holds_for" PresheafOnLocale ;
TYPING
(* The gluing condition states that every matching family has a unique amalgamation. *)
Γ ⊢ P : PRESHEAF on L
Condition := ∀ (C:Cover), ∀(MF:MatchingFamily for (P,C)),
( ∃! s ∈ P(CoveredOpen(C)) s.t. ∀i, P(incl_i)(s) == section_i(MF) )
--------------------------------------------------------------------
Γ ⊢ AXIOM ... holds_for P is TRUE if Condition holds ;
CATEGORY
[[ AXIOM SheafGluingCondition ... ]] = "The assertion that the presheaf P satisfies the sheaf axiom. This property elevates the presheaf from mere 'restrictable data' to 'local data' that can be uniquely glued together to form global data. Categorically, it means P(a) is the limit of the diagram formed by the matching family." ;

(* --- The Master Definition --- *)

SheafOnLocaleDeclaration ::= "SHEAF" Identifier "on" LocaleDeclaration ;
TYPING
(* A sheaf is a presheaf that satisfies the gluing axiom. *)
Premise1: Γ ⊢ P is a PRESHEAF on L
Premise2: Γ ⊢ AXIOM SheafGluingCondition holds_for P
------------------------------------------------------
Γ ⊢ SHEAF P on L is a valid declaration ;
CATEGORY
[[ SHEAF P on L ]] = "A presheaf that satisfies the gluing condition. Sheaves are the central objects of topos theory, providing a bridge between topology, logic, and geometry. They represent 'continuously varying sets' over the base locale." ;


(* ========================================================================================================== )
( == Section 2.2-2.3: Properties of the Category of Sheaves, Sh(L) == )
( ========================================================================================================== )
(*
ELABORATION: These sections establish the fundamental result that the category of sheaves on a locale,
denoted Sh(L), is not just a category but a "Grothendieck topos." This is a very powerful statement,
implying that Sh(L) has an exceptionally rich and well-behaved internal structure. A deep elaboration requires
us to formalize this claim and then unpack its major consequences, including the existence of a
"subobject classifier," which is the heart of a topos's internal logic.
*)

(* ========================================================================================================== )
( == Part 1: The Main Theorem - Sh(L) is a Topos == )
( ========================================================================================================== )

CategoryOfSheaves ::= "Sh" "(" LocaleDeclaration ")" ;
TYPING
(* This constructor defines the category of sheaves on a locale L. *)
Γ ⊢ L : LOCALE
Objects := { P | Γ ⊢ P is SHEAF on L }
Morphisms := { α : P₁ ⇒ P₂ | α is a NaturalTransformation between the underlying presheaves }

Γ ⊢ Sh(L) : FullSubcategory(of: Presheaves on L) ;
CATEGORY
[[ Sh(L) ]] = "The category of sheaves of sets on the locale L. This category is the primary object of study." ;

GrothendieckToposDeclaration ::= Identifier "is" "GROTHENDIECK_TOPOS" ;
TYPING
(*

A category C is a Grothendieck topos if it is equivalent to the category of sheaves on some site.

An equivalent characterization is given by Giraud's Axioms, which are internal to C.
*)
Γ ⊢ C : Category
GiraudAxiom1: C is cocomplete and has a set of generators.
GiraudAxiom2: Coproducts in C are disjoint and stable under pullback.
GiraudAxiom3: Equivalence relations in C are effective.

Γ ⊢ C is GROTHENDIECK_TOPOS is TRUE if GiraudAxioms hold ;
CATEGORY
[[ C is GROTHENDIECK_TOPOS ]] = "A category that behaves like a category of sheaves. Toposes are foundational universes for mathematics, possessing rich internal logic and serving as a bridge between geometry, logic, and algebra." ;

TheoremDeclaration ::= "THEOREM" "CategoryOfSheavesIsATopos" ":" "For any locale L, Sh(L) is a GROTHENDIECK_TOPOS." ;
TYPING
(* This is a central theorem of topos theory. *)
Γ ⊢ L : LOCALE

Γ ⊢ Sh(L) is a GROTHENDIECK_TOPOS : ProvableProposition ;
CATEGORY
[[ THEOREM "CategoryOfSheavesIsATopos" ]] = "The fundamental theorem asserting that the category of sheaves on a locale provides a canonical model of a Grothendieck topos. All the rich properties of a topos are therefore available in Sh(L)." ;

MetaDirectiveAnalysis ::= "(" "Elaborate on Section 2.2-2.3: Properties of the Category of Sheaves, Sh(L) Part 2: Consequences - Completeness, CCC, and the Subobject Classifier" ")" "==>" {
(*
ELABORATION (Deeper Dive): The previous elaboration stated that Sh(L) is complete, cocomplete, and Cartesian Closed with a subobject classifier. A deeper elaboration requires us to deconstruct how these properties arise from the fact that Sh(L) is a reflective subcategory of the category of presheaves Psh(L). The key insight is that the presheaf category is extremely well-behaved, and these "nice" properties are either inherited directly (for limits) or constructed via the reflection (for colimits and exponentials).

This elaboration will proceed by:

Deconstructing Completeness and Cocompleteness: We will formalize the constructions, showing that limits in Sh(L) are simply computed as limits in Psh(L), but colimits require an extra "sheafification" step.

Deconstructing the Cartesian Closed Structure: We will formalize the construction of the exponential object G^F in Sh(L), showing it is the sheafification of a presheaf-level internal Hom.

Deconstructing the Subobject Classifier: We will formalize the mechanism of classification itself: the "characteristic map" χ associated with any subsheaf, and the universal pullback property it satisfies, which is the defining feature of Ω.
*)

(* ========================================================================================================== )
( == Part 2A: Deconstructing Completeness and Cocompleteness == )
( ========================================================================================================== )

PresheafCategory ::= "Psh" "(" LocaleDeclaration ")" ;
TYPING
(* The category of all presheaves on L. This is our 'ambient' well-behaved universe. *)
Γ ⊢ L : LOCALE

Γ ⊢ Psh(L) : Category (specifically, [Frame(L)^op, Set]) ;
CATEGORY
[[ Psh(L) ]] = "The category of presheaves on L. This category is a Grothendieck topos and is complete, cocomplete, and Cartesian closed. Its (co)limits are computed 'pointwise'." ;

LimitInSheafCategory ::= "Limit_Sh" "(" DiagramDeclaration ")" ;
TYPING
(* Limits in Sh(L) are computed "as in Psh(L)". The limit of a diagram of sheaves is already a sheaf. *)
Γ ⊢ D : Diagram(J, Sh(L))
Let D_psh be D viewed as a diagram in Psh(L).
Limit_in_Psh := The pointwise limit of D_psh.

Γ ⊢ Limit_Sh(D) : SHEAF on L (where Limit_Sh(D) == Limit_in_Psh) ;
CATEGORY
[[ Limit_Sh(D) ]] = "The assertion that the category of sheaves is a complete category. The limit of any diagram of sheaves is computed by taking the limit of the underlying presheaves, and the resulting presheaf is automatically a sheaf. This means the inclusion functor i: Sh(L) ↪ Psh(L) creates limits." ;

ColimitInSheafCategory ::= "Colimit_Sh" "(" DiagramDeclaration ")" ;
TYPING
(* Colimits in Sh(L) are computed by taking the colimit in Psh(L) and then applying the sheafification functor. *)
Γ ⊢ D : Diagram(J, Sh(L))
Let D_psh be D viewed as a diagram in Psh(L).
Colimit_in_Psh := The pointwise colimit of D_psh.

Γ ⊢ Colimit_Sh(D) : SHEAF on L (defined as Sheafify(Colimit_in_Psh)) ;
CATEGORY
[[ Colimit_Sh(D) ]] = "The assertion that the category of sheaves is a cocomplete category. The colimit of a diagram of sheaves is the sheafification of the colimit of the underlying presheaves. This is a direct consequence of the sheafification functor a being the left adjoint to the inclusion functor i." ;

(* ========================================================================================================== )
( == Part 2B: Deconstructing the Cartesian Closed Structure == )
( ========================================================================================================== )

InternalHomPresheaf ::= "PshHom" "(" PresheafOnLocale "," PresheafOnLocale ")" ;
TYPING
(* This constructs the internal Hom at the presheaf level. *)
Γ ⊢ F, G : PRESHEAF on L
Let Frm_L = Frame(L).
ActionOnObjects(U ∈ Frm_L): PshHom(F,G)(U) := Hom_{Psh(L/U)}( F|_U, G|_U )
(The set of natural transformations between the restrictions of F and G to the sub-locale U)

Γ ⊢ PshHom(F,G) : PRESHEAF on L ;
CATEGORY
[[ PshHom(F,G) ]] = "The internal hom-object in the category of presheaves. For any open U, a section of this presheaf is a natural transformation between the restrictions of F and G to U. This object makes Psh(L) Cartesian closed." ;

ExponentialObject_Sheaf ::= SHEAF Identifier "^" SHEAF Identifier ;
TYPING
(* The exponential object in Sh(L) is the sheafification of the presheaf-level internal hom. *)
Γ ⊢ F, G : SHEAF on L
Psh_Exp := PshHom(F, G)

Γ ⊢ G^F : SHEAF on L (defined as Sheafify(Psh_Exp)) ;
CATEGORY
[[ G^F ]] = "The exponential object, or internal hom, in the category of sheaves. It is the sheaf representing the 'sheaf of morphisms' from F to G. Its existence is what makes Sh(L) a Cartesian Closed Category (CCC)." ;

(* ========================================================================================================== )
( == Part 2C: Deconstructing the Subobject Classifier == )
( ========================================================================================================== )

CharacteristicMapConstructor ::= "χ_" "(" MonomorphismDeclaration ")" ;
TYPING
(*

For any subsheaf S of F (represented by a mono m:S↪F), this constructs its characteristic map χ_m: F → Ω.

The map is a natural transformation whose component at an open U is a function χ_m_U: F(U) → Ω(U).
*)
Γ ⊢ m : S ↪ F is MONOMORPHISM in Sh(L)
-- Define the component map χ_m_U : F(U) → Ω(U) --
ActionOnObjects(s ∈ F(U)):
χ_m_U(s) := Join( {V ⊆ U | the restriction of s to V factors through S} )

Γ ⊢ χ_m : NaturalTransformation(F, Ω) ;
CATEGORY
[[ χ_m ]] = "The characteristic map of the subsheaf S. For a given local section s of F over U, this map returns the largest sub-open of U on which s actually belongs to the subsheaf S. It is a map that measures 'the extent to which a section is in the subsheaf'." ;

SubobjectClassifierAxiom ::= "AXIOM" "ClassificationPullback" "for" "(" MonomorphismDeclaration ")" ;
TYPING
(*

This is the universal property of the subobject classifier. It asserts that for any subsheaf S↪F,

the square formed by its characteristic map χ_m and the global 'true' section is a pullback square.
*)
Γ ⊢ m : S ↪ F is MONOMORPHISM in Sh(L)
Let t : 1 → Ω be the terminal sheaf's map to Ω ("true").
Let ! : S → 1 be the unique map to the terminal sheaf.

Γ ⊢ AXIOM ... is TRUE if (the square with corners S, F, 1, Ω and maps m, χ_m, !, t is a PULLBACK) ;
CATEGORY
[[ AXIOM "ClassificationPullback" for m ]] = "The formal statement of the universal property of the subobject classifier. It asserts that the subsheaf S can be perfectly recovered as the pullback of the 'generic subobject' (the true map) along the characteristic map χ_m. This means S is precisely the 'locus of truth' for the predicate χ_m." ;
}


(* ========================================================================================================== )
( == Section 2.4-2.5: Etale Spaces and Stalks == )
( ========================================================================================================== )
(*
ELABORATION: These sections provide an alternative, more geometric perspective on sheaves. The main result
is that the category of sheaves on a (sober) space X is equivalent to the category of "etale spaces" over X.
An etale space is a bundle that is locally a homeomorphism, and the connection is made via the concept of "stalks".
A deep elaboration requires formalizing this entire equivalence by defining the geometric world, the
algebraic-to-geometric bridge (stalks and the total space construction), the geometric-to-algebraic bridge
(the sheaf of sections), and the final equivalence theorem itself.
*)

MorphismPropertyAssertion ::= Identifier "is" "LOCAL_HOMEOMORPHISM" ;
TYPING
(*
* This rule formalizes the point-set definition of a local homeomorphism. A map p is a
* local homeomorphism if for every point in the domain, there is an open neighborhood
* that is mapped homeomorphically onto an open neighborhood in the codomain.
*)
Γ ⊢ p : Morphism(E, X) in Top
Condition := ∀ e ∈ E, ∃ (U ⊆ E is an open neighborhood of e) s.t.
( (p(U) is open in X) ∧ (the restriction p|_U : U → p(U) is a HOMEOMORPHISM) )
--------------------------------------------------------------------------------------------------
Γ ⊢ p is LOCAL_HOMEOMORPHISM is TRUE if Condition holds ;
CATEGORY
[[ p is LOCAL_HOMEOMORPHISM ]] = "The property of a map being 'locally an isomorphism'. It is a fundamental concept in differential geometry (defining covering spaces and manifolds) and topology, ensuring that the local topological structure is preserved." ;

EtaleSpaceOver ::= "ETALE_SPACE" Identifier "over" Identifier ;
TYPING
(* This is the refined definition of an etale space, now explicitly based on the property of being a local homeomorphism. *)
Γ ⊢ E, X : Object_in(Top)
Γ ⊢ p : Morphism(E, X)
Premise: Γ ⊢ p is LOCAL_HOMEOMORPHISM
--------------------------------------------------
Γ ⊢ ETALE_SPACE p over X is a valid declaration ;
CATEGORY
[[ ETALE_SPACE p over X ]] = "A space E that is 'spread out' over a base space X in a locally trivial way. The fibres of this map (the preimages of points) are discrete sets. An etale space is the geometric object that corresponds to a sheaf." ;

CategoryOfEtaleSpaces ::= "Etale" "(" Identifier ")" ;
TYPING
(*
* This defines the a category Etale(X) of all etale spaces over a fixed base space X.
* The morphisms are required to respect the projection maps to the base.
*)
Γ ⊢ X : Object_in(Top)
Objects(Etale(X)) := { p | Γ ⊢ p is ETALE_SPACE over X }
Morphisms(Etale(X)) from (p₁:E₁→X) to (p₂:E₂→X) :=
{ f : Morphism(E₁, E₂) in Top | the diagram (E₁ --f--> E₂ --p₂--> X) equals (E₁ --p₁--> X) }
--------------------------------------------------------------------------------------------------
Γ ⊢ Etale(X) : Category ;
CATEGORY
[[ Etale(X) ]] = "The category of etale spaces over X. This is the 'geometric side' of the Sheaf-Etale equivalence. It is the full subcategory of the slice category Top/X whose objects are the local homeomorphisms." ;

(* ========================================================================================================== )
( == Elaborated Section 2.4-2.5, Part 2: The Bridge Between Worlds (Stalks and Sections) == )
( ========================================================================================================== )
(*
ELABORATION (Deeper Dive): This elaboration focuses exclusively on the bridge constructions. We will
deconstruct the definitions of Stalk, TotalEtaleSpace, and SheafOfSections to reveal the precise
machinery that translates between the algebraic world of sheaves and the geometric world of etale spaces.
This involves formalizing the inputs, the universal properties, and the key theorems that justify why
these constructions work.
*)

(* ========================================================================================================== )
( == Part 2a: The Algebraic-to-Geometric Bridge (Stalks → Total Space) == )
( ========================================================================================================== )
(This construction takes an algebraic presheaf and builds its geometric counterpart, the etale space.)

Diagram_of_Neighborhoods ::= "DIAGRAM_Neighborhoods" "(" PointDeclaration ")" ;
TYPING
(*

This formalizes the initial data for the stalk construction. For a point p, its open

neighborhoods form a directed set (ordered by reverse inclusion), which gives rise to a

diagram in the category Set via the presheaf.
*)
Γ ⊢ L : LOCALE, Γ ⊢ p : PointOf(L)
Γ ⊢ F : PRESHEAF on L
Neighborhoods_p := { U ∈ Frame(L) | p is in U }, ordered by ⊇.

Γ ⊢ DIAGRAM_Neighborhoods(p) : Diagram(Neighborhoods_p^op, Set) (defined by restricting F) ;
CATEGORY
[[ DIAGRAM_Neighborhoods(p) ]] = "The directed system of sections of the presheaf F over the open neighborhoods of the point p. The colimit of this diagram gathers all the information about F 'in the vicinity' of p." ;

GermOfAPresheaf ::= "Germ" "(" PresheafOnLocale "," PointDeclaration "," ElementDeclaration ")" ;
TYPING
(*

A germ is an element of the stalk. It is formally an equivalence class of sections defined

on neighborhoods of the point, where two sections are equivalent if they agree on some smaller neighborhood.

A colimit is precisely the set of these equivalence classes.
*)
Context: Let S = Stalk(F, p) = Colimit(DIAGRAM_Neighborhoods(p))
Γ ⊢ s_U : ElementOf(F(U)) for some neighborhood U of p.

Γ ⊢ Germ(F, p, s_U) : ElementOf(S) ;
CATEGORY
[[ Germ(F, p, s_U) ]] = "A germ of the section s_U at the point p. It represents the 'infinitesimal value' of the presheaf at p, abstracting away from the specific open set on which the representative section was defined." ;

StalkConstructor ::= "Stalk" "(" PresheafOnLocale "," PointDeclaration ")" ;
TYPING
(* The refined definition of the stalk as the set of all germs. *)
Γ ⊢ F : PRESHEAF on L, Γ ⊢ p : PointOf(L)

Γ ⊢ Stalk(F,p) : Set (defined as { g | g is a GermOfAPresheaf at p }) ;
CATEGORY
[[ Stalk(F, p) ]] = "The set of 'germs' of the presheaf F at the point p, constructed as the colimit over the directed system of sections on ever-smaller neighborhoods of p. This object captures the local behavior of the presheaf at a specific point." ;

BasicOpen_in_EtaleSpace ::= "OpenSection" "(" PresheafOnLocale "," ElementDeclaration ")" ;
TYPING
(*

This defines the basic open sets that form the topology on the total space of stalks.

For any section s on an open set U of the base space, there is a corresponding open set

in the total space, consisting of all the germs of s.
*)
Γ ⊢ F : PRESHEAF on L
Let X = pt(L). U ∈ Open(X).
Γ ⊢ s : ElementOf(F(U))

Γ ⊢ OpenSection(F, s) : Subset of TotalSpaceOfStalks(F) (defined as { Germ(F, p, s) | p ∈ U }) ;
CATEGORY
[[ OpenSection(F, s) ]] = "The basic open set in the etale space topology corresponding to the section s. The collection of all such sets forms a basis for the topology of the total space E." ;

TotalSpaceOfStalks ::= "TotalEtaleSpace" "(" PresheafOnLocale ")" ;
TYPING
(* The refined definition, making the topology explicit. *)
Γ ⊢ F : PRESHEAF on L
Let X = pt(L).
UnderlyingSet_E := ∐_{x∈X} Stalk(F,x)
Topology_on_E := The topology generated by the basis { B | B is a BasicOpen_in_EtaleSpace for F }
ProjectionMap_p(s ∈ Stalk(F,x)) := x

Γ ⊢ TotalEtaleSpace(F) : TopologicalSpace (E, Topology_on_E) with projection p ;
CATEGORY
[[ TotalEtaleSpace(F) ]] = "The geometric realization of a presheaf F. The underlying set is the disjoint union of all stalks, and it is given the unique topology (the 'sheaf topology') that makes the projection map to the base space a local homeomorphism. This is the functor from the algebraic world to the geometric world." ;

(* ========================================================================================================== )
( == Part 2b: The Geometric-to-Algebraic Bridge (Sections) == )
( ========================================================================================================== )
(This construction takes a geometric etale space and extracts its algebraic sheaf of sections.)

ContinuousSection ::= "SECTION" Identifier "of" EtaleSpaceOver "over" Identifier ;
TYPING
(* A section 's' of an etale space p:E→X over an open set U is a continuous map that is a right-inverse to the projection. *)
Γ ⊢ p : ETALE_SPACE E over X
Γ ⊢ U : OpenSubset of X

Γ ⊢ SECTION s of p over U is valid if (s: U→E is Continuous ∧ p∘s == inclusion_of_U_in_X) ;
CATEGORY
[[ SECTION s of p over U ]] = "A continuous choice of a point in the fibre above each point of U. These are the fundamental 'local data' of the geometric object." ;

SheafOfSectionsFunctor ::= "Γ" "(" EtaleSpaceOver ")" ;
TYPING
(* The refined definition of the functor of sections. *)
Γ ⊢ p : ETALE_SPACE E over X
-- Define the presheaf P_Γ --
ActionOnObjects(U ∈ Open(X)):
P_Γ(U) := { s | Γ ⊢ SECTION s of p over U is valid }
ActionOnMorphisms (Restriction):
P_Γ(incl_{UV}) is the function that restricts a section over U to the smaller open set V.

Γ ⊢ Γ(p) : SHEAF on X (defined by the presheaf P_Γ) ;
CATEGORY
[[ Γ(p) ]] = "The sheaf of continuous sections of the etale space p. It translates the geometric structure of the bundle p into the algebraic language of sheaves. The non-trivial fact that this presheaf of sections is always a sheaf is the key to the equivalence." ;

TheoremDeclaration ::= "THEOREM" "SectionsOfEtaleSpaceFormASheaf" ":"
"The presheaf of continuous sections of any etale space is a sheaf." ;
TYPING
Let P_Γ be the presheaf of sections for an etale space p.

Γ ⊢ AXIOM SheafGluingCondition holds_for P_Γ : ProvableProposition ;
CATEGORY
[[ THEOREM "SectionsOfEtaleSpaceFormASheaf" ]] = "The assertion that the geometric structure of a local homeomorphism is precisely what is needed to guarantee that its presheaf of sections satisfies the algebraic gluing axiom. The local homeomorphism property allows patches of sections that agree on overlaps to be uniquely glued into a larger continuous section." ;

(* ========================================================================================================== )
( == Part 3: The Main Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "SheafEtaleEquivalence" ":"
"The category of sheaves on a sober space X is equivalent to the category of etale spaces over X." ;
TYPING
Let X be a SOBER_SPACE. Let L = Ω(X).
Let Sh_X := Sh(L)
Let Etale_X := the category of etale spaces over X.
F_stalks : Sh_X → Etale_X (defined by TotalEtaleSpace)
G_sections : Etale_X → Sh_X (defined by SheafOfSectionsFunctor)

Γ ⊢ F_stalks and G_sections form an EquivalenceOfCategories ;
CATEGORY
[[ THEOREM "SheafEtaleEquivalence" ]] = "A fundamental result that provides a powerful geometric intuition for the abstract notion of a sheaf. It asserts that to give a sheaf on a space is the same as to give a space 'spread out' over it in a locally trivial way. This equivalence is the foundation for many constructions in algebraic geometry and topology." ;


(* ========================================================================================================== )
( == Section 2.6: Associated sheaves and etale morphisms == )
( ========================================================================================================== )
(*
ELABORATION: This section brings together several powerful concepts from both Chapter 1 (Locales) and Chapter 2 (Sheaves).
The goal is to understand how a special type of map between "spaces" (an etale locale morphism) behaves
with respect to their associated categories of sheaves.

The main result is profound: an etale morphism f: L → M is a "local isomorphism" in such a strong sense
that it induces an equivalence between the entire categories of sheaves, Sh(L) ≅ Sh(M). This means that from the
perspective of sheaf theory, the two locales are indistinguishable.

Our elaboration will proceed by:

Formalizing the Bridge (The Change of Base Functors): We will first formalize the functors that a locale
morphism f: L → M induces between the sheaf categories. These are the "direct image" functor f_* (pushforward)
and the "inverse image" functor f* (pullback). We will state their fundamental adjunctional relationship: f* ⊣ f_*.

Revisiting the Associated Sheaf: We will briefly restate the sheafification functor a, as the inverse image
functor f* is constructed using it. This is the "associated sheaf" part of the section title.

Stating the Main Equivalence Theorem: We will then state the central theorem: if the locale morphism f is
additionally "etale" (the localic version of a local homeomorphism), then the adjunction between the sheaf
categories is not just an adjunction, but an equivalence of categories. This is the primary result.
*)

(* ========================================================================================================== )
( == Part 1: The Bridge Functors for Sheaves on Locales == )
( ========================================================================================================== )
(A morphism of locales f: L → M induces a pair of adjoint functors between their sheaf categories.)

DirectImageFunctor_Locale ::= Identifier "_" ;
TYPING
(

This constructor takes a locale morphism f: L → M and produces the direct image functor f_*: Sh(L) → Sh(M).

The locale morphism f corresponds to a frame homomorphism g: Frame(M) → Frame(L).

This functor is defined by pre-composition on the underlying presheaves.
*)
Γ ⊢ f : LocaleMorphism(from:L, to:M)
Let g: Frame(M) → Frame(L) be the corresponding frame homomorphism.
ActionOnObjects( F : SHEAF on L ):
-- The direct image presheaf P(U) for U∈Frame(M) is defined as F(g(U)).
-- This presheaf can be shown to already be a sheaf.
f_*F(U) := F(g(U))

Γ ⊢ f_* : Functor(Sh(L), Sh(M)) ;
CATEGORY
[[ f_* ]] = "The direct image functor (or pushforward). It takes a sheaf on the 'domain' locale L and views it as a sheaf on the 'codomain' locale M. For an open U in M, the sections of f_*F are simply the sections of F over the corresponding open g(U) in L." ;

InverseImageFunctor_Locale ::= Identifier "" ;
TYPING
(

This constructor defines the inverse image functor f*: Sh(M) → Sh(L).

Its construction is more complex and requires sheafification (the 'associated sheaf').
)
Γ ⊢ f : LocaleMorphism(from:L, to:M)
Let g: Frame(M) → Frame(L) be the corresponding frame homomorphism.
ActionOnObjects( G : SHEAF on M ):
-- First, define a presheaf P on L by P(V) := colim_{U s.t. V≤g(U)} G(U).
-- The inverse image sheaf is the sheafification of this presheaf.
fG := Sheafify(P)

Γ ⊢ f* : Functor(Sh(M), Sh(L)) ;
CATEGORY
[[ f* ]] = "The inverse image functor (or pullback). It takes a sheaf on M and pulls it back to a sheaf on L. The stalk of the resulting sheaf f*G at a point p of L is isomorphic to the stalk of G at the point f(p) of M. This is the correct categorical way to 'restrict' a sheaf along a map." ;

TheoremDeclaration ::= "THEOREM" "LocaleChangeOfBaseAdjunction" ":"
"For any locale morphism f, the inverse image functor f* is left adjoint to the direct image functor f_*." ;
TYPING
Context: Γ ⊢ f : LocaleMorphism(L, M)
Let f_star_inv := InverseImageFunctor(f) : Sh(M) → Sh(L)
Let f_star_dir := DirectImageFunctor_Locale(f) : Sh(L) → Sh(M)

Γ ⊢ f_star_inv ⊣ f_star_dir : Adjunction(Sh(M), Sh(L)) ;
CATEGORY
[[ THEOREM "LocaleChangeOfBaseAdjunction" ]] = "A fundamental adjunction in sheaf theory on locales. The natural isomorphism is Hom_{Sh(L)}(f*G, F) ≅ Hom_{Sh(M)}(G, f_*F). This adjunction is the foundation for relating sheaf-theoretic constructions on different locales." ;

(* ========================================================================================================== )
( == Part 2: The Main Equivalence Theorem for Etale Morphisms == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "EtaleMorphismInducesSheafEquivalence" ":"
"If f: L → M is an ETALE locale morphism, then the inverse image functor f*: Sh(M) → Sh(L) is an equivalence of categories." ;
TYPING
(*

This is the central result of the section. It connects the geometric property of the locale morphism

with a very strong categorical property of the induced functor between sheaf topoi.
*)
Premise: Γ ⊢ f : ETALE LocaleMorphism(from:L, to:M)
Let f_star := InverseImageFunctor_Locale(f) : Sh(M) → Sh(L)

Conclusion: Γ ⊢ f_star is an EquivalenceOfCategories : MetaTheorem ;
CATEGORY
[[ THEOREM "EtaleMorphismInducesSheafEquivalence" ]] = "The assertion that an etale morphism of locales is a 'sheaf-theoretic isomorphism'. An etale map is the point-free analogue of a local homeomorphism, a map that makes L look locally identical to M. The theorem confirms this intuition in the strongest possible way: the categories of sheaves on L and M, which encode all the 'local data' on the spaces, are structurally identical. This means that from the point of view of the topos of sheaves, an etale morphism is an isomorphism." ;
}


(* ========================================================================================================== )
( == Section 2.7-2.9: Internal Logic, Ω-sets, and Completeness == )
( ========================================================================================================== )
(*
ELABORATION: These advanced sections explore the deep connection between the category of sheaves on a locale,
Sh(L), and its rich internal logic. A sheaf topos is not just a category; it is a mathematical universe where
one can do a form of set theory. In this universe, the role of the two-element set of truth values {true, false}
is played by the subobject classifier Ω (which for Sh(L) is the frame of the locale itself).

The central insight is that sheaves can be completely described from a "set-theoretic" perspective that is
internal to the topos. The key object in this internal view is the "Ω-set"—a set equipped with an explicit,
Ω-valued equality relation. The main theorem then shows that sheaves correspond precisely to the "complete"
Ω-sets, which are those that are saturated with "elements."

This elaboration will deconstruct this profound correspondence by:

Formalizing the Internal Set (The Ω-set): We will formally define an Ω-set as a pair consisting
of a classical set of "global elements" and a function that defines a "truth-value of equality" for
any two elements, where the truth values come from the frame Ω. We will formalize the axioms
(reflexivity, symmetry, transitivity) that this equality predicate must satisfy.

Formalizing the Notion of Completeness: We will then define what it means for an Ω-set to be
"complete." This is a saturation property, ensuring that the set of global elements is rich enough to
represent all possible "ideal elements" (characters) definable within the internal logic.

Stating the Main Equivalence Theorem: Finally, we will state the fundamental representation theorem:
the category of sheaves on a locale L is equivalent to the category of complete Ω-sets, where Ω is
the frame of L. This provides a powerful dictionary for translating between the external, categorical
view of sheaves and the internal, logical/set-theoretic view.
*)

(* ========================================================================================================== )
( == Elaborated Section 2.7-2.9, Part 1: The Internal Set (The Ω-set) == )
( ========================================================================================================== )
(*
ELABORATION (Deeper Dive): This elaboration focuses exclusively on the formal structure of the "Ω-set".
The previous summary introduced the concept; this deep dive deconstructs it into its finest constituent
parts, separating the raw DATA from the AXIOMS it must satisfy. This makes the analogy to classical
algebraic structures (like a group, which is data of a set and an operation, plus axioms) perfectly explicit.

Furthermore, a complete understanding requires defining not just the objects, but the structure-preserving
maps between them. Therefore, this elaboration will also formalize the "Ω-set Homomorphism" and culminate in
the definition of the "Category of Ω-sets".
*)

(* ========================================================================================================== )
( == Step 1: The Data of an Ω-set == )
( ========================================================================================================== )

OmegaSetData ::= "DATA_OmegaSet" "(" "Elements" ":" Identifier "," "Equality" ":" Identifier ")" ;
TYPING
(*

This rule declares the raw data of an Ω-set, before any laws are imposed. It is a pair (X, δ).

X is a standard, classical set of "global elements".

δ is a function assigning a "truth value" from the frame F (our Ω) to each pair of elements.
*)
Let L be a LOCALE, and F = Frame(L) be its frame (our Ω).
Γ ⊢ X : Set
Γ ⊢ δ : Function(X × X, Carrier(F))

Γ ⊢ DATA_OmegaSet (Elements:X, Equality:δ) : OmegaSetData_Type ;
CATEGORY
[[ DATA_OmegaSet (X, δ) ]] = "The raw data for an internal set. X is the set of global points or constants of the set, and δ is a candidate for its F-valued equality predicate." ;

(* ========================================================================================================== )
( == Step 2: The Axioms for the Equality Predicate == )
( ========================================================================================================== )
(These axioms ensure the equality predicate δ behaves like a true, intuitionistic equality.)

OmegaSet_ReflexivityAxiom ::= "AXIOM" "Reflexivity" "for" OmegaSetData ;
TYPING
(* This axiom asserts that for any element x, the truth value of "x equals x" is maximal truth (1_F). *)
Context: Γ ⊢ data=(X,δ) : OmegaSetData_Type
Condition := ∀x ∈ X, δ(x,x) == TopElement(FrameOf(data))

Γ ⊢ AXIOM Reflexivity for data is TRUE if Condition holds ;
CATEGORY
[[ AXIOM Reflexivity ... ]] = "The internal logic axiom asserting ∀x. x=x. It ensures the F-valued equality is reflexive." ;

OmegaSet_SymmetryAxiom ::= "AXIOM" "Symmetry" "for" OmegaSetData ;
TYPING
(* This axiom asserts that the truth value of "x equals y" is the same as "y equals x". *)
Context: Γ ⊢ data=(X,δ) : OmegaSetData_Type
Condition := ∀x,y ∈ X, δ(x,y) == δ(y,x)

Γ ⊢ AXIOM Symmetry for data is TRUE if Condition holds ;
CATEGORY
[[ AXIOM Symmetry ... ]] = "The internal logic axiom asserting ∀x,y. (x=y → y=x). It ensures the F-valued equality is symmetric." ;

OmegaSet_TransitivityAxiom ::= "AXIOM" "Transitivity" "for" OmegaSetData ;
TYPING
(* This axiom asserts that the truth value of "x equals z" is at least as true as "x equals y AND y equals z". *)
Context: Γ ⊢ data=(X,δ) : OmegaSetData_Type
Condition := ∀x,y,z ∈ X, (δ(x,y) ∧ δ(y,z)) ≤ δ(x,z)

Γ ⊢ AXIOM Transitivity for data is TRUE if Condition holds ;
CATEGORY
[[ AXIOM Transitivity ... ]] = "The internal logic axiom asserting ∀x,y,z. (x=y ∧ y=z → x=z). It ensures the F-valued equality is transitive. The use of ≤ instead of == is characteristic of the intuitionistic setting." ;

(* ========================================================================================================== )
( == Step 3: The Assembled Definition and its Morphisms == )
( ========================================================================================================== )

OmegaSetDeclaration_Verified ::= "OMEGA_SET" Identifier "is" "{" "Data" ":" OmegaSetData ";" "Verification" ":" "{" OmegaSet_ReflexivityAxiom ";" OmegaSet_SymmetryAxiom ";" OmegaSet_TransitivityAxiom "}" "}" ;
TYPING
(* The refined master definition, explicitly separating the data from the axiomatic verification. *)
Γ ⊢ data : OmegaSetData_Type
Γ ⊢ AXIOM Reflexivity for data is TRUE
Γ ⊢ AXIOM Symmetry for data is TRUE
Γ ⊢ AXIOM Transitivity for data is TRUE

Γ ⊢ OMEGA_SET S ... : OmegaSet_Object ;
CATEGORY
[[ OMEGA_SET S ... ]] = "A verified Ω-set. This structure combines the raw data with the proof that this data satisfies the coherence laws required for an internal, F-valued equivalence relation. It is a fully-formed object in the category of Ω-sets." ;

OmegaSetHomomorphism ::= "OMEGA_HOMOMORPHISM" Identifier ":" OmegaSetDeclaration_Verified "→" OmegaSetDeclaration_Verified ;
TYPING
(*

A morphism between two Ω-sets (X, δ_X) and (Y, δ_Y) is a function f:X→Y on the underlying sets

that "respects" the Ω-valued equality. This is formalized by the inequality below.
*)
Γ ⊢ S_X=(X,δ_X), S_Y=(Y,δ_Y) : OmegaSet_Object
Γ ⊢ f : Function(X, Y)
Condition_RespectsEquality: ∀x₁,x₂ ∈ X, ( δ_X(x₁, x₂) ≤ δ_Y(f(x₁), f(x₂)) )

Γ ⊢ OMEGA_HOMOMORPHISM f ... is a valid declaration if Condition_RespectsEquality holds ;
CATEGORY
[[ OMEGA_HOMOMORPHISM f ... ]] = "A structure-preserving map between Ω-sets. The condition δ_X(x, x') ≤ δ_Y(f(x), f(x')) is the internal version of the statement x=x' → f(x)=f(x'). It ensures that if two elements are considered 'equal' to some degree in the domain, their images must be considered 'equal' to at least that same degree in the codomain." ;

Category_of_OmegaSets ::= "Category_OmegaSet" "(" FrameDeclaration ")" ;
TYPING
(* This rule assembles the previous definitions into the full category. *)
Γ ⊢ F : FRAME
Objects := { S | Γ ⊢ S : OMEGA_SET_Verified with respect to F }
Morphisms := { f | Γ ⊢ f : OMEGA_HOMOMORPHISM between objects in this category }

Γ ⊢ Category_OmegaSet(F) : Category ;
CATEGORY
[[ Category_OmegaSet(F) ]] = "The category of F-sets, denoted F-Set. This is the category that provides the internal, set-theoretic perspective on the topos of sheaves Sh(L), where F is the frame of the locale L. The main theorem of the next sections is that the subcategory of complete F-sets is equivalent to Sh(L)." ;

(* ========================================================================================================== )
( == Elaborated Section 2.7-2.9, Part 2: The Main Equivalence Theorem (Sheaves as Complete Ω-Sets) == )
( ========================================================================================================== )
(*
ELABORATION (Deeper Dive): The statement that Sh(L) is equivalent to the category of complete Ω-sets is profound.
A deep elaboration requires us to formalize the very functors that establish this equivalence. This process
reveals how the components of a sheaf (its sections, restriction maps) are translated into the components of an
Ω-set (its global elements, equality predicate), and vice-versa.

This elaboration will deconstruct the equivalence into three parts:

Formalizing the First Functor (Sheaf → Ω-Set): We will define the functor A that takes a sheaf and
constructs its corresponding complete Ω-set. We will specify precisely how the set of "global elements"
and the "equality predicate" are derived from the sheaf's structure.

Formalizing the Second Functor (Ω-Set → Sheaf): We will define the functor S that takes a complete
Ω-set and constructs its corresponding sheaf. We will specify how the "sections over an open" and the
"restriction maps" are derived from the Ω-set's internal logic.

Stating the Refined Equivalence: We will re-state the main theorem, asserting that these two
explicitly constructed functors, A and S, are quasi-inverses and thus witness the equivalence
of the two categories.
*)

(* ========================================================================================================== )
( == Part 2a: The Functor from Sheaves to Ω-Sets == )
( ========================================================================================================== )

Functor_SheafToOmegaSet ::= "Functor_A" ":" "Sh(" LocaleDeclaration ")" "→" "Category_CompleteOmegaSet" "(" FrameDeclaration ")" ;
TYPING
(*

This rule defines the functor A that translates from the categorical world of sheaves to the internal,

set-theoretic world of Ω-sets. We must define its action on objects and morphisms.
*)
-- Action on Objects --
Given a SHEAF F on L (with frame Ω_L):

The set of "global elements" X is defined as the set of sections over the top element: X := F(1).

The Ω-valued "equality predicate" δ: X×X → Ω_L is defined by the "equalizer object" in the frame.
For any two global sections s₁, s₂ ∈ F(1), δ(s₁, s₂) is the largest open U on which they agree:
δ(s₁, s₂) := ⋁{ U ∈ Ω_L | s₁|_U == s₂|_U in F(U) }.

It is a non-trivial theorem that the resulting Ω-set A(F) = (X, δ) is always COMPLETE.

-- Action on Morphisms --
Given a morphism α: F₁ → F₂ (a natural transformation), the corresponding Ω-homomorphism
f: A(F₁) → A(F₂) is the component of α at the top element:
f := α_1 : F₁(1) → F₂(1).
(This function can be proven to be an Ω-homomorphism).

Γ ⊢ Functor_A ... is a well-defined Functor ;
CATEGORY
[[ Functor_A ]] = "The functor that takes a sheaf and extracts its 'internal set' representation. It interprets the global sections of the sheaf as the 'elements' of the set and defines their intuitionistic equality based on the extent to which they agree locally. This functor provides the translation from the external, categorical perspective to the internal, logical one." ;

(* ========================================================================================================== )
( == Part 2b: The Functor from Ω-Sets to Sheaves == )
( ========================================================================================================== )

Functor_OmegaSetToSheaf ::= "Functor_S" ":" "Category_CompleteOmegaSet" "(" FrameDeclaration ")" "→" "Sh(" LocaleDeclaration ")" ;
TYPING
(*

This rule defines the functor S that translates from the internal, set-theoretic world of complete Ω-sets

back to the categorical world of sheaves. We must define its action on objects and morphisms.
*)
-- Action on Objects --
Given a COMPLETE OMEGA_SET (X, δ) with respect to frame Ω_L:

We construct a presheaf P_(X,δ). The sections over an open U ∈ Ω_L are "U-elements", defined as
maps s: X → Ω_L that satisfy two internal logic axioms:
(i) s(x) ≤ U (s is supported on U)
(ii) s(x) ∧ δ(x,y) ≤ s(y) (s respects the equality)
P_(X,δ)(U) := { s: X→Ω_L | s is a U-element }.

The restriction maps are inclusions.

The completeness of the Ω-set (X,δ) is precisely the condition needed to prove that this
presheaf P_(X,δ) is in fact a SHEAF.
S((X,δ)) := P_(X,δ).

-- Action on Morphisms --
Given an Ω-homomorphism f: (X₁,δ₁) → (X₂,δ₂), the corresponding sheaf morphism (natural transformation)
α: S((X₁,δ₁)) → S((X₂,δ₂)) is given by pre-composition.
The component at U, α_U : S((X₁,δ₁))(U) → S((X₂,δ₂))(U), maps a section s:X₁→Ω_L to the composite s∘f.

Γ ⊢ Functor_S ... is a well-defined Functor ;
CATEGORY
[[ Functor_S ]] = "The functor that takes an internal, complete Ω-set and constructs its external, categorical representation as a sheaf. It interprets a 'U-element' of the internal set as a 'section over U' of the sheaf. The completeness of the Ω-set is the crucial ingredient that guarantees the resulting presheaf of sections satisfies the sheaf gluing axiom. This functor provides the translation from the internal, logical perspective back to the external, categorical one." ;

(* ========================================================================================================== )
( == Part 2c: The Refined Equivalence Theorem == )
( ========================================================================================================== )

TheoremDeclaration ::= "THEOREM" "SheavesAreCompleteOmegaSets_Refined" ":"
"The functors Functor_A and Functor_S are quasi-inverses, establishing an equivalence of categories between Sh(L) and the category of complete Ω-sets." ;
TYPING
Let L be a LOCALE with Frame Ω_L.
Let Sh_L := Sh(L).
Let CΩSet_L := the category of complete Ω-sets for Ω_L.
Let A := Functor_SheafToOmegaSet : Sh_L → CΩSet_L.
Let S := Functor_OmegaSetToSheaf : CΩSet_L → Sh_L.

Γ ⊢ (S ∘ A ≅ Id_{Sh_L}) ∧ (A ∘ S ≅ Id_{CΩSet_L}) : ProvableIsomorphism ;
CATEGORY
[[ THEOREM "SheavesAreCompleteOmegaSets_Refined" ]] = "The assertion that the explicitly constructed functors A and S provide a perfect, invertible dictionary between the world of sheaves and the world of complete internal sets. This refined theorem does not just state that an equivalence exists, but exhibits the very machinery that creates it, providing a fully constructive account of the profound connection between the external category theory and the internal logic of a topos." ;

(* ========================================================================================================== )
( == Section 2.10: Basic facts in ring theory (Context for Sheaves of Modules) == )
( ========================================================================================================== )

SheafOfRings ::= "SHEAF_OF_RINGS" Identifier "on" LocaleDeclaration ;
TYPING
(* A sheaf of rings is a sheaf whose values are rings and whose restriction maps are ring homomorphisms. *)
Γ ⊢ O : SHEAF on L
Condition: ∀(a∈Frame(L)), O(a) is a Ring, and ∀(b≤a), the restriction O(a)→O(b) is a RingHomomorphism.

Γ ⊢ SHEAF_OF_RINGS O on L is a valid declaration ;
CATEGORY
[[ SHEAF_OF_RINGS O on L ]] = "A 'variable ring' indexed by the opens of a locale. This is the foundational structure for algebraic geometry, where O is the structure sheaf of a scheme." ;

SheafOfOModules ::= "SHEAF_OF" "(" SheafOfRings ")" "-MODULES" Identifier ;
TYPING
(* A sheaf of O-modules is a sheaf M where each section M(a) is a module over the ring O(a). *)
Γ ⊢ O : SHEAF_OF_RINGS on L
Γ ⊢ M : SHEAF on L
Condition: ∀(a∈Frame(L)), M(a) is an O(a)-Module, and restrictions are O-linear.

Γ ⊢ ... is a valid declaration ;
CATEGORY
[[ SHEAF_OF O -MODULES M ]] = "A 'variable module' over a 'variable ring', indexed by the opens of a locale. The category of such sheaves, denoted O-Mod, is the central object of study in modern algebraic geometry." ;

CorollaryDeclaration ::= "COROLLARY" "CategoryOfOModulesIsAbelian" ":"
"If O is a SHEAF_OF_RINGS, then the category of sheaves of O-modules is an ABELIAN_CATEGORY." ;
TYPING
Let O-Mod be the category of sheaves of O-modules.
(This can be proven by checking the abelian category axioms, which hold 'pointwise' at each open set).

Γ ⊢ O-Mod is an ABELIAN_CATEGORY : ProvableProposition ;
CATEGORY
[[ COROLLARY "CategoryOfOModulesIsAbelian" ]] = "The assertion that the category of O-modules inherits the rich abelian structure of the underlying category of modules for each ring O(a). This guarantees that homological algebra can be performed on sheaves of modules, which is the basis for sheaf cohomology." ;
