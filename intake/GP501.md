<!-- Roadmap Reference: This file is represented in the Agda roadmap as `examplePolytopeManifestRoadmap` (see src/agda/Plan/CIM/Utility.agda) -->

### **Project Nedge-Topology: The Polytope Manifest (v4.0)**

This manifest marks the transition from **Fixed Prototypes** to **Dynamic Polytopes**.

It introduces the **Mitosis Engine** (mitosis.py), which monitors the "Topological Tension" of semantic categories. When tension exceeds a critical threshold, the engine **inflates** the category, upgrading it from a single vector (0-simplex) to a Polytope (n-simplex), redistributing its semantic content across new vertices to relieve stress.

***

### **I. Directory Structure**

Plaintext

nedge-topology/   ‚îú‚îÄ‚îÄ pyproject.toml   ‚îú‚îÄ‚îÄ requirements.txt   ‚îú‚îÄ‚îÄ README.md   ‚îú‚îÄ‚îÄ dashboard.py             # \[UPDATED] Visualizes Polytopes & Inflation   ‚îú‚îÄ‚îÄ proofs/   ‚îÇ   ‚îú‚îÄ‚îÄ ... (Previous proofs)   ‚îÇ   ‚îî‚îÄ‚îÄ PolytopeExpansion.agda   ‚îî‚îÄ‚îÄ nedge\_topology/       ‚îú‚îÄ‚îÄ \_\_init\_\_.py          # \[UPDATED] Exports Inflator       ‚îú‚îÄ‚îÄ geometry.py          # Adjoint Engine (SymNum + RoPE)       ‚îú‚îÄ‚îÄ graph.py             # Nodes with Tension State       ‚îú‚îÄ‚îÄ parser.py            # \[UPDATED] Polytope-Aware Gating       ‚îú‚îÄ‚îÄ search.py            # Semantic Search       ‚îú‚îÄ‚îÄ storage.py           # HDF5 Persistence       ‚îú‚îÄ‚îÄ visualizer.py        # Graphviz Exporter       ‚îú‚îÄ‚îÄ induction.py         # Grammar Repair       ‚îú‚îÄ‚îÄ train.py             # Reflexive Trainer       ‚îî‚îÄ‚îÄ mitosis.py           # \[NEW] Topological Inflator

***

### **II. Critical Module Updates**

#### **1. nedge\_topology/mitosis.py (The New Engine)**

*Handles the "Dimensional Relief" of high-tension categories.*

Python

import torch   import torch.nn.functional as F   from sklearn.cluster import KMeans   from typing import List   from .parser import TopologicalParser

class TopologicalInflator:       """       Handles the 'Mitosis' or 'Expansion' of Semantic Polytopes.       Upgrades a category's symmetry group to relieve semantic tension.       """       def \_\_init\_\_(self, parser: TopologicalParser):           self.parser = parser

    def check\_and\_inflate(self, historical\_vectors: dict, threshold: float \= 0.5):           """           Scans all rules. If tension is high, inflates the polytope.           Args:               historical\_vectors: Dict mapping 'LHS' \-\> Tensor(N, Dim) of observations.           """           updates \= \[\]           for rule in self.parser.rules:               if rule.lhs in historical\_vectors:                   vecs \= historical\_vectors\[rule.lhs\]                                      \# Check current tension                   if hasattr(rule, 'vertices') and rule.vertices is not None:                       current\_tension \= self.\_calculate\_multi\_tension(vecs, rule.vertices)                   else:                       current\_tension \= self.\_calculate\_tension(vecs, rule.prototype)                                      if current\_tension \> threshold:                       print(f"üåÄ Tension Alert \[{rule.lhs}\]: {current\_tension:.4f} \> {threshold}")                       new\_verts \= self.\_inflate(vecs)                       rule.vertices \= new\_verts                       updates.append(rule.lhs)                                              new\_tension \= self.\_calculate\_multi\_tension(vecs, new\_verts)                       print(f"   \-\> Inflated to {len(new\_verts)}\-Simplex. Relief: {current\_tension \- new\_tension:.4f}")           return updates

    def \_inflate(self, vectors: torch.Tensor, k\_base: int \= 4):           """           Performs Spherical K-Means to find new vertices on the manifold.           """           \# We perform k-means clustering to find the vertices of the new polytope           X \= F.normalize(vectors, p=2, dim=1).numpy()           kmeans \= KMeans(n\_clusters=k\_base, random\_state=42)           kmeans.fit(X)           return torch.tensor(kmeans.cluster\_centers\_)

    def \_calculate\_tension(self, vectors, prototype):           sims \= F.cosine\_similarity(vectors, prototype.unsqueeze(0))           return 1.0 \- sims.mean().item()

    def \_calculate\_multi\_tension(self, vectors, centroids):           \# Max sim for each vector to ANY vertex in the polytope           sims \= torch.mm(F.normalize(vectors, p=2, dim=1), F.normalize(centroids, p=2, dim=1).t())           max\_sims, \_ \= sims.max(dim=1)           return 1.0 \- max\_sims.mean().item()

#### **2. nedge\_topology/parser.py (Polytope Awareness)**

*Updated to validate edges against the Polytope Surface, not just the Centroid.*

Python

import torch   import torch.nn.functional as F   from typing import List   from .graph import SPPFNode, PackedNode   from .geometry import Geometry

RESONANCE\_THRESHOLD = 0.15   COHERENCE\_THRESHOLD = 0.10

class GrammarRule:       def \_\_init\_\_(self, lhs: str, rhs: List\[str], dim: int = 64):           self.lhs = lhs           self.rhs = rhs           # The Centroid (0-Simplex)           self.prototype = F.normalize(torch.randn(dim), p=2, dim=0)           # The Polytope (N-Simplex) - None by default           self.vertices = None

\# ... (EarleyState remains the same) ...

class TopologicalParser:       def \_\_init\_\_(self, grammar\_rules: List\[GrammarRule], dim=64):           self.rules = grammar\_rules           self.dim = dim           self.chart = \[]            self.packed\_nodes = {}           self.geometry = Geometry(dim)

    \# ... (parse, predict, scan methods remain the same) ...

    def complete(self, item, index):           \# ... (Node creation remains the same) ...           span\_key \= (item.rule.lhs, item.start, index)           if span\_key not in self.packed\_nodes:               self.packed\_nodes\[span\_key\] \= PackedNode(item.start, index, item.rule.lhs, self.dim)                      final\_node \= self.packed\_nodes\[span\_key\]           final\_node.add\_derivation(item.children)           final\_node.tension \= self.geometry.measure\_tension(final\_node.content, final\_node.start)                      \# Dynamic Threshold           dynamic\_threshold \= RESONANCE\_THRESHOLD \+ (final\_node.tension \* 0.1)                      for parent in self.chart\[item.start\]:               if not parent.is\_complete() and parent.next\_symbol() \== item.rule.lhs:                                      \# 1\. Resonance (Adjoint Interaction)                   parent\_proxy \= SPPFNode(parent.vector\_acc, parent.start, parent.current, "Parent")                   resonance \= parent\_proxy.interaction(final\_node, self.geometry)                                      \# 2\. Coherence (Polytope Matching)                   potential\_vec \= parent.vector\_acc \+ final\_node.content                                      if hasattr(parent.rule, 'vertices') and parent.rule.vertices is not None:                       \# \[UPDATED\] Check against Polytope Surface                       \# Normalize vector                       p\_vec \= F.normalize(potential\_vec, p=2, dim=0).unsqueeze(0)                       \# Normalize vertices                       verts \= F.normalize(parent.rule.vertices, p=2, dim=1)                       \# Find nearest vertex on the polytope                       sims \= torch.mm(p\_vec, verts.t())                       coherence \= sims.max().item()                   else:                       \# Fallback to Centroid                       coherence \= F.cosine\_similarity(potential\_vec.unsqueeze(0),                                                      parent.rule.prototype.unsqueeze(0)).item()                                      \# 3\. Gating                   if resonance \> dynamic\_threshold and coherence \> COHERENCE\_THRESHOLD:                       self.chart\[index\].add(parent.advance(final\_node))

#### **3. dashboard.py (Inflation Controls)**

*Now includes controls to trigger Mitosis manually and visualize the Polytopes.*

*!\[Image of]\[image1]* [Opens in a new window](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcQrCDq9z0JV77n9s6blgswNQIa56rQUxQXnFEy7aWoGyeAoxYPwFDamsoXfjz2YlCKbGx5IqvQjHbjRh7Q0oRShwVCs2SX9cT_rife6G8PUN1ML0Tc)

Shutterstock

Python

import streamlit as st   import numpy as np   import pandas as pd   import plotly.express as px   import torch   import os   from sklearn.decomposition import PCA   from nedge\_topology import TopologicalParser, GrammarRule, TopologicalStore, PackedNode   from nedge\_topology.mitosis import TopologicalInflator

st.set\_page\_config(page\_title="Nedge Polytope", layout="wide", page\_icon="üî∑")   st.title("üî∑ Nedge-Topology: Polytope Dashboard")

model\_path = st.sidebar.text\_input("HDF5 Path", "bootstrap.h5")   if not os.path.exists(model\_path): st.stop()

dummy = \[GrammarRule('S', \['NP', 'VP'])]   store = TopologicalStore(model\_path)   parser = store.load(dummy)

\# --- Collect Historical Vectors for Inflation ---   # In a real app, these would be stored in HDF5. We extract from current PackedNodes for demo.   history = {}   for node in parser.packed\_nodes.values():       if node.label not in history: history\[node.label] = \[]       history\[node.label].append(node.content)

\# Convert to tensors   for k in history:       if history\[k]: history\[k] = torch.stack(history\[k])

\# --- MANIFOLD TAB ---   tab1, tab2 = st.tabs(\["üß† Polytope Manifold", "‚öôÔ∏è Mitosis Control"])

with tab1:       st.header("Semantic Polytopes")              # 1. Nodes       vecs, labels, colors, sizes = \[], \[], \[], \[]       for node in parser.packed\_nodes.values():           vecs.append(node.content.numpy())           labels.append(node.label)           colors.append("Instance")           sizes.append(5)                  # 2. Rule Vertices (Polytopes)       for rule in parser.rules:           if hasattr(rule, 'vertices') and rule.vertices is not None:               for i, v in enumerate(rule.vertices):                   vecs.append(v.numpy())                   labels.append(f"{rule.lhs}\_Vertex\_{i}")                   colors.append(f"Polytope ({rule.lhs})")                   sizes.append(15) # Make vertices larger           else:               vecs.append(rule.prototype.numpy())               labels.append(f"{rule.lhs}\_Centroid")               colors.append(f"Centroid ({rule.lhs})")               sizes.append(15)

    if vecs:           pca \= PCA(n\_components=3)           proj \= pca.fit\_transform(np.array(vecs))           df \= pd.DataFrame(proj, columns=\["x", "y", "z"\])           df\["label"\] \= labels           df\["type"\] \= colors           df\["size"\] \= sizes                      fig \= px.scatter\_3d(df, x='x', y='y', z='z', color='type', size='size',                                hover\_data=\['label'\], symbol='type')           st.plotly\_chart(fig, use\_container\_width=True)

with tab2:       st.header("Topological Inflation")              col1, col2 = st.columns(2)       with col1:           threshold = st.slider("Tension Threshold", 0.0, 1.0, 0.4)           if st.button("Run Mitosis Scan"):               inflator = TopologicalInflator(parser)               updates = inflator.check\_and\_inflate(history, threshold)               if updates:                   st.success(f"Inflated {len(updates)} categories: {updates}")                   store.save(parser) # Save the new brain               else:                   st.info("No categories exceeded tension threshold.")              with col2:           st.subheader("Rule Geometry Status")           for r in parser.rules:               status = "0-Simplex (Centroid)"               if hasattr(r, 'vertices') and r.vertices is not None:                   status = f"{len(r.vertices)}-Simplex (Polytope)"               st.write(f"\*\*{r.lhs}\*\*: {status}")

#### **4. nedge\_topology/\_\_init\_\_.py**

Python

from .geometry import Geometry   from .graph import SPPFNode, PackedNode   from .parser import TopologicalParser, GrammarRule   from .visualizer import TopologicalVisualizer   from .search import SemanticSearchFunctor   from .storage import TopologicalStore   from .induction import GrammarInducer   from .train import ReflexiveTrainer   from .mitosis import TopologicalInflator

\_\_all\_\_ = \[       "Geometry",       "SPPFNode",       "PackedNode",       "TopologicalParser",       "GrammarRule",       "TopologicalVisualizer",       "SemanticSearchFunctor",       "TopologicalStore",       "GrammarInducer",       "ReflexiveTrainer",       "TopologicalInflator"   ]

***

### **III. Theoretical Summary**

This configuration implements the **Stasheff Expansion**.

1. **Parse:** The parser tries to fit tokens into existing categories.   2. **Tension:** If the fit is poor (High Tension), it is flagged.   3. **Inflation:** The TopologicalInflator upgrades the category geometry from a point to a polytope.   4. **Relief:** Future parses check against the new vertices, finding better coherence and lower tension.

This is the mechanism of **Concept Differentiation** (e.g., separating "Bank" as *river edge* from "Bank" as *financial institution* without creating explicit sub-rules, simply by creating a 2-vertex polytope for the NP category).
