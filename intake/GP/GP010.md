Would you like me to guide you through the **Agda Compilation Step**, ensuring that the RotationalTransport.agda proof compiles successfully and verifying that your Python geometry.py implementation is mathematically consistent with the verified type signatures?

### **I. Formal Correction & Packaging Strategy**

I formally correct the elision of the **Deployment Substrate**. To reify this theoretical system into a usable tool for your **Nedge** environment, we must organize it as a standard Python distribution.

This package, nedge-topology, is structured to enforce the **Separation of Concerns** between the Geometry (RoPE), the Topology (SPPF), and the Observation (Search/Viz).

---

### **II. The Package Structure**

Here is the file tree for the repository:

Plaintext

nedge-topology/   ├── pyproject.toml           \# Build system configuration   ├── setup.py                 \# Installation script   ├── README.md                \# Documentation   ├── nedge\_topology/   │   ├── \_\_init\_\_.py          \# Exports the API   │   ├── geometry.py          \# RoPE & Group Action Logic   │   ├── graph.py             \# SPPFNode & PackedNode (The Objects)   │   ├── parser.py            \# Vectorized Earley Logic (The Functor)   │   ├── search.py            \# Semantic Search (The Observer)   │   └── visualizer.py        \# Graphviz Export (The Lens)   └── proofs/       └── RotationalTransport.agda  \# Formal verification of RoPE properties

---

### **III. Source Code**

#### **1\. pyproject.toml**

Ini, TOML

\[build-system\]   requires \= \["setuptools\>=61.0"\]   build-backend \= "setuptools.build\_meta"

\[project\]   name \= "nedge-topology"   version \= "0.1.0"   description \= "A Unified Topological Parser implementing RoPE-based SPPF and Vectorized Superposition."   authors \= \[{name \= "Michael Mol", email \= "mikem@rosettacode.org"}\]   dependencies \= \[       "torch\>=2.0.0",       "numpy"   \]   requires-python \= "\>=3.9"

#### **2\. nedge\_topology/geometry.py**

*The axiomatic definition of the Rotational Group Action.*

Python

import torch

class RotationalGeometry:       """       Implements the Functor mapping Indices to Rotations (Group Action).       """       @staticmethod       def get\_freqs(dim: int, theta: float \= 10000.0):           \# Split dimensions for 2D: Half for X-start, Half for Y-end           half\_dim \= dim // 2           freqs \= 1.0 / (theta \*\* (torch.arange(0, half\_dim, 2).float() / half\_dim))           return freqs

    @staticmethod       def apply\_2d\_rope(vector: torch.Tensor, start: int, end: int) \-\> torch.Tensor:           """           Applies the Group Action: vector |\> Rotate(start, end)           """           dim \= vector.shape\[-1\]           half\_dim \= dim // 2                      \# Split vector into Start-sensitive and End-sensitive subspaces           v\_start \= vector\[..., :half\_dim\]           v\_end \= vector\[..., half\_dim:\]                      freqs \= RotationalGeometry.get\_freqs(dim)                      \# Complex Transport           v\_start\_c \= torch.view\_as\_complex(v\_start.float().reshape(-1, 2))           v\_end\_c \= torch.view\_as\_complex(v\_end.float().reshape(-1, 2))                      \# Calculate Rotors           angles\_start \= start \* freqs           rot\_start \= torch.polar(torch.ones\_like(angles\_start), angles\_start)                      angles\_end \= end \* freqs           rot\_end \= torch.polar(torch.ones\_like(angles\_end), angles\_end)                      \# Apply Group Action           v\_start\_rot \= torch.view\_as\_real(v\_start\_c \* rot\_start).flatten()           v\_end\_rot \= torch.view\_as\_real(v\_end\_c \* rot\_end).flatten()                      return torch.cat(\[v\_start\_rot, v\_end\_rot\])

#### **3\. nedge\_topology/graph.py**

*The Topological Objects (Nodes and Superpositions).*

Python

import torch   import math   import torch.nn.functional as F   from typing import List   from .geometry import RotationalGeometry

class SPPFNode:       """       The Base Object in the Semantic Category.       """       def \_\_init\_\_(self, content: torch.Tensor, start: int, end: int, label: str):           self.content \= content           self.start \= start           self.end \= end           self.label \= label           self.dim \= content.shape\[-1\]

    def rotated\_vector(self):           """Returns the vector transported to its absolute location."""           return RotationalGeometry.apply\_2d\_rope(self.content, self.start, self.end)

    def \_\_matmul\_\_(self, other):           """           The Morphism Detector.           Calculates interaction strength (Inner Product) under Transport.           """           if not isinstance(other, SPPFNode): return NotImplemented           q \= self.rotated\_vector()           k \= other.rotated\_vector()           return torch.dot(q, k) / math.sqrt(self.dim)

    def \_\_repr\_\_(self):           return f"Node\<{self.label}\>({self.start},{self.end})"

class PackedNode(SPPFNode):       """       Represents a Superposition State (Ambiguity).       """       def \_\_init\_\_(self, start: int, end: int, label: str, dim: int):           super().\_\_init\_\_(torch.zeros(dim), start, end, label)           self.derivations \= \[\] \# History for topological reconstruction

    def add\_derivation(self, children: List\[SPPFNode\]):           \# 1\. Synthesize vector for this specific derivation path           path\_vector \= torch.zeros\_like(self.content)           for child in children:               path\_vector \+= child.content                      \# 2\. Superposition (Constructive/Destructive Interference)           self.content \+= path\_vector           self.derivations.append(children)                      \# 3\. Renormalize (Energy Conservation)           if self.content.norm() \> 1e-9:               self.content \= F.normalize(self.content, p=2, dim=0)

#### **4\. nedge\_topology/parser.py**

*The Topological Functor (Vectorized Earley).*

Python

import torch   import torch.nn.functional as F   from typing import List, Dict, Set   from .graph import SPPFNode, PackedNode

class GrammarRule:       def \_\_init\_\_(self, lhs: str, rhs: List\[str\], dim: int \= 64):           self.lhs \= lhs           self.rhs \= rhs           \# Semantic Prototype (The 'Ideal' meaning of the rule)           self.prototype \= F.normalize(torch.randn(dim), p=2, dim=0)

class EarleyState:       def \_\_init\_\_(self, rule: GrammarRule, dot: int, start: int, current: int,                     vector\_acc: torch.Tensor, children: List\[SPPFNode\]):           self.rule \= rule           self.dot \= dot           self.start \= start           self.current \= current           self.vector\_acc \= vector\_acc           self.children \= children

    def next\_symbol(self):           if self.dot \< len(self.rule.rhs): return self.rule.rhs\[self.dot\]           return None

    def is\_complete(self):           return self.dot \== len(self.rule.rhs)

    def advance(self, child: SPPFNode):           new\_vec \= self.vector\_acc \+ child.content           return EarleyState(               self.rule, self.dot \+ 1, self.start, child.end,                new\_vec, self.children \+ \[child\]           )              def \_\_eq\_\_(self, other):           return (self.rule \== other.rule and self.dot \== other.dot and                    self.start \== other.start and self.current \== other.current)              def \_\_hash\_\_(self):           return hash((self.rule.lhs, self.dot, self.start, self.current))

class TopologicalParser:       def \_\_init\_\_(self, grammar\_rules: List\[GrammarRule\], dim=64):           self.rules \= grammar\_rules           self.dim \= dim           self.chart \= \[\]            self.packed\_nodes \= {} 

    def parse(self, tokens: List\[str\]):           n \= len(tokens)           self.chart \= \[set() for \_ in range(n \+ 1)\]           self.packed\_nodes \= {}

        \# Init           for rule in self.rules:               if rule.lhs \== 'S':                   self.chart\[0\].add(EarleyState(rule, 0, 0, 0, torch.zeros(self.dim), \[\]))

        \# Loop           for i in range(n \+ 1):               while True:                   initial\_len \= len(self.chart\[i\])                   current\_items \= list(self.chart\[i\])                   for item in current\_items:                       if item.is\_complete():                           self.complete(item, i)                       else:                           sym \= item.next\_symbol()                           if self.is\_non\_terminal(sym):                               self.predict(sym, i)                   if len(self.chart\[i\]) \== initial\_len: break                              if i \< n: self.scan(i, tokens\[i\])

        return self.get\_result(n)

    def is\_non\_terminal(self, sym):           return any(r.lhs \== sym for r in self.rules)

    def predict(self, symbol, index):           for rule in self.rules:               if rule.lhs \== symbol:                   self.chart\[index\].add(EarleyState(rule, 0, index, index, torch.zeros(self.dim), \[\]))

    def scan(self, index, token\_text):           \# Lexical Lookup Simulation           seed \= sum(ord(c) for c in token\_text)           torch.manual\_seed(seed)            lexical\_vec \= F.normalize(torch.randn(self.dim), p=2, dim=0)                      node \= SPPFNode(lexical\_vec, index, index \+ 1, token\_text)           for item in self.chart\[index\]:               if not item.is\_complete() and item.next\_symbol() \== token\_text:                   self.chart\[index \+ 1\].add(item.advance(node))

    def complete(self, item: EarleyState, index):           span\_key \= (item.rule.lhs, item.start, index)           if span\_key not in self.packed\_nodes:               self.packed\_nodes\[span\_key\] \= PackedNode(item.start, index, item.rule.lhs, self.dim)                      self.packed\_nodes\[span\_key\].add\_derivation(item.children)           final\_node \= self.packed\_nodes\[span\_key\]                      for parent in self.chart\[item.start\]:               if not parent.is\_complete() and parent.next\_symbol() \== item.rule.lhs:                   self.chart\[index\].add(parent.advance(final\_node))

    def get\_result(self, n):           return \[item for item in self.chart\[n\] if item.rule.lhs \== 'S' and item.start \== 0 and item.is\_complete()\]

#### **5\. nedge\_topology/visualizer.py**

*The Graphviz Exporter.*

Python

import colorsys   from .graph import PackedNode

class TopologicalVisualizer:       def \_\_init\_\_(self, parser):           self.parser \= parser           self.nodes\_seen \= set()           self.dot\_lines \= \[\]           self.\_header()

    def \_header(self):           self.dot\_lines \= \[               'digraph "Goesdelian\_Spiral" {',               '  bgcolor="\#0d1117";',               '  rankdir=BT;',               '  node \[fontname="Consolas", fontcolor="\#c9d1d9", color="\#c9d1d9", style="filled"\];',               '  edge \[color="\#8b949e", arrowsize=0.7\];'           \]

    def \_get\_phase\_color(self, index: int, max\_len: int \= 10):           hue \= (index / (max\_len \+ 1)) \* 0.8           r, g, b \= colorsys.hsv\_to\_rgb(hue, 0.85, 0.9)           return f"\#{int(r\*255):02x}{int(g\*255):02x}{int(b\*255):02x}"

    def visualize(self, output\_file="semantic\_manifold.dot"):           max\_idx \= 0           roots \= \[\]           for key, node in self.parser.packed\_nodes.items():               if key\[2\] \> max\_idx: max\_idx \= key\[2\]               if node.label \== 'S' and node.start \== 0: roots.append(node)

        for root in roots: self.\_traverse(root, max\_idx)                      self.dot\_lines.append('}')           with open(output\_file, "w", encoding="utf-8") as f:               f.write("\\n".join(self.dot\_lines))           print(f"Visualization exported to {output\_file}")

    def \_traverse(self, node, max\_idx):           if id(node) in self.nodes\_seen: return           self.nodes\_seen.add(id(node))           node\_id \= f"node\_{id(node)}"           color \= self.\_get\_phase\_color(node.start, max\_idx)

        if hasattr(node, 'derivations'):               shape \= "doubleoctagon" if len(node.derivations) \> 1 else "octagon"               label \= f"{node.label}\\\\n\[{node.start}:{node.end}\]"               self.dot\_lines.append(f'  {node\_id} \[label="{label}", shape={shape}, fillcolor="{color}33", color="{color}"\];')                              for i, children in enumerate(node.derivations):                   link\_id \= node\_id                   if len(node.derivations) \> 1:                       d\_id \= f"{node\_id}\_d{i}"                       self.dot\_lines.append(f'  {d\_id} \[label="", shape=circle, width=0.1, fillcolor="\#ffffff"\];')                       self.dot\_lines.append(f'  {node\_id} \-\> {d\_id} \[arrowhead=none\];')                       link\_id \= d\_id                   for child in children:                       self.\_traverse(child, max\_idx)                       self.dot\_lines.append(f'  {link\_id} \-\> node\_{id(child)};')           else:               label \= f"{node.label}\\\\n({node.start})"               self.dot\_lines.append(f'  {node\_id} \[label="{label}", shape=box, fillcolor="{color}55", color="{color}"\];')

#### **6\. nedge\_topology/search.py**

*The Semantic Functor.*

Python

import torch   import torch.nn.functional as F

class SemanticSearchFunctor:       def \_\_init\_\_(self, parser\_nodes):           self.packed\_nodes \= parser\_nodes           self.heatmap \= {}

    def search(self, root\_node, query\_vector):           self.heatmap \= {}           return self.\_recursive\_project(root\_node, query\_vector)

    def \_recursive\_project(self, node, query\_vec):           node\_sim \= F.cosine\_similarity(node.content.unsqueeze(0), query\_vec.unsqueeze(0)).item()           self.heatmap\[node\] \= node\_sim

        if not hasattr(node, 'derivations') or not node.derivations:               return \[node\], node\_sim

        best\_score \= \-1.0           best\_path \= \[\]

        for children in node.derivations:               family\_vec \= sum((child.content for child in children), torch.zeros\_like(query\_vec))               family\_score \= F.cosine\_similarity(family\_vec.unsqueeze(0), query\_vec.unsqueeze(0)).item()                              if family\_score \> best\_score:                   best\_score \= family\_score                   current\_path \= \[node\]                   for child in children:                       child\_path, \_ \= self.\_recursive\_project(child, query\_vec)                       current\_path.extend(child\_path)                   best\_path \= current\_path                      return best\_path, best\_score

#### **7\. nedge\_topology/\_\_init\_\_.py**

Python

from .geometry import RotationalGeometry   from .graph import SPPFNode, PackedNode   from .parser import TopologicalParser, GrammarRule   from .visualizer import TopologicalVisualizer   from .search import SemanticSearchFunctor

\_\_all\_\_ \= \[       "RotationalGeometry",       "SPPFNode",       "PackedNode",       "TopologicalParser",       "GrammarRule",       "TopologicalVisualizer",       "SemanticSearchFunctor"   \]

---

### **IV. Next Step**

You can now install this via pip install \-e ..
